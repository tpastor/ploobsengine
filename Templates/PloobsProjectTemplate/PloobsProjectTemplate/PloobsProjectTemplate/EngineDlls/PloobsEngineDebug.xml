<?xml version="1.0"?>
<doc>
  <assembly>
    <name>PloobsEngineDebug</name>
  </assembly>
  <members>
    <member name="M:FarseerPhysics.Controllers.ControllerFilter.IgnoreController(FarseerPhysics.Controllers.ControllerType)">
      <summary>
            Ignores the controller. The controller has no effect on this body.
            </summary>
      <param name="controller">The controller type.</param>
    </member>
    <member name="M:FarseerPhysics.Controllers.ControllerFilter.RestoreController(FarseerPhysics.Controllers.ControllerType)">
      <summary>
            Restore the controller. The controller affects this body.
            </summary>
      <param name="controller">The controller type.</param>
    </member>
    <member name="M:FarseerPhysics.Controllers.ControllerFilter.IsControllerIgnored(FarseerPhysics.Controllers.ControllerType)">
      <summary>
            Determines whether this body ignores the the specified controller.
            </summary>
      <param name="controller">The controller type.</param>
      <returns>
        <c>true</c> if the body has the specified flag; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="T:FarseerPhysics.Dynamics.FilterData">
      <summary>
            Contains filter data that can determine whether an object should be processed or not.
            </summary>
    </member>
    <member name="M:FarseerPhysics.Dynamics.FilterData.AddDisabledCategory(FarseerPhysics.Dynamics.Category)">
      <summary>
            Adds the category.
            </summary>
      <param name="category">The category.</param>
    </member>
    <member name="M:FarseerPhysics.Dynamics.FilterData.RemoveDisabledCategory(FarseerPhysics.Dynamics.Category)">
      <summary>
            Removes the category.
            </summary>
      <param name="category">The category.</param>
    </member>
    <member name="M:FarseerPhysics.Dynamics.FilterData.IsInDisabledCategory(FarseerPhysics.Dynamics.Category)">
      <summary>
            Determines whether this body ignores the the specified controller.
            </summary>
      <param name="category">The category.</param>
      <returns>
        <c>true</c> if the object has the specified category; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="M:FarseerPhysics.Dynamics.FilterData.AddEnabledCategory(FarseerPhysics.Dynamics.Category)">
      <summary>
            Adds the category.
            </summary>
      <param name="category">The category.</param>
    </member>
    <member name="M:FarseerPhysics.Dynamics.FilterData.RemoveEnabledCategory(FarseerPhysics.Dynamics.Category)">
      <summary>
            Removes the category.
            </summary>
      <param name="category">The category.</param>
    </member>
    <member name="M:FarseerPhysics.Dynamics.FilterData.IsInEnabledCategory(FarseerPhysics.Dynamics.Category)">
      <summary>
            Determines whether this body ignores the the specified controller.
            </summary>
      <param name="category">The category.</param>
      <returns>
        <c>true</c> if the object has the specified category; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="T:FarseerPhysics.Collision.DynamicTreeBroadPhase">
      <summary>
            The broad-phase is used for computing pairs and performing volume queries and ray casts.
            This broad-phase does not persist pairs. Instead, this reports potentially new pairs.
            It is up to the client to consume the new pairs and to track subsequent overlap.
            </summary>
    </member>
    <member name="M:FarseerPhysics.Collision.DynamicTreeBroadPhase.AddProxy(FarseerPhysics.Dynamics.FixtureProxy@)">
      <summary>
            Create a proxy with an initial AABB. Pairs are not reported until
            UpdatePairs is called.
            </summary>
      <param name="aabb">The aabb.</param>
      <param name="proxy">The user data.</param>
      <returns>
      </returns>
    </member>
    <member name="M:FarseerPhysics.Collision.DynamicTreeBroadPhase.RemoveProxy(System.Int32)">
      <summary>
            Destroy a proxy. It is up to the client to remove any pairs.
            </summary>
      <param name="proxyId">The proxy id.</param>
    </member>
    <member name="M:FarseerPhysics.Collision.DynamicTreeBroadPhase.GetFatAABB(System.Int32,FarseerPhysics.Collision.AABB@)">
      <summary>
            Get the AABB for a proxy.
            </summary>
      <param name="proxyId">The proxy id.</param>
      <param name="aabb">The aabb.</param>
    </member>
    <member name="M:FarseerPhysics.Collision.DynamicTreeBroadPhase.GetProxy(System.Int32)">
      <summary>
            Get user data from a proxy. Returns null if the id is invalid.
            </summary>
      <param name="proxyId">The proxy id.</param>
      <returns>
      </returns>
    </member>
    <member name="M:FarseerPhysics.Collision.DynamicTreeBroadPhase.TestOverlap(System.Int32,System.Int32)">
      <summary>
            Test overlap of fat AABBs.
            </summary>
      <param name="proxyIdA">The proxy id A.</param>
      <param name="proxyIdB">The proxy id B.</param>
      <returns>
      </returns>
    </member>
    <member name="M:FarseerPhysics.Collision.DynamicTreeBroadPhase.UpdatePairs(FarseerPhysics.Dynamics.BroadphaseDelegate)">
      <summary>
            Update the pairs. This results in pair callbacks. This can only add pairs.
            </summary>
      <param name="callback">The callback.</param>
    </member>
    <member name="M:FarseerPhysics.Collision.DynamicTreeBroadPhase.Query(System.Func{System.Int32,System.Boolean},FarseerPhysics.Collision.AABB@)">
      <summary>
            Query an AABB for overlapping proxies. The callback class
            is called for each proxy that overlaps the supplied AABB.
            </summary>
      <param name="callback">The callback.</param>
      <param name="aabb">The aabb.</param>
    </member>
    <member name="M:FarseerPhysics.Collision.DynamicTreeBroadPhase.RayCast(System.Func{FarseerPhysics.Collision.RayCastInput,System.Int32,System.Single},FarseerPhysics.Collision.RayCastInput@)">
      <summary>
            Ray-cast against the proxies in the tree. This relies on the callback
            to perform a exact ray-cast in the case were the proxy contains a shape.
            The callback also performs the any collision filtering. This has performance
            roughly equal to k * log(n), where k is the number of collisions and n is the
            number of proxies in the tree.
            </summary>
      <param name="callback">A callback class that is called for each proxy that is hit by the ray.</param>
      <param name="input">The ray-cast input data. The ray extends from p1 to p1 + maxFraction * (p2 - p1).</param>
    </member>
    <member name="M:FarseerPhysics.Collision.DynamicTreeBroadPhase.ComputeHeight">
      <summary>
            Compute the height of the embedded tree.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="P:FarseerPhysics.Collision.DynamicTreeBroadPhase.ProxyCount">
      <summary>
            Get the number of proxies.
            </summary>
      <value>The proxy count.</value>
    </member>
    <member name="F:FarseerPhysics.Dynamics.Joints.Joint.Breakpoint">
      <summary>
            The Breakpoint simply indicates the maximum Value the JointError can be before it breaks.
            The default value is float.MaxValue
            </summary>
    </member>
    <member name="M:FarseerPhysics.Dynamics.Joints.Joint.#ctor(FarseerPhysics.Dynamics.Body)">
      <summary>
            Constructor for fixed joint
            </summary>
    </member>
    <member name="M:FarseerPhysics.Dynamics.Joints.Joint.GetReactionForce(System.Single)">
      <summary>
            Get the reaction force on body2 at the joint anchor in Newtons.
            </summary>
      <param name="inv_dt">The inv_dt.</param>
      <returns>
      </returns>
    </member>
    <member name="M:FarseerPhysics.Dynamics.Joints.Joint.GetReactionTorque(System.Single)">
      <summary>
            Get the reaction torque on body2 in N*m.
            </summary>
      <param name="inv_dt">The inv_dt.</param>
      <returns>
      </returns>
    </member>
    <member name="M:FarseerPhysics.Dynamics.Joints.Joint.IsFixedType">
      <summary>
            Return true if the joint is a fixed type.
            </summary>
    </member>
    <member name="M:FarseerPhysics.Dynamics.Joints.Joint.SolvePositionConstraints">
      <summary>
            Solves the position constraints.
            </summary>
      <returns>returns true if the position errors are within tolerance.</returns>
    </member>
    <member name="P:FarseerPhysics.Dynamics.Joints.Joint.JointType">
      <summary>
            Gets or sets the type of the joint.
            </summary>
      <value>The type of the joint.</value>
    </member>
    <member name="P:FarseerPhysics.Dynamics.Joints.Joint.BodyA">
      <summary>
            Get the first body attached to this joint.
            </summary>
      <value>
      </value>
    </member>
    <member name="P:FarseerPhysics.Dynamics.Joints.Joint.BodyB">
      <summary>
            Get the second body attached to this joint.
            </summary>
      <value>
      </value>
    </member>
    <member name="P:FarseerPhysics.Dynamics.Joints.Joint.WorldAnchorA">
      <summary>
            Get the anchor point on body1 in world coordinates.
            </summary>
      <value>
      </value>
    </member>
    <member name="P:FarseerPhysics.Dynamics.Joints.Joint.WorldAnchorB">
      <summary>
            Get the anchor point on body2 in world coordinates.
            </summary>
      <value>
      </value>
    </member>
    <member name="P:FarseerPhysics.Dynamics.Joints.Joint.UserData">
      <summary>
            Set the user data pointer.
            </summary>
      <value>The data.</value>
    </member>
    <member name="P:FarseerPhysics.Dynamics.Joints.Joint.Active">
      <summary>
            Short-cut function to determine if either body is inactive.
            </summary>
      <value>
        <c>true</c> if active; otherwise, <c>false</c>.</value>
    </member>
    <member name="P:FarseerPhysics.Dynamics.Joints.Joint.CollideConnected">
      <summary>
            Set this flag to true if the attached bodies should collide.
            </summary>
    </member>
    <member name="E:FarseerPhysics.Dynamics.Joints.Joint.Broke">
      <summary>
            Fires when the joint is broken.
            </summary>
    </member>
    <member name="T:FarseerPhysics.Dynamics.Joints.PulleyJoint">
      <summary>
            The pulley joint is connected to two bodies and two fixed ground points.
            The pulley supports a ratio such that:
            length1 + ratio * length2 <!--<-->= ant
            Yes, the force transmitted is scaled by the ratio.
            The pulley also enforces a maximum length limit on both sides. This is
            useful to prevent one side of the pulley hitting the top.
            </summary>
    </member>
    <member name="F:FarseerPhysics.Dynamics.Joints.PulleyJoint.GroundAnchorA">
      <summary>
            Get the first ground anchor.
            </summary>
      <value>
      </value>
    </member>
    <member name="F:FarseerPhysics.Dynamics.Joints.PulleyJoint.GroundAnchorB">
      <summary>
            Get the second ground anchor.
            </summary>
      <value>
      </value>
    </member>
    <member name="M:FarseerPhysics.Dynamics.Joints.PulleyJoint.#ctor(FarseerPhysics.Dynamics.Body,FarseerPhysics.Dynamics.Body,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,System.Single)">
      <summary>
            Initialize the bodies, anchors, lengths, max lengths, and ratio using the world anchors.
            This requires two ground anchors,
            two dynamic body anchor points, max lengths for each side,
            and a pulley ratio.
            </summary>
      <param name="bodyA">The first body.</param>
      <param name="bodyB">The second body.</param>
      <param name="groundAnchorA">The ground anchor for the first body.</param>
      <param name="groundAnchorB">The ground anchor for the second body.</param>
      <param name="localAnchorA">The first body anchor.</param>
      <param name="localAnchorB">The second body anchor.</param>
      <param name="ratio">The ratio.</param>
    </member>
    <member name="P:FarseerPhysics.Dynamics.Joints.PulleyJoint.LengthA">
      <summary>
            Get the current length of the segment attached to body1.
            </summary>
      <value>
      </value>
    </member>
    <member name="P:FarseerPhysics.Dynamics.Joints.PulleyJoint.LengthB">
      <summary>
            Get the current length of the segment attached to body2.
            </summary>
      <value>
      </value>
    </member>
    <member name="P:FarseerPhysics.Dynamics.Joints.PulleyJoint.Ratio">
      <summary>
            Get the pulley ratio.
            </summary>
      <value>
      </value>
    </member>
    <member name="T:FarseerPhysics.Dynamics.Joints.DistanceJoint">
      <summary>
            A distance joint rains two points on two bodies
            to remain at a fixed distance from each other. You can view
            this as a massless, rigid rod.
            </summary>
    </member>
    <member name="F:FarseerPhysics.Dynamics.Joints.DistanceJoint.LocalAnchorA">
      <summary>
            The local anchor point relative to bodyA's origin.
            </summary>
    </member>
    <member name="F:FarseerPhysics.Dynamics.Joints.DistanceJoint.LocalAnchorB">
      <summary>
            The local anchor point relative to bodyB's origin.
            </summary>
    </member>
    <member name="M:FarseerPhysics.Dynamics.Joints.DistanceJoint.#ctor(FarseerPhysics.Dynamics.Body,FarseerPhysics.Dynamics.Body,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2)">
      <summary>
            This requires defining an
            anchor point on both bodies and the non-zero length of the
            distance joint. If you don't supply a length, the local anchor points
            is used so that the initial configuration can violate the constraint
            slightly. This helps when saving and loading a game.
            @warning Do not use a zero or short length.
            </summary>
      <param name="bodyA">The first body</param>
      <param name="bodyB">The second body</param>
      <param name="localAnchorA">The first body anchor</param>
      <param name="localAnchorB">The second body anchor</param>
    </member>
    <member name="P:FarseerPhysics.Dynamics.Joints.DistanceJoint.Length">
      <summary>
            The natural length between the anchor points.
            Manipulating the length can lead to non-physical behavior when the frequency is zero.
            </summary>
    </member>
    <member name="P:FarseerPhysics.Dynamics.Joints.DistanceJoint.Frequency">
      <summary>
            The mass-spring-damper frequency in Hertz.
            </summary>
    </member>
    <member name="P:FarseerPhysics.Dynamics.Joints.DistanceJoint.DampingRatio">
      <summary>
            The damping ratio. 0 = no damping, 1 = critical damping.
            </summary>
    </member>
    <member name="F:FarseerPhysics.Controllers.BuoyancyController.AngularDragCoefficient">
      <summary>
            Controls the rotational drag that the fluid exerts on the bodies within it. Use higher values will simulate thick fluid, like honey, lower values to
            simulate water-like fluids. 
            </summary>
    </member>
    <member name="F:FarseerPhysics.Controllers.BuoyancyController.Density">
      <summary>
            Density of the fluid. Higher values will make things more buoyant, lower values will cause things to sink.
            </summary>
    </member>
    <member name="F:FarseerPhysics.Controllers.BuoyancyController.LinearDragCoefficient">
      <summary>
            Controls the linear drag that the fluid exerts on the bodies within it.  Use higher values will simulate thick fluid, like honey, lower values to
            simulate water-like fluids.
            </summary>
    </member>
    <member name="F:FarseerPhysics.Controllers.BuoyancyController.Velocity">
      <summary>
            Acts like waterflow. Defaults to 0,0.
            </summary>
    </member>
    <member name="M:FarseerPhysics.Controllers.BuoyancyController.#ctor(FarseerPhysics.Collision.AABB,System.Single,System.Single,System.Single,Microsoft.Xna.Framework.Vector2)">
      <summary>
            Initializes a new instance of the <see cref="T:FarseerPhysics.Controllers.BuoyancyController" /> class.
            </summary>
      <param name="container">Only bodies inside this AABB will be influenced by the controller</param>
      <param name="density">Density of the fluid</param>
      <param name="linearDragCoefficient">Linear drag coefficient of the fluid</param>
      <param name="rotationalDragCoefficient">Rotational drag coefficient of the fluid</param>
      <param name="gravity">The direction gravity acts. Buoyancy force will act in opposite direction of gravity.</param>
    </member>
    <member name="T:FarseerPhysics.Controllers.AbstractForceController.DecayModes">
      <summary>
            Modes for Decay. Actual Decay must be implemented in inheriting 
            classes
            </summary>
    </member>
    <member name="T:FarseerPhysics.Controllers.AbstractForceController.ForceTypes">
      <summary>
            Forcetypes are used in the decay math to properly get the distance.
            They are also used to draw a representation in DebugView
            </summary>
    </member>
    <member name="T:FarseerPhysics.Controllers.AbstractForceController.TimingModes">
      <summary>
            Timing Modes
            Switched: Standard on/off mode using the baseclass enabled property
            Triggered: When the Trigger() method is called the force is active 
            for a specified Impulse Length
            Curve: Still to be defined. The basic idea is having a Trigger 
            combined with a curve for the strength
            </summary>
    </member>
    <member name="F:FarseerPhysics.Controllers.AbstractForceController.DecayCurve">
      <summary>
            Curve to be used for Decay in Curve mode
            </summary>
    </member>
    <member name="F:FarseerPhysics.Controllers.AbstractForceController.ForceType">
      <summary>
            The Forcetype of the instance
            </summary>
    </member>
    <member name="F:FarseerPhysics.Controllers.AbstractForceController.Randomize">
      <summary>
            Provided for reuse to provide Variation functionality in 
            inheriting classes
            </summary>
    </member>
    <member name="F:FarseerPhysics.Controllers.AbstractForceController.StrengthCurve">
      <summary>
            Curve used by Curve Mode as an animated multiplier for the force 
            strength.
            Only positions between 0 and 1 are considered as that range is 
            stretched to have ImpulseLength.
            </summary>
    </member>
    <member name="M:FarseerPhysics.Controllers.AbstractForceController.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:FarseerPhysics.Controllers.AbstractForceController.#ctor(FarseerPhysics.Controllers.AbstractForceController.TimingModes)">
      <summary>
            Overloaded Contstructor with supplying Timing Mode
            </summary>
      <param name="mode">
      </param>
    </member>
    <member name="M:FarseerPhysics.Controllers.AbstractForceController.GetDecayMultiplier(FarseerPhysics.Dynamics.Body)">
      <summary>
            Calculate the Decay for a given body. Meant to ease force 
            development and stick to the DRY principle and provide unified and 
            predictable decay math.
            </summary>
      <param name="body">The body to calculate decay for</param>
      <returns>A multiplier to multiply the force with to add decay 
            support in inheriting classes</returns>
    </member>
    <member name="M:FarseerPhysics.Controllers.AbstractForceController.Trigger">
      <summary>
            Triggers the trigger modes (Trigger and Curve)
            </summary>
    </member>
    <member name="M:FarseerPhysics.Controllers.AbstractForceController.Update(System.Single)">
      <summary>
            Inherited from Controller
            Depending on the TimingMode perform timing logic and call ApplyForce()
            </summary>
      <param name="dt">
      </param>
    </member>
    <member name="M:FarseerPhysics.Controllers.AbstractForceController.ApplyForce(System.Single,System.Single)">
      <summary>
            Apply the force supplying strength (wich is modified in Update() 
            according to the TimingMode
            </summary>
      <param name="dt">
      </param>
      <param name="strength">The strength</param>
    </member>
    <member name="P:FarseerPhysics.Controllers.AbstractForceController.Strength">
      <summary>
            Global Strength of the force to be applied
            </summary>
    </member>
    <member name="P:FarseerPhysics.Controllers.AbstractForceController.Position">
      <summary>
            Position of the Force. Can be ignored (left at (0,0) for forces
            that are not position-dependent
            </summary>
    </member>
    <member name="P:FarseerPhysics.Controllers.AbstractForceController.MaximumSpeed">
      <summary>
            Maximum speed of the bodies. Bodies that are travelling faster are
            supposed to be ignored
            </summary>
    </member>
    <member name="P:FarseerPhysics.Controllers.AbstractForceController.MaximumForce">
      <summary>
            Maximum Force to be applied. As opposed to Maximum Speed this is 
            independent of the velocity of
            the affected body
            </summary>
    </member>
    <member name="P:FarseerPhysics.Controllers.AbstractForceController.TimingMode">
      <summary>
            Timing Mode of the force instance
            </summary>
    </member>
    <member name="P:FarseerPhysics.Controllers.AbstractForceController.ImpulseTime">
      <summary>
            Time of the current impulse. Incremented in update till 
            ImpulseLength is reached
            </summary>
    </member>
    <member name="P:FarseerPhysics.Controllers.AbstractForceController.ImpulseLength">
      <summary>
            Length of a triggered impulse. Used in both Triggered and Curve Mode
            </summary>
    </member>
    <member name="P:FarseerPhysics.Controllers.AbstractForceController.Triggered">
      <summary>
            Indicating if we are currently during an Impulse 
            (Triggered and Curve Mode)
            </summary>
    </member>
    <member name="P:FarseerPhysics.Controllers.AbstractForceController.Variation">
      <summary>
            Variation of the force applied to each body affected
            !! Must be used in inheriting classes properly !!
            </summary>
    </member>
    <member name="P:FarseerPhysics.Controllers.AbstractForceController.DecayMode">
      <summary>
            See DecayModes
            </summary>
    </member>
    <member name="P:FarseerPhysics.Controllers.AbstractForceController.DecayStart">
      <summary>
            Start of the distance based Decay. To set a non decaying area
            </summary>
    </member>
    <member name="P:FarseerPhysics.Controllers.AbstractForceController.DecayEnd">
      <summary>
            Maximum distance a force should be applied
            </summary>
    </member>
    <member name="T:FarseerPhysics.Common.PolygonManipulation.YuPengClipper.Edge">
      <summary>Specifies an Edge. Edges are used to represent simplicies in simplical chains</summary>
    </member>
    <member name="M:FarseerPhysics.Common.PolygonManipulation.YuPengClipper.Execute(FarseerPhysics.Common.Vertices,FarseerPhysics.Common.Vertices,FarseerPhysics.Common.PolygonManipulation.PolyClipType,FarseerPhysics.Common.PolygonManipulation.PolyClipError@)">
      <summary>
            Implements "A new algorithm for Boolean operations on general polygons" 
            available here: http://liama.ia.ac.cn/wiki/_media/user:dong:dong_cg_05.pdf
            Merges two polygons, a subject and a clip with the specified operation. Polygons may not be 
            self-intersecting.
            
            Warning: May yield incorrect results or even crash if polygons contain collinear points.
            </summary>
      <param name="subject">The subject polygon.</param>
      <param name="clip">The clip polygon, which is added, 
            substracted or intersected with the subject</param>
      <param name="clipType">The operation to be performed. Either
            Union, Difference or Intersection.</param>
      <param name="error">The error generated (if any)</param>
      <returns>A list of closed polygons, which make up the result of the clipping operation.
            Outer contours are ordered counter clockwise, holes are ordered clockwise.</returns>
    </member>
    <member name="M:FarseerPhysics.Common.PolygonManipulation.YuPengClipper.CalculateIntersections(FarseerPhysics.Common.Vertices,FarseerPhysics.Common.Vertices,FarseerPhysics.Common.Vertices@,FarseerPhysics.Common.Vertices@)">
      <summary>
            Calculates all intersections between two polygons.
            </summary>
      <param name="polygon1">The first polygon.</param>
      <param name="polygon2">The second polygon.</param>
      <param name="slicedPoly1">Returns the first polygon with added intersection points.</param>
      <param name="slicedPoly2">Returns the second polygon with added intersection points.</param>
    </member>
    <member name="M:FarseerPhysics.Common.PolygonManipulation.YuPengClipper.CalculateSimplicalChain(FarseerPhysics.Common.Vertices,System.Collections.Generic.List{System.Single}@,System.Collections.Generic.List{FarseerPhysics.Common.PolygonManipulation.YuPengClipper.Edge}@)">
      <summary>
            Calculates the simplical chain corresponding to the input polygon.
            </summary>
      <remarks>Used by method <c>Execute()</c>.</remarks>
    </member>
    <member name="M:FarseerPhysics.Common.PolygonManipulation.YuPengClipper.CalculateResultChain(System.Collections.Generic.List{System.Single},System.Collections.Generic.List{FarseerPhysics.Common.PolygonManipulation.YuPengClipper.Edge},System.Collections.Generic.List{System.Single},System.Collections.Generic.List{FarseerPhysics.Common.PolygonManipulation.YuPengClipper.Edge},FarseerPhysics.Common.PolygonManipulation.PolyClipType,System.Collections.Generic.List{FarseerPhysics.Common.PolygonManipulation.YuPengClipper.Edge}@)">
      <summary>
            Calculates the characteristics function for all edges of
            the given simplical chains and builds the result chain.
            </summary>
      <remarks>Used by method <c>Execute()</c>.</remarks>
    </member>
    <member name="M:FarseerPhysics.Common.PolygonManipulation.YuPengClipper.BuildPolygonsFromChain(System.Collections.Generic.List{FarseerPhysics.Common.PolygonManipulation.YuPengClipper.Edge},System.Collections.Generic.List{FarseerPhysics.Common.Vertices}@)">
      <summary>
            Calculates the polygon(s) from the result simplical chain.
            </summary>
      <remarks>Used by method <c>Execute()</c>.</remarks>
    </member>
    <member name="M:FarseerPhysics.Common.PolygonManipulation.YuPengClipper.CalculateBeta(Microsoft.Xna.Framework.Vector2,FarseerPhysics.Common.PolygonManipulation.YuPengClipper.Edge,System.Single)">
      <summary>
            Needed to calculate the characteristics function of a simplex.
            </summary>
      <remarks>Used by method <c>CalculateEdgeCharacter()</c>.</remarks>
    </member>
    <member name="M:FarseerPhysics.Common.PolygonManipulation.YuPengClipper.GetAlpha(Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2)">
      <summary>
            Needed for sorting multiple intersections points on the same edge.
            </summary>
      <remarks>Used by method <c>CalculateIntersections()</c>.</remarks>
    </member>
    <member name="M:FarseerPhysics.Common.PolygonManipulation.YuPengClipper.CalculateSimplexCoefficient(Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2)">
      <summary>
            Returns the coefficient of a simplex.
            </summary>
      <remarks>Used by method <c>CalculateSimplicalChain()</c>.</remarks>
    </member>
    <member name="M:FarseerPhysics.Common.PolygonManipulation.YuPengClipper.PointInSimplex(Microsoft.Xna.Framework.Vector2,FarseerPhysics.Common.PolygonManipulation.YuPengClipper.Edge)">
      <summary>
            Winding number test for a point in a simplex.
            </summary>
      <param name="point">The point to be tested.</param>
      <param name="edge">The edge that the point is tested against.</param>
      <returns>False if the winding number is even and the point is outside
            the simplex and True otherwise.</returns>
    </member>
    <member name="M:FarseerPhysics.Common.PolygonManipulation.YuPengClipper.PointOnLineSegment(Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2)">
      <summary>
            Tests if a point lies on a line segment.
            </summary>
      <remarks>Used by method <c>CalculateBeta()</c>.</remarks>
    </member>
    <member name="T:Poly2Tri.Triangulation.Delaunay.Sweep.AdvancingFront">
            @author Thomas Ã…hlen (thahlen@gmail.com)
        </member>
    <member name="M:Poly2Tri.Triangulation.Delaunay.Sweep.AdvancingFront.FindSearchNode(System.Double)">
      <summary>
            MM:  This seems to be used by LocateNode to guess a position in the implicit linked list of AdvancingFrontNodes near x
                 Removed an overload that depended on this being exact
            </summary>
    </member>
    <member name="M:Poly2Tri.Triangulation.Delaunay.Sweep.AdvancingFront.LocateNode(Poly2Tri.Triangulation.TriangulationPoint)">
      <summary>
            We use a balancing tree to locate a node smaller or equal to given key value
            </summary>
    </member>
    <member name="M:Poly2Tri.Triangulation.Delaunay.Sweep.AdvancingFront.LocatePoint(Poly2Tri.Triangulation.TriangulationPoint)">
      <summary>
            This implementation will use simple node traversal algorithm to find a point on the front
            </summary>
    </member>
    <member name="M:FarseerPhysics.Factories.BodyFactory.CreateCapsule(FarseerPhysics.Dynamics.World,System.Single,System.Single,System.Int32,System.Single,System.Int32,System.Single,Microsoft.Xna.Framework.Vector2,System.Object)">
      <summary>
            Creates a capsule.
            Note: Automatically decomposes the capsule if it contains too many vertices (controlled by Settings.MaxPolygonVertices)
            </summary>
      <param name="world">The world.</param>
      <param name="height">The height.</param>
      <param name="topRadius">The top radius.</param>
      <param name="topEdges">The top edges.</param>
      <param name="bottomRadius">The bottom radius.</param>
      <param name="bottomEdges">The bottom edges.</param>
      <param name="density">The density.</param>
      <param name="position">The position.</param>
      <returns>
      </returns>
    </member>
    <member name="M:FarseerPhysics.Factories.BodyFactory.CreateRoundedRectangle(FarseerPhysics.Dynamics.World,System.Single,System.Single,System.Single,System.Single,System.Int32,System.Single,Microsoft.Xna.Framework.Vector2,System.Object)">
      <summary>
            Creates a rounded rectangle.
            Note: Automatically decomposes the capsule if it contains too many vertices (controlled by Settings.MaxPolygonVertices)
            </summary>
      <param name="world">The world.</param>
      <param name="width">The width.</param>
      <param name="height">The height.</param>
      <param name="xRadius">The x radius.</param>
      <param name="yRadius">The y radius.</param>
      <param name="segments">The segments.</param>
      <param name="density">The density.</param>
      <param name="position">The position.</param>
      <returns>
      </returns>
    </member>
    <member name="M:FarseerPhysics.Factories.BodyFactory.CreateBreakableBody(FarseerPhysics.Dynamics.World,FarseerPhysics.Common.Vertices,System.Single,Microsoft.Xna.Framework.Vector2,System.Object)">
      <summary>
            Creates a breakable body. You would want to remove collinear points before using this.
            </summary>
      <param name="world">The world.</param>
      <param name="vertices">The vertices.</param>
      <param name="density">The density.</param>
      <param name="position">The position.</param>
      <returns>
      </returns>
    </member>
    <member name="T:FarseerPhysics.Controllers.VelocityLimitController">
      <summary>
            Put a limit on the linear (translation - the movespeed) and angular (rotation) velocity
            of bodies added to this controller.
            </summary>
    </member>
    <member name="M:FarseerPhysics.Controllers.VelocityLimitController.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:FarseerPhysics.Controllers.VelocityLimitController" /> class.
            Sets the max linear velocity to Settings.MaxTranslation
            Sets the max angular velocity to Settings.MaxRotation
            </summary>
    </member>
    <member name="M:FarseerPhysics.Controllers.VelocityLimitController.#ctor(System.Single,System.Single)">
      <summary>
            Initializes a new instance of the <see cref="T:FarseerPhysics.Controllers.VelocityLimitController" /> class.
            Pass in 0 or float.MaxValue to disable the limit.
            maxAngularVelocity = 0 will disable the angular velocity limit.
            </summary>
      <param name="maxLinearVelocity">The max linear velocity.</param>
      <param name="maxAngularVelocity">The max angular velocity.</param>
    </member>
    <member name="P:FarseerPhysics.Controllers.VelocityLimitController.MaxAngularVelocity">
      <summary>
            Gets or sets the max angular velocity.
            </summary>
      <value>The max angular velocity.</value>
    </member>
    <member name="P:FarseerPhysics.Controllers.VelocityLimitController.MaxLinearVelocity">
      <summary>
            Gets or sets the max linear velocity.
            </summary>
      <value>The max linear velocity.</value>
    </member>
    <member name="M:FarseerPhysics.Common.PolygonTools.CreateRectangle(System.Single,System.Single)">
      <summary>
            Build vertices to represent an axis-aligned box.
            </summary>
      <param name="hx">the half-width.</param>
      <param name="hy">the half-height.</param>
    </member>
    <member name="M:FarseerPhysics.Common.PolygonTools.CreateRectangle(System.Single,System.Single,Microsoft.Xna.Framework.Vector2,System.Single)">
      <summary>
            Build vertices to represent an oriented box.
            </summary>
      <param name="hx">the half-width.</param>
      <param name="hy">the half-height.</param>
      <param name="center">the center of the box in local coordinates.</param>
      <param name="angle">the rotation of the box in local coordinates.</param>
    </member>
    <member name="M:FarseerPhysics.Common.PolygonTools.CreateRoundedRectangle(System.Single,System.Single,System.Single,System.Single,System.Int32)">
      <summary>
            Creates a rounded rectangle with the specified width and height.
            </summary>
      <param name="width">The width.</param>
      <param name="height">The height.</param>
      <param name="xRadius">The rounding X radius.</param>
      <param name="yRadius">The rounding Y radius.</param>
      <param name="segments">The number of segments to subdivide the edges.</param>
      <returns>
      </returns>
    </member>
    <member name="M:FarseerPhysics.Common.PolygonTools.CreateLine(Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2)">
      <summary>
            Set this as a single edge.
            </summary>
      <param name="start">The first point.</param>
      <param name="end">The second point.</param>
    </member>
    <member name="M:FarseerPhysics.Common.PolygonTools.CreateCircle(System.Single,System.Int32)">
      <summary>
            Creates a circle with the specified radius and number of edges.
            </summary>
      <param name="radius">The radius.</param>
      <param name="numberOfEdges">The number of edges. The more edges, the more it resembles a circle</param>
      <returns>
      </returns>
    </member>
    <member name="M:FarseerPhysics.Common.PolygonTools.CreateEllipse(System.Single,System.Single,System.Int32)">
      <summary>
            Creates a ellipse with the specified width, height and number of edges.
            </summary>
      <param name="xRadius">Width of the ellipse.</param>
      <param name="yRadius">Height of the ellipse.</param>
      <param name="numberOfEdges">The number of edges. The more edges, the more it resembles an ellipse</param>
      <returns>
      </returns>
    </member>
    <member name="M:FarseerPhysics.Common.PolygonTools.CreateCapsule(System.Single,System.Single,System.Int32)">
      <summary>
            Creates an capsule with the specified height, radius and number of edges.
            A capsule has the same form as a pill capsule.
            </summary>
      <param name="height">Height (inner height + 2 * radius) of the capsule.</param>
      <param name="endRadius">Radius of the capsule ends.</param>
      <param name="edges">The number of edges of the capsule ends. The more edges, the more it resembles an capsule</param>
      <returns>
      </returns>
    </member>
    <member name="M:FarseerPhysics.Common.PolygonTools.CreateCapsule(System.Single,System.Single,System.Int32,System.Single,System.Int32)">
      <summary>
            Creates an capsule with the specified  height, radius and number of edges.
            A capsule has the same form as a pill capsule.
            </summary>
      <param name="height">Height (inner height + radii) of the capsule.</param>
      <param name="topRadius">Radius of the top.</param>
      <param name="topEdges">The number of edges of the top. The more edges, the more it resembles an capsule</param>
      <param name="bottomRadius">Radius of bottom.</param>
      <param name="bottomEdges">The number of edges of the bottom. The more edges, the more it resembles an capsule</param>
      <returns>
      </returns>
    </member>
    <member name="M:FarseerPhysics.Common.PolygonTools.CreateGear(System.Single,System.Int32,System.Single,System.Single)">
      <summary>
            Creates a gear shape with the specified radius and number of teeth.
            </summary>
      <param name="radius">The radius.</param>
      <param name="numberOfTeeth">The number of teeth.</param>
      <param name="tipPercentage">The tip percentage.</param>
      <param name="toothHeight">Height of the tooth.</param>
      <returns>
      </returns>
    </member>
    <member name="M:FarseerPhysics.Common.PolygonTools.CreatePolygon(System.UInt32[],System.Int32)">
      <summary>
            Detects the vertices by analyzing the texture data.
            </summary>
      <param name="data">The texture data.</param>
      <param name="width">The texture width.</param>
      <returns>
      </returns>
    </member>
    <member name="M:FarseerPhysics.Common.PolygonTools.CreatePolygon(System.UInt32[],System.Int32,System.Boolean)">
      <summary>
            Detects the vertices by analyzing the texture data.
            </summary>
      <param name="data">The texture data.</param>
      <param name="width">The texture width.</param>
      <param name="holeDetection">if set to <c>true</c> it will perform hole detection.</param>
      <returns>
      </returns>
    </member>
    <member name="M:FarseerPhysics.Common.PolygonTools.CreatePolygon(System.UInt32[],System.Int32,System.Single,System.Byte,System.Boolean,System.Boolean)">
      <summary>
            Detects the vertices by analyzing the texture data.
            </summary>
      <param name="data">The texture data.</param>
      <param name="width">The texture width.</param>
      <param name="hullTolerance">The hull tolerance.</param>
      <param name="alphaTolerance">The alpha tolerance.</param>
      <param name="multiPartDetection">if set to <c>true</c> it will perform multi part detection.</param>
      <param name="holeDetection">if set to <c>true</c> it will perform hole detection.</param>
      <returns>
      </returns>
    </member>
    <member name="T:FarseerPhysics.Collision.Shapes.MassData">
      <summary>
            This holds the mass data computed for a shape.
            </summary>
    </member>
    <member name="F:FarseerPhysics.Collision.Shapes.MassData.Area">
      <summary>
            The area of the shape
            </summary>
    </member>
    <member name="F:FarseerPhysics.Collision.Shapes.MassData.Centroid">
      <summary>
            The position of the shape's centroid relative to the shape's origin.
            </summary>
    </member>
    <member name="F:FarseerPhysics.Collision.Shapes.MassData.Inertia">
      <summary>
            The rotational inertia of the shape about the local origin.
            </summary>
    </member>
    <member name="F:FarseerPhysics.Collision.Shapes.MassData.Mass">
      <summary>
            The mass of the shape, usually in kilograms.
            </summary>
    </member>
    <member name="T:FarseerPhysics.Collision.Shapes.Shape">
      <summary>
            A shape is used for collision detection. You can create a shape however you like.
            Shapes used for simulation in World are created automatically when a Fixture
            is created. Shapes may encapsulate a one or more child shapes.
            </summary>
    </member>
    <member name="M:FarseerPhysics.Collision.Shapes.Shape.Clone">
      <summary>
            Clone the concrete shape
            </summary>
      <returns>A clone of the shape</returns>
    </member>
    <member name="M:FarseerPhysics.Collision.Shapes.Shape.TestPoint(FarseerPhysics.Common.Transform@,Microsoft.Xna.Framework.Vector2@)">
      <summary>
            Test a point for containment in this shape. This only works for convex shapes.
            </summary>
      <param name="transform">The shape world transform.</param>
      <param name="point">a point in world coordinates.</param>
      <returns>True if the point is inside the shape</returns>
    </member>
    <member name="M:FarseerPhysics.Collision.Shapes.Shape.RayCast(FarseerPhysics.Collision.RayCastOutput@,FarseerPhysics.Collision.RayCastInput@,FarseerPhysics.Common.Transform@,System.Int32)">
      <summary>
            Cast a ray against a child shape.
            </summary>
      <param name="output">The ray-cast results.</param>
      <param name="input">The ray-cast input parameters.</param>
      <param name="transform">The transform to be applied to the shape.</param>
      <param name="childIndex">The child shape index.</param>
      <returns>True if the ray-cast hits the shape</returns>
    </member>
    <member name="M:FarseerPhysics.Collision.Shapes.Shape.ComputeAABB(FarseerPhysics.Collision.AABB@,FarseerPhysics.Common.Transform@,System.Int32)">
      <summary>
            Given a transform, compute the associated axis aligned bounding box for a child shape.
            </summary>
      <param name="aabb">The aabb results.</param>
      <param name="transform">The world transform of the shape.</param>
      <param name="childIndex">The child shape index.</param>
    </member>
    <member name="M:FarseerPhysics.Collision.Shapes.Shape.ComputeProperties">
      <summary>
            Compute the mass properties of this shape using its dimensions and density.
            The inertia tensor is computed about the local origin, not the centroid.
            </summary>
    </member>
    <member name="P:FarseerPhysics.Collision.Shapes.Shape.ShapeType">
      <summary>
            Get the type of this shape.
            </summary>
      <value>The type of the shape.</value>
    </member>
    <member name="P:FarseerPhysics.Collision.Shapes.Shape.ChildCount">
      <summary>
            Get the number of child primitives.
            </summary>
      <value>
      </value>
    </member>
    <member name="P:FarseerPhysics.Collision.Shapes.Shape.Density">
      <summary>
            Gets or sets the density.
            </summary>
      <value>The density.</value>
    </member>
    <member name="P:FarseerPhysics.Collision.Shapes.Shape.Radius">
      <summary>
            Radius of the Shape
            </summary>
    </member>
    <member name="M:FarseerPhysics.Collision.Shapes.CircleShape.TestPoint(FarseerPhysics.Common.Transform@,Microsoft.Xna.Framework.Vector2@)">
      <summary>
            Test a point for containment in this shape. This only works for convex shapes.
            </summary>
      <param name="transform">The shape world transform.</param>
      <param name="point">a point in world coordinates.</param>
      <returns>True if the point is inside the shape</returns>
    </member>
    <member name="M:FarseerPhysics.Collision.Shapes.CircleShape.RayCast(FarseerPhysics.Collision.RayCastOutput@,FarseerPhysics.Collision.RayCastInput@,FarseerPhysics.Common.Transform@,System.Int32)">
      <summary>
            Cast a ray against a child shape.
            </summary>
      <param name="output">The ray-cast results.</param>
      <param name="input">The ray-cast input parameters.</param>
      <param name="transform">The transform to be applied to the shape.</param>
      <param name="childIndex">The child shape index.</param>
      <returns>True if the ray-cast hits the shape</returns>
    </member>
    <member name="M:FarseerPhysics.Collision.Shapes.CircleShape.ComputeAABB(FarseerPhysics.Collision.AABB@,FarseerPhysics.Common.Transform@,System.Int32)">
      <summary>
            Given a transform, compute the associated axis aligned bounding box for a child shape.
            </summary>
      <param name="aabb">The aabb results.</param>
      <param name="transform">The world transform of the shape.</param>
      <param name="childIndex">The child shape index.</param>
    </member>
    <member name="M:FarseerPhysics.Collision.Shapes.CircleShape.ComputeProperties">
      <summary>
            Compute the mass properties of this shape using its dimensions and density.
            The inertia tensor is computed about the local origin, not the centroid.
            </summary>
    </member>
    <member name="T:FarseerPhysics.Dynamics.Joints.FixedPrismaticJoint">
      <summary>
            A prismatic joint. This joint provides one degree of freedom: translation
            along an axis fixed in body1. Relative rotation is prevented. You can
            use a joint limit to restrict the range of motion and a joint motor to
            drive the motion or to model joint friction.
            </summary>
    </member>
    <member name="M:FarseerPhysics.Dynamics.Joints.FixedPrismaticJoint.#ctor(FarseerPhysics.Dynamics.Body,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2)">
      <summary>
            This requires defining a line of
            motion using an axis and an anchor point. The definition uses local
            anchor points and a local axis so that the initial configuration
            can violate the constraint slightly. The joint translation is zero
            when the local anchor points coincide in world space. Using local
            anchors and a local axis helps when saving and loading a game.
            </summary>
      <param name="body">The body.</param>
      <param name="worldAnchor">The anchor.</param>
      <param name="axis">The axis.</param>
    </member>
    <member name="P:FarseerPhysics.Dynamics.Joints.FixedPrismaticJoint.JointTranslation">
      <summary>
            Get the current joint translation, usually in meters.
            </summary>
      <value>
      </value>
    </member>
    <member name="P:FarseerPhysics.Dynamics.Joints.FixedPrismaticJoint.JointSpeed">
      <summary>
            Get the current joint translation speed, usually in meters per second.
            </summary>
      <value>
      </value>
    </member>
    <member name="P:FarseerPhysics.Dynamics.Joints.FixedPrismaticJoint.LimitEnabled">
      <summary>
            Is the joint limit enabled?
            </summary>
      <value>
        <c>true</c> if [limit enabled]; otherwise, <c>false</c>.</value>
    </member>
    <member name="P:FarseerPhysics.Dynamics.Joints.FixedPrismaticJoint.LowerLimit">
      <summary>
            Get the lower joint limit, usually in meters.
            </summary>
      <value>
      </value>
    </member>
    <member name="P:FarseerPhysics.Dynamics.Joints.FixedPrismaticJoint.UpperLimit">
      <summary>
            Get the upper joint limit, usually in meters.
            </summary>
      <value>
      </value>
    </member>
    <member name="P:FarseerPhysics.Dynamics.Joints.FixedPrismaticJoint.MotorEnabled">
      <summary>
            Is the joint motor enabled?
            </summary>
      <value>
        <c>true</c> if [motor enabled]; otherwise, <c>false</c>.</value>
    </member>
    <member name="P:FarseerPhysics.Dynamics.Joints.FixedPrismaticJoint.MotorSpeed">
      <summary>
            Set the motor speed, usually in meters per second.
            </summary>
      <value>The speed.</value>
    </member>
    <member name="P:FarseerPhysics.Dynamics.Joints.FixedPrismaticJoint.MaxMotorForce">
      <summary>
            Set the maximum motor force, usually in N.
            </summary>
      <value>The force.</value>
    </member>
    <member name="P:FarseerPhysics.Dynamics.Joints.FixedPrismaticJoint.MotorForce">
      <summary>
            Get the current motor force, usually in N.
            </summary>
      <value>
      </value>
    </member>
    <member name="M:Poly2Tri.Triangulation.Delaunay.Sweep.DTSweepConstraint.#ctor(Poly2Tri.Triangulation.TriangulationPoint,Poly2Tri.Triangulation.TriangulationPoint)">
      <summary>
            Give two points in any order. Will always be ordered so
            that q.y &gt; p.y and q.x &gt; p.x if same y value 
            </summary>
    </member>
    <member name="M:FarseerPhysics.Common.ConvexHull.ChainHull.GetConvexHull(FarseerPhysics.Common.Vertices)">
      <summary>
            Gets the convex hull.
            </summary>
      <remarks>
            http://www.softsurfer.com/Archive/algorithm_0109/algorithm_0109.htm
            </remarks>
      <returns>
      </returns>
    </member>
    <member name="T:FarseerPhysics.Factories.JointFactory">
      <summary>
            An easy to use factory for using joints.
            </summary>
    </member>
    <member name="M:FarseerPhysics.Factories.JointFactory.CreateRevoluteJoint(FarseerPhysics.Dynamics.Body,FarseerPhysics.Dynamics.Body,Microsoft.Xna.Framework.Vector2)">
      <summary>
            Creates a revolute joint.
            </summary>
      <param name="bodyA">
      </param>
      <param name="bodyB">
      </param>
      <param name="localAnchorB">The anchor of bodyB in local coordinates</param>
      <returns>
      </returns>
    </member>
    <member name="M:FarseerPhysics.Factories.JointFactory.CreateRevoluteJoint(FarseerPhysics.Dynamics.World,FarseerPhysics.Dynamics.Body,FarseerPhysics.Dynamics.Body,Microsoft.Xna.Framework.Vector2)">
      <summary>
            Creates a revolute joint and adds it to the world
            </summary>
      <param name="world">
      </param>
      <param name="bodyA">
      </param>
      <param name="bodyB">
      </param>
      <param name="anchor">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:FarseerPhysics.Factories.JointFactory.CreateFixedRevoluteJoint(FarseerPhysics.Dynamics.World,FarseerPhysics.Dynamics.Body,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2)">
      <summary>
            Creates the fixed revolute joint.
            </summary>
      <param name="world">The world.</param>
      <param name="body">The body.</param>
      <param name="bodyAnchor">The body anchor.</param>
      <param name="worldAnchor">The world anchor.</param>
      <returns>
      </returns>
    </member>
    <member name="M:FarseerPhysics.Factories.JointFactory.CreateWeldJoint(FarseerPhysics.Dynamics.Body,FarseerPhysics.Dynamics.Body,Microsoft.Xna.Framework.Vector2)">
      <summary>
            Creates a weld joint
            </summary>
      <param name="bodyA">
      </param>
      <param name="bodyB">
      </param>
      <param name="localAnchor">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:FarseerPhysics.Factories.JointFactory.CreateWeldJoint(FarseerPhysics.Dynamics.World,FarseerPhysics.Dynamics.Body,FarseerPhysics.Dynamics.Body,Microsoft.Xna.Framework.Vector2)">
      <summary>
            Creates a weld joint and adds it to the world
            </summary>
      <param name="world">
      </param>
      <param name="bodyA">
      </param>
      <param name="bodyB">
      </param>
      <param name="localanchorB">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:FarseerPhysics.Factories.JointFactory.CreatePrismaticJoint(FarseerPhysics.Dynamics.Body,FarseerPhysics.Dynamics.Body,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2)">
      <summary>
            Creates a prsimatic joint
            </summary>
      <param name="bodyA">
      </param>
      <param name="bodyB">
      </param>
      <param name="localanchorB">
      </param>
      <param name="axis">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:FarseerPhysics.Factories.JointFactory.CreatePrismaticJoint(FarseerPhysics.Dynamics.World,FarseerPhysics.Dynamics.Body,FarseerPhysics.Dynamics.Body,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2)">
      <summary>
            Creates a prismatic joint and adds it to the world
            </summary>
      <param name="world">
      </param>
      <param name="bodyA">
      </param>
      <param name="bodyB">
      </param>
      <param name="localanchorB">
      </param>
      <param name="axis">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:FarseerPhysics.Factories.JointFactory.CreateLineJoint(FarseerPhysics.Dynamics.Body,FarseerPhysics.Dynamics.Body,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2)">
      <summary>
            Creates a line joint
            </summary>
      <param name="bodyA">
      </param>
      <param name="bodyB">
      </param>
      <param name="anchor">
      </param>
      <param name="axis">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:FarseerPhysics.Factories.JointFactory.CreateLineJoint(FarseerPhysics.Dynamics.World,FarseerPhysics.Dynamics.Body,FarseerPhysics.Dynamics.Body,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2)">
      <summary>
            Creates a line joint and adds it to the world
            </summary>
      <param name="world">
      </param>
      <param name="bodyA">
      </param>
      <param name="bodyB">
      </param>
      <param name="localanchorB">
      </param>
      <param name="axis">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:FarseerPhysics.Factories.JointFactory.CreateAngleJoint(FarseerPhysics.Dynamics.World,FarseerPhysics.Dynamics.Body,FarseerPhysics.Dynamics.Body)">
      <summary>
            Creates an angle joint.
            </summary>
      <param name="world">The world.</param>
      <param name="bodyA">The first body.</param>
      <param name="bodyB">The second body.</param>
      <returns>
      </returns>
    </member>
    <member name="M:FarseerPhysics.Factories.JointFactory.CreateFixedAngleJoint(FarseerPhysics.Dynamics.World,FarseerPhysics.Dynamics.Body)">
      <summary>
            Creates a fixed angle joint.
            </summary>
      <param name="world">The world.</param>
      <param name="body">The body.</param>
      <returns>
      </returns>
    </member>
    <member name="T:FarseerPhysics.Dynamics.Joints.FixedDistanceJoint">
      <summary>
            A distance joint rains two points on two bodies
            to remain at a fixed distance from each other. You can view
            this as a massless, rigid rod.
            </summary>
    </member>
    <member name="F:FarseerPhysics.Dynamics.Joints.FixedDistanceJoint.LocalAnchorA">
      <summary>
            The local anchor point relative to bodyA's origin.
            </summary>
    </member>
    <member name="M:FarseerPhysics.Dynamics.Joints.FixedDistanceJoint.#ctor(FarseerPhysics.Dynamics.Body,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2)">
      <summary>
            This requires defining an
            anchor point on both bodies and the non-zero length of the
            distance joint. If you don't supply a length, the local anchor points
            is used so that the initial configuration can violate the constraint
            slightly. This helps when saving and loading a game.
            @warning Do not use a zero or short length.
            </summary>
      <param name="body">The body.</param>
      <param name="bodyAnchor">The body anchor.</param>
      <param name="worldAnchor">The world anchor.</param>
    </member>
    <member name="P:FarseerPhysics.Dynamics.Joints.FixedDistanceJoint.Length">
      <summary>
            The natural length between the anchor points.
            Manipulating the length can lead to non-physical behavior when the frequency is zero.
            </summary>
    </member>
    <member name="P:FarseerPhysics.Dynamics.Joints.FixedDistanceJoint.Frequency">
      <summary>
            The mass-spring-damper frequency in Hertz.
            </summary>
    </member>
    <member name="P:FarseerPhysics.Dynamics.Joints.FixedDistanceJoint.DampingRatio">
      <summary>
            The damping ratio. 0 = no damping, 1 = critical damping.
            </summary>
    </member>
    <member name="T:FarseerPhysics.Common.PhysicsLogic.RayDataComparer">
      <summary>
            This is a comprarer used for 
            detecting angle difference between rays
            </summary>
    </member>
    <member name="F:FarseerPhysics.Common.PhysicsLogic.Explosion.MaxEdgeOffset">
      <summary>
            Two degrees: maximum angle from edges to first ray tested
            </summary>
    </member>
    <member name="F:FarseerPhysics.Common.PhysicsLogic.Explosion.EdgeRatio">
      <summary>
            Ratio of arc length to angle from edges to first ray tested.
            Defaults to 1/40.
            </summary>
    </member>
    <member name="F:FarseerPhysics.Common.PhysicsLogic.Explosion.IgnoreWhenInsideShape">
      <summary>
            Ignore Explosion if it happens inside a shape.
            Default value is false.
            </summary>
    </member>
    <member name="F:FarseerPhysics.Common.PhysicsLogic.Explosion.MaxAngle">
      <summary>
            Max angle between rays (used when segment is large).
            Defaults to 15 degrees
            </summary>
    </member>
    <member name="F:FarseerPhysics.Common.PhysicsLogic.Explosion.MaxShapes">
      <summary>
            Maximum number of shapes involved in the explosion.
            Defaults to 100
            </summary>
    </member>
    <member name="F:FarseerPhysics.Common.PhysicsLogic.Explosion.MinRays">
      <summary>
            How many rays per shape/body/segment.
            Defaults to 5
            </summary>
    </member>
    <member name="M:FarseerPhysics.Common.PhysicsLogic.Explosion.Activate(Microsoft.Xna.Framework.Vector2,System.Single,System.Single)">
      <summary>
            This makes the explosive explode
            </summary>
      <param name="pos">
            The position where the explosion happens
            </param>
      <param name="radius">
            The explosion radius
            </param>
      <param name="maxForce">
            The explosion force at the explosion point
            (then is inversely proportional to the square of the distance)
            </param>
      <returns>
            A dictionnary containing all the "exploded" fixtures
            with a list of the applied impulses
            </returns>
    </member>
    <member name="T:FarseerPhysics.Common.LineTools">
      <summary>
            Collection of helper methods for misc collisions.
            Does float tolerance and line collisions with lines and AABBs.
            </summary>
    </member>
    <member name="M:FarseerPhysics.Common.LineTools.LineIntersect2(Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2@)">
      <summary>
            Check if the lines a0-&gt;a1 and b0-&gt;b1 cross.
            If they do, intersectionPoint will be filled
            with the point of crossing.
            
            Grazing lines should not return true.
             
             </summary>
      <param name="a0">
      </param>
      <param name="a1">
      </param>
      <param name="b0">
      </param>
      <param name="b1">
      </param>
      <param name="intersectionPoint">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:FarseerPhysics.Common.LineTools.LineIntersect(Microsoft.Xna.Framework.Vector2@,Microsoft.Xna.Framework.Vector2@,Microsoft.Xna.Framework.Vector2@,Microsoft.Xna.Framework.Vector2@,System.Boolean,System.Boolean,Microsoft.Xna.Framework.Vector2@)">
      <summary>
            This method detects if two line segments (or lines) intersect,
            and, if so, the point of intersection. Use the <paramref name="firstIsSegment" /> and
            <paramref name="secondIsSegment" /> parameters to set whether the intersection point
            must be on the first and second line segments. Setting these
            both to true means you are doing a line-segment to line-segment
            intersection. Setting one of them to true means you are doing a
            line to line-segment intersection test, and so on.
            Note: If two line segments are coincident, then 
            no intersection is detected (there are actually
            infinite intersection points).
            Author: Jeremy Bell
            </summary>
      <param name="point1">The first point of the first line segment.</param>
      <param name="point2">The second point of the first line segment.</param>
      <param name="point3">The first point of the second line segment.</param>
      <param name="point4">The second point of the second line segment.</param>
      <param name="point">This is set to the intersection
            point if an intersection is detected.</param>
      <param name="firstIsSegment">Set this to true to require that the 
            intersection point be on the first line segment.</param>
      <param name="secondIsSegment">Set this to true to require that the
            intersection point be on the second line segment.</param>
      <returns>True if an intersection is detected, false otherwise.</returns>
    </member>
    <member name="M:FarseerPhysics.Common.LineTools.LineIntersect(Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,System.Boolean,System.Boolean,Microsoft.Xna.Framework.Vector2@)">
      <summary>
            This method detects if two line segments (or lines) intersect,
            and, if so, the point of intersection. Use the <paramref name="firstIsSegment" /> and
            <paramref name="secondIsSegment" /> parameters to set whether the intersection point
            must be on the first and second line segments. Setting these
            both to true means you are doing a line-segment to line-segment
            intersection. Setting one of them to true means you are doing a
            line to line-segment intersection test, and so on.
            Note: If two line segments are coincident, then 
            no intersection is detected (there are actually
            infinite intersection points).
            Author: Jeremy Bell
            </summary>
      <param name="point1">The first point of the first line segment.</param>
      <param name="point2">The second point of the first line segment.</param>
      <param name="point3">The first point of the second line segment.</param>
      <param name="point4">The second point of the second line segment.</param>
      <param name="intersectionPoint">This is set to the intersection
            point if an intersection is detected.</param>
      <param name="firstIsSegment">Set this to true to require that the 
            intersection point be on the first line segment.</param>
      <param name="secondIsSegment">Set this to true to require that the
            intersection point be on the second line segment.</param>
      <returns>True if an intersection is detected, false otherwise.</returns>
    </member>
    <member name="M:FarseerPhysics.Common.LineTools.LineIntersect(Microsoft.Xna.Framework.Vector2@,Microsoft.Xna.Framework.Vector2@,Microsoft.Xna.Framework.Vector2@,Microsoft.Xna.Framework.Vector2@,Microsoft.Xna.Framework.Vector2@)">
      <summary>
            This method detects if two line segments intersect,
            and, if so, the point of intersection. 
            Note: If two line segments are coincident, then 
            no intersection is detected (there are actually
            infinite intersection points).
            </summary>
      <param name="point1">The first point of the first line segment.</param>
      <param name="point2">The second point of the first line segment.</param>
      <param name="point3">The first point of the second line segment.</param>
      <param name="point4">The second point of the second line segment.</param>
      <param name="intersectionPoint">This is set to the intersection
            point if an intersection is detected.</param>
      <returns>True if an intersection is detected, false otherwise.</returns>
    </member>
    <member name="M:FarseerPhysics.Common.LineTools.LineIntersect(Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2@)">
      <summary>
            This method detects if two line segments intersect,
            and, if so, the point of intersection. 
            Note: If two line segments are coincident, then 
            no intersection is detected (there are actually
            infinite intersection points).
            </summary>
      <param name="point1">The first point of the first line segment.</param>
      <param name="point2">The second point of the first line segment.</param>
      <param name="point3">The first point of the second line segment.</param>
      <param name="point4">The second point of the second line segment.</param>
      <param name="intersectionPoint">This is set to the intersection
            point if an intersection is detected.</param>
      <returns>True if an intersection is detected, false otherwise.</returns>
    </member>
    <member name="M:FarseerPhysics.Common.LineTools.LineSegmentVerticesIntersect(Microsoft.Xna.Framework.Vector2@,Microsoft.Xna.Framework.Vector2@,FarseerPhysics.Common.Vertices,System.Collections.Generic.List{Microsoft.Xna.Framework.Vector2}@)">
      <summary>
            Get all intersections between a line segment and a list of vertices
            representing a polygon. The vertices reuse adjacent points, so for example
            edges one and two are between the first and second vertices and between the
            second and third vertices. The last edge is between vertex vertices.Count - 1
            and verts0. (ie, vertices from a Geometry or AABB)
            </summary>
      <param name="point1">The first point of the line segment to test</param>
      <param name="point2">The second point of the line segment to test.</param>
      <param name="vertices">The vertices, as described above</param>
      <param name="intersectionPoints">An list of intersection points. Any intersection points
            found will be added to this list.</param>
    </member>
    <member name="M:FarseerPhysics.Common.LineTools.LineSegmentAABBIntersect(Microsoft.Xna.Framework.Vector2@,Microsoft.Xna.Framework.Vector2@,FarseerPhysics.Collision.AABB,System.Collections.Generic.List{Microsoft.Xna.Framework.Vector2}@)">
      <summary>
            Get all intersections between a line segment and an AABB. 
            </summary>
      <param name="point1">The first point of the line segment to test</param>
      <param name="point2">The second point of the line segment to test.</param>
      <param name="aabb">The AABB that is used for testing intersection.</param>
      <param name="intersectionPoints">An list of intersection points. Any intersection points found will be added to this list.</param>
    </member>
    <member name="T:FarseerPhysics.Common.Decomposition.SeidelDecomposer">
      <summary>
            Convex decomposition algorithm based on Raimund Seidel's paper "A simple and fast incremental randomized
            algorithm for computing trapezoidal decompositions and for triangulating polygons"
            See also: "Computational Geometry", 3rd edition, by Mark de Berg et al, Chapter 6.2
                      "Computational Geometry in C", 2nd edition, by Joseph O'Rourke
            </summary>
    </member>
    <member name="M:FarseerPhysics.Common.Decomposition.SeidelDecomposer.ConvexPartition(FarseerPhysics.Common.Vertices,System.Single)">
      <summary>
            Decompose the polygon into several smaller non-concave polygon.
            </summary>
      <param name="vertices">The polygon to decompose.</param>
      <param name="sheer">The sheer to use. If you get bad results, try using a higher value. The default value is 0.001</param>
      <returns>A list of triangles</returns>
    </member>
    <member name="M:FarseerPhysics.Common.Decomposition.SeidelDecomposer.ConvexPartitionTrapezoid(FarseerPhysics.Common.Vertices,System.Single)">
      <summary>
            Decompose the polygon into several smaller non-concave polygon.
            </summary>
      <param name="vertices">The polygon to decompose.</param>
      <param name="sheer">The sheer to use. If you get bad results, try using a higher value. The default value is 0.001</param>
      <returns>A list of trapezoids</returns>
    </member>
    <member name="M:QuadTreeBroadPhase.#ctor(FarseerPhysics.Collision.AABB)">
      <summary>
            Creates a new quad tree broadphase with the specified span.
            </summary>
      <param name="span">the maximum span of the tree (world size)</param>
    </member>
    <member name="M:QuadTreeBroadPhase.TestOverlap(System.Int32,System.Int32)">
      <summary>
            Test overlap of fat AABBs.
            </summary>
      <param name="proxyIdA">The proxy id A.</param>
      <param name="proxyIdB">The proxy id B.</param>
      <returns>
      </returns>
    </member>
    <member name="P:QuadTreeBroadPhase.ProxyCount">
      <summary>
             The number of proxies
            </summary>
    </member>
    <member name="F:FarseerPhysics.Settings.MaxSubSteps">
      <summary>
            Maximum number of sub-steps per contact in continuous physics simulation.
            </summary>
    </member>
    <member name="F:FarseerPhysics.Settings.ConserveMemory">
      <summary>
            Conserve memory makes sure that objects are used by reference instead of cloned.
            When you give a vertices collection to a PolygonShape, it will by default copy the vertices
            instead of using the original reference. This is to ensure that objects modified outside the engine
            does not affect the engine itself, however, this uses extra memory. This behavior
            can be turned off by setting ConserveMemory to true.
            </summary>
    </member>
    <member name="F:FarseerPhysics.Settings.MaxManifoldPoints">
      <summary>
            The maximum number of contact points between two convex shapes.
            </summary>
    </member>
    <member name="F:FarseerPhysics.Settings.AABBExtension">
      <summary>
            This is used to fatten AABBs in the dynamic tree. This allows proxies
            to move by a small amount without triggering a tree adjustment.
            This is in meters.
            </summary>
    </member>
    <member name="F:FarseerPhysics.Settings.AABBMultiplier">
      <summary>
            This is used to fatten AABBs in the dynamic tree. This is used to predict
            the future position based on the current displacement.
            This is a dimensionless multiplier.
            </summary>
    </member>
    <member name="F:FarseerPhysics.Settings.LinearSlop">
      <summary>
            A small length used as a collision and constraint tolerance. Usually it is
            chosen to be numerically significant, but visually insignificant.
            </summary>
    </member>
    <member name="F:FarseerPhysics.Settings.AngularSlop">
      <summary>
            A small angle used as a collision and constraint tolerance. Usually it is
            chosen to be numerically significant, but visually insignificant.
            </summary>
    </member>
    <member name="F:FarseerPhysics.Settings.PolygonRadius">
      <summary>
            The radius of the polygon/edge shape skin. This should not be modified. Making
            this smaller means polygons will have an insufficient buffer for continuous collision.
            Making it larger may create artifacts for vertex collision.
            </summary>
    </member>
    <member name="F:FarseerPhysics.Settings.MaxTOIContacts">
      <summary>
            Maximum number of contacts to be handled to solve a TOI impact.
            </summary>
    </member>
    <member name="F:FarseerPhysics.Settings.VelocityThreshold">
      <summary>
            A velocity threshold for elastic collisions. Any collision with a relative linear
            velocity below this threshold will be treated as inelastic.
            </summary>
    </member>
    <member name="F:FarseerPhysics.Settings.MaxLinearCorrection">
      <summary>
            The maximum linear position correction used when solving constraints. This helps to
            prevent overshoot.
            </summary>
    </member>
    <member name="F:FarseerPhysics.Settings.MaxAngularCorrection">
      <summary>
            The maximum angular position correction used when solving constraints. This helps to
            prevent overshoot.
            </summary>
    </member>
    <member name="F:FarseerPhysics.Settings.ContactBaumgarte">
      <summary>
            This scale factor controls how fast overlap is resolved. Ideally this would be 1 so
            that overlap is removed in one time step. However using values close to 1 often lead
            to overshoot.
            </summary>
    </member>
    <member name="F:FarseerPhysics.Settings.TimeToSleep">
      <summary>
            The time that a body must be still before it will go to sleep.
            </summary>
    </member>
    <member name="F:FarseerPhysics.Settings.LinearSleepTolerance">
      <summary>
            A body cannot sleep if its linear velocity is above this tolerance.
            </summary>
    </member>
    <member name="F:FarseerPhysics.Settings.AngularSleepTolerance">
      <summary>
            A body cannot sleep if its angular velocity is above this tolerance.
            </summary>
    </member>
    <member name="F:FarseerPhysics.Settings.MaxTranslation">
      <summary>
            The maximum linear velocity of a body. This limit is very large and is used
            to prevent numerical problems. You shouldn't need to adjust this.
            </summary>
    </member>
    <member name="F:FarseerPhysics.Settings.MaxRotation">
      <summary>
            The maximum angular velocity of a body. This limit is very large and is used
            to prevent numerical problems. You shouldn't need to adjust this.
            </summary>
    </member>
    <member name="F:FarseerPhysics.Settings.EnableDiagnostics">
      <summary>
            Enabling diagnistics causes the engine to gather timing information.
            You can see how much time it took to solve the contacts, solve CCD
            and update the controllers.
            NOTE: If you are using a debug view that shows performance counters,
            you might want to enable this.
            </summary>
    </member>
    <member name="F:FarseerPhysics.Settings.VelocityIterations">
      <summary>
            The number of velocity iterations used in the solver.
            </summary>
    </member>
    <member name="F:FarseerPhysics.Settings.PositionIterations">
      <summary>
            The number of position iterations used in the solver.
            </summary>
    </member>
    <member name="F:FarseerPhysics.Settings.ContinuousPhysics">
      <summary>
            Enable/Disable Continuous Collision Detection (CCD)
            </summary>
    </member>
    <member name="F:FarseerPhysics.Settings.TOIVelocityIterations">
      <summary>
            The number of velocity iterations in the TOI solver
            </summary>
    </member>
    <member name="F:FarseerPhysics.Settings.TOIPositionIterations">
      <summary>
            The number of position iterations in the TOI solver
            </summary>
    </member>
    <member name="F:FarseerPhysics.Settings.EnableWarmstarting">
      <summary>
            Enable/Disable warmstarting
            </summary>
    </member>
    <member name="F:FarseerPhysics.Settings.AllowSleep">
      <summary>
            Enable/Disable sleeping
            </summary>
    </member>
    <member name="F:FarseerPhysics.Settings.MaxPolygonVertices">
      <summary>
            The maximum number of vertices on a convex polygon.
            </summary>
    </member>
    <member name="F:FarseerPhysics.Settings.UseFPECollisionCategories">
      <summary>
            Farseer Physics Engine has a different way of filtering fixtures than Box2d.
            We have both FPE and Box2D filtering in the engine. If you are upgrading
            from earlier versions of FPE, set this to true.
            </summary>
    </member>
    <member name="M:FarseerPhysics.Settings.MixFriction(System.Single,System.Single)">
      <summary>
            Friction mixing law. Feel free to customize this.
            </summary>
      <param name="friction1">The friction1.</param>
      <param name="friction2">The friction2.</param>
      <returns>
      </returns>
    </member>
    <member name="M:FarseerPhysics.Settings.MixRestitution(System.Single,System.Single)">
      <summary>
            Restitution mixing law. Feel free to customize this.
            </summary>
      <param name="restitution1">The restitution1.</param>
      <param name="restitution2">The restitution2.</param>
      <returns>
      </returns>
    </member>
    <member name="T:FarseerPhysics.Dynamics.Joints.SliderJoint">
      <summary>
            A distance joint contrains two points on two bodies
            to remain at a fixed distance from each other. You can view
            this as a massless, rigid rod.
            </summary>
    </member>
    <member name="M:FarseerPhysics.Dynamics.Joints.SliderJoint.#ctor(FarseerPhysics.Dynamics.Body,FarseerPhysics.Dynamics.Body,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,System.Single,System.Single)">
      <summary>
            Initializes a new instance of the <see cref="T:FarseerPhysics.Dynamics.Joints.SliderJoint" /> class.
            Warning: Do not use a zero or short length.
            </summary>
      <param name="bodyA">The first body.</param>
      <param name="bodyB">The second body.</param>
      <param name="localAnchorA">The first body anchor.</param>
      <param name="localAnchorB">The second body anchor.</param>
      <param name="minLength">The minimum length between anchorpoints</param>
      <param name="maxlength">The maximum length between anchorpoints.</param>
    </member>
    <member name="P:FarseerPhysics.Dynamics.Joints.SliderJoint.MaxLength">
      <summary>
            The maximum length between the anchor points.
            </summary>
      <value>The length.</value>
    </member>
    <member name="P:FarseerPhysics.Dynamics.Joints.SliderJoint.MinLength">
      <summary>
            The minimal length between the anchor points.
            </summary>
      <value>The length.</value>
    </member>
    <member name="P:FarseerPhysics.Dynamics.Joints.SliderJoint.Frequency">
      <summary>
            The mass-spring-damper frequency in Hertz.
            </summary>
      <value>The frequency.</value>
    </member>
    <member name="P:FarseerPhysics.Dynamics.Joints.SliderJoint.DampingRatio">
      <summary>
            The damping ratio. 0 = no damping, 1 = critical damping.
            </summary>
      <value>The damping ratio.</value>
    </member>
    <member name="T:FarseerPhysics.Dynamics.Island">
      <summary>
            This is an internal class.
            </summary>
    </member>
    <member name="T:FarseerPhysics.Common.VerticesDetectionType">
      <summary>
            The detection type affects the resulting polygon data.
            </summary>
    </member>
    <member name="F:FarseerPhysics.Common.VerticesDetectionType.Integrated">
      <summary>
            Holes are integrated into the main polygon.
            </summary>
    </member>
    <member name="F:FarseerPhysics.Common.VerticesDetectionType.Separated">
      <summary>
            The data of the main polygon and hole polygons is returned separately.
            </summary>
    </member>
    <member name="M:FarseerPhysics.Common.Vertices.NextIndex(System.Int32)">
      <summary>
            Nexts the index.
            </summary>
      <param name="index">The index.</param>
      <returns>
      </returns>
    </member>
    <member name="M:FarseerPhysics.Common.Vertices.PreviousIndex(System.Int32)">
      <summary>
            Gets the previous index.
            </summary>
      <param name="index">The index.</param>
      <returns>
      </returns>
    </member>
    <member name="M:FarseerPhysics.Common.Vertices.GetSignedArea">
      <summary>
            Gets the signed area.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:FarseerPhysics.Common.Vertices.GetArea">
      <summary>
            Gets the area.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:FarseerPhysics.Common.Vertices.GetCentroid">
      <summary>
            Gets the centroid.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:FarseerPhysics.Common.Vertices.GetRadius">
      <summary>
            Gets the radius based on area.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:FarseerPhysics.Common.Vertices.GetCollisionBox">
      <summary>
            Returns an AABB for vertex.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:FarseerPhysics.Common.Vertices.Translate(Microsoft.Xna.Framework.Vector2@)">
      <summary>
            Translates the vertices with the specified vector.
            </summary>
      <param name="vector">The vector.</param>
    </member>
    <member name="M:FarseerPhysics.Common.Vertices.Scale(Microsoft.Xna.Framework.Vector2@)">
      <summary>
            Scales the vertices with the specified vector.
            </summary>
      <param name="value">The Value.</param>
    </member>
    <member name="M:FarseerPhysics.Common.Vertices.Rotate(System.Single)">
      <summary>
            Rotate the vertices with the defined value in radians.
            </summary>
      <param name="value">The amount to rotate by in radians.</param>
    </member>
    <member name="M:FarseerPhysics.Common.Vertices.IsConvex">
      <summary>
            Assuming the polygon is simple; determines whether the polygon is convex.
            NOTE: It will also return false if the input contains colinear edges.
            </summary>
      <returns>
        <c>true</c> if it is convex; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="M:FarseerPhysics.Common.Vertices.ForceCounterClockWise">
      <summary>
            Forces counter clock wise order.
            </summary>
    </member>
    <member name="M:FarseerPhysics.Common.Vertices.IsSimple">
      <summary>
            Check for edge crossings
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:FarseerPhysics.Common.Vertices.CheckPolygon">
      <summary>
             Checks if polygon is valid for use in Box2d engine.
             Last ditch effort to ensure no invalid polygons are
             added to world geometry.
            
             Performs a full check, for simplicity, convexity,
             orientation, minimum angle, and volume.  This won't
             be very efficient, and a lot of it is redundant when
             other tools in this section are used.
             </summary>
      <returns>
      </returns>
    </member>
    <member name="M:FarseerPhysics.Common.Vertices.TraceEdge(FarseerPhysics.Common.Vertices)">
      <summary>
            Trace the edge of a non-simple polygon and return a simple polygon.
            
            Method:
            Start at vertex with minimum y (pick maximum x one if there are two).
            We aim our "lastDir" vector at (1.0, 0)
            We look at the two rays going off from our start vertex, and follow whichever
            has the smallest angle (in -Pi . Pi) wrt lastDir ("rightest" turn)
            Loop until we hit starting vertex:
            We add our current vertex to the list.
            We check the seg from current vertex to next vertex for intersections
            - if no intersections, follow to next vertex and continue
            - if intersections, pick one with minimum distance
            - if more than one, pick one with "rightest" next point (two possibilities for each)
            </summary>
      <param name="verts">The vertices.</param>
      <returns>
      </returns>
    </member>
    <member name="M:FarseerPhysics.Common.Vertices.ProjectToAxis(Microsoft.Xna.Framework.Vector2@,System.Single@,System.Single@)">
      <summary>
            Projects to axis.
            </summary>
      <param name="axis">The axis.</param>
      <param name="min">The min.</param>
      <param name="max">The max.</param>
    </member>
    <member name="M:FarseerPhysics.Common.Vertices.PointInPolygon(Microsoft.Xna.Framework.Vector2@)">
      <summary>
            Winding number test for a point in a polygon.
            </summary>
            See more info about the algorithm here: http://softsurfer.com/Archive/algorithm_0103/algorithm_0103.htm
            <param name="point">The point to be tested.</param><returns>-1 if the winding number is zero and the point is outside
            the polygon, 1 if the point is inside the polygon, and 0 if the point
            is on the polygons edge.</returns></member>
    <member name="M:FarseerPhysics.Common.Vertices.PointInPolygonAngle(Microsoft.Xna.Framework.Vector2@)">
      <summary>
            Compute the sum of the angles made between the test point and each pair of points making up the polygon. 
            If this sum is 2pi then the point is an interior point, if 0 then the point is an exterior point. 
            ref: http://ozviz.wasp.uwa.edu.au/~pbourke/geometry/insidepoly/  - Solution 2 
            </summary>
    </member>
    <member name="T:FarseerPhysics.Common.DetectedVertices">
      <summary>
            Detected vertices of a single polygon.
            </summary>
    </member>
    <member name="T:FarseerPhysics.Common.TextureConverter">
      <summary>
      </summary>
    </member>
    <member name="F:FarseerPhysics.Common.TextureConverter.ClosePixels">
      <summary>
            This array is ment to be readonly.
            It's not because it is accessed very frequently.
            </summary>
    </member>
    <member name="M:FarseerPhysics.Common.TextureConverter.SetTextureData(System.UInt32[],System.Int32)">
      <summary>
      </summary>
      <param name="data">
      </param>
      <param name="width">
      </param>
    </member>
    <member name="M:FarseerPhysics.Common.TextureConverter.DetectVertices(System.UInt32[],System.Int32)">
      <summary>
            Detects the vertices of the supplied texture data. (PolygonDetectionType.Integrated)
            </summary>
      <param name="data">The texture data.</param>
      <param name="width">The texture width.</param>
      <returns>
      </returns>
    </member>
    <member name="M:FarseerPhysics.Common.TextureConverter.DetectVertices(System.UInt32[],System.Int32,System.Boolean)">
      <summary>
            Detects the vertices of the supplied texture data.
            </summary>
      <param name="data">The texture data.</param>
      <param name="width">The texture width.</param>
      <param name="holeDetection">if set to <c>true</c> it will perform hole detection.</param>
      <returns>
      </returns>
    </member>
    <member name="M:FarseerPhysics.Common.TextureConverter.DetectVertices(System.UInt32[],System.Int32,System.Single,System.Byte,System.Boolean,System.Boolean)">
      <summary>
            Detects the vertices of the supplied texture data.
            </summary>
      <param name="data">The texture data.</param>
      <param name="width">The texture width.</param>
      <param name="holeDetection">if set to <c>true</c> it will perform hole detection.</param>
      <param name="hullTolerance">The hull tolerance.</param>
      <param name="alphaTolerance">The alpha tolerance.</param>
      <param name="multiPartDetection">if set to <c>true</c> it will perform multi part detection.</param>
      <returns>
      </returns>
    </member>
    <member name="M:FarseerPhysics.Common.TextureConverter.SearchHoleEntrance(FarseerPhysics.Common.Vertices,System.Nullable{Microsoft.Xna.Framework.Vector2})">
      <summary>
            Function to search for an entrance point of a hole in a polygon. It searches the polygon from top to bottom between the polygon edges.
            </summary>
      <param name="polygon">The polygon to search in.</param>
      <param name="lastHoleEntrance">The last entrance point.</param>
      <returns>The next holes entrance point. Null if ther are no holes.</returns>
    </member>
    <member name="M:FarseerPhysics.Common.TextureConverter.SearchCrossingEdges(FarseerPhysics.Common.Vertices,System.Int32)">
      <summary>
            Searches the polygon for the x coordinates of the edges that cross the specified y coordinate.
            </summary>
      <param name="polygon">Polygon to search in.</param>
      <param name="y">Y coordinate to check for edges.</param>
      <returns>Descending sorted list of x coordinates of edges that cross the specified y coordinate.</returns>
    </member>
    <member name="M:FarseerPhysics.Common.TextureConverter.CreateSimplePolygon(Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2)">
      <summary>
      </summary>
      <param name="entrance">
      </param>
      <param name="last">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:FarseerPhysics.Common.TextureConverter.SearchNextHullEntrance(System.Collections.Generic.List{FarseerPhysics.Common.DetectedVertices},Microsoft.Xna.Framework.Vector2,System.Nullable{Microsoft.Xna.Framework.Vector2}@)">
      <summary>
            Searches for the next shape.
            </summary>
      <param name="detectedPolygons">Already detected polygons.</param>
      <param name="start">Search start coordinate.</param>
      <param name="entrance">Returns the found entrance coordinate. Null if no other shapes found.</param>
      <returns>True if a new shape was found.</returns>
    </member>
    <member name="P:FarseerPhysics.Common.TextureConverter.PolygonDetectionType">
      <summary>
            Get or set the polygon detection type.
            </summary>
    </member>
    <member name="P:FarseerPhysics.Common.TextureConverter.HoleDetection">
      <summary>
            Will detect texture 'holes' if set to true. Slows down the detection. Default is false.
            </summary>
    </member>
    <member name="P:FarseerPhysics.Common.TextureConverter.MultipartDetection">
      <summary>
            Will detect texture multiple 'solid' isles if set to true. Slows down the detection. Default is false.
            </summary>
    </member>
    <member name="P:FarseerPhysics.Common.TextureConverter.PixelOffsetOptimization">
      <summary>
            Will optimize the vertex positions along the interpolated normal between two edges about a half pixel (post processing). Default is false.
            </summary>
    </member>
    <member name="P:FarseerPhysics.Common.TextureConverter.Transform">
      <summary>
            Can be used for scaling.
            </summary>
    </member>
    <member name="P:FarseerPhysics.Common.TextureConverter.AlphaTolerance">
      <summary>
            Alpha (coverage) tolerance. Default is 20: Every pixel with a coverage value equal or greater to 20 will be counts as solid.
            </summary>
    </member>
    <member name="P:FarseerPhysics.Common.TextureConverter.HullTolerance">
      <summary>
            Default is 1.5f.
            </summary>
    </member>
    <member name="M:FarseerPhysics.Common.PolygonManipulation.CuttingTools.SplitShape(FarseerPhysics.Dynamics.Fixture,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,System.Single,FarseerPhysics.Common.Vertices@,FarseerPhysics.Common.Vertices@)">
      <summary>
            Split a fixture into 2 vertice collections using the given entry and exit-point.
            </summary>
      <param name="fixture">The Fixture to split</param>
      <param name="entryPoint">The entry point - The start point</param>
      <param name="exitPoint">The exit point - The end point</param>
      <param name="splitSize">The size of the split. Think of this as the laser-width</param>
      <param name="first">The first collection of vertexes</param>
      <param name="second">The second collection of vertexes</param>
    </member>
    <member name="M:FarseerPhysics.Common.PolygonManipulation.CuttingTools.Cut(FarseerPhysics.Dynamics.World,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,System.Single)">
      <summary>
            This is a high-level function to cuts fixtures inside the given world, using the start and end points.
            Note: We don't support cutting when the start or end is inside a shape.
            </summary>
      <param name="world">The world.</param>
      <param name="start">The startpoint.</param>
      <param name="end">The endpoint.</param>
      <param name="thickness">The thickness of the cut</param>
    </member>
    <member name="T:FarseerPhysics.Common.Decomposition.EarclipDecomposer">
      <summary>
            Ported from jBox2D. Original author: ewjordan 
            Triangulates a polygon using simple ear-clipping algorithm.
            
            Only works on simple polygons.
            
            Triangles may be degenerate, especially if you have identical points
            in the input to the algorithm.  Check this before you use them.
            </summary>
    </member>
    <member name="M:FarseerPhysics.Common.Decomposition.EarclipDecomposer.ConvexPartition(FarseerPhysics.Common.Vertices)">
      <summary>
             Decomposes a non-convex polygon into a number of convex polygons, up
             to maxPolys (remaining pieces are thrown out).
            
             Each resulting polygon will have no more than Settings.MaxPolygonVertices
             vertices.
             
             Warning: Only works on simple polygons
             </summary>
      <param name="vertices">The vertices.</param>
      <returns>
      </returns>
    </member>
    <member name="M:FarseerPhysics.Common.Decomposition.EarclipDecomposer.ConvexPartition(FarseerPhysics.Common.Vertices,System.Int32,System.Single)">
      <summary>
            Decomposes a non-convex polygon into a number of convex polygons, up
            to maxPolys (remaining pieces are thrown out).
            Each resulting polygon will have no more than Settings.MaxPolygonVertices
            vertices.
            Warning: Only works on simple polygons
            </summary>
      <param name="vertices">The vertices.</param>
      <param name="maxPolys">The maximum number of polygons.</param>
      <param name="tolerance">The tolerance.</param>
      <returns>
      </returns>
    </member>
    <member name="M:FarseerPhysics.Common.Decomposition.EarclipDecomposer.PolygonizeTriangles(System.Collections.Generic.List{FarseerPhysics.Common.Decomposition.Triangle},System.Int32,System.Single)">
      <summary>
             Turns a list of triangles into a list of convex polygons. Very simple
             method - start with a seed triangle, keep adding triangles to it until
             you can't add any more without making the polygon non-convex.
            
             Returns an integer telling how many polygons were created.  Will fill
             polys array up to polysLength entries, which may be smaller or larger
             than the return value.
             
             Takes O(N///P) where P is the number of resultant polygons, N is triangle
             count.
             
             The final polygon list will not necessarily be minimal, though in
             practice it works fairly well.
             </summary>
      <param name="triangulated">The triangulated.</param>
      <param name="maxPolys">The maximun number of polygons</param>
      <param name="tolerance">The tolerance</param>
      <returns>
      </returns>
    </member>
    <member name="M:FarseerPhysics.Common.Decomposition.EarclipDecomposer.TriangulatePolygon(FarseerPhysics.Common.Vertices)">
      <summary>
             Triangulates a polygon using simple ear-clipping algorithm. Returns
             size of Triangle array unless the polygon can't be triangulated.
             This should only happen if the polygon self-intersects,
             though it will not _always_ return null for a bad polygon - it is the
             caller's responsibility to check for self-intersection, and if it
             doesn't, it should at least check that the return value is non-null
             before using. You're warned!
            
             Triangles may be degenerate, especially if you have identical points
             in the input to the algorithm.  Check this before you use them.
            
             This is totally unoptimized, so for large polygons it should not be part
             of the simulation loop.
            
             Warning: Only works on simple polygons.
             </summary>
      <returns>
      </returns>
    </member>
    <member name="M:FarseerPhysics.Common.Decomposition.EarclipDecomposer.ResolvePinchPoint(FarseerPhysics.Common.Vertices,FarseerPhysics.Common.Vertices@,FarseerPhysics.Common.Vertices@)">
      <summary>
            Finds and fixes "pinch points," points where two polygon
            vertices are at the same point.
            
            If a pinch point is found, pin is broken up into poutA and poutB
            and true is returned; otherwise, returns false.
            
            Mostly for internal use.
            
            O(N^2) time, which sucks...
            </summary>
      <param name="pin">The pin.</param>
      <param name="poutA">The pout A.</param>
      <param name="poutB">The pout B.</param>
      <returns>
      </returns>
    </member>
    <member name="M:FarseerPhysics.Common.Decomposition.EarclipDecomposer.Remainder(System.Int32,System.Int32)">
      <summary>
            Fix for obnoxious behavior for the % operator for negative numbers...
            </summary>
      <param name="x">The x.</param>
      <param name="modulus">The modulus.</param>
      <returns>
      </returns>
    </member>
    <member name="M:FarseerPhysics.Common.Decomposition.EarclipDecomposer.IsEar(System.Int32,System.Single[],System.Single[],System.Int32)">
      <summary>
             Checks if vertex i is the tip of an ear in polygon defined by xv[] and
             yv[].
            
             Assumes clockwise orientation of polygon...ick
             </summary>
      <param name="i">The i.</param>
      <param name="xv">The xv.</param>
      <param name="yv">The yv.</param>
      <param name="xvLength">Length of the xv.</param>
      <returns>
        <c>true</c> if the specified i is ear; otherwise, <c>false</c>.
             </returns>
    </member>
    <member name="T:FarseerPhysics.Collision.Shapes.PolygonShape">
      <summary>
            Represents a simple non-selfintersecting convex polygon.
            If you want to have concave polygons, you will have to use the <see cref="T:FarseerPhysics.Common.Decomposition.BayazitDecomposer" /> or the <see cref="T:FarseerPhysics.Common.Decomposition.EarclipDecomposer" />
            to decompose the concave polygon into 2 or more convex polygons.
            </summary>
    </member>
    <member name="M:FarseerPhysics.Collision.Shapes.PolygonShape.#ctor(FarseerPhysics.Common.Vertices,System.Single)">
      <summary>
            Initializes a new instance of the <see cref="T:FarseerPhysics.Collision.Shapes.PolygonShape" /> class.
            </summary>
      <param name="vertices">The vertices.</param>
      <param name="density">The density.</param>
    </member>
    <member name="M:FarseerPhysics.Collision.Shapes.PolygonShape.Set(FarseerPhysics.Common.Vertices)">
      <summary>
            Copy vertices. This assumes the vertices define a convex polygon.
            It is assumed that the exterior is the the right of each edge.
            </summary>
      <param name="vertices">The vertices.</param>
    </member>
    <member name="M:FarseerPhysics.Collision.Shapes.PolygonShape.ComputeProperties">
      <summary>
            Compute the mass properties of this shape using its dimensions and density.
            The inertia tensor is computed about the local origin, not the centroid.
            </summary>
    </member>
    <member name="M:FarseerPhysics.Collision.Shapes.PolygonShape.SetAsBox(System.Single,System.Single)">
      <summary>
            Build vertices to represent an axis-aligned box.
            </summary>
      <param name="halfWidth">The half-width.</param>
      <param name="halfHeight">The half-height.</param>
    </member>
    <member name="M:FarseerPhysics.Collision.Shapes.PolygonShape.SetAsBox(System.Single,System.Single,Microsoft.Xna.Framework.Vector2,System.Single)">
      <summary>
            Build vertices to represent an oriented box.
            </summary>
      <param name="halfWidth">The half-width..</param>
      <param name="halfHeight">The half-height.</param>
      <param name="center">The center of the box in local coordinates.</param>
      <param name="angle">The rotation of the box in local coordinates.</param>
    </member>
    <member name="M:FarseerPhysics.Collision.Shapes.PolygonShape.TestPoint(FarseerPhysics.Common.Transform@,Microsoft.Xna.Framework.Vector2@)">
      <summary>
            Test a point for containment in this shape. This only works for convex shapes.
            </summary>
      <param name="transform">The shape world transform.</param>
      <param name="point">a point in world coordinates.</param>
      <returns>True if the point is inside the shape</returns>
    </member>
    <member name="M:FarseerPhysics.Collision.Shapes.PolygonShape.RayCast(FarseerPhysics.Collision.RayCastOutput@,FarseerPhysics.Collision.RayCastInput@,FarseerPhysics.Common.Transform@,System.Int32)">
      <summary>
            Cast a ray against a child shape.
            </summary>
      <param name="output">The ray-cast results.</param>
      <param name="input">The ray-cast input parameters.</param>
      <param name="transform">The transform to be applied to the shape.</param>
      <param name="childIndex">The child shape index.</param>
      <returns>True if the ray-cast hits the shape</returns>
    </member>
    <member name="M:FarseerPhysics.Collision.Shapes.PolygonShape.ComputeAABB(FarseerPhysics.Collision.AABB@,FarseerPhysics.Common.Transform@,System.Int32)">
      <summary>
            Given a transform, compute the associated axis aligned bounding box for a child shape.
            </summary>
      <param name="aabb">The aabb results.</param>
      <param name="transform">The world transform of the shape.</param>
      <param name="childIndex">The child shape index.</param>
    </member>
    <member name="T:FarseerPhysics.Dynamics.BodyType">
      <summary>
            The body type.
            </summary>
    </member>
    <member name="F:FarseerPhysics.Dynamics.BodyType.Static">
      <summary>
            Zero velocity, may be manually moved. Note: even static bodies have mass.
            </summary>
    </member>
    <member name="F:FarseerPhysics.Dynamics.BodyType.Kinematic">
      <summary>
            Zero mass, non-zero velocity set by user, moved by solver
            </summary>
    </member>
    <member name="F:FarseerPhysics.Dynamics.BodyType.Dynamic">
      <summary>
            Positive mass, non-zero velocity determined by forces, moved by solver
            </summary>
    </member>
    <member name="M:FarseerPhysics.Dynamics.Body.ResetDynamics">
      <summary>
            Resets the dynamics of this body.
            Sets torque, force and linear/angular velocity to 0
            </summary>
    </member>
    <member name="M:FarseerPhysics.Dynamics.Body.CreateFixture(FarseerPhysics.Collision.Shapes.Shape)">
      <summary>
            Creates a fixture and attach it to this body.
            If the density is non-zero, this function automatically updates the mass of the body.
            Contacts are not created until the next time step.
            Warning: This function is locked during callbacks.
            </summary>
      <param name="shape">The shape.</param>
      <returns>
      </returns>
    </member>
    <member name="M:FarseerPhysics.Dynamics.Body.CreateFixture(FarseerPhysics.Collision.Shapes.Shape,System.Object)">
      <summary>
            Creates a fixture and attach it to this body.
            If the density is non-zero, this function automatically updates the mass of the body.
            Contacts are not created until the next time step.
            Warning: This function is locked during callbacks.
            </summary>
      <param name="shape">The shape.</param>
      <param name="userData">Application specific data</param>
      <returns>
      </returns>
    </member>
    <member name="M:FarseerPhysics.Dynamics.Body.DestroyFixture(FarseerPhysics.Dynamics.Fixture)">
      <summary>
            Destroy a fixture. This removes the fixture from the broad-phase and
            destroys all contacts associated with this fixture. This will
            automatically adjust the mass of the body if the body is dynamic and the
            fixture has positive density.
            All fixtures attached to a body are implicitly destroyed when the body is destroyed.
            Warning: This function is locked during callbacks.
            </summary>
      <param name="fixture">The fixture to be removed.</param>
    </member>
    <member name="M:FarseerPhysics.Dynamics.Body.SetTransform(Microsoft.Xna.Framework.Vector2@,System.Single)">
      <summary>
            Set the position of the body's origin and rotation.
            This breaks any contacts and wakes the other bodies.
            Manipulating a body's transform may cause non-physical behavior.
            </summary>
      <param name="position">The world position of the body's local origin.</param>
      <param name="rotation">The world rotation in radians.</param>
    </member>
    <member name="M:FarseerPhysics.Dynamics.Body.SetTransform(Microsoft.Xna.Framework.Vector2,System.Single)">
      <summary>
            Set the position of the body's origin and rotation.
            This breaks any contacts and wakes the other bodies.
            Manipulating a body's transform may cause non-physical behavior.
            </summary>
      <param name="position">The world position of the body's local origin.</param>
      <param name="rotation">The world rotation in radians.</param>
    </member>
    <member name="M:FarseerPhysics.Dynamics.Body.SetTransformIgnoreContacts(Microsoft.Xna.Framework.Vector2@,System.Single)">
      <summary>
            For teleporting a body without considering new contacts immediately.
            </summary>
      <param name="position">The position.</param>
      <param name="angle">The angle.</param>
    </member>
    <member name="M:FarseerPhysics.Dynamics.Body.GetTransform(FarseerPhysics.Common.Transform@)">
      <summary>
            Get the body transform for the body's origin.
            </summary>
      <param name="transform">The transform of the body's origin.</param>
    </member>
    <member name="M:FarseerPhysics.Dynamics.Body.ApplyForce(Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2)">
      <summary>
            Apply a force at a world point. If the force is not
            applied at the center of mass, it will generate a torque and
            affect the angular velocity. This wakes up the body.
            </summary>
      <param name="force">The world force vector, usually in Newtons (N).</param>
      <param name="point">The world position of the point of application.</param>
    </member>
    <member name="M:FarseerPhysics.Dynamics.Body.ApplyForce(Microsoft.Xna.Framework.Vector2@)">
      <summary>
            Applies a force at the center of mass.
            </summary>
      <param name="force">The force.</param>
    </member>
    <member name="M:FarseerPhysics.Dynamics.Body.ApplyForce(Microsoft.Xna.Framework.Vector2)">
      <summary>
            Applies a force at the center of mass.
            </summary>
      <param name="force">The force.</param>
    </member>
    <member name="M:FarseerPhysics.Dynamics.Body.ApplyForce(Microsoft.Xna.Framework.Vector2@,Microsoft.Xna.Framework.Vector2@)">
      <summary>
            Apply a force at a world point. If the force is not
            applied at the center of mass, it will generate a torque and
            affect the angular velocity. This wakes up the body.
            </summary>
      <param name="force">The world force vector, usually in Newtons (N).</param>
      <param name="point">The world position of the point of application.</param>
    </member>
    <member name="M:FarseerPhysics.Dynamics.Body.ApplyTorque(System.Single)">
      <summary>
            Apply a torque. This affects the angular velocity
            without affecting the linear velocity of the center of mass.
            This wakes up the body.
            </summary>
      <param name="torque">The torque about the z-axis (out of the screen), usually in N-m.</param>
    </member>
    <member name="M:FarseerPhysics.Dynamics.Body.ApplyLinearImpulse(Microsoft.Xna.Framework.Vector2)">
      <summary>
            Apply an impulse at a point. This immediately modifies the velocity.
            This wakes up the body.
            </summary>
      <param name="impulse">The world impulse vector, usually in N-seconds or kg-m/s.</param>
    </member>
    <member name="M:FarseerPhysics.Dynamics.Body.ApplyLinearImpulse(Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2)">
      <summary>
            Apply an impulse at a point. This immediately modifies the velocity.
            It also modifies the angular velocity if the point of application
            is not at the center of mass.
            This wakes up the body.
            </summary>
      <param name="impulse">The world impulse vector, usually in N-seconds or kg-m/s.</param>
      <param name="point">The world position of the point of application.</param>
    </member>
    <member name="M:FarseerPhysics.Dynamics.Body.ApplyLinearImpulse(Microsoft.Xna.Framework.Vector2@)">
      <summary>
            Apply an impulse at a point. This immediately modifies the velocity.
            This wakes up the body.
            </summary>
      <param name="impulse">The world impulse vector, usually in N-seconds or kg-m/s.</param>
    </member>
    <member name="M:FarseerPhysics.Dynamics.Body.ApplyLinearImpulse(Microsoft.Xna.Framework.Vector2@,Microsoft.Xna.Framework.Vector2@)">
      <summary>
            Apply an impulse at a point. This immediately modifies the velocity.
            It also modifies the angular velocity if the point of application
            is not at the center of mass.
            This wakes up the body.
            </summary>
      <param name="impulse">The world impulse vector, usually in N-seconds or kg-m/s.</param>
      <param name="point">The world position of the point of application.</param>
    </member>
    <member name="M:FarseerPhysics.Dynamics.Body.ApplyAngularImpulse(System.Single)">
      <summary>
            Apply an angular impulse.
            </summary>
      <param name="impulse">The angular impulse in units of kg*m*m/s.</param>
    </member>
    <member name="M:FarseerPhysics.Dynamics.Body.ResetMassData">
      <summary>
            This resets the mass properties to the sum of the mass properties of the fixtures.
            This normally does not need to be called unless you called SetMassData to override
            the mass and you later want to reset the mass.
            </summary>
    </member>
    <member name="M:FarseerPhysics.Dynamics.Body.GetWorldPoint(Microsoft.Xna.Framework.Vector2@)">
      <summary>
            Get the world coordinates of a point given the local coordinates.
            </summary>
      <param name="localPoint">A point on the body measured relative the the body's origin.</param>
      <returns>The same point expressed in world coordinates.</returns>
    </member>
    <member name="M:FarseerPhysics.Dynamics.Body.GetWorldPoint(Microsoft.Xna.Framework.Vector2)">
      <summary>
            Get the world coordinates of a point given the local coordinates.
            </summary>
      <param name="localPoint">A point on the body measured relative the the body's origin.</param>
      <returns>The same point expressed in world coordinates.</returns>
    </member>
    <member name="M:FarseerPhysics.Dynamics.Body.GetWorldVector(Microsoft.Xna.Framework.Vector2@)">
      <summary>
            Get the world coordinates of a vector given the local coordinates.
            Note that the vector only takes the rotation into account, not the position.
            </summary>
      <param name="localVector">A vector fixed in the body.</param>
      <returns>The same vector expressed in world coordinates.</returns>
    </member>
    <member name="M:FarseerPhysics.Dynamics.Body.GetWorldVector(Microsoft.Xna.Framework.Vector2)">
      <summary>
            Get the world coordinates of a vector given the local coordinates.
            </summary>
      <param name="localVector">A vector fixed in the body.</param>
      <returns>The same vector expressed in world coordinates.</returns>
    </member>
    <member name="M:FarseerPhysics.Dynamics.Body.GetLocalPoint(Microsoft.Xna.Framework.Vector2@)">
      <summary>
            Gets a local point relative to the body's origin given a world point.
            Note that the vector only takes the rotation into account, not the position.
            </summary>
      <param name="worldPoint">A point in world coordinates.</param>
      <returns>The corresponding local point relative to the body's origin.</returns>
    </member>
    <member name="M:FarseerPhysics.Dynamics.Body.GetLocalPoint(Microsoft.Xna.Framework.Vector2)">
      <summary>
            Gets a local point relative to the body's origin given a world point.
            </summary>
      <param name="worldPoint">A point in world coordinates.</param>
      <returns>The corresponding local point relative to the body's origin.</returns>
    </member>
    <member name="M:FarseerPhysics.Dynamics.Body.GetLocalVector(Microsoft.Xna.Framework.Vector2@)">
      <summary>
            Gets a local vector given a world vector.
            Note that the vector only takes the rotation into account, not the position.
            </summary>
      <param name="worldVector">A vector in world coordinates.</param>
      <returns>The corresponding local vector.</returns>
    </member>
    <member name="M:FarseerPhysics.Dynamics.Body.GetLocalVector(Microsoft.Xna.Framework.Vector2)">
      <summary>
            Gets a local vector given a world vector.
            Note that the vector only takes the rotation into account, not the position.
            </summary>
      <param name="worldVector">A vector in world coordinates.</param>
      <returns>The corresponding local vector.</returns>
    </member>
    <member name="M:FarseerPhysics.Dynamics.Body.GetLinearVelocityFromWorldPoint(Microsoft.Xna.Framework.Vector2)">
      <summary>
            Get the world linear velocity of a world point attached to this body.
            </summary>
      <param name="worldPoint">A point in world coordinates.</param>
      <returns>The world velocity of a point.</returns>
    </member>
    <member name="M:FarseerPhysics.Dynamics.Body.GetLinearVelocityFromWorldPoint(Microsoft.Xna.Framework.Vector2@)">
      <summary>
            Get the world linear velocity of a world point attached to this body.
            </summary>
      <param name="worldPoint">A point in world coordinates.</param>
      <returns>The world velocity of a point.</returns>
    </member>
    <member name="M:FarseerPhysics.Dynamics.Body.GetLinearVelocityFromLocalPoint(Microsoft.Xna.Framework.Vector2)">
      <summary>
            Get the world velocity of a local point.
            </summary>
      <param name="localPoint">A point in local coordinates.</param>
      <returns>The world velocity of a point.</returns>
    </member>
    <member name="M:FarseerPhysics.Dynamics.Body.GetLinearVelocityFromLocalPoint(Microsoft.Xna.Framework.Vector2@)">
      <summary>
            Get the world velocity of a local point.
            </summary>
      <param name="localPoint">A point in local coordinates.</param>
      <returns>The world velocity of a point.</returns>
    </member>
    <member name="M:FarseerPhysics.Dynamics.Body.ShouldCollide(FarseerPhysics.Dynamics.Body)">
      <summary>
            This is used to prevent connected bodies from colliding.
            It may lie, depending on the collideConnected flag.
            </summary>
      <param name="other">The other body.</param>
      <returns>
      </returns>
    </member>
    <member name="P:FarseerPhysics.Dynamics.Body.Revolutions">
      <summary>
            Gets the total number revolutions the body has made.
            </summary>
      <value>The revolutions.</value>
    </member>
    <member name="P:FarseerPhysics.Dynamics.Body.BodyType">
      <summary>
            Gets or sets the body type.
            </summary>
      <value>The type of body.</value>
    </member>
    <member name="P:FarseerPhysics.Dynamics.Body.LinearVelocity">
      <summary>
            Get or sets the linear velocity of the center of mass.
            </summary>
      <value>The linear velocity.</value>
    </member>
    <member name="P:FarseerPhysics.Dynamics.Body.AngularVelocity">
      <summary>
            Gets or sets the angular velocity. Radians/second.
            </summary>
      <value>The angular velocity.</value>
    </member>
    <member name="P:FarseerPhysics.Dynamics.Body.LinearDamping">
      <summary>
            Gets or sets the linear damping.
            </summary>
      <value>The linear damping.</value>
    </member>
    <member name="P:FarseerPhysics.Dynamics.Body.AngularDamping">
      <summary>
            Gets or sets the angular damping.
            </summary>
      <value>The angular damping.</value>
    </member>
    <member name="P:FarseerPhysics.Dynamics.Body.IsBullet">
      <summary>
            Gets or sets a value indicating whether this body should be included in the CCD solver.
            </summary>
      <value>
        <c>true</c> if this instance is included in CCD; otherwise, <c>false</c>.</value>
    </member>
    <member name="P:FarseerPhysics.Dynamics.Body.SleepingAllowed">
      <summary>
            You can disable sleeping on this body. If you disable sleeping, the
            body will be woken.
            </summary>
      <value>
        <c>true</c> if sleeping is allowed; otherwise, <c>false</c>.</value>
    </member>
    <member name="P:FarseerPhysics.Dynamics.Body.Awake">
      <summary>
            Set the sleep state of the body. A sleeping body has very
            low CPU cost.
            </summary>
      <value>
        <c>true</c> if awake; otherwise, <c>false</c>.</value>
    </member>
    <member name="P:FarseerPhysics.Dynamics.Body.Enabled">
      <summary>
            Set the active state of the body. An inactive body is not
            simulated and cannot be collided with or woken up.
            If you pass a flag of true, all fixtures will be added to the
            broad-phase.
            If you pass a flag of false, all fixtures will be removed from
            the broad-phase and all contacts will be destroyed.
            Fixtures and joints are otherwise unaffected. You may continue
            to create/destroy fixtures and joints on inactive bodies.
            Fixtures on an inactive body are implicitly inactive and will
            not participate in collisions, ray-casts, or queries.
            Joints connected to an inactive body are implicitly inactive.
            An inactive body is still owned by a b2World object and remains
            in the body list.
            </summary>
      <value>
        <c>true</c> if active; otherwise, <c>false</c>.</value>
    </member>
    <member name="P:FarseerPhysics.Dynamics.Body.FixedRotation">
      <summary>
            Set this body to have fixed rotation. This causes the mass
            to be reset.
            </summary>
      <value>
        <c>true</c> if it has fixed rotation; otherwise, <c>false</c>.</value>
    </member>
    <member name="P:FarseerPhysics.Dynamics.Body.FixtureList">
      <summary>
            Gets all the fixtures attached to this body.
            </summary>
      <value>The fixture list.</value>
    </member>
    <member name="P:FarseerPhysics.Dynamics.Body.JointList">
      <summary>
            Get the list of all joints attached to this body.
            </summary>
      <value>The joint list.</value>
    </member>
    <member name="P:FarseerPhysics.Dynamics.Body.ContactList">
      <summary>
            Get the list of all contacts attached to this body.
            Warning: this list changes during the time step and you may
            miss some collisions if you don't use ContactListener.
            </summary>
      <value>The contact list.</value>
    </member>
    <member name="P:FarseerPhysics.Dynamics.Body.UserData">
      <summary>
            Set the user data. Use this to store your application specific data.
            </summary>
      <value>The user data.</value>
    </member>
    <member name="P:FarseerPhysics.Dynamics.Body.Position">
      <summary>
            Get the world body origin position.
            </summary>
      <returns>Return the world position of the body's origin.</returns>
    </member>
    <member name="P:FarseerPhysics.Dynamics.Body.Rotation">
      <summary>
            Get the angle in radians.
            </summary>
      <returns>Return the current world rotation angle in radians.</returns>
    </member>
    <member name="P:FarseerPhysics.Dynamics.Body.IsStatic">
      <summary>
            Gets or sets a value indicating whether this body is static.
            </summary>
      <value>
        <c>true</c> if this instance is static; otherwise, <c>false</c>.</value>
    </member>
    <member name="P:FarseerPhysics.Dynamics.Body.IgnoreGravity">
      <summary>
            Gets or sets a value indicating whether this body ignores gravity.
            </summary>
      <value>
        <c>true</c> if  it ignores gravity; otherwise, <c>false</c>.</value>
    </member>
    <member name="P:FarseerPhysics.Dynamics.Body.WorldCenter">
      <summary>
            Get the world position of the center of mass.
            </summary>
      <value>The world position.</value>
    </member>
    <member name="P:FarseerPhysics.Dynamics.Body.LocalCenter">
      <summary>
            Get the local position of the center of mass.
            </summary>
      <value>The local position.</value>
    </member>
    <member name="P:FarseerPhysics.Dynamics.Body.Mass">
      <summary>
            Gets or sets the mass. Usually in kilograms (kg).
            </summary>
      <value>The mass.</value>
    </member>
    <member name="P:FarseerPhysics.Dynamics.Body.Inertia">
      <summary>
            Get or set the rotational inertia of the body about the local origin. usually in kg-m^2.
            </summary>
      <value>The inertia.</value>
    </member>
    <member name="M:FarseerPhysics.Common.ConvexHull.GiftWrap.GetConvexHull(FarseerPhysics.Common.Vertices)">
      <summary>
            Find the convex hull of a point cloud using "Gift-wrap" algorithm - start
            with an extremal point, and walk around the outside edge by testing
            angles.
            
            Runs in O(N*S) time where S is number of sides of resulting polygon.
            Worst case: point cloud is all vertices of convex polygon: O(N^2).
            There may be faster algorithms to do this, should you need one -
            this is just the simplest. You can get O(N log N) expected time if you
            try, I think, and O(N) if you restrict inputs to simple polygons.
            Returns null if number of vertices passed is less than 3.
            Results should be passed through convex decomposition afterwards
            to ensure that each shape has few enough points to be used in Box2d.
            
            Warning: May be buggy with colinear points on hull.
            </summary>
      <param name="vertices">The vertices.</param>
      <returns>
      </returns>
    </member>
    <member name="T:FarseerPhysics.Collision.TOIInput">
      <summary>
            Input parameters for CalculateTimeOfImpact
            </summary>
    </member>
    <member name="M:FarseerPhysics.Collision.TimeOfImpact.CalculateTimeOfImpact(FarseerPhysics.Collision.TOIOutput@,FarseerPhysics.Collision.TOIInput)">
      <summary>
            Compute the upper bound on time before two shapes penetrate. Time is represented as
            a fraction between [0,tMax]. This uses a swept separating axis and may miss some intermediate,
            non-tunneling collision. If you change the time interval, you should call this function
            again.
            Note: use Distance() to compute the contact point and normal at the time of impact.
            </summary>
      <param name="output">The output.</param>
      <param name="input">The input.</param>
    </member>
    <member name="T:FarseerPhysics.Dynamics.Joints.FrictionJoint">
      <summary>
            Friction joint. This is used for top-down friction.
            It provides 2D translational friction and angular friction.
            </summary>
    </member>
    <member name="P:FarseerPhysics.Dynamics.Joints.FrictionJoint.MaxForce">
      <summary>
            The maximum friction force in N.
            </summary>
    </member>
    <member name="P:FarseerPhysics.Dynamics.Joints.FrictionJoint.MaxTorque">
      <summary>
            The maximum friction torque in N-m.
            </summary>
    </member>
    <member name="M:FarseerPhysics.Common.PhysicsLogic.PhysicsLogicFilter.IgnorePhysicsLogic(FarseerPhysics.Common.PhysicsLogic.PhysicsLogicType)">
      <summary>
            Ignores the controller. The controller has no effect on this body.
            </summary>
      <param name="type">The logic type.</param>
    </member>
    <member name="M:FarseerPhysics.Common.PhysicsLogic.PhysicsLogicFilter.RestorePhysicsLogic(FarseerPhysics.Common.PhysicsLogic.PhysicsLogicType)">
      <summary>
            Restore the controller. The controller affects this body.
            </summary>
      <param name="type">The logic type.</param>
    </member>
    <member name="M:FarseerPhysics.Common.PhysicsLogic.PhysicsLogicFilter.IsPhysicsLogicIgnored(FarseerPhysics.Common.PhysicsLogic.PhysicsLogicType)">
      <summary>
            Determines whether this body ignores the the specified controller.
            </summary>
      <param name="type">The logic type.</param>
      <returns>
        <c>true</c> if the body has the specified flag; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="T:FarseerPhysics.Collision.Shapes.LoopShape">
      <summary>
            A loop Shape is a free form sequence of line segments that form a circular list.
            The loop may cross upon itself, but this is not recommended for smooth collision.
            The loop has double sided collision, so you can use inside and outside collision.
            Therefore, you may use any winding order.
            </summary>
    </member>
    <member name="F:FarseerPhysics.Collision.Shapes.LoopShape.Vertices">
      <summary>
            The vertices. These are not owned/freed by the loop Shape.
            </summary>
    </member>
    <member name="M:FarseerPhysics.Collision.Shapes.LoopShape.GetChildEdge(FarseerPhysics.Collision.Shapes.EdgeShape@,System.Int32)">
      <summary>
            Get a child edge.
            </summary>
      <param name="edge">The edge.</param>
      <param name="index">The index.</param>
    </member>
    <member name="M:FarseerPhysics.Collision.Shapes.LoopShape.TestPoint(FarseerPhysics.Common.Transform@,Microsoft.Xna.Framework.Vector2@)">
      <summary>
            Test a point for containment in this shape. This only works for convex shapes.
            </summary>
      <param name="transform">The shape world transform.</param>
      <param name="point">a point in world coordinates.</param>
      <returns>True if the point is inside the shape</returns>
    </member>
    <member name="M:FarseerPhysics.Collision.Shapes.LoopShape.RayCast(FarseerPhysics.Collision.RayCastOutput@,FarseerPhysics.Collision.RayCastInput@,FarseerPhysics.Common.Transform@,System.Int32)">
      <summary>
            Cast a ray against a child shape.
            </summary>
      <param name="output">The ray-cast results.</param>
      <param name="input">The ray-cast input parameters.</param>
      <param name="transform">The transform to be applied to the shape.</param>
      <param name="childIndex">The child shape index.</param>
      <returns>True if the ray-cast hits the shape</returns>
    </member>
    <member name="M:FarseerPhysics.Collision.Shapes.LoopShape.ComputeAABB(FarseerPhysics.Collision.AABB@,FarseerPhysics.Common.Transform@,System.Int32)">
      <summary>
            Given a transform, compute the associated axis aligned bounding box for a child shape.
            </summary>
      <param name="aabb">The aabb results.</param>
      <param name="transform">The world transform of the shape.</param>
      <param name="childIndex">The child shape index.</param>
    </member>
    <member name="M:FarseerPhysics.Collision.Shapes.LoopShape.ComputeProperties">
      <summary>
            Chains have zero mass.
            </summary>
    </member>
    <member name="T:FarseerPhysics.Dynamics.RayCastCallback">
      <summary>
            Called for each fixture found in the query. You control how the ray cast
            proceeds by returning a float:
            <returns>-1 to filter, 0 to terminate, fraction to clip the ray for closest hit, 1 to continue</returns></summary>
    </member>
    <member name="T:FarseerPhysics.Dynamics.EndContactDelegate">
      <summary>
            This delegate is called when a contact is deleted
            </summary>
    </member>
    <member name="T:FarseerPhysics.Dynamics.BeginContactDelegate">
      <summary>
            This delegate is called when a contact is created
            </summary>
    </member>
    <member name="T:FarseerPhysics.Dynamics.Joints.WeldJoint">
      <summary>
            A weld joint essentially glues two bodies together. A weld joint may
            distort somewhat because the island constraint solver is approximate.
            </summary>
    </member>
    <member name="M:FarseerPhysics.Dynamics.Joints.WeldJoint.#ctor(FarseerPhysics.Dynamics.Body,FarseerPhysics.Dynamics.Body,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2)">
      <summary>
            You need to specify a local anchor point
            where they are attached and the relative body angle. The position
            of the anchor point is important for computing the reaction torque.
            You can change the anchor points relative to bodyA or bodyB by changing LocalAnchorA
            and/or LocalAnchorB.
            </summary>
      <param name="bodyA">The first body</param>
      <param name="bodyB">The second body</param>
      <param name="localAnchorA">The first body anchor.</param>
      <param name="localAnchorB">The second body anchor.</param>
    </member>
    <member name="P:FarseerPhysics.Dynamics.Joints.WeldJoint.ReferenceAngle">
      <summary>
            The body2 angle minus body1 angle in the reference state (radians).
            </summary>
    </member>
    <member name="F:FarseerPhysics.DebugViewFlags.Shape">
      <summary>
            Draw shapes.
            </summary>
    </member>
    <member name="F:FarseerPhysics.DebugViewFlags.Joint">
      <summary>
            Draw joint connections.
            </summary>
    </member>
    <member name="F:FarseerPhysics.DebugViewFlags.AABB">
      <summary>
            Draw axis aligned bounding boxes.
            </summary>
    </member>
    <member name="F:FarseerPhysics.DebugViewFlags.Pair">
      <summary>
            Draw broad-phase pairs.
            </summary>
    </member>
    <member name="F:FarseerPhysics.DebugViewFlags.CenterOfMass">
      <summary>
            Draw center of mass frame.
            </summary>
    </member>
    <member name="F:FarseerPhysics.DebugViewFlags.DebugPanel">
      <summary>
            Draw useful debug data such as timings and number of bodies, joints, contacts and more.
            </summary>
    </member>
    <member name="F:FarseerPhysics.DebugViewFlags.ContactPoints">
      <summary>
            Draw contact points between colliding bodies.
            </summary>
    </member>
    <member name="F:FarseerPhysics.DebugViewFlags.ContactNormals">
      <summary>
            Draw contact normals. Need ContactPoints to be enabled first.
            </summary>
    </member>
    <member name="F:FarseerPhysics.DebugViewFlags.PolygonPoints">
      <summary>
            Draws the vertices of polygons.
            </summary>
    </member>
    <member name="F:FarseerPhysics.DebugViewFlags.PerformanceGraph">
      <summary>
            Draws the performance graph.
            </summary>
    </member>
    <member name="F:FarseerPhysics.DebugViewFlags.Controllers">
      <summary>
            Draws controllers.
            </summary>
    </member>
    <member name="T:FarseerPhysics.DebugView">
            Implement and register this class with a World to provide debug drawing of physics
            entities in your game.
        </member>
    <member name="M:FarseerPhysics.DebugView.AppendFlags(FarseerPhysics.DebugViewFlags)">
      <summary>
            Append flags to the current flags.
            </summary>
      <param name="flags">The flags.</param>
    </member>
    <member name="M:FarseerPhysics.DebugView.RemoveFlags(FarseerPhysics.DebugViewFlags)">
      <summary>
            Remove flags from the current flags.
            </summary>
      <param name="flags">The flags.</param>
    </member>
    <member name="M:FarseerPhysics.DebugView.DrawPolygon(Microsoft.Xna.Framework.Vector2[],System.Int32,System.Single,System.Single,System.Single)">
      <summary>
            Draw a closed polygon provided in CCW order.
            </summary>
      <param name="vertices">The vertices.</param>
      <param name="count">The vertex count.</param>
      <param name="red">The red value.</param>
      <param name="blue">The blue value.</param>
      <param name="green">The green value.</param>
    </member>
    <member name="M:FarseerPhysics.DebugView.DrawSolidPolygon(Microsoft.Xna.Framework.Vector2[],System.Int32,System.Single,System.Single,System.Single)">
      <summary>
            Draw a solid closed polygon provided in CCW order.
            </summary>
      <param name="vertices">The vertices.</param>
      <param name="count">The vertex count.</param>
      <param name="red">The red value.</param>
      <param name="blue">The blue value.</param>
      <param name="green">The green value.</param>
    </member>
    <member name="M:FarseerPhysics.DebugView.DrawCircle(Microsoft.Xna.Framework.Vector2,System.Single,System.Single,System.Single,System.Single)">
      <summary>
            Draw a circle.
            </summary>
      <param name="center">The center.</param>
      <param name="radius">The radius.</param>
      <param name="red">The red value.</param>
      <param name="blue">The blue value.</param>
      <param name="green">The green value.</param>
    </member>
    <member name="M:FarseerPhysics.DebugView.DrawSolidCircle(Microsoft.Xna.Framework.Vector2,System.Single,Microsoft.Xna.Framework.Vector2,System.Single,System.Single,System.Single)">
      <summary>
            Draw a solid circle.
            </summary>
      <param name="center">The center.</param>
      <param name="radius">The radius.</param>
      <param name="axis">The axis.</param>
      <param name="red">The red value.</param>
      <param name="blue">The blue value.</param>
      <param name="green">The green value.</param>
    </member>
    <member name="M:FarseerPhysics.DebugView.DrawSegment(Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,System.Single,System.Single,System.Single)">
      <summary>
            Draw a line segment.
            </summary>
      <param name="start">The start.</param>
      <param name="end">The end.</param>
      <param name="red">The red value.</param>
      <param name="blue">The blue value.</param>
      <param name="green">The green value.</param>
    </member>
    <member name="M:FarseerPhysics.DebugView.DrawTransform(FarseerPhysics.Common.Transform@)">
      <summary>
            Draw a transform. Choose your own length scale.
            </summary>
      <param name="transform">The transform.</param>
    </member>
    <member name="P:FarseerPhysics.DebugView.Flags">
      <summary>
            Gets or sets the debug view flags.
            </summary>
      <value>The flags.</value>
    </member>
    <member name="T:Poly2Tri.Triangulation.TriangulationUtil">
            @author Thomas Ã…hlÃ©n, thahlen@gmail.com
        </member>
    <member name="M:Poly2Tri.Triangulation.TriangulationUtil.SmartIncircle(Poly2Tri.Triangulation.TriangulationPoint,Poly2Tri.Triangulation.TriangulationPoint,Poly2Tri.Triangulation.TriangulationPoint,Poly2Tri.Triangulation.TriangulationPoint)">
      <summary>
              Requirements:
            1. a,b and c form a triangle.
            2. a and d is know to be on opposite side of bc
            <code>
                           a
                           +
                          / \
                         /   \
                       b/     \c
                       +-------+ 
                      /    B    \  
                     /           \ 
            </code>
               Facts:
             d has to be in area B to have a chance to be inside the circle formed by a,b and c
             d is outside B if orient2d(a,b,d) or orient2d(c,a,d) is CW
             This preknowledge gives us a way to optimize the incircle test
            </summary>
      <param name="pa">triangle point, opposite d</param>
      <param name="pb">triangle point</param>
      <param name="pc">triangle point</param>
      <param name="pd">point opposite a</param>
      <returns>true if d is inside circle, false if on circle edge</returns>
    </member>
    <member name="M:Poly2Tri.Triangulation.TriangulationUtil.Orient2d(Poly2Tri.Triangulation.TriangulationPoint,Poly2Tri.Triangulation.TriangulationPoint,Poly2Tri.Triangulation.TriangulationPoint)">
            Forumla to calculate signed area
            Positive if CCW
            Negative if CW
            0 if collinear
            A[P1,P2,P3]  =  (x1*y2 - y1*x2) + (x2*y3 - y2*x3) + (x3*y1 - y3*x1)
                         =  (x1-x3)*(y2-y3) - (y1-y3)*(x2-x3)
        </member>
    <member name="M:QuadTree`1.Partition(FarseerPhysics.Collision.AABB,FarseerPhysics.Collision.AABB)">
      <summary>
            returns the quadrant of span that entirely contains test. if none, return 0.
            </summary>
      <param name="span">
      </param>
      <param name="test">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:QuadTree`1.RayCastAABB(FarseerPhysics.Collision.AABB,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2)">
      <summary>
            tests if ray intersects AABB
            </summary>
      <param name="aabb">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:FarseerPhysics.Dynamics.TimeStep">
      <summary>
            This is an internal structure.
            </summary>
    </member>
    <member name="F:FarseerPhysics.Dynamics.TimeStep.dt">
      <summary>
            Time step (Delta time)
            </summary>
    </member>
    <member name="F:FarseerPhysics.Dynamics.TimeStep.dtRatio">
      <summary>
            dt * inv_dt0
            </summary>
    </member>
    <member name="F:FarseerPhysics.Dynamics.TimeStep.inv_dt">
      <summary>
            Inverse time step (0 if dt == 0).
            </summary>
    </member>
    <member name="T:FarseerPhysics.Dynamics.Joints.RevoluteJoint">
      <summary>
            A revolute joint rains to bodies to share a common point while they
            are free to rotate about the point. The relative rotation about the shared
            point is the joint angle. You can limit the relative rotation with
            a joint limit that specifies a lower and upper angle. You can use a motor
            to drive the relative rotation about the shared point. A maximum motor torque
            is provided so that infinite forces are not generated.
            </summary>
    </member>
    <member name="M:FarseerPhysics.Dynamics.Joints.RevoluteJoint.#ctor(FarseerPhysics.Dynamics.Body,FarseerPhysics.Dynamics.Body,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2)">
      <summary>
            Initialize the bodies and local anchor.
            This requires defining an
            anchor point where the bodies are joined. The definition
            uses local anchor points so that the initial configuration
            can violate the constraint slightly. You also need to
            specify the initial relative angle for joint limits. This
            helps when saving and loading a game.
            The local anchor points are measured from the body's origin
            rather than the center of mass because:
            1. you might not know where the center of mass will be.
            2. if you add/remove shapes from a body and recompute the mass,
            the joints will be broken.
            </summary>
      <param name="bodyA">The first body.</param>
      <param name="bodyB">The second body.</param>
      <param name="localAnchorA">The first body anchor.</param>
      <param name="localAnchorB">The second anchor.</param>
    </member>
    <member name="P:FarseerPhysics.Dynamics.Joints.RevoluteJoint.JointAngle">
      <summary>
            Get the current joint angle in radians.
            </summary>
      <value>
      </value>
    </member>
    <member name="P:FarseerPhysics.Dynamics.Joints.RevoluteJoint.JointSpeed">
      <summary>
            Get the current joint angle speed in radians per second.
            </summary>
      <value>
      </value>
    </member>
    <member name="P:FarseerPhysics.Dynamics.Joints.RevoluteJoint.LimitEnabled">
      <summary>
            Is the joint limit enabled?
            </summary>
      <value>
        <c>true</c> if [limit enabled]; otherwise, <c>false</c>.</value>
    </member>
    <member name="P:FarseerPhysics.Dynamics.Joints.RevoluteJoint.LowerLimit">
      <summary>
            Get the lower joint limit in radians.
            </summary>
      <value>
      </value>
    </member>
    <member name="P:FarseerPhysics.Dynamics.Joints.RevoluteJoint.UpperLimit">
      <summary>
            Get the upper joint limit in radians.
            </summary>
      <value>
      </value>
    </member>
    <member name="P:FarseerPhysics.Dynamics.Joints.RevoluteJoint.MotorEnabled">
      <summary>
            Is the joint motor enabled?
            </summary>
      <value>
        <c>true</c> if [motor enabled]; otherwise, <c>false</c>.</value>
    </member>
    <member name="P:FarseerPhysics.Dynamics.Joints.RevoluteJoint.MotorSpeed">
      <summary>
            Set the motor speed in radians per second.
            </summary>
      <value>The speed.</value>
    </member>
    <member name="P:FarseerPhysics.Dynamics.Joints.RevoluteJoint.MaxMotorTorque">
      <summary>
            Set the maximum motor torque, usually in N-m.
            </summary>
      <value>The torque.</value>
    </member>
    <member name="P:FarseerPhysics.Dynamics.Joints.RevoluteJoint.MotorTorque">
      <summary>
            Get the current motor torque, usually in N-m.
            </summary>
      <value>
      </value>
    </member>
    <member name="T:FarseerPhysics.Dynamics.FixtureProxy">
      <summary>
            This proxy is used internally to connect fixtures to the broad-phase.
            </summary>
    </member>
    <member name="T:FarseerPhysics.Dynamics.Fixture">
      <summary>
            A fixture is used to attach a Shape to a body for collision detection. A fixture
            inherits its transform from its parent. Fixtures hold additional non-geometric data
            such as friction, collision filters, etc.
            Fixtures are created via Body.CreateFixture.
            Warning: You cannot reuse fixtures.
            </summary>
    </member>
    <member name="F:FarseerPhysics.Dynamics.Fixture.AfterCollision">
      <summary>
            Fires after two shapes has collided and are solved. This gives you a chance to get the impact force.
            </summary>
    </member>
    <member name="F:FarseerPhysics.Dynamics.Fixture.BeforeCollision">
      <summary>
            Fires when two fixtures are close to each other.
            Due to how the broadphase works, this can be quite inaccurate as shapes are approximated using AABBs.
            </summary>
    </member>
    <member name="F:FarseerPhysics.Dynamics.Fixture.OnCollision">
      <summary>
            Fires when two shapes collide and a contact is created between them.
            Note that the first fixture argument is always the fixture that the delegate is subscribed to.
            </summary>
    </member>
    <member name="F:FarseerPhysics.Dynamics.Fixture.OnSeparation">
      <summary>
            Fires when two shapes separate and a contact is removed between them.
            Note that the first fixture argument is always the fixture that the delegate is subscribed to.
            </summary>
    </member>
    <member name="M:FarseerPhysics.Dynamics.Fixture.RestoreCollisionWith(FarseerPhysics.Dynamics.Fixture)">
      <summary>
            Restores collisions between this fixture and the provided fixture.
            </summary>
      <param name="fixture">The fixture.</param>
    </member>
    <member name="M:FarseerPhysics.Dynamics.Fixture.IgnoreCollisionWith(FarseerPhysics.Dynamics.Fixture)">
      <summary>
            Ignores collisions between this fixture and the provided fixture.
            </summary>
      <param name="fixture">The fixture.</param>
    </member>
    <member name="M:FarseerPhysics.Dynamics.Fixture.IsFixtureIgnored(FarseerPhysics.Dynamics.Fixture)">
      <summary>
            Determines whether collisions are ignored between this fixture and the provided fixture.
            </summary>
      <param name="fixture">The fixture.</param>
      <returns>
        <c>true</c> if the fixture is ignored; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="M:FarseerPhysics.Dynamics.Fixture.Refilter">
      <summary>
            Contacts are persistant and will keep being persistant unless they are
            flagged for filtering.
            This methods flags all contacts associated with the body for filtering.
            </summary>
    </member>
    <member name="M:FarseerPhysics.Dynamics.Fixture.TestPoint(Microsoft.Xna.Framework.Vector2@)">
      <summary>
            Test a point for containment in this fixture.
            </summary>
      <param name="point">A point in world coordinates.</param>
      <returns>
      </returns>
    </member>
    <member name="M:FarseerPhysics.Dynamics.Fixture.RayCast(FarseerPhysics.Collision.RayCastOutput@,FarseerPhysics.Collision.RayCastInput@,System.Int32)">
      <summary>
            Cast a ray against this Shape.
            </summary>
      <param name="output">The ray-cast results.</param>
      <param name="input">The ray-cast input parameters.</param>
      <param name="childIndex">Index of the child.</param>
      <returns>
      </returns>
    </member>
    <member name="M:FarseerPhysics.Dynamics.Fixture.GetAABB(FarseerPhysics.Collision.AABB@,System.Int32)">
      <summary>
            Get the fixture's AABB. This AABB may be enlarge and/or stale.
            If you need a more accurate AABB, compute it using the Shape and
            the body transform.
            </summary>
      <param name="aabb">The aabb.</param>
      <param name="childIndex">Index of the child.</param>
    </member>
    <member name="P:FarseerPhysics.Dynamics.Fixture.CollisionGroup">
      <summary>
            Defaults to 0
            
            If Settings.UseFPECollisionCategories is set to false:
            Collision groups allow a certain group of objects to never collide (negative)
            or always collide (positive). Zero means no collision group. Non-zero group
            filtering always wins against the mask bits.
            
            If Settings.UseFPECollisionCategories is set to true:
            If 2 fixtures are in the same collision group, they will not collide.
            </summary>
    </member>
    <member name="P:FarseerPhysics.Dynamics.Fixture.CollidesWith">
      <summary>
            Defaults to Category.All
            
            The collision mask bits. This states the categories that this
            fixture would accept for collision.
            Use Settings.UseFPECollisionCategories to change the behavior.
            </summary>
    </member>
    <member name="P:FarseerPhysics.Dynamics.Fixture.CollisionCategories">
      <summary>
            The collision categories this fixture is a part of.
            
            If Settings.UseFPECollisionCategories is set to false:
            Defaults to Category.Cat1
            
            If Settings.UseFPECollisionCategories is set to true:
            Defaults to Category.All
            </summary>
    </member>
    <member name="P:FarseerPhysics.Dynamics.Fixture.ShapeType">
      <summary>
            Get the type of the child Shape. You can use this to down cast to the concrete Shape.
            </summary>
      <value>The type of the shape.</value>
    </member>
    <member name="P:FarseerPhysics.Dynamics.Fixture.Shape">
      <summary>
            Get the child Shape. You can modify the child Shape, however you should not change the
            number of vertices because this will crash some collision caching mechanisms.
            </summary>
      <value>The shape.</value>
    </member>
    <member name="P:FarseerPhysics.Dynamics.Fixture.IsSensor">
      <summary>
            Gets or sets a value indicating whether this fixture is a sensor.
            </summary>
      <value>
        <c>true</c> if this instance is a sensor; otherwise, <c>false</c>.</value>
    </member>
    <member name="P:FarseerPhysics.Dynamics.Fixture.Body">
      <summary>
            Get the parent body of this fixture. This is null if the fixture is not attached.
            </summary>
      <value>The body.</value>
    </member>
    <member name="P:FarseerPhysics.Dynamics.Fixture.UserData">
      <summary>
            Set the user data. Use this to store your application specific data.
            </summary>
      <value>The user data.</value>
    </member>
    <member name="P:FarseerPhysics.Dynamics.Fixture.Friction">
      <summary>
            Get or set the coefficient of friction.
            </summary>
      <value>The friction.</value>
    </member>
    <member name="P:FarseerPhysics.Dynamics.Fixture.Restitution">
      <summary>
            Get or set the coefficient of restitution.
            </summary>
      <value>The restitution.</value>
    </member>
    <member name="P:FarseerPhysics.Dynamics.Fixture.FixtureId">
      <summary>
            Gets a unique ID for this fixture.
            </summary>
      <value>The fixture id.</value>
    </member>
    <member name="F:FarseerPhysics.Dynamics.ContactManager.BeginContact">
      <summary>
            Fires when a contact is created
            </summary>
    </member>
    <member name="F:FarseerPhysics.Dynamics.ContactManager.ContactFilter">
      <summary>
            The filter used by the contact manager.
            </summary>
    </member>
    <member name="F:FarseerPhysics.Dynamics.ContactManager.EndContact">
      <summary>
            Fires when a contact is deleted
            </summary>
    </member>
    <member name="F:FarseerPhysics.Dynamics.ContactManager.OnBroadphaseCollision">
      <summary>
            Fires when the broadphase detects that two Fixtures are close to each other.
            </summary>
    </member>
    <member name="F:FarseerPhysics.Dynamics.ContactManager.PostSolve">
      <summary>
            Fires after the solver has run
            </summary>
    </member>
    <member name="F:FarseerPhysics.Dynamics.ContactManager.PreSolve">
      <summary>
            Fires before the solver runs
            </summary>
    </member>
    <member name="M:FarseerPhysics.Common.PolygonManipulation.SimplifyTools.CollinearSimplify(FarseerPhysics.Common.Vertices,System.Single)">
      <summary>
            Removes all collinear points on the polygon.
            </summary>
      <param name="vertices">The polygon that needs simplification.</param>
      <param name="collinearityTolerance">The collinearity tolerance.</param>
      <returns>A simplified polygon.</returns>
    </member>
    <member name="M:FarseerPhysics.Common.PolygonManipulation.SimplifyTools.CollinearSimplify(FarseerPhysics.Common.Vertices)">
      <summary>
            Removes all collinear points on the polygon.
            Has a default bias of 0
            </summary>
      <param name="vertices">The polygon that needs simplification.</param>
      <returns>A simplified polygon.</returns>
    </member>
    <member name="M:FarseerPhysics.Common.PolygonManipulation.SimplifyTools.DouglasPeuckerSimplify(FarseerPhysics.Common.Vertices,System.Single)">
      <summary>
            Ramer-Douglas-Peucker polygon simplification algorithm. This is the general recursive version that does not use the
            speed-up technique by using the Melkman convex hull.
            
            If you pass in 0, it will remove all collinear points
            </summary>
      <returns>The simplified polygon</returns>
    </member>
    <member name="M:FarseerPhysics.Common.PolygonManipulation.SimplifyTools.MergeParallelEdges(FarseerPhysics.Common.Vertices,System.Single)">
      <summary>
            Merges all parallel edges in the list of vertices
            </summary>
      <param name="vertices">The vertices.</param>
      <param name="tolerance">The tolerance.</param>
    </member>
    <member name="M:FarseerPhysics.Common.PolygonManipulation.SimplifyTools.MergeIdenticalPoints(FarseerPhysics.Common.Vertices)">
      <summary>
            Merges the identical points in the polygon.
            </summary>
      <param name="vertices">The vertices.</param>
      <returns>
      </returns>
    </member>
    <member name="M:FarseerPhysics.Common.PolygonManipulation.SimplifyTools.ReduceByDistance(FarseerPhysics.Common.Vertices,System.Single)">
      <summary>
            Reduces the polygon by distance.
            </summary>
      <param name="vertices">The vertices.</param>
      <param name="distance">The distance between points. Points closer than this will be 'joined'.</param>
      <returns>
      </returns>
    </member>
    <member name="M:FarseerPhysics.Common.PolygonManipulation.SimplifyTools.ReduceByNth(FarseerPhysics.Common.Vertices,System.Int32)">
      <summary>
            Reduces the polygon by removing the Nth vertex in the vertices list.
            </summary>
      <param name="vertices">The vertices.</param>
      <param name="nth">The Nth point to remove. Example: 5.</param>
      <returns>
      </returns>
    </member>
    <member name="M:FarseerPhysics.Common.ConvexHull.Melkman.GetConvexHull(FarseerPhysics.Common.Vertices)">
      <summary>
            Creates a convex hull.
            Note:
            1. Vertices must be of a simple polygon, i.e. edges do not overlap.
            2. Melkman does not work on point clouds
            </summary>
      <remarks>
            Implemented using Melkman's Convex Hull Algorithm - O(n) time complexity.
            Reference: http://www.ams.sunysb.edu/~jsbm/courses/345/melkman.pdf
            </remarks>
      <returns>A convex hull in counterclockwise winding order.</returns>
    </member>
    <member name="T:FarseerPhysics.Collision.DistanceProxy">
      <summary>
            A distance proxy is used by the GJK algorithm.
            It encapsulates any shape.
            </summary>
    </member>
    <member name="M:FarseerPhysics.Collision.DistanceProxy.Set(FarseerPhysics.Collision.Shapes.Shape,System.Int32)">
      <summary>
            Initialize the proxy using the given shape. The shape
            must remain in scope while the proxy is in use.
            </summary>
      <param name="shape">The shape.</param>
      <param name="index">The index.</param>
    </member>
    <member name="M:FarseerPhysics.Collision.DistanceProxy.GetSupport(Microsoft.Xna.Framework.Vector2)">
      <summary>
            Get the supporting vertex index in the given direction.
            </summary>
      <param name="direction">The direction.</param>
      <returns>
      </returns>
    </member>
    <member name="M:FarseerPhysics.Collision.DistanceProxy.GetSupportVertex(Microsoft.Xna.Framework.Vector2)">
      <summary>
            Get the supporting vertex in the given direction.
            </summary>
      <param name="direction">The direction.</param>
      <returns>
      </returns>
    </member>
    <member name="T:FarseerPhysics.Collision.SimplexCache">
      <summary>
            Used to warm start ComputeDistance.
            Set count to zero on first call.
            </summary>
    </member>
    <member name="F:FarseerPhysics.Collision.SimplexCache.Count">
      <summary>
            Length or area
            </summary>
    </member>
    <member name="F:FarseerPhysics.Collision.SimplexCache.IndexA">
      <summary>
            Vertices on shape A
            </summary>
    </member>
    <member name="F:FarseerPhysics.Collision.SimplexCache.IndexB">
      <summary>
            Vertices on shape B
            </summary>
    </member>
    <member name="T:FarseerPhysics.Collision.DistanceInput">
      <summary>
            Input for ComputeDistance.
            You have to option to use the shape radii
            in the computation. 
            </summary>
    </member>
    <member name="T:FarseerPhysics.Collision.DistanceOutput">
      <summary>
            Output for ComputeDistance.
            </summary>
    </member>
    <member name="F:FarseerPhysics.Collision.DistanceOutput.Iterations">
      <summary>
            Number of GJK iterations used
            </summary>
    </member>
    <member name="F:FarseerPhysics.Collision.DistanceOutput.PointA">
      <summary>
            Closest point on shapeA
            </summary>
    </member>
    <member name="F:FarseerPhysics.Collision.DistanceOutput.PointB">
      <summary>
            Closest point on shapeB
            </summary>
    </member>
    <member name="F:FarseerPhysics.Collision.SimplexVertex.A">
      <summary>
            Barycentric coordinate for closest point 
            </summary>
    </member>
    <member name="F:FarseerPhysics.Collision.SimplexVertex.IndexA">
      <summary>
            wA index
            </summary>
    </member>
    <member name="F:FarseerPhysics.Collision.SimplexVertex.IndexB">
      <summary>
            wB index
            </summary>
    </member>
    <member name="F:FarseerPhysics.Collision.SimplexVertex.W">
      <summary>
            wB - wA
            </summary>
    </member>
    <member name="F:FarseerPhysics.Collision.SimplexVertex.WA">
      <summary>
            Support point in proxyA
            </summary>
    </member>
    <member name="F:FarseerPhysics.Collision.SimplexVertex.WB">
      <summary>
            Support point in proxyB
            </summary>
    </member>
    <member name="T:FarseerPhysics.Common.WorldXmlSerializer">
      <summary>
      </summary>
    </member>
    <member name="M:FarseerPhysics.Common.MathUtils.IsValid(System.Single)">
      <summary>
            This function is used to ensure that a floating point number is
            not a NaN or infinity.
            </summary>
      <param name="x">The x.</param>
      <returns>
        <c>true</c> if the specified x is valid; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="M:FarseerPhysics.Common.MathUtils.InvSqrt(System.Single)">
      <summary>
            This is a approximate yet fast inverse square-root.
            </summary>
      <param name="x">The x.</param>
      <returns>
      </returns>
    </member>
    <member name="M:FarseerPhysics.Common.MathUtils.VectorAngle(Microsoft.Xna.Framework.Vector2@,Microsoft.Xna.Framework.Vector2@)">
      <summary>
            Return the angle between two vectors on a plane
            The angle is from vector 1 to vector 2, positive anticlockwise
            The result is between -pi -&gt; pi
            </summary>
    </member>
    <member name="M:FarseerPhysics.Common.MathUtils.Area(Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2)">
      <summary>
            Returns a positive number if c is to the left of the line going from a to b.
            </summary>
      <returns>Positive number if point is left, negative if point is right, 
            and 0 if points are collinear.</returns>
    </member>
    <member name="M:FarseerPhysics.Common.MathUtils.Area(Microsoft.Xna.Framework.Vector2@,Microsoft.Xna.Framework.Vector2@,Microsoft.Xna.Framework.Vector2@)">
      <summary>
            Returns a positive number if c is to the left of the line going from a to b.
            </summary>
      <returns>Positive number if point is left, negative if point is right, 
            and 0 if points are collinear.</returns>
    </member>
    <member name="M:FarseerPhysics.Common.MathUtils.Collinear(Microsoft.Xna.Framework.Vector2@,Microsoft.Xna.Framework.Vector2@,Microsoft.Xna.Framework.Vector2@)">
      <summary>
            Determines if three vertices are collinear (ie. on a straight line)
            </summary>
      <param name="a">First vertex</param>
      <param name="b">Second vertex</param>
      <param name="c">Third vertex</param>
      <returns>
      </returns>
    </member>
    <member name="M:FarseerPhysics.Common.MathUtils.FloatEquals(System.Single,System.Single,System.Single)">
      <summary>
            Checks if a floating point Value is equal to another,
            within a certain tolerance.
            </summary>
      <param name="value1">The first floating point Value.</param>
      <param name="value2">The second floating point Value.</param>
      <param name="delta">The floating point tolerance.</param>
      <returns>True if the values are "equal", false otherwise.</returns>
    </member>
    <member name="M:FarseerPhysics.Common.MathUtils.FloatInRange(System.Single,System.Single,System.Single)">
      <summary>
            Checks if a floating point Value is within a specified
            range of values (inclusive).
            </summary>
      <param name="value">The Value to check.</param>
      <param name="min">The minimum Value.</param>
      <param name="max">The maximum Value.</param>
      <returns>True if the Value is within the range specified,
            false otherwise.</returns>
    </member>
    <member name="T:FarseerPhysics.Common.Mat22">
      <summary>
            A 2-by-2 matrix. Stored in column-major order.
            </summary>
    </member>
    <member name="M:FarseerPhysics.Common.Mat22.#ctor(Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2)">
      <summary>
            Construct this matrix using columns.
            </summary>
      <param name="c1">The c1.</param>
      <param name="c2">The c2.</param>
    </member>
    <member name="M:FarseerPhysics.Common.Mat22.#ctor(System.Single,System.Single,System.Single,System.Single)">
      <summary>
            Construct this matrix using scalars.
            </summary>
      <param name="a11">The a11.</param>
      <param name="a12">The a12.</param>
      <param name="a21">The a21.</param>
      <param name="a22">The a22.</param>
    </member>
    <member name="M:FarseerPhysics.Common.Mat22.#ctor(System.Single)">
      <summary>
            Construct this matrix using an angle. This matrix becomes
            an orthonormal rotation matrix.
            </summary>
      <param name="angle">The angle.</param>
    </member>
    <member name="M:FarseerPhysics.Common.Mat22.Set(Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2)">
      <summary>
            Initialize this matrix using columns.
            </summary>
      <param name="c1">The c1.</param>
      <param name="c2">The c2.</param>
    </member>
    <member name="M:FarseerPhysics.Common.Mat22.Set(System.Single)">
      <summary>
            Initialize this matrix using an angle. This matrix becomes
            an orthonormal rotation matrix.
            </summary>
      <param name="angle">The angle.</param>
    </member>
    <member name="M:FarseerPhysics.Common.Mat22.SetIdentity">
      <summary>
            Set this to the identity matrix.
            </summary>
    </member>
    <member name="M:FarseerPhysics.Common.Mat22.SetZero">
      <summary>
            Set this matrix to all zeros.
            </summary>
    </member>
    <member name="M:FarseerPhysics.Common.Mat22.Solve(Microsoft.Xna.Framework.Vector2)">
      <summary>
            Solve A * x = b, where b is a column vector. This is more efficient
            than computing the inverse in one-shot cases.
            </summary>
      <param name="b">The b.</param>
      <returns>
      </returns>
    </member>
    <member name="P:FarseerPhysics.Common.Mat22.Angle">
      <summary>
            Extract the angle from this matrix (assumed to be
            a rotation matrix).
            </summary>
      <value>
      </value>
    </member>
    <member name="T:FarseerPhysics.Common.Mat33">
      <summary>
            A 3-by-3 matrix. Stored in column-major order.
            </summary>
    </member>
    <member name="M:FarseerPhysics.Common.Mat33.#ctor(Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3)">
      <summary>
            Construct this matrix using columns.
            </summary>
      <param name="c1">The c1.</param>
      <param name="c2">The c2.</param>
      <param name="c3">The c3.</param>
    </member>
    <member name="M:FarseerPhysics.Common.Mat33.SetZero">
      <summary>
            Set this matrix to all zeros.
            </summary>
    </member>
    <member name="M:FarseerPhysics.Common.Mat33.Solve33(Microsoft.Xna.Framework.Vector3)">
      <summary>
            Solve A * x = b, where b is a column vector. This is more efficient
            than computing the inverse in one-shot cases.
            </summary>
      <param name="b">The b.</param>
      <returns>
      </returns>
    </member>
    <member name="M:FarseerPhysics.Common.Mat33.Solve22(Microsoft.Xna.Framework.Vector2)">
      <summary>
            Solve A * x = b, where b is a column vector. This is more efficient
            than computing the inverse in one-shot cases. Solve only the upper
            2-by-2 matrix equation.
            </summary>
      <param name="b">The b.</param>
      <returns>
      </returns>
    </member>
    <member name="T:FarseerPhysics.Common.Transform">
      <summary>
            A transform contains translation and rotation. It is used to represent
            the position and orientation of rigid frames.
            </summary>
    </member>
    <member name="M:FarseerPhysics.Common.Transform.#ctor(Microsoft.Xna.Framework.Vector2@,FarseerPhysics.Common.Mat22@)">
      <summary>
            Initialize using a position vector and a rotation matrix.
            </summary>
      <param name="position">The position.</param>
      <param name="r">The r.</param>
    </member>
    <member name="M:FarseerPhysics.Common.Transform.SetIdentity">
      <summary>
            Set this to the identity transform.
            </summary>
    </member>
    <member name="M:FarseerPhysics.Common.Transform.Set(Microsoft.Xna.Framework.Vector2,System.Single)">
      <summary>
            Set this based on the position and angle.
            </summary>
      <param name="position">The position.</param>
      <param name="angle">The angle.</param>
    </member>
    <member name="P:FarseerPhysics.Common.Transform.Angle">
      <summary>
            Calculate the angle that the rotation matrix represents.
            </summary>
      <value>
      </value>
    </member>
    <member name="T:FarseerPhysics.Common.Sweep">
      <summary>
            This describes the motion of a body/shape for TOI computation.
            Shapes are defined with respect to the body origin, which may
            no coincide with the center of mass. However, to support dynamics
            we must interpolate the center of mass position.
            </summary>
    </member>
    <member name="F:FarseerPhysics.Common.Sweep.A">
      <summary>
            World angles
            </summary>
    </member>
    <member name="F:FarseerPhysics.Common.Sweep.Alpha0">
      <summary>
            Fraction of the current time step in the range [0,1]
            c0 and a0 are the positions at alpha0.
            </summary>
    </member>
    <member name="F:FarseerPhysics.Common.Sweep.C">
      <summary>
            Center world positions
            </summary>
    </member>
    <member name="F:FarseerPhysics.Common.Sweep.LocalCenter">
      <summary>
            Local center of mass position
            </summary>
    </member>
    <member name="M:FarseerPhysics.Common.Sweep.GetTransform(FarseerPhysics.Common.Transform@,System.Single)">
      <summary>
            Get the interpolated transform at a specific time.
            </summary>
      <param name="xf">The transform.</param>
      <param name="beta">beta is a factor in [0,1], where 0 indicates alpha0.</param>
    </member>
    <member name="M:FarseerPhysics.Common.Sweep.Advance(System.Single)">
      <summary>
            Advance the sweep forward, yielding a new initial state.
            </summary>
      <param name="alpha">new initial time..</param>
    </member>
    <member name="M:FarseerPhysics.Common.Sweep.Normalize">
      <summary>
            Normalize the angles.
            </summary>
    </member>
    <member name="T:FarseerPhysics.Common.Decomposition.FlipcodeDecomposer">
      <summary>
            Triangulates a polygon into triangles.
            Doesn't handle holes.
            </summary>
    </member>
    <member name="M:FarseerPhysics.Common.Decomposition.FlipcodeDecomposer.InsideTriangle(Microsoft.Xna.Framework.Vector2@,Microsoft.Xna.Framework.Vector2@,Microsoft.Xna.Framework.Vector2@,Microsoft.Xna.Framework.Vector2@)">
      <summary>
            Check if the point P is inside the triangle defined by
            the points A, B, C
            </summary>
      <param name="a">The A point.</param>
      <param name="b">The B point.</param>
      <param name="c">The C point.</param>
      <param name="p">The point to be tested.</param>
      <returns>True if the point is inside the triangle</returns>
    </member>
    <member name="M:FarseerPhysics.Common.Decomposition.FlipcodeDecomposer.Snip(FarseerPhysics.Common.Vertices,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32[])">
      <summary>
            Cut a the contour and add a triangle into V to describe the 
            location of the cut
            </summary>
      <param name="contour">The list of points defining the polygon</param>
      <param name="u">The index of the first point</param>
      <param name="v">The index of the second point</param>
      <param name="w">The index of the third point</param>
      <param name="n">The number of elements in the array.</param>
      <param name="V">The array to populate with indicies of triangles.</param>
      <returns>True if a triangle was found</returns>
    </member>
    <member name="M:FarseerPhysics.Common.Decomposition.FlipcodeDecomposer.ConvexPartition(FarseerPhysics.Common.Vertices)">
      <summary>
            Decompose the polygon into triangles
            </summary>
      <param name="contour">The list of points describing the polygon</param>
      <returns>
      </returns>
    </member>
    <member name="M:Poly2Tri.Triangulation.Polygon.Polygon.#ctor(System.Collections.Generic.IList{Poly2Tri.Triangulation.Polygon.PolygonPoint})">
      <summary>
            Create a polygon from a list of at least 3 points with no duplicates.
            </summary>
      <param name="points">A list of unique points</param>
    </member>
    <member name="M:Poly2Tri.Triangulation.Polygon.Polygon.#ctor(System.Collections.Generic.IEnumerable{Poly2Tri.Triangulation.Polygon.PolygonPoint})">
      <summary>
            Create a polygon from a list of at least 3 points with no duplicates.
            </summary>
      <param name="points">A list of unique points.</param>
    </member>
    <member name="M:Poly2Tri.Triangulation.Polygon.Polygon.PrepareTriangulation(Poly2Tri.Triangulation.TriangulationContext)">
      <summary>
            Creates constraints and populates the context with points
            </summary>
      <param name="tcx">The context</param>
    </member>
    <member name="M:Poly2Tri.Triangulation.Polygon.Polygon.AddHole(Poly2Tri.Triangulation.Polygon.Polygon)">
      <summary>
            Add a hole to the polygon.
            </summary>
      <param name="poly">A subtraction polygon fully contained inside this polygon.</param>
    </member>
    <member name="M:Poly2Tri.Triangulation.Polygon.Polygon.InsertPointAfter(Poly2Tri.Triangulation.Polygon.PolygonPoint,Poly2Tri.Triangulation.Polygon.PolygonPoint)">
      <summary>
            Inserts newPoint after point.
            </summary>
      <param name="point">The point to insert after in the polygon</param>
      <param name="newPoint">The point to insert into the polygon</param>
    </member>
    <member name="M:Poly2Tri.Triangulation.Polygon.Polygon.AddPoints(System.Collections.Generic.IEnumerable{Poly2Tri.Triangulation.Polygon.PolygonPoint})">
      <summary>
            Inserts list (after last point in polygon?)
            </summary>
      <param name="list">
      </param>
    </member>
    <member name="M:Poly2Tri.Triangulation.Polygon.Polygon.AddPoint(Poly2Tri.Triangulation.Polygon.PolygonPoint)">
      <summary>
            Adds a point after the last in the polygon.
            </summary>
      <param name="p">The point to add</param>
    </member>
    <member name="M:Poly2Tri.Triangulation.Polygon.Polygon.RemovePoint(Poly2Tri.Triangulation.Polygon.PolygonPoint)">
      <summary>
            Removes a point from the polygon.
            </summary>
      <param name="p">
      </param>
    </member>
    <member name="T:FarseerPhysics.Collision.ContactFeature">
      <summary>
            The features that intersect to form the contact point
            This must be 4 bytes or less.
            </summary>
    </member>
    <member name="F:FarseerPhysics.Collision.ContactFeature.IndexA">
      <summary>
            Feature index on ShapeA
            </summary>
    </member>
    <member name="F:FarseerPhysics.Collision.ContactFeature.IndexB">
      <summary>
            Feature index on ShapeB
            </summary>
    </member>
    <member name="F:FarseerPhysics.Collision.ContactFeature.TypeA">
      <summary>
            The feature type on ShapeA
            </summary>
    </member>
    <member name="F:FarseerPhysics.Collision.ContactFeature.TypeB">
      <summary>
            The feature type on ShapeB
            </summary>
    </member>
    <member name="T:FarseerPhysics.Collision.ContactID">
      <summary>
            Contact ids to facilitate warm starting.
            </summary>
    </member>
    <member name="F:FarseerPhysics.Collision.ContactID.Features">
      <summary>
            The features that intersect to form the contact point
            </summary>
    </member>
    <member name="F:FarseerPhysics.Collision.ContactID.Key">
      <summary>
            Used to quickly compare contact ids.
            </summary>
    </member>
    <member name="T:FarseerPhysics.Collision.ManifoldPoint">
      <summary>
            A manifold point is a contact point belonging to a contact
            manifold. It holds details related to the geometry and dynamics
            of the contact points.
            The local point usage depends on the manifold type:
            -ShapeType.Circles: the local center of circleB
            -SeparationFunction.FaceA: the local center of cirlceB or the clip point of polygonB
            -SeparationFunction.FaceB: the clip point of polygonA
            This structure is stored across time steps, so we keep it small.
            Note: the impulses are used for internal caching and may not
            provide reliable contact forces, especially for high speed collisions.
            </summary>
    </member>
    <member name="F:FarseerPhysics.Collision.ManifoldPoint.Id">
      <summary>
            Uniquely identifies a contact point between two Shapes
            </summary>
    </member>
    <member name="T:FarseerPhysics.Collision.Manifold">
      <summary>
            A manifold for two touching convex Shapes.
            Box2D supports multiple types of contact:
            - clip point versus plane with radius
            - point versus point with radius (circles)
            The local point usage depends on the manifold type:
            -ShapeType.Circles: the local center of circleA
            -SeparationFunction.FaceA: the center of faceA
            -SeparationFunction.FaceB: the center of faceB
            Similarly the local normal usage:
            -ShapeType.Circles: not used
            -SeparationFunction.FaceA: the normal on polygonA
            -SeparationFunction.FaceB: the normal on polygonB
            We store contacts in this way so that position correction can
            account for movement, which is critical for continuous physics.
            All contact scenarios must be expressed in one of these types.
            This structure is stored across time steps, so we keep it small.
            </summary>
    </member>
    <member name="F:FarseerPhysics.Collision.Manifold.LocalNormal">
      <summary>
            Not use for Type.SeparationFunction.Points
            </summary>
    </member>
    <member name="F:FarseerPhysics.Collision.Manifold.LocalPoint">
      <summary>
            Usage depends on manifold type
            </summary>
    </member>
    <member name="F:FarseerPhysics.Collision.Manifold.PointCount">
      <summary>
            The number of manifold points
            </summary>
    </member>
    <member name="F:FarseerPhysics.Collision.Manifold.Points">
      <summary>
            The points of contact
            </summary>
    </member>
    <member name="T:FarseerPhysics.Collision.PointState">
      <summary>
            This is used for determining the state of contact points.
            </summary>
    </member>
    <member name="F:FarseerPhysics.Collision.PointState.Null">
      <summary>
            Point does not exist
            </summary>
    </member>
    <member name="F:FarseerPhysics.Collision.PointState.Add">
      <summary>
            Point was added in the update
            </summary>
    </member>
    <member name="F:FarseerPhysics.Collision.PointState.Persist">
      <summary>
            Point persisted across the update
            </summary>
    </member>
    <member name="F:FarseerPhysics.Collision.PointState.Remove">
      <summary>
            Point was removed in the update
            </summary>
    </member>
    <member name="T:FarseerPhysics.Collision.ClipVertex">
      <summary>
            Used for computing contact manifolds.
            </summary>
    </member>
    <member name="T:FarseerPhysics.Collision.RayCastInput">
      <summary>
            Ray-cast input data. The ray extends from p1 to p1 + maxFraction * (p2 - p1).
            </summary>
    </member>
    <member name="T:FarseerPhysics.Collision.RayCastOutput">
      <summary>
            Ray-cast output data.  The ray hits at p1 + fraction * (p2 - p1), where p1 and p2
            come from RayCastInput. 
            </summary>
    </member>
    <member name="T:FarseerPhysics.Collision.AABB">
      <summary>
            An axis aligned bounding box.
            </summary>
    </member>
    <member name="F:FarseerPhysics.Collision.AABB.LowerBound">
      <summary>
            The lower vertex
            </summary>
    </member>
    <member name="F:FarseerPhysics.Collision.AABB.UpperBound">
      <summary>
            The upper vertex
            </summary>
    </member>
    <member name="M:FarseerPhysics.Collision.AABB.IsValid">
      <summary>
            Verify that the bounds are sorted.
            </summary>
      <returns>
        <c>true</c> if this instance is valid; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="M:FarseerPhysics.Collision.AABB.Combine(FarseerPhysics.Collision.AABB@)">
      <summary>
            Combine an AABB into this one.
            </summary>
      <param name="aabb">The aabb.</param>
    </member>
    <member name="M:FarseerPhysics.Collision.AABB.Combine(FarseerPhysics.Collision.AABB@,FarseerPhysics.Collision.AABB@)">
      <summary>
            Combine two AABBs into this one.
            </summary>
      <param name="aabb1">The aabb1.</param>
      <param name="aabb2">The aabb2.</param>
    </member>
    <member name="M:FarseerPhysics.Collision.AABB.Contains(FarseerPhysics.Collision.AABB@)">
      <summary>
            Does this aabb contain the provided AABB.
            </summary>
      <param name="aabb">The aabb.</param>
      <returns>
        <c>true</c> if it contains the specified aabb; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="M:FarseerPhysics.Collision.AABB.Contains(Microsoft.Xna.Framework.Vector2@)">
      <summary>
            Determines whether the AAABB contains the specified point.
            </summary>
      <param name="point">The point.</param>
      <returns>
        <c>true</c> if it contains the specified point; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="P:FarseerPhysics.Collision.AABB.Center">
      <summary>
            Get the center of the AABB.
            </summary>
      <value>
      </value>
    </member>
    <member name="P:FarseerPhysics.Collision.AABB.Extents">
      <summary>
            Get the extents of the AABB (half-widths).
            </summary>
      <value>
      </value>
    </member>
    <member name="P:FarseerPhysics.Collision.AABB.Perimeter">
      <summary>
            Get the perimeter length
            </summary>
      <value>
      </value>
    </member>
    <member name="P:FarseerPhysics.Collision.AABB.Vertices">
      <summary>
            Gets the vertices of the AABB.
            </summary>
      <value>The corners of the AABB</value>
    </member>
    <member name="P:FarseerPhysics.Collision.AABB.Q1">
      <summary>
            first quadrant
            </summary>
    </member>
    <member name="T:FarseerPhysics.Collision.FatEdge">
      <summary>
            Edge shape plus more stuff.
            </summary>
    </member>
    <member name="T:FarseerPhysics.Collision.EPProxy">
      <summary>
            This lets us treate and edge shape and a polygon in the same
            way in the SAT collider.
            </summary>
    </member>
    <member name="M:FarseerPhysics.Collision.Collision.GetWorldManifold(FarseerPhysics.Collision.Manifold@,FarseerPhysics.Common.Transform@,System.Single,FarseerPhysics.Common.Transform@,System.Single,Microsoft.Xna.Framework.Vector2@,FarseerPhysics.Common.FixedArray2{Microsoft.Xna.Framework.Vector2}@)">
      <summary>
            Evaluate the manifold with supplied transforms. This assumes
            modest motion from the original state. This does not change the
            point count, impulses, etc. The radii must come from the Shapes
            that generated the manifold.
            </summary>
      <param name="manifold">The manifold.</param>
      <param name="transformA">The transform for A.</param>
      <param name="radiusA">The radius for A.</param>
      <param name="transformB">The transform for B.</param>
      <param name="radiusB">The radius for B.</param>
      <param name="normal">World vector pointing from A to B</param>
      <param name="points">Torld contact point (point of intersection).</param>
    </member>
    <member name="M:FarseerPhysics.Collision.Collision.CollideCircles(FarseerPhysics.Collision.Manifold@,FarseerPhysics.Collision.Shapes.CircleShape,FarseerPhysics.Common.Transform@,FarseerPhysics.Collision.Shapes.CircleShape,FarseerPhysics.Common.Transform@)">
            Compute the collision manifold between two circles.
        </member>
    <member name="M:FarseerPhysics.Collision.Collision.CollidePolygonAndCircle(FarseerPhysics.Collision.Manifold@,FarseerPhysics.Collision.Shapes.PolygonShape,FarseerPhysics.Common.Transform@,FarseerPhysics.Collision.Shapes.CircleShape,FarseerPhysics.Common.Transform@)">
      <summary>
            Compute the collision manifold between a polygon and a circle.
            </summary>
      <param name="manifold">The manifold.</param>
      <param name="polygonA">The polygon A.</param>
      <param name="transformA">The transform of A.</param>
      <param name="circleB">The circle B.</param>
      <param name="transformB">The transform of B.</param>
    </member>
    <member name="M:FarseerPhysics.Collision.Collision.CollidePolygons(FarseerPhysics.Collision.Manifold@,FarseerPhysics.Collision.Shapes.PolygonShape,FarseerPhysics.Common.Transform@,FarseerPhysics.Collision.Shapes.PolygonShape,FarseerPhysics.Common.Transform@)">
      <summary>
            Compute the collision manifold between two polygons.
            </summary>
      <param name="manifold">The manifold.</param>
      <param name="polyA">The poly A.</param>
      <param name="transformA">The transform A.</param>
      <param name="polyB">The poly B.</param>
      <param name="transformB">The transform B.</param>
    </member>
    <member name="M:FarseerPhysics.Collision.Collision.CollideEdgeAndCircle(FarseerPhysics.Collision.Manifold@,FarseerPhysics.Collision.Shapes.EdgeShape,FarseerPhysics.Common.Transform@,FarseerPhysics.Collision.Shapes.CircleShape,FarseerPhysics.Common.Transform@)">
      <summary>
            Compute contact points for edge versus circle.
            This accounts for edge connectivity.
            </summary>
      <param name="manifold">The manifold.</param>
      <param name="edgeA">The edge A.</param>
      <param name="transformA">The transform A.</param>
      <param name="circleB">The circle B.</param>
      <param name="transformB">The transform B.</param>
    </member>
    <member name="M:FarseerPhysics.Collision.Collision.CollideEdgeAndPolygon(FarseerPhysics.Collision.Manifold@,FarseerPhysics.Collision.Shapes.EdgeShape,FarseerPhysics.Common.Transform@,FarseerPhysics.Collision.Shapes.PolygonShape,FarseerPhysics.Common.Transform@)">
      <summary>
            Collides and edge and a polygon, taking into account edge adjacency.
            </summary>
      <param name="manifold">The manifold.</param>
      <param name="edgeA">The edge A.</param>
      <param name="xfA">The xf A.</param>
      <param name="polygonB">The polygon B.</param>
      <param name="xfB">The xf B.</param>
    </member>
    <member name="M:FarseerPhysics.Collision.Collision.ClipSegmentToLine(FarseerPhysics.Common.FixedArray2{FarseerPhysics.Collision.ClipVertex}@,FarseerPhysics.Common.FixedArray2{FarseerPhysics.Collision.ClipVertex}@,Microsoft.Xna.Framework.Vector2,System.Single,System.Int32)">
      <summary>
            Clipping for contact manifolds.
            </summary>
      <param name="vOut">The v out.</param>
      <param name="vIn">The v in.</param>
      <param name="normal">The normal.</param>
      <param name="offset">The offset.</param>
      <param name="vertexIndexA">The vertex index A.</param>
      <returns>
      </returns>
    </member>
    <member name="M:FarseerPhysics.Collision.Collision.EdgeSeparation(FarseerPhysics.Collision.Shapes.PolygonShape,FarseerPhysics.Common.Transform@,System.Int32,FarseerPhysics.Collision.Shapes.PolygonShape,FarseerPhysics.Common.Transform@)">
      <summary>
            Find the separation between poly1 and poly2 for a give edge normal on poly1.
            </summary>
      <param name="poly1">The poly1.</param>
      <param name="xf1">The XF1.</param>
      <param name="edge1">The edge1.</param>
      <param name="poly2">The poly2.</param>
      <param name="xf2">The XF2.</param>
      <returns>
      </returns>
    </member>
    <member name="M:FarseerPhysics.Collision.Collision.FindMaxSeparation(System.Int32@,FarseerPhysics.Collision.Shapes.PolygonShape,FarseerPhysics.Common.Transform@,FarseerPhysics.Collision.Shapes.PolygonShape,FarseerPhysics.Common.Transform@)">
      <summary>
            Find the max separation between poly1 and poly2 using edge normals from poly1.
            </summary>
      <param name="edgeIndex">Index of the edge.</param>
      <param name="poly1">The poly1.</param>
      <param name="xf1">The XF1.</param>
      <param name="poly2">The poly2.</param>
      <param name="xf2">The XF2.</param>
      <returns>
      </returns>
    </member>
    <member name="T:FarseerPhysics.Dynamics.Joints.PrismaticJoint">
      <summary>
            A prismatic joint. This joint provides one degree of freedom: translation
            along an axis fixed in body1. Relative rotation is prevented. You can
            use a joint limit to restrict the range of motion and a joint motor to
            drive the motion or to model joint friction.
            </summary>
    </member>
    <member name="M:FarseerPhysics.Dynamics.Joints.PrismaticJoint.#ctor(FarseerPhysics.Dynamics.Body,FarseerPhysics.Dynamics.Body,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2)">
      <summary>
            This requires defining a line of
            motion using an axis and an anchor point. The definition uses local
            anchor points and a local axis so that the initial configuration
            can violate the constraint slightly. The joint translation is zero
            when the local anchor points coincide in world space. Using local
            anchors and a local axis helps when saving and loading a game.
            </summary>
      <param name="bodyA">The first body.</param>
      <param name="bodyB">The second body.</param>
      <param name="localAnchorA">The first body anchor.</param>
      <param name="localAnchorB">The second body anchor.</param>
      <param name="axis">The axis.</param>
    </member>
    <member name="P:FarseerPhysics.Dynamics.Joints.PrismaticJoint.JointTranslation">
      <summary>
            Get the current joint translation, usually in meters.
            </summary>
      <value>
      </value>
    </member>
    <member name="P:FarseerPhysics.Dynamics.Joints.PrismaticJoint.JointSpeed">
      <summary>
            Get the current joint translation speed, usually in meters per second.
            </summary>
      <value>
      </value>
    </member>
    <member name="P:FarseerPhysics.Dynamics.Joints.PrismaticJoint.LimitEnabled">
      <summary>
            Is the joint limit enabled?
            </summary>
      <value>
        <c>true</c> if [limit enabled]; otherwise, <c>false</c>.</value>
    </member>
    <member name="P:FarseerPhysics.Dynamics.Joints.PrismaticJoint.LowerLimit">
      <summary>
            Get the lower joint limit, usually in meters.
            </summary>
      <value>
      </value>
    </member>
    <member name="P:FarseerPhysics.Dynamics.Joints.PrismaticJoint.UpperLimit">
      <summary>
            Get the upper joint limit, usually in meters.
            </summary>
      <value>
      </value>
    </member>
    <member name="P:FarseerPhysics.Dynamics.Joints.PrismaticJoint.MotorEnabled">
      <summary>
            Is the joint motor enabled?
            </summary>
      <value>
        <c>true</c> if [motor enabled]; otherwise, <c>false</c>.</value>
    </member>
    <member name="P:FarseerPhysics.Dynamics.Joints.PrismaticJoint.MotorSpeed">
      <summary>
            Set the motor speed, usually in meters per second.
            </summary>
      <value>The speed.</value>
    </member>
    <member name="P:FarseerPhysics.Dynamics.Joints.PrismaticJoint.MaxMotorForce">
      <summary>
            Set the maximum motor force, usually in N.
            </summary>
      <value>The force.</value>
    </member>
    <member name="P:FarseerPhysics.Dynamics.Joints.PrismaticJoint.MotorForce">
      <summary>
            Get the current motor force, usually in N.
            </summary>
      <value>
      </value>
    </member>
    <member name="T:FarseerPhysics.Dynamics.Joints.FixedFrictionJoint">
      <summary>
            Friction joint. This is used for top-down friction.
            It provides 2D translational friction and angular friction.
            </summary>
    </member>
    <member name="F:FarseerPhysics.Dynamics.Joints.FixedFrictionJoint.MaxForce">
      <summary>
            The maximum friction force in N.
            </summary>
    </member>
    <member name="F:FarseerPhysics.Dynamics.Joints.FixedFrictionJoint.MaxTorque">
      <summary>
            The maximum friction torque in N-m.
            </summary>
    </member>
    <member name="T:FarseerPhysics.Common.Decomposition.BayazitDecomposer">
      <summary>
            Convex decomposition algorithm created by Mark Bayazit (http://mnbayazit.com/)
            For more information about this algorithm, see http://mnbayazit.com/406/bayazit
            </summary>
    </member>
    <member name="M:FarseerPhysics.Common.Decomposition.BayazitDecomposer.ConvexPartition(FarseerPhysics.Common.Vertices)">
      <summary>
            Decompose the polygon into several smaller non-concave polygon.
            If the polygon is already convex, it will return the original polygon, unless it is over Settings.MaxPolygonVertices.
            Precondition: Counter Clockwise polygon
            </summary>
      <param name="vertices">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:FarseerPhysics.Factories.FixtureFactory">
      <summary>
            An easy to use factory for creating bodies
            </summary>
    </member>
    <member name="T:FarseerPhysics.Dynamics.Joints.RopeJoint">
      <summary>
            A rope joint enforces a maximum distance between two points
            on two bodies. It has no other effect.
            Warning: if you attempt to change the maximum length during
            the simulation you will get some non-physical behavior.
            A model that would allow you to dynamically modify the length
            would have some sponginess, so I chose not to implement it
            that way. See b2DistanceJoint if you want to dynamically
            control length.
            </summary>
    </member>
    <member name="P:FarseerPhysics.Dynamics.Joints.RopeJoint.MaxLength">
            Get the maximum length of the rope.
        </member>
    <member name="T:FarseerPhysics.Common.Path">
      <summary>
            Path:
            Very similar to Vertices, but this
            class contains vectors describing
            control points on a Catmull-Rom
            curve.
            </summary>
    </member>
    <member name="F:FarseerPhysics.Common.Path.ControlPoints">
      <summary>
            All the points that makes up the curve
            </summary>
    </member>
    <member name="M:FarseerPhysics.Common.Path.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:FarseerPhysics.Common.Path" /> class.
            </summary>
    </member>
    <member name="M:FarseerPhysics.Common.Path.#ctor(Microsoft.Xna.Framework.Vector2[])">
      <summary>
            Initializes a new instance of the <see cref="T:FarseerPhysics.Common.Path" /> class.
            </summary>
      <param name="vertices">The vertices to created the path from.</param>
    </member>
    <member name="M:FarseerPhysics.Common.Path.#ctor(System.Collections.Generic.IList{Microsoft.Xna.Framework.Vector2})">
      <summary>
            Initializes a new instance of the <see cref="T:FarseerPhysics.Common.Path" /> class.
            </summary>
      <param name="vertices">The vertices to created the path from.</param>
    </member>
    <member name="M:FarseerPhysics.Common.Path.NextIndex(System.Int32)">
      <summary>
            Gets the next index of a controlpoint
            </summary>
      <param name="index">The index.</param>
      <returns>
      </returns>
    </member>
    <member name="M:FarseerPhysics.Common.Path.PreviousIndex(System.Int32)">
      <summary>
            Gets the previous index of a controlpoint
            </summary>
      <param name="index">The index.</param>
      <returns>
      </returns>
    </member>
    <member name="M:FarseerPhysics.Common.Path.Translate(Microsoft.Xna.Framework.Vector2@)">
      <summary>
            Translates the control points by the specified vector.
            </summary>
      <param name="vector">The vector.</param>
    </member>
    <member name="M:FarseerPhysics.Common.Path.Scale(Microsoft.Xna.Framework.Vector2@)">
      <summary>
            Scales the control points by the specified vector.
            </summary>
      <param name="value">The Value.</param>
    </member>
    <member name="M:FarseerPhysics.Common.Path.Rotate(System.Single)">
      <summary>
            Rotate the control points by the defined value in radians.
            </summary>
      <param name="value">The amount to rotate by in radians.</param>
    </member>
    <member name="M:FarseerPhysics.Common.Path.GetVertices(System.Int32)">
      <summary>
            Returns a set of points defining the
            curve with the specifed number of divisions
            between each control point.
            </summary>
      <param name="divisions">Number of divisions between each control point.</param>
      <returns>
      </returns>
    </member>
    <member name="M:FarseerPhysics.Common.Path.GetPositionNormal(System.Single)">
      <summary>
            Gets the normal for the given time.
            </summary>
      <param name="time">The time</param>
      <returns>The normal.</returns>
    </member>
    <member name="P:FarseerPhysics.Common.Path.Closed">
      <summary>
            True if the curve is closed.
            </summary>
      <value>
        <c>true</c> if closed; otherwise, <c>false</c>.</value>
    </member>
    <member name="T:Poly2Tri.Triangulation.Delaunay.Sweep.DTSweepContext">
             
             @author Thomas Ã…hlÃ©n, thahlen@gmail.com
            
        </member>
    <member name="M:Poly2Tri.Triangulation.Delaunay.Sweep.DTSweepContext.MapTriangleToNodes(Poly2Tri.Triangulation.Delaunay.DelaunayTriangle)">
      <summary>
            Try to map a node to all sides of this triangle that don't have 
            a neighbor.
            </summary>
    </member>
    <member name="F:Poly2Tri.Triangulation.Delaunay.DelaunayTriangle.EdgeIsConstrained">
            Flags to determine if an edge is a Delauney edge 
        </member>
    <member name="F:Poly2Tri.Triangulation.Delaunay.DelaunayTriangle.EdgeIsDelaunay">
            Flags to determine if an edge is a Constrained edge 
        </member>
    <member name="F:Poly2Tri.Triangulation.Delaunay.DelaunayTriangle.Points">
            Has this triangle been marked as an interior triangle? 
        </member>
    <member name="M:Poly2Tri.Triangulation.Delaunay.DelaunayTriangle.MarkNeighbor(Poly2Tri.Triangulation.TriangulationPoint,Poly2Tri.Triangulation.TriangulationPoint,Poly2Tri.Triangulation.Delaunay.DelaunayTriangle)">
      <summary>
            Update neighbor pointers
            </summary>
      <param name="p1">Point 1 of the shared edge</param>
      <param name="p2">Point 2 of the shared edge</param>
      <param name="t">This triangle's new neighbor</param>
    </member>
    <member name="M:Poly2Tri.Triangulation.Delaunay.DelaunayTriangle.MarkNeighbor(Poly2Tri.Triangulation.Delaunay.DelaunayTriangle)">
      <summary>
            Exhaustive search to update neighbor pointers
            </summary>
    </member>
    <member name="M:Poly2Tri.Triangulation.Delaunay.DelaunayTriangle.Clear">
            Clears all references to all other triangles and points
        </member>
    <member name="M:Poly2Tri.Triangulation.Delaunay.DelaunayTriangle.OppositePoint(Poly2Tri.Triangulation.Delaunay.DelaunayTriangle,Poly2Tri.Triangulation.TriangulationPoint)">
      <param name="t">Opposite triangle</param>
      <param name="p">The point in t that isn't shared between the triangles</param>
    </member>
    <member name="M:Poly2Tri.Triangulation.Delaunay.DelaunayTriangle.Legalize(Poly2Tri.Triangulation.TriangulationPoint,Poly2Tri.Triangulation.TriangulationPoint)">
      <summary>
            Legalize triangle by rotating clockwise around oPoint
            </summary>
      <param name="oPoint">The origin point to rotate around</param>
      <param name="nPoint">???</param>
    </member>
    <member name="M:Poly2Tri.Triangulation.Delaunay.DelaunayTriangle.MarkNeighborEdges">
      <summary>
            Finalize edge marking
            </summary>
    </member>
    <member name="M:Poly2Tri.Triangulation.Delaunay.DelaunayTriangle.MarkConstrainedEdge(Poly2Tri.Triangulation.TriangulationPoint,Poly2Tri.Triangulation.TriangulationPoint)">
      <summary>
            Mark edge as constrained
            </summary>
    </member>
    <member name="M:Poly2Tri.Triangulation.Delaunay.DelaunayTriangle.EdgeIndex(Poly2Tri.Triangulation.TriangulationPoint,Poly2Tri.Triangulation.TriangulationPoint)">
      <summary>
            Get the index of the neighbor that shares this edge (or -1 if it isn't shared)
            </summary>
      <returns>index of the shared edge or -1 if edge isn't shared</returns>
    </member>
    <member name="T:FarseerPhysics.Dynamics.Joints.FixedRevoluteJoint">
      <summary>
            A revolute joint rains to bodies to share a common point while they
            are free to rotate about the point. The relative rotation about the shared
            point is the joint angle. You can limit the relative rotation with
            a joint limit that specifies a lower and upper angle. You can use a motor
            to drive the relative rotation about the shared point. A maximum motor torque
            is provided so that infinite forces are not generated.
            </summary>
    </member>
    <member name="M:FarseerPhysics.Dynamics.Joints.FixedRevoluteJoint.#ctor(FarseerPhysics.Dynamics.Body,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2)">
      <summary>
            Initialize the bodies, anchors, and reference angle using the world
            anchor.
            This requires defining an
            anchor point where the bodies are joined. The definition
            uses local anchor points so that the initial configuration
            can violate the constraint slightly. You also need to
            specify the initial relative angle for joint limits. This
            helps when saving and loading a game.
            The local anchor points are measured from the body's origin
            rather than the center of mass because:
            1. you might not know where the center of mass will be.
            2. if you add/remove shapes from a body and recompute the mass,
            the joints will be broken.
            </summary>
      <param name="body">The body.</param>
      <param name="bodyAnchor">The body anchor.</param>
      <param name="worldAnchor">The world anchor.</param>
    </member>
    <member name="P:FarseerPhysics.Dynamics.Joints.FixedRevoluteJoint.JointAngle">
      <summary>
            Get the current joint angle in radians.
            </summary>
      <value>
      </value>
    </member>
    <member name="P:FarseerPhysics.Dynamics.Joints.FixedRevoluteJoint.JointSpeed">
      <summary>
            Get the current joint angle speed in radians per second.
            </summary>
      <value>
      </value>
    </member>
    <member name="P:FarseerPhysics.Dynamics.Joints.FixedRevoluteJoint.LimitEnabled">
      <summary>
            Is the joint limit enabled?
            </summary>
      <value>
        <c>true</c> if [limit enabled]; otherwise, <c>false</c>.</value>
    </member>
    <member name="P:FarseerPhysics.Dynamics.Joints.FixedRevoluteJoint.LowerLimit">
      <summary>
            Get the lower joint limit in radians.
            </summary>
      <value>
      </value>
    </member>
    <member name="P:FarseerPhysics.Dynamics.Joints.FixedRevoluteJoint.UpperLimit">
      <summary>
            Get the upper joint limit in radians.
            </summary>
      <value>
      </value>
    </member>
    <member name="P:FarseerPhysics.Dynamics.Joints.FixedRevoluteJoint.MotorEnabled">
      <summary>
            Is the joint motor enabled?
            </summary>
      <value>
        <c>true</c> if [motor enabled]; otherwise, <c>false</c>.</value>
    </member>
    <member name="P:FarseerPhysics.Dynamics.Joints.FixedRevoluteJoint.MotorSpeed">
      <summary>
            Set the motor speed in radians per second.
            </summary>
      <value>The speed.</value>
    </member>
    <member name="P:FarseerPhysics.Dynamics.Joints.FixedRevoluteJoint.MaxMotorTorque">
      <summary>
            Set the maximum motor torque, usually in N-m.
            </summary>
      <value>The torque.</value>
    </member>
    <member name="P:FarseerPhysics.Dynamics.Joints.FixedRevoluteJoint.MotorTorque">
      <summary>
            Get the current motor torque, usually in N-m.
            </summary>
      <value>
      </value>
    </member>
    <member name="T:FarseerPhysics.Dynamics.Contacts.ContactEdge">
      <summary>
            A contact edge is used to connect bodies and contacts together
            in a contact graph where each body is a node and each contact
            is an edge. A contact edge belongs to a doubly linked list
            maintained in each attached body. Each contact has two contact
            nodes, one for each attached body.
            </summary>
    </member>
    <member name="F:FarseerPhysics.Dynamics.Contacts.ContactEdge.Contact">
      <summary>
            The contact
            </summary>
    </member>
    <member name="F:FarseerPhysics.Dynamics.Contacts.ContactEdge.Next">
      <summary>
            The next contact edge in the body's contact list
            </summary>
    </member>
    <member name="F:FarseerPhysics.Dynamics.Contacts.ContactEdge.Other">
      <summary>
            Provides quick access to the other body attached.
            </summary>
    </member>
    <member name="F:FarseerPhysics.Dynamics.Contacts.ContactEdge.Prev">
      <summary>
            The previous contact edge in the body's contact list
            </summary>
    </member>
    <member name="F:FarseerPhysics.Dynamics.Contacts.ContactFlags.Island">
      <summary>
            Used when crawling contact graph when forming islands.
            </summary>
    </member>
    <member name="F:FarseerPhysics.Dynamics.Contacts.ContactFlags.Touching">
      <summary>
            Set when the shapes are touching.
            </summary>
    </member>
    <member name="F:FarseerPhysics.Dynamics.Contacts.ContactFlags.Enabled">
      <summary>
            This contact can be disabled (by user)
            </summary>
    </member>
    <member name="F:FarseerPhysics.Dynamics.Contacts.ContactFlags.Filter">
      <summary>
            This contact needs filtering because a fixture filter was changed.
            </summary>
    </member>
    <member name="F:FarseerPhysics.Dynamics.Contacts.ContactFlags.BulletHit">
      <summary>
            This bullet contact had a TOI event
            </summary>
    </member>
    <member name="F:FarseerPhysics.Dynamics.Contacts.ContactFlags.TOI">
      <summary>
            This contact has a valid TOI i the field TOI
            </summary>
    </member>
    <member name="T:FarseerPhysics.Dynamics.Contacts.Contact">
      <summary>
            The class manages contact between two shapes. A contact exists for each overlapping
            AABB in the broad-phase (except if filtered). Therefore a contact object may exist
            that has no contact points.
            </summary>
    </member>
    <member name="M:FarseerPhysics.Dynamics.Contacts.Contact.GetManifold(FarseerPhysics.Collision.Manifold@)">
      <summary>
            Get the contact manifold. Do not modify the manifold unless you understand the
            internals of Box2D.
            </summary>
      <param name="manifold">The manifold.</param>
    </member>
    <member name="M:FarseerPhysics.Dynamics.Contacts.Contact.GetWorldManifold(Microsoft.Xna.Framework.Vector2@,FarseerPhysics.Common.FixedArray2{Microsoft.Xna.Framework.Vector2}@)">
      <summary>
            Gets the world manifold.
            </summary>
    </member>
    <member name="M:FarseerPhysics.Dynamics.Contacts.Contact.IsTouching">
      <summary>
            Determines whether this contact is touching.
            </summary>
      <returns>
        <c>true</c> if this instance is touching; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="M:FarseerPhysics.Dynamics.Contacts.Contact.FlagForFiltering">
      <summary>
            Flag this contact for filtering. Filtering will occur the next time step.
            </summary>
    </member>
    <member name="M:FarseerPhysics.Dynamics.Contacts.Contact.Update(FarseerPhysics.Dynamics.ContactManager)">
      <summary>
            Update the contact manifold and touching status.
            Note: do not assume the fixture AABBs are overlapping or are valid.
            </summary>
      <param name="contactManager">The contact manager.</param>
    </member>
    <member name="M:FarseerPhysics.Dynamics.Contacts.Contact.Evaluate(FarseerPhysics.Collision.Manifold@,FarseerPhysics.Common.Transform@,FarseerPhysics.Common.Transform@)">
      <summary>
            Evaluate this contact with your own manifold and transforms.   
            </summary>
      <param name="manifold">The manifold.</param>
      <param name="transformA">The first transform.</param>
      <param name="transformB">The second transform.</param>
    </member>
    <member name="P:FarseerPhysics.Dynamics.Contacts.Contact.Enabled">
            Enable/disable this contact. This can be used inside the pre-solve
            contact listener. The contact is only disabled for the current
            time step (or sub-step in continuous collisions).
        </member>
    <member name="P:FarseerPhysics.Dynamics.Contacts.Contact.ChildIndexA">
      <summary>
            Get the child primitive index for fixture A.
            </summary>
      <value>The child index A.</value>
    </member>
    <member name="P:FarseerPhysics.Dynamics.Contacts.Contact.ChildIndexB">
      <summary>
            Get the child primitive index for fixture B.
            </summary>
      <value>The child index B.</value>
    </member>
    <member name="T:FarseerPhysics.Controllers.SimpleWindForce">
      <summary>
            Reference implementation for forces based on AbstractForceController
            It supports all features provided by the base class and illustrates proper
            usage as an easy to understand example.
            As a side-effect it is a nice and easy to use wind force for your projects
            </summary>
    </member>
    <member name="P:FarseerPhysics.Controllers.SimpleWindForce.Direction">
      <summary>
            Direction of the windforce
            </summary>
    </member>
    <member name="P:FarseerPhysics.Controllers.SimpleWindForce.Divergence">
      <summary>
            The amount of Direction randomization. Allowed range is 0-1.
            </summary>
    </member>
    <member name="P:FarseerPhysics.Controllers.SimpleWindForce.IgnorePosition">
      <summary>
            Ignore the position and apply the force. If off only in the "front" (relative to position and direction)
            will be affected
            </summary>
    </member>
    <member name="T:FarseerPhysics.Common.TerrainTester">
      <summary>
            Return true if the specified color is inside the terrain.
            </summary>
    </member>
    <member name="T:FarseerPhysics.Common.MSTerrain">
      <summary>
            Simple class to maintain a terrain.
            </summary>
    </member>
    <member name="F:FarseerPhysics.Common.MSTerrain.World">
      <summary>
            World to manage terrain in.
            </summary>
    </member>
    <member name="F:FarseerPhysics.Common.MSTerrain.Center">
      <summary>
            Center of terrain in world units.
            </summary>
    </member>
    <member name="F:FarseerPhysics.Common.MSTerrain.Width">
      <summary>
            Width of terrain in world units.
            </summary>
    </member>
    <member name="F:FarseerPhysics.Common.MSTerrain.Height">
      <summary>
            Height of terrain in world units.
            </summary>
    </member>
    <member name="F:FarseerPhysics.Common.MSTerrain.PointsPerUnit">
      <summary>
            Points per each world unit used to define the terrain in the point cloud.
            </summary>
    </member>
    <member name="F:FarseerPhysics.Common.MSTerrain.CellSize">
      <summary>
            Points per cell.
            </summary>
    </member>
    <member name="F:FarseerPhysics.Common.MSTerrain.SubCellSize">
      <summary>
            Points per sub cell.
            </summary>
    </member>
    <member name="F:FarseerPhysics.Common.MSTerrain.Iterations">
      <summary>
            Number of iterations to perform in the Marching Squares algorithm.
            Note: More then 3 has almost no effect on quality.
            </summary>
    </member>
    <member name="F:FarseerPhysics.Common.MSTerrain.Decomposer">
      <summary>
            Decomposer to use when regenerating terrain. Can be changed on the fly without consequence.
            Note: Some decomposerers are unstable.
            </summary>
    </member>
    <member name="F:FarseerPhysics.Common.MSTerrain._terrainMap">
      <summary>
            Point cloud defining the terrain.
            </summary>
    </member>
    <member name="F:FarseerPhysics.Common.MSTerrain._bodyMap">
      <summary>
            Generated bodies.
            </summary>
    </member>
    <member name="M:FarseerPhysics.Common.MSTerrain.Initialize">
      <summary>
            Initialize the terrain for use.
            </summary>
    </member>
    <member name="M:FarseerPhysics.Common.MSTerrain.ApplyTexture(Microsoft.Xna.Framework.Graphics.Texture2D,Microsoft.Xna.Framework.Vector2,FarseerPhysics.Common.TerrainTester)">
      <summary>
            Apply a texture to the terrain using the specified TerrainTester.
            </summary>
      <param name="texture">Texture to apply.</param>
      <param name="position">Top left position of the texture relative to the terrain.</param>
      <param name="tester">Delegate method used to determine what colors should be included in the terrain.</param>
    </member>
    <member name="M:FarseerPhysics.Common.MSTerrain.ConvertTextureToData(Microsoft.Xna.Framework.Graphics.Texture2D,FarseerPhysics.Common.TerrainTester)">
      <summary>
            Convert a texture to an sbtye array compatible with ApplyData().
            </summary>
      <param name="texture">Texture to convert.</param>
      <param name="tester">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:FarseerPhysics.Common.MSTerrain.ModifyTerrain(Microsoft.Xna.Framework.Vector2,System.SByte)">
      <summary>
            Modify a single point in the terrain.
            </summary>
      <param name="location">World location to modify. Automatically clipped.</param>
      <param name="value">-1 = inside terrain, 1 = outside terrain</param>
    </member>
    <member name="M:FarseerPhysics.Common.MSTerrain.RegenerateTerrain">
      <summary>
            Regenerate the terrain.
            </summary>
    </member>
    <member name="T:FarseerPhysics.Common.MarchingSquares.CxFastList`1">
      <summary>
            Designed as a complete port of CxFastList from CxStd.
            </summary>
    </member>
    <member name="M:FarseerPhysics.Common.MarchingSquares.CxFastList`1.Begin">
      <summary>
            Iterator to start of list (O(1))
            </summary>
    </member>
    <member name="M:FarseerPhysics.Common.MarchingSquares.CxFastList`1.End">
      <summary>
            Iterator to end of list (O(1))
            </summary>
    </member>
    <member name="M:FarseerPhysics.Common.MarchingSquares.CxFastList`1.Front">
      <summary>
            Returns first element of list (O(1))
            </summary>
    </member>
    <member name="M:FarseerPhysics.Common.MarchingSquares.CxFastList`1.Add(`0)">
      <summary>
            add object to list (O(1))
            </summary>
    </member>
    <member name="M:FarseerPhysics.Common.MarchingSquares.CxFastList`1.Remove(`0)">
      <summary>
            remove object from list, returns true if an element was removed (O(n))
            </summary>
    </member>
    <member name="M:FarseerPhysics.Common.MarchingSquares.CxFastList`1.Pop">
      <summary>
            pop element from head of list (O(1)) Note: this does not return the object popped! 
            There is good reason to this, and it regards the Alloc list variants which guarantee 
            objects are released to the object pool. You do not want to retrieve an element 
            through pop or else that object may suddenly be used by another piece of code which 
            retrieves it from the object pool.
            </summary>
    </member>
    <member name="M:FarseerPhysics.Common.MarchingSquares.CxFastList`1.Insert(FarseerPhysics.Common.MarchingSquares.CxFastListNode{`0},`0)">
      <summary>
            insert object after 'node' returning an iterator to the inserted object.
            </summary>
    </member>
    <member name="M:FarseerPhysics.Common.MarchingSquares.CxFastList`1.Erase(FarseerPhysics.Common.MarchingSquares.CxFastListNode{`0},FarseerPhysics.Common.MarchingSquares.CxFastListNode{`0})">
      <summary>
            removes the element pointed to by 'node' with 'prev' being the previous iterator, 
            returning an iterator to the element following that of 'node' (O(1))
            </summary>
    </member>
    <member name="M:FarseerPhysics.Common.MarchingSquares.CxFastList`1.Empty">
      <summary>
            whether the list is empty (O(1))
            </summary>
    </member>
    <member name="M:FarseerPhysics.Common.MarchingSquares.CxFastList`1.Size">
      <summary>
            computes size of list (O(n))
            </summary>
    </member>
    <member name="M:FarseerPhysics.Common.MarchingSquares.CxFastList`1.Clear">
      <summary>
            empty the list (O(1) if CxMixList, O(n) otherwise)
            </summary>
    </member>
    <member name="M:FarseerPhysics.Common.MarchingSquares.CxFastList`1.Has(`0)">
      <summary>
            returns true if 'value' is an element of the list (O(n))
            </summary>
    </member>
    <member name="F:FarseerPhysics.Common.MarchingSquares._lookMarch">
            Linearly interpolate between (x0 to x1) given a value at these coordinates (v0 and v1)
                        such as to approximate value(return) = 0
                    *
        </member>
    <member name="M:FarseerPhysics.Common.MarchingSquares.Square(System.Single)">
            Square value for use in marching squares *
        </member>
    <member name="M:FarseerPhysics.Common.MarchingSquares.combLeft(FarseerPhysics.Common.MarchingSquares.GeomPoly@,FarseerPhysics.Common.MarchingSquares.GeomPoly@)">
            Used in polygon composition to composit polygons into scan lines
                        Combining polya and polyb into one super-polygon stored in polya.
                    *
        </member>
    <member name="T:FarseerPhysics.Factories.PathManager">
      <summary>
            An easy to use manager for creating paths.
            </summary>
    </member>
    <member name="M:FarseerPhysics.Factories.PathManager.ConvertPathToEdges(FarseerPhysics.Common.Path,FarseerPhysics.Dynamics.Body,System.Int32)">
      <summary>
            Convert a path into a set of edges and attaches them to the specified body.
            Note: use only for static edges.
            </summary>
      <param name="path">The path.</param>
      <param name="body">The body.</param>
      <param name="subdivisions">The subdivisions.</param>
    </member>
    <member name="M:FarseerPhysics.Factories.PathManager.ConvertPathToPolygon(FarseerPhysics.Common.Path,FarseerPhysics.Dynamics.Body,System.Single,System.Int32)">
      <summary>
            Convert a closed path into a polygon.
            Convex decomposition is automatically performed.
            </summary>
      <param name="path">The path.</param>
      <param name="body">The body.</param>
      <param name="density">The density.</param>
      <param name="subdivisions">The subdivisions.</param>
    </member>
    <member name="M:FarseerPhysics.Factories.PathManager.EvenlyDistributeShapesAlongPath(FarseerPhysics.Dynamics.World,FarseerPhysics.Common.Path,System.Collections.Generic.IEnumerable{FarseerPhysics.Collision.Shapes.Shape},FarseerPhysics.Dynamics.BodyType,System.Int32,System.Object)">
      <summary>
            Duplicates the given Body along the given path for approximatly the given copies.
            </summary>
      <param name="world">The world.</param>
      <param name="path">The path.</param>
      <param name="shapes">The shapes.</param>
      <param name="type">The type.</param>
      <param name="copies">The copies.</param>
      <param name="userData">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:FarseerPhysics.Factories.PathManager.EvenlyDistributeShapesAlongPath(FarseerPhysics.Dynamics.World,FarseerPhysics.Common.Path,FarseerPhysics.Collision.Shapes.Shape,FarseerPhysics.Dynamics.BodyType,System.Int32,System.Object)">
      <summary>
            Duplicates the given Body along the given path for approximatly the given copies.
            </summary>
      <param name="world">The world.</param>
      <param name="path">The path.</param>
      <param name="shape">The shape.</param>
      <param name="type">The type.</param>
      <param name="copies">The copies.</param>
      <param name="userData">The user data.</param>
      <returns>
      </returns>
    </member>
    <member name="M:FarseerPhysics.Factories.PathManager.MoveBodyOnPath(FarseerPhysics.Common.Path,FarseerPhysics.Dynamics.Body,System.Single,System.Single,System.Single)">
      <summary>
            Moves the body on the path.
            </summary>
      <param name="path">The path.</param>
      <param name="body">The body.</param>
      <param name="time">The time.</param>
      <param name="strength">The strength.</param>
      <param name="timeStep">The time step.</param>
    </member>
    <member name="M:FarseerPhysics.Factories.PathManager.AttachBodiesWithRevoluteJoint(FarseerPhysics.Dynamics.World,System.Collections.Generic.List{FarseerPhysics.Dynamics.Body},Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,System.Boolean,System.Boolean)">
      <summary>
            Attaches the bodies with revolute joints.
            </summary>
      <param name="world">The world.</param>
      <param name="bodies">The bodies.</param>
      <param name="localAnchorA">The local anchor A.</param>
      <param name="localAnchorB">The local anchor B.</param>
      <param name="connectFirstAndLast">if set to <c>true</c> [connect first and last].</param>
      <param name="collideConnected">if set to <c>true</c> [collide connected].</param>
    </member>
    <member name="M:FarseerPhysics.Factories.PathManager.AttachBodiesWithSliderJoint(FarseerPhysics.Dynamics.World,System.Collections.Generic.List{FarseerPhysics.Dynamics.Body},Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,System.Boolean,System.Boolean,System.Single,System.Single)">
      <summary>
            Attaches the bodies with revolute joints.
            </summary>
      <param name="world">The world.</param>
      <param name="bodies">The bodies.</param>
      <param name="localAnchorA">The local anchor A.</param>
      <param name="localAnchorB">The local anchor B.</param>
      <param name="connectFirstAndLast">if set to <c>true</c> [connect first and last].</param>
      <param name="collideConnected">if set to <c>true</c> [collide connected].</param>
      <param name="minLength">Minimum length of the slider joint.</param>
      <param name="maxLength">Maximum length of the slider joint.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Poly2Tri.Triangulation.Sets.ConstrainedPointSet.#ctor(System.Collections.Generic.List{Poly2Tri.Triangulation.TriangulationPoint},System.Collections.Generic.IEnumerable{Poly2Tri.Triangulation.TriangulationPoint})">
            
            @param points - A list of all points in PointSet
            @param constraints - Pairs of two points defining a constraint, all points <b>must</b> be part of given PointSet!
        </member>
    <member name="M:FarseerPhysics.Factories.LinkFactory.CreateChain(FarseerPhysics.Dynamics.World,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,System.Single,System.Single,System.Boolean,System.Boolean,System.Int32,System.Single)">
      <summary>
            Creates a chain.
            </summary>
      <param name="world">The world.</param>
      <param name="start">The start.</param>
      <param name="end">The end.</param>
      <param name="linkWidth">The width.</param>
      <param name="linkHeight">The height.</param>
      <param name="fixStart">if set to <c>true</c> [fix start].</param>
      <param name="fixEnd">if set to <c>true</c> [fix end].</param>
      <param name="numberOfLinks">The number of links.</param>
      <param name="linkDensity">The link density.</param>
      <returns>
      </returns>
    </member>
    <member name="F:FarseerPhysics.Dynamics.WorldFlags.NewFixture">
      <summary>
            Flag that indicates a new fixture has been added to the world.
            </summary>
    </member>
    <member name="F:FarseerPhysics.Dynamics.WorldFlags.ClearForces">
      <summary>
            Flag that clear the forces after each time step.
            </summary>
    </member>
    <member name="T:FarseerPhysics.Dynamics.World">
      <summary>
            The world class manages all physics entities, dynamic simulation,
            and asynchronous queries.
            </summary>
    </member>
    <member name="F:FarseerPhysics.Dynamics.World.BodyAdded">
      <summary>
            Fires whenever a body has been added
            </summary>
    </member>
    <member name="F:FarseerPhysics.Dynamics.World.BodyRemoved">
      <summary>
            Fires whenever a body has been removed
            </summary>
    </member>
    <member name="F:FarseerPhysics.Dynamics.World.FixtureAdded">
      <summary>
            Fires whenever a fixture has been added
            </summary>
    </member>
    <member name="F:FarseerPhysics.Dynamics.World.FixtureRemoved">
      <summary>
            Fires whenever a fixture has been removed
            </summary>
    </member>
    <member name="F:FarseerPhysics.Dynamics.World.JointAdded">
      <summary>
            Fires whenever a joint has been added
            </summary>
    </member>
    <member name="F:FarseerPhysics.Dynamics.World.JointRemoved">
      <summary>
            Fires whenever a joint has been removed
            </summary>
    </member>
    <member name="F:FarseerPhysics.Dynamics.World.Enabled">
      <summary>
            If false, the whole simulation stops. It still processes added and removed geometries.
            </summary>
    </member>
    <member name="F:FarseerPhysics.Dynamics.World.Gravity">
      <summary>
            Change the global gravity vector.
            </summary>
      <value>The gravity.</value>
    </member>
    <member name="M:FarseerPhysics.Dynamics.World.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:FarseerPhysics.Dynamics.World" /> class.
            </summary>
    </member>
    <member name="M:FarseerPhysics.Dynamics.World.#ctor(Microsoft.Xna.Framework.Vector2)">
      <summary>
            Initializes a new instance of the <see cref="T:FarseerPhysics.Dynamics.World" /> class.
            </summary>
      <param name="gravity">The gravity.</param>
    </member>
    <member name="M:FarseerPhysics.Dynamics.World.AddBody(FarseerPhysics.Dynamics.Body)">
      <summary>
            Add a rigid body.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:FarseerPhysics.Dynamics.World.RemoveBody(FarseerPhysics.Dynamics.Body)">
      <summary>
            Destroy a rigid body.
            Warning: This automatically deletes all associated shapes and joints.
            </summary>
      <param name="body">The body.</param>
    </member>
    <member name="M:FarseerPhysics.Dynamics.World.AddJoint(FarseerPhysics.Dynamics.Joints.Joint)">
      <summary>
            Create a joint to constrain bodies together. This may cause the connected bodies to cease colliding.
            </summary>
      <param name="joint">The joint.</param>
    </member>
    <member name="M:FarseerPhysics.Dynamics.World.RemoveJoint(FarseerPhysics.Dynamics.Joints.Joint)">
      <summary>
            Destroy a joint. This may cause the connected bodies to begin colliding.
            </summary>
      <param name="joint">The joint.</param>
    </member>
    <member name="M:FarseerPhysics.Dynamics.World.ProcessChanges">
      <summary>
            All adds and removes are cached by the World duing a World step.
            To process the changes before the world updates again, call this method.
            </summary>
    </member>
    <member name="M:FarseerPhysics.Dynamics.World.Step(System.Single)">
      <summary>
            Take a time step. This performs collision detection, integration,
            and consraint solution.
            </summary>
      <param name="dt">The amount of time to simulate, this should not vary.</param>
    </member>
    <member name="M:FarseerPhysics.Dynamics.World.ClearForces">
      <summary>
            Call this after you are done with time steps to clear the forces. You normally
            call this after each call to Step, unless you are performing sub-steps. By default,
            forces will be automatically cleared, so you don't need to call this function.
            </summary>
    </member>
    <member name="M:FarseerPhysics.Dynamics.World.QueryAABB(System.Func{FarseerPhysics.Dynamics.Fixture,System.Boolean},FarseerPhysics.Collision.AABB@)">
      <summary>
            Query the world for all fixtures that potentially overlap the
            provided AABB.
            
            Inside the callback:
            Return true: Continues the query
            Return false: Terminate the query
            </summary>
      <param name="callback">A user implemented callback class.</param>
      <param name="aabb">The aabb query box.</param>
    </member>
    <member name="M:FarseerPhysics.Dynamics.World.RayCast(FarseerPhysics.Dynamics.RayCastCallback,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2)">
      <summary>
            Ray-cast the world for all fixtures in the path of the ray. Your callback
            controls whether you get the closest point, any point, or n-points.
            The ray-cast ignores shapes that contain the starting point.
            
            Inside the callback:
            return -1: ignore this fixture and continue
            return 0: terminate the ray cast
            return fraction: clip the ray to this point
            return 1: don't clip the ray and continue
            </summary>
      <param name="callback">A user implemented callback class.</param>
      <param name="point1">The ray starting point.</param>
      <param name="point2">The ray ending point.</param>
    </member>
    <member name="M:FarseerPhysics.Dynamics.World.SolveTOI(FarseerPhysics.Dynamics.TimeStep@)">
      <summary>
            Find TOI contacts and solve them.
            </summary>
      <param name="step">The step.</param>
    </member>
    <member name="M:FarseerPhysics.Dynamics.World.TestPointAll(Microsoft.Xna.Framework.Vector2)">
      <summary>
            Returns a list of fixtures that are at the specified point.
            </summary>
      <param name="point">The point.</param>
      <returns>
      </returns>
    </member>
    <member name="P:FarseerPhysics.Dynamics.World.ProxyCount">
      <summary>
            Get the number of broad-phase proxies.
            </summary>
      <value>The proxy count.</value>
    </member>
    <member name="P:FarseerPhysics.Dynamics.World.AutoClearForces">
      <summary>
            Set flag to control automatic clearing of forces after each time step.
            </summary>
      <value>
        <c>true</c> if it should auto clear forces; otherwise, <c>false</c>.</value>
    </member>
    <member name="P:FarseerPhysics.Dynamics.World.ContactManager">
      <summary>
            Get the contact manager for testing.
            </summary>
      <value>The contact manager.</value>
    </member>
    <member name="P:FarseerPhysics.Dynamics.World.BodyList">
      <summary>
            Get the world body list.
            </summary>
      <value>Thehead of the world body list.</value>
    </member>
    <member name="P:FarseerPhysics.Dynamics.World.JointList">
      <summary>
            Get the world joint list. 
            </summary>
      <value>The joint list.</value>
    </member>
    <member name="P:FarseerPhysics.Dynamics.World.ContactList">
      <summary>
            Get the world contact list. With the returned contact, use Contact.GetNext to get
            the next contact in the world list. A null contact indicates the end of the list.
            </summary>
      <value>The head of the world contact list.</value>
    </member>
    <member name="P:FarseerPhysics.Dynamics.World.EnableSubStepping">
      <summary>
            Enable/disable single stepped continuous physics. For testing.
            </summary>
    </member>
    <member name="T:FarseerPhysics.Dynamics.Joints.JointEdge">
      <summary>
            A joint edge is used to connect bodies and joints together
            in a joint graph where each body is a node and each joint
            is an edge. A joint edge belongs to a doubly linked list
            maintained in each attached body. Each joint has two joint
            nodes, one for each attached body.
            </summary>
    </member>
    <member name="F:FarseerPhysics.Dynamics.Joints.JointEdge.Joint">
      <summary>
            The joint.
            </summary>
    </member>
    <member name="F:FarseerPhysics.Dynamics.Joints.JointEdge.Next">
      <summary>
            The next joint edge in the body's joint list.
            </summary>
    </member>
    <member name="F:FarseerPhysics.Dynamics.Joints.JointEdge.Other">
      <summary>
            Provides quick access to the other body attached.
            </summary>
    </member>
    <member name="F:FarseerPhysics.Dynamics.Joints.JointEdge.Prev">
      <summary>
            The previous joint edge in the body's joint list.
            </summary>
    </member>
    <member name="T:FarseerPhysics.Dynamics.Joints.GearJoint">
      <summary>
            A gear joint is used to connect two joints together. Either joint
            can be a revolute or prismatic joint. You specify a gear ratio
            to bind the motions together:
            coordinate1 + ratio * coordinate2 = ant
            The ratio can be negative or positive. If one joint is a revolute joint
            and the other joint is a prismatic joint, then the ratio will have units
            of length or units of 1/length.
            @warning The revolute and prismatic joints must be attached to
            fixed bodies (which must be body1 on those joints).
            </summary>
    </member>
    <member name="M:FarseerPhysics.Dynamics.Joints.GearJoint.#ctor(FarseerPhysics.Dynamics.Joints.Joint,FarseerPhysics.Dynamics.Joints.Joint,System.Single)">
      <summary>
            Requires two existing revolute or prismatic joints (any combination will work).
            The provided joints must attach a dynamic body to a static body.
            </summary>
      <param name="jointA">The first joint.</param>
      <param name="jointB">The second joint.</param>
      <param name="ratio">The ratio.</param>
    </member>
    <member name="P:FarseerPhysics.Dynamics.Joints.GearJoint.Ratio">
      <summary>
            The gear ratio.
            </summary>
    </member>
    <member name="P:FarseerPhysics.Dynamics.Joints.GearJoint.JointA">
      <summary>
            The first revolute/prismatic joint attached to the gear joint.
            </summary>
    </member>
    <member name="P:FarseerPhysics.Dynamics.Joints.GearJoint.JointB">
      <summary>
            The second revolute/prismatic joint attached to the gear joint.
            </summary>
    </member>
    <member name="T:FarseerPhysics.Dynamics.Joints.FixedMouseJoint">
      <summary>
            A mouse joint is used to make a point on a body track a
            specified world point. This a soft constraint with a maximum
            force. This allows the constraint to stretch and without
            applying huge forces.
            NOTE: this joint is not documented in the manual because it was
            developed to be used in the testbed. If you want to learn how to
            use the mouse joint, look at the testbed.
            </summary>
    </member>
    <member name="M:FarseerPhysics.Dynamics.Joints.FixedMouseJoint.#ctor(FarseerPhysics.Dynamics.Body,Microsoft.Xna.Framework.Vector2)">
      <summary>
            This requires a world target point,
            tuning parameters, and the time step.
            </summary>
      <param name="body">The body.</param>
      <param name="worldAnchor">The target.</param>
    </member>
    <member name="P:FarseerPhysics.Dynamics.Joints.FixedMouseJoint.MaxForce">
      <summary>
            The maximum constraint force that can be exerted
            to move the candidate body. Usually you will express
            as some multiple of the weight (multiplier * mass * gravity).
            </summary>
    </member>
    <member name="P:FarseerPhysics.Dynamics.Joints.FixedMouseJoint.Frequency">
      <summary>
            The response speed.
            </summary>
    </member>
    <member name="P:FarseerPhysics.Dynamics.Joints.FixedMouseJoint.DampingRatio">
      <summary>
            The damping ratio. 0 = no damping, 1 = critical damping.
            </summary>
    </member>
    <member name="T:FarseerPhysics.Dynamics.Joints.AngleJoint">
      <summary>
            Maintains a fixed angle between two bodies
            </summary>
    </member>
    <member name="T:FarseerPhysics.Dynamics.BreakableBody">
      <summary>
            A type of body that supports multiple fixtures that can break apart.
            </summary>
    </member>
    <member name="F:FarseerPhysics.Dynamics.BreakableBody.Strength">
      <summary>
            The force needed to break the body apart.
            Default: 500
            </summary>
    </member>
    <member name="M:Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.Triangulate(Poly2Tri.Triangulation.Delaunay.Sweep.DTSweepContext)">
      <summary>
            Triangulate simple polygon with holes
            </summary>
    </member>
    <member name="M:Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.Sweep(Poly2Tri.Triangulation.Delaunay.Sweep.DTSweepContext)">
      <summary>
            Start sweeping the Y-sorted point set from bottom to top
            </summary>
    </member>
    <member name="M:Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.FinalizationConvexHull(Poly2Tri.Triangulation.Delaunay.Sweep.DTSweepContext)">
      <summary>
            If this is a Delaunay Triangulation of a pointset we need to fill so the triangle mesh gets a ConvexHull 
            </summary>
    </member>
    <member name="M:Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.TurnAdvancingFrontConvex(Poly2Tri.Triangulation.Delaunay.Sweep.DTSweepContext,Poly2Tri.Triangulation.Delaunay.Sweep.AdvancingFrontNode,Poly2Tri.Triangulation.Delaunay.Sweep.AdvancingFrontNode)">
      <summary>
            We will traverse the entire advancing front and fill it to form a convex hull.
            </summary>
    </member>
    <member name="M:Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.PointEvent(Poly2Tri.Triangulation.Delaunay.Sweep.DTSweepContext,Poly2Tri.Triangulation.TriangulationPoint)">
      <summary>
            Find closes node to the left of the new point and
            create a new triangle. If needed new holes and basins
            will be filled to.
            </summary>
    </member>
    <member name="M:Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.NewFrontTriangle(Poly2Tri.Triangulation.Delaunay.Sweep.DTSweepContext,Poly2Tri.Triangulation.TriangulationPoint,Poly2Tri.Triangulation.Delaunay.Sweep.AdvancingFrontNode)">
      <summary>
            Creates a new front triangle and legalize it
            </summary>
    </member>
    <member name="M:Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.NextFlipPoint(Poly2Tri.Triangulation.TriangulationPoint,Poly2Tri.Triangulation.TriangulationPoint,Poly2Tri.Triangulation.Delaunay.DelaunayTriangle,Poly2Tri.Triangulation.TriangulationPoint)">
      <summary>
            When we need to traverse from one triangle to the next we need 
            the point in current triangle that is the opposite point to the next
            triangle. 
            </summary>
    </member>
    <member name="M:Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.NextFlipTriangle(Poly2Tri.Triangulation.Delaunay.Sweep.DTSweepContext,FarseerPhysics.Common.Decomposition.CDT.Orientation,Poly2Tri.Triangulation.Delaunay.DelaunayTriangle,Poly2Tri.Triangulation.Delaunay.DelaunayTriangle,Poly2Tri.Triangulation.TriangulationPoint,Poly2Tri.Triangulation.TriangulationPoint)">
      <summary>
            After a flip we have two triangles and know that only one will still be
            intersecting the edge. So decide which to contiune with and legalize the other
            </summary>
      <param name="tcx">
      </param>
      <param name="o">should be the result of an TriangulationUtil.orient2d( eq, op, ep )</param>
      <param name="t">triangle 1</param>
      <param name="ot">triangle 2</param>
      <param name="p">a point shared by both triangles</param>
      <param name="op">another point shared by both triangles</param>
      <returns>returns the triangle still intersecting the edge</returns>
    </member>
    <member name="M:Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.FillAdvancingFront(Poly2Tri.Triangulation.Delaunay.Sweep.DTSweepContext,Poly2Tri.Triangulation.Delaunay.Sweep.AdvancingFrontNode)">
      <summary>
            Fills holes in the Advancing Front
            </summary>
    </member>
    <member name="M:Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.FillBasinReq(Poly2Tri.Triangulation.Delaunay.Sweep.DTSweepContext,Poly2Tri.Triangulation.Delaunay.Sweep.AdvancingFrontNode)">
      <summary>
            Recursive algorithm to fill a Basin with triangles
            </summary>
    </member>
    <member name="M:Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.HoleAngle(Poly2Tri.Triangulation.Delaunay.Sweep.AdvancingFrontNode)">
      <summary>
            ???
            </summary>
      <param name="node">middle node</param>
      <returns>the angle between 3 front nodes</returns>
    </member>
    <member name="M:Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.BasinAngle(Poly2Tri.Triangulation.Delaunay.Sweep.AdvancingFrontNode)">
      <summary>
            The basin angle is decided against the horizontal line [1,0]
            </summary>
    </member>
    <member name="M:Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.Fill(Poly2Tri.Triangulation.Delaunay.Sweep.DTSweepContext,Poly2Tri.Triangulation.Delaunay.Sweep.AdvancingFrontNode)">
      <summary>
            Adds a triangle to the advancing front to fill a hole.
            </summary>
      <param name="tcx">
      </param>
      <param name="node">middle node, that is the bottom of the hole</param>
    </member>
    <member name="M:Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.Legalize(Poly2Tri.Triangulation.Delaunay.Sweep.DTSweepContext,Poly2Tri.Triangulation.Delaunay.DelaunayTriangle)">
      <summary>
            Returns true if triangle was legalized
            </summary>
    </member>
    <member name="M:Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.RotateTrianglePair(Poly2Tri.Triangulation.Delaunay.DelaunayTriangle,Poly2Tri.Triangulation.TriangulationPoint,Poly2Tri.Triangulation.Delaunay.DelaunayTriangle,Poly2Tri.Triangulation.TriangulationPoint)">
      <summary>
            Rotates a triangle pair one vertex CW
                  n2                    n2
             P +-----+             P +-----+
               | t  /|               |\  t |  
               |   / |               | \   |
             n1|  /  |n3           n1|  \  |n3
               | /   |    after CW   |   \ |
               |/ oT |               | oT \|
               +-----+ oP            +-----+
                  n4                    n4
            </summary>
    </member>
    <member name="T:FarseerPhysics.Collision.Shapes.EdgeShape">
      <summary>
            A line segment (edge) Shape. These can be connected in chains or loops
            to other edge Shapes. The connectivity information is used to ensure
            correct contact normals.
            </summary>
    </member>
    <member name="F:FarseerPhysics.Collision.Shapes.EdgeShape.Vertex0">
      <summary>
            Optional adjacent vertices. These are used for smooth collision.
            </summary>
    </member>
    <member name="F:FarseerPhysics.Collision.Shapes.EdgeShape.Vertex3">
      <summary>
            Optional adjacent vertices. These are used for smooth collision.
            </summary>
    </member>
    <member name="F:FarseerPhysics.Collision.Shapes.EdgeShape._vertex1">
      <summary>
            Edge start vertex
            </summary>
    </member>
    <member name="F:FarseerPhysics.Collision.Shapes.EdgeShape._vertex2">
      <summary>
            Edge end vertex
            </summary>
    </member>
    <member name="M:FarseerPhysics.Collision.Shapes.EdgeShape.Set(Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2)">
      <summary>
            Set this as an isolated edge.
            </summary>
      <param name="start">The start.</param>
      <param name="end">The end.</param>
    </member>
    <member name="M:FarseerPhysics.Collision.Shapes.EdgeShape.TestPoint(FarseerPhysics.Common.Transform@,Microsoft.Xna.Framework.Vector2@)">
      <summary>
            Test a point for containment in this shape. This only works for convex shapes.
            </summary>
      <param name="transform">The shape world transform.</param>
      <param name="point">a point in world coordinates.</param>
      <returns>True if the point is inside the shape</returns>
    </member>
    <member name="M:FarseerPhysics.Collision.Shapes.EdgeShape.RayCast(FarseerPhysics.Collision.RayCastOutput@,FarseerPhysics.Collision.RayCastInput@,FarseerPhysics.Common.Transform@,System.Int32)">
      <summary>
            Cast a ray against a child shape.
            </summary>
      <param name="output">The ray-cast results.</param>
      <param name="input">The ray-cast input parameters.</param>
      <param name="transform">The transform to be applied to the shape.</param>
      <param name="childIndex">The child shape index.</param>
      <returns>True if the ray-cast hits the shape</returns>
    </member>
    <member name="M:FarseerPhysics.Collision.Shapes.EdgeShape.ComputeAABB(FarseerPhysics.Collision.AABB@,FarseerPhysics.Common.Transform@,System.Int32)">
      <summary>
            Given a transform, compute the associated axis aligned bounding box for a child shape.
            </summary>
      <param name="aabb">The aabb results.</param>
      <param name="transform">The world transform of the shape.</param>
      <param name="childIndex">The child shape index.</param>
    </member>
    <member name="M:FarseerPhysics.Collision.Shapes.EdgeShape.ComputeProperties">
      <summary>
            Compute the mass properties of this shape using its dimensions and density.
            The inertia tensor is computed about the local origin, not the centroid.
            </summary>
    </member>
    <member name="P:FarseerPhysics.Collision.Shapes.EdgeShape.Vertex1">
      <summary>
            These are the edge vertices
            </summary>
    </member>
    <member name="P:FarseerPhysics.Collision.Shapes.EdgeShape.Vertex2">
      <summary>
            These are the edge vertices
            </summary>
    </member>
    <member name="T:FarseerPhysics.Collision.DynamicTreeNode`1">
      <summary>
            A node in the dynamic tree. The client does not interact with this directly.
            </summary>
    </member>
    <member name="F:FarseerPhysics.Collision.DynamicTreeNode`1.AABB">
      <summary>
            This is the fattened AABB.
            </summary>
    </member>
    <member name="T:FarseerPhysics.Collision.DynamicTree`1">
      <summary>
             A dynamic tree arranges data in a binary tree to accelerate
             queries such as volume queries and ray casts. Leafs are proxies
             with an AABB. In the tree we expand the proxy AABB by Settings.b2_fatAABBFactor
             so that the proxy AABB is bigger than the client object. This allows the client
             object to move by small amounts without triggering a tree update.
            
             Nodes are pooled and relocatable, so we use node indices rather than pointers.
             </summary>
    </member>
    <member name="F:FarseerPhysics.Collision.DynamicTree`1._path">
      <summary>
            This is used incrementally traverse the tree for re-balancing.
            </summary>
    </member>
    <member name="M:FarseerPhysics.Collision.DynamicTree`1.#ctor">
      <summary>
            Constructing the tree initializes the node pool.
            </summary>
    </member>
    <member name="M:FarseerPhysics.Collision.DynamicTree`1.AddProxy(FarseerPhysics.Collision.AABB@,`0)">
      <summary>
            Create a proxy in the tree as a leaf node. We return the index
            of the node instead of a pointer so that we can grow
            the node pool.        
            /// </summary>
      <param name="aabb">The aabb.</param>
      <param name="userData">The user data.</param>
      <returns>Index of the created proxy</returns>
    </member>
    <member name="M:FarseerPhysics.Collision.DynamicTree`1.RemoveProxy(System.Int32)">
      <summary>
            Destroy a proxy. This asserts if the id is invalid.
            </summary>
      <param name="proxyId">The proxy id.</param>
    </member>
    <member name="M:FarseerPhysics.Collision.DynamicTree`1.MoveProxy(System.Int32,FarseerPhysics.Collision.AABB@,Microsoft.Xna.Framework.Vector2)">
      <summary>
            Move a proxy with a swepted AABB. If the proxy has moved outside of its fattened AABB,
            then the proxy is removed from the tree and re-inserted. Otherwise
            the function returns immediately.
            </summary>
      <param name="proxyId">The proxy id.</param>
      <param name="aabb">The aabb.</param>
      <param name="displacement">The displacement.</param>
      <returns>true if the proxy was re-inserted.</returns>
    </member>
    <member name="M:FarseerPhysics.Collision.DynamicTree`1.Rebalance(System.Int32)">
      <summary>
            Perform some iterations to re-balance the tree.
            </summary>
      <param name="iterations">The iterations.</param>
    </member>
    <member name="M:FarseerPhysics.Collision.DynamicTree`1.GetUserData(System.Int32)">
      <summary>
            Get proxy user data.
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="proxyId">The proxy id.</param>
      <returns>the proxy user data or 0 if the id is invalid.</returns>
    </member>
    <member name="M:FarseerPhysics.Collision.DynamicTree`1.GetFatAABB(System.Int32,FarseerPhysics.Collision.AABB@)">
      <summary>
            Get the fat AABB for a proxy.
            </summary>
      <param name="proxyId">The proxy id.</param>
      <param name="fatAABB">The fat AABB.</param>
    </member>
    <member name="M:FarseerPhysics.Collision.DynamicTree`1.ComputeHeight">
      <summary>
            Compute the height of the binary tree in O(N) time. Should not be
            called often.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:FarseerPhysics.Collision.DynamicTree`1.Query(System.Func{System.Int32,System.Boolean},FarseerPhysics.Collision.AABB@)">
      <summary>
            Query an AABB for overlapping proxies. The callback class
            is called for each proxy that overlaps the supplied AABB.
            </summary>
      <param name="callback">The callback.</param>
      <param name="aabb">The aabb.</param>
    </member>
    <member name="M:FarseerPhysics.Collision.DynamicTree`1.RayCast(System.Func{FarseerPhysics.Collision.RayCastInput,System.Int32,System.Single},FarseerPhysics.Collision.RayCastInput@)">
      <summary>
            Ray-cast against the proxies in the tree. This relies on the callback
            to perform a exact ray-cast in the case were the proxy contains a Shape.
            The callback also performs the any collision filtering. This has performance
            roughly equal to k * log(n), where k is the number of collisions and n is the
            number of proxies in the tree.
            </summary>
      <param name="callback">A callback class that is called for each proxy that is hit by the ray.</param>
      <param name="input">The ray-cast input data. The ray extends from p1 to p1 + maxFraction * (p2 - p1).</param>
    </member>
    <member name="T:TomShane.Neoforce.Controls.Control">
      <summary>
            Defines the base class for all controls.
            </summary>
    </member>
    <member name="P:TomShane.Neoforce.Controls.Control.Cursor">
      <summary>
            Gets or sets the cursor displaying over the control.
            </summary>
    </member>
    <member name="P:TomShane.Neoforce.Controls.Control.Controls">
      <summary>
            Gets a list of all child controls.
            </summary>
    </member>
    <member name="P:TomShane.Neoforce.Controls.Control.MovableArea">
      <summary>
            Gets or sets a rectangular area that reacts on moving the control with the mouse.
            </summary>
    </member>
    <member name="P:TomShane.Neoforce.Controls.Control.IsChild">
      <summary>
            Gets a value indicating whether this control is a child control.
            </summary>
    </member>
    <member name="P:TomShane.Neoforce.Controls.Control.IsParent">
      <summary>
            Gets a value indicating whether this control is a parent control.
            </summary>
    </member>
    <member name="P:TomShane.Neoforce.Controls.Control.IsRoot">
      <summary>
            Gets a value indicating whether this control is a root control.
            </summary>
    </member>
    <member name="P:TomShane.Neoforce.Controls.Control.CanFocus">
      <summary>
            Gets or sets a value indicating whether this control can receive focus. 
            </summary>
    </member>
    <member name="P:TomShane.Neoforce.Controls.Control.Detached">
      <summary>
            Gets or sets a value indicating whether this control is rendered off the parents texture.
            </summary>
    </member>
    <member name="P:TomShane.Neoforce.Controls.Control.Passive">
      <summary>
            Gets or sets a value indicating whether this controls can receive user input events.
            </summary>
    </member>
    <member name="P:TomShane.Neoforce.Controls.Control.Movable">
      <summary>
            Gets or sets a value indicating whether this control can be moved by the mouse.
            </summary>
    </member>
    <member name="P:TomShane.Neoforce.Controls.Control.Resizable">
      <summary>
            Gets or sets a value indicating whether this control can be resized by the mouse.
            </summary>
    </member>
    <member name="P:TomShane.Neoforce.Controls.Control.ResizerSize">
      <summary>
            Gets or sets the size of the rectangular borders around the control used for resizing by the mouse.
            </summary>
    </member>
    <member name="P:TomShane.Neoforce.Controls.Control.ContextMenu">
      <summary>
            Gets or sets the ContextMenu associated with this control.
            </summary>
    </member>
    <member name="P:TomShane.Neoforce.Controls.Control.DoubleClicks">
      <summary>
            Gets or sets a value indicating whether this control should process mouse double-clicks.
            </summary>
    </member>
    <member name="P:TomShane.Neoforce.Controls.Control.OutlineResizing">
      <summary>
            Gets or sets a value indicating whether this control should use ouline resizing.
            </summary>
    </member>
    <member name="P:TomShane.Neoforce.Controls.Control.OutlineMoving">
      <summary>
            Gets or sets a value indicating whether this control should use outline moving.
            </summary>
    </member>
    <member name="P:TomShane.Neoforce.Controls.Control.Tag">
      <summary>
            Gets or sets the object that contains data about the control.
            </summary>
    </member>
    <member name="P:TomShane.Neoforce.Controls.Control.Margins">
      <summary>
            Gets or sets the value indicating the distance from another control. Usable with StackPanel control.
            </summary>
    </member>
    <member name="P:TomShane.Neoforce.Controls.Control.DesignMode">
      <summary>
            Gets or sets the value indicating wheter control is in design mode.
            </summary>
    </member>
    <member name="P:TomShane.Neoforce.Controls.Control.GamePadActions">
      <summary>
            Gets or sets gamepad actions for the control.
            </summary>
    </member>
    <member name="P:TomShane.Neoforce.Controls.Control.PartialOutline">
      <summary>
            Gets or sets the value indicating whether the control outline is displayed only for certain edges. 
            </summary>
    </member>
    <member name="P:TomShane.Neoforce.Controls.Control.StayOnBack">
      <summary>
            Gets or sets the value indicating whether the control is allowed to be brought in the front.
            </summary>
    </member>
    <member name="P:TomShane.Neoforce.Controls.Control.StayOnTop">
      <summary>
            Gets or sets the value indicating that the control should stay on top of other controls.
            </summary>
    </member>
    <member name="P:TomShane.Neoforce.Controls.Control.Name">
      <summary>
            Gets or sets a name of the control.
            </summary>
    </member>
    <member name="P:TomShane.Neoforce.Controls.Control.Focused">
      <summary>
            Gets or sets a value indicating whether this control has input focus.
            </summary>
    </member>
    <member name="P:TomShane.Neoforce.Controls.Control.ControlState">
      <summary>
            Gets a value indicating current state of the control.
            </summary>
    </member>
    <member name="P:TomShane.Neoforce.Controls.Control.DrawingRect">
      <summary>
            Gets an area where is the control supposed to be drawn.
            </summary>
    </member>
    <member name="P:TomShane.Neoforce.Controls.Control.Suspended">
      <summary>
            Gets or sets a value indicating whether this control should receive any events.
            </summary>
    </member>
    <member name="P:TomShane.Neoforce.Controls.Control.IsMoving">
      <summary>
            Gets or sets a value indicating whether this controls is currently being moved.
            </summary>
    </member>
    <member name="P:TomShane.Neoforce.Controls.Control.IsResizing">
      <summary>
            Gets or sets a value indicating whether this controls is currently being resized.
            </summary>
    </member>
    <member name="P:TomShane.Neoforce.Controls.Control.Anchor">
      <summary>
            Gets or sets the edges of the container to which a control is bound and determines how a control is resized with its parent.
            </summary>
    </member>
    <member name="P:TomShane.Neoforce.Controls.Control.ResizeEdge">
      <summary>
            Gets or sets the edges of the contol which are allowed for resizing.
            </summary>
    </member>
    <member name="P:TomShane.Neoforce.Controls.Control.Skin">
      <summary>
            Gets or sets the skin used for rendering the control.
            </summary>
    </member>
    <member name="P:TomShane.Neoforce.Controls.Control.Text">
      <summary>
            Gets or sets the text associated with this control.
            </summary>
    </member>
    <member name="P:TomShane.Neoforce.Controls.Control.Alpha">
      <summary>
            Gets or sets the alpha value for this control.
            </summary>
    </member>
    <member name="P:TomShane.Neoforce.Controls.Control.BackColor">
      <summary>
            Gets or sets the background color for the control.
            </summary>
    </member>
    <member name="P:TomShane.Neoforce.Controls.Control.Color">
      <summary>
            Gets or sets the color for the control.
            </summary>
    </member>
    <member name="P:TomShane.Neoforce.Controls.Control.TextColor">
      <summary>
            Gets or sets the text color for the control.
            </summary>
    </member>
    <member name="P:TomShane.Neoforce.Controls.Control.Enabled">
      <summary>
            Gets or sets a value indicating whether the control can respond to user interaction.
            </summary>
    </member>
    <member name="P:TomShane.Neoforce.Controls.Control.Visible">
      <summary>
            Gets or sets a value that indicates whether the control is rendered.
            </summary>
    </member>
    <member name="P:TomShane.Neoforce.Controls.Control.Parent">
      <summary>
            Gets or sets the parent for the control.
            </summary>
    </member>
    <member name="P:TomShane.Neoforce.Controls.Control.Root">
      <summary>
            Gets or sets the root for the control.
            </summary>
    </member>
    <member name="P:TomShane.Neoforce.Controls.Control.Left">
      <summary>
            Gets or sets the distance, in pixels, between the left edge of the control and the left edge of its parent.
            </summary>
    </member>
    <member name="P:TomShane.Neoforce.Controls.Control.Top">
      <summary>
            Gets or sets the distance, in pixels, between the top edge of the control and the top edge of its parent.
            </summary>
    </member>
    <member name="P:TomShane.Neoforce.Controls.Control.Width">
      <summary>
            Gets or sets the width of the control.
            </summary>
    </member>
    <member name="P:TomShane.Neoforce.Controls.Control.Height">
      <summary>
            Gets or sets the height of the control.
            </summary>
    </member>
    <member name="P:TomShane.Neoforce.Controls.Control.MinimumWidth">
      <summary>
            Gets or sets the minimum width in pixels the control can be sized to.
            </summary>
    </member>
    <member name="P:TomShane.Neoforce.Controls.Control.MinimumHeight">
      <summary>
            /// Gets or sets the minimum height in pixels the control can be sized to.
            </summary>
    </member>
    <member name="P:TomShane.Neoforce.Controls.Control.MaximumWidth">
      <summary>
            /// Gets or sets the maximum width in pixels the control can be sized to.
            </summary>
    </member>
    <member name="P:TomShane.Neoforce.Controls.Control.MaximumHeight">
      <summary>
            Gets or sets the maximum height in pixels the control can be sized to.
            </summary>
    </member>
    <member name="T:TomShane.Neoforce.Controls.ListBox">
      <summary>
      Represents a control to display a list of items.
    </summary>
    </member>
    <member name="T:TomShane.Neoforce.Controls.Window">
      <summary>
      Represents a window or dialog box that makes up an application's user interface.
    </summary>
    </member>
    <member name="T:TomShane.Neoforce.Controls.ButtonBase">
      <summary>
      Implements the basic functionality common to button controls.
    </summary>
    </member>
    <member name="T:TomShane.Neoforce.Controls.GamePadActions">
      <summary>
            Defines the gamepad actions mapping.
            </summary>
    </member>
    <member name="T:TomShane.Neoforce.Controls.ControlsList">
      <summary>
            Defines type used as a controls collection.
            </summary>
    </member>
    <member name="T:TomShane.Neoforce.Controls.Button">
      <summary>
      Represents a button control.
    </summary>
    </member>
    <member name="T:TomShane.Neoforce.Controls.SizeMode">
      <summary>
      Specifies how an image is positioned within a control.
    </summary>
    </member>
    <member name="T:TomShane.Neoforce.Controls.ButtonMode">
      <summary>
      Specifies how an image is positioned within a control.
    </summary>
    </member>
    <member name="T:TomShane.Neoforce.Controls.Glyph">
      <summary>
      Represents an image on a button.
    </summary>
    </member>
    <member name="T:TomShane.Neoforce.Controls.Manager">
      <summary>
            Manages rendering of all controls.
            </summary>
    </member>
    <member name="M:TomShane.Neoforce.Controls.Manager.#ctor(Microsoft.Xna.Framework.Game,Microsoft.Xna.Framework.GraphicsDeviceManager,System.String,System.Windows.Forms.Form)">
      <summary>
            Initializes a new instance of the Manager class.
            </summary>
      <param name="game">The Game class.</param>
      <param name="graphics">The GraphicsDeviceManager class provided by the Game class.</param>
      <param name="skin">The name of the skin being loaded at the start.</param>
      <param name="window">The window -- in xbox set to null.</param>
    </member>
    <member name="M:TomShane.Neoforce.Controls.Manager.#ctor(Microsoft.Xna.Framework.Game,System.String,System.Windows.Forms.Form)">
      <summary>
            Initializes a new instance of the Manager class.
            </summary>
      <param name="game">The Game class.</param>
      <param name="skin">The name of the skin being loaded at the start.</param>
      <param name="window">The window.</param>
    </member>
    <member name="M:TomShane.Neoforce.Controls.Manager.#ctor(Microsoft.Xna.Framework.Game,Microsoft.Xna.Framework.GraphicsDeviceManager,System.Windows.Forms.Form)">
      <summary>
            Initializes a new instance of the Manager class, loads the default skin and registers manager in the game class automatically.
            </summary>
      <param name="game">The Game class.</param>
      <param name="graphics">The GraphicsDeviceManager class provided by the Game class.</param>
      <param name="window">The window.</param>
    </member>
    <member name="M:TomShane.Neoforce.Controls.Manager.#ctor(Microsoft.Xna.Framework.Game,System.Windows.Forms.Form)">
      <summary>
            Initializes a new instance of the Manager class, loads the default skin and registers manager in the game class automatically.
            </summary>
      <param name="game">
            The Game class.
            </param>
    </member>
    <member name="M:TomShane.Neoforce.Controls.Manager.PrepareGraphicsDevice(System.Object,Microsoft.Xna.Framework.PreparingDeviceSettingsEventArgs)">
      <summary>
            Method used as an event handler for the GraphicsDeviceManager.PreparingDeviceSettings event.
            </summary>
    </member>
    <member name="M:TomShane.Neoforce.Controls.Manager.Initialize">
      <summary>
            Initializes the controls manager.
            </summary>
    </member>
    <member name="M:TomShane.Neoforce.Controls.Manager.SetSkin(System.String)">
      <summary>
            Sets and loads the new skin.
            </summary>
      <param name="name">
            The name of the skin being loaded.
            </param>
    </member>
    <member name="M:TomShane.Neoforce.Controls.Manager.SetSkin(TomShane.Neoforce.Controls.Skin)">
      <summary>
            Sets the new skin.
            </summary>
      <param name="skin">
            The skin being set.
            </param>
    </member>
    <member name="M:TomShane.Neoforce.Controls.Manager.BringToFront(TomShane.Neoforce.Controls.Control)">
      <summary>
            Brings the control to the front of the z-order.
            </summary>
      <param name="control">
            The control being brought to the front.
            </param>
    </member>
    <member name="M:TomShane.Neoforce.Controls.Manager.SendToBack(TomShane.Neoforce.Controls.Control)">
      <summary>
            Sends the control to the back of the z-order.
            </summary>
      <param name="control">
            The control being sent back.
            </param>
    </member>
    <member name="M:TomShane.Neoforce.Controls.Manager.Update(Microsoft.Xna.Framework.GameTime)">
      <summary>
            Called when the manager needs to be updated.
            </summary>
      <param name="gameTime">
            Time elapsed since the last call to Update.
            </param>
    </member>
    <member name="M:TomShane.Neoforce.Controls.Manager.Add(TomShane.Neoforce.Controls.Component)">
      <summary>
            Adds a component or a control to the manager.
            </summary>
      <param name="component">
            The component or control being added.
            </param>
    </member>
    <member name="M:TomShane.Neoforce.Controls.Manager.Remove(TomShane.Neoforce.Controls.Component)">
      <summary>
            Removes a component or a control from the manager.
            </summary>
      <param name="component">
            The component or control being removed.
            </param>
    </member>
    <member name="M:TomShane.Neoforce.Controls.Manager.BeginDraw(Microsoft.Xna.Framework.GameTime)">
      <summary>
            Renders all controls added to the manager.
            </summary>
      <param name="gameTime">
            Time passed since the last call to Draw.
            </param>
    </member>
    <member name="M:TomShane.Neoforce.Controls.Manager.EndDraw">
      <summary>
            Draws texture resolved from RenderTarget used for rendering.
            </summary>
    </member>
    <member name="M:TomShane.Neoforce.Controls.Manager.EndDraw(Microsoft.Xna.Framework.Rectangle)">
      <summary>
            Draws texture resolved from RenderTarget to specified rectangle.
            </summary>
    </member>
    <member name="P:TomShane.Neoforce.Controls.Manager.Disposing">
      <summary>
            Gets a value indicating whether Manager is in the process of disposing.
            </summary>
    </member>
    <member name="P:TomShane.Neoforce.Controls.Manager.Window">
      <summary>
            Returns the <see cref="T:System.Windows.Forms.Form" /> the game runs in.
            </summary>
    </member>
    <member name="P:TomShane.Neoforce.Controls.Manager.Cursor">
      <summary>
            Gets or sets an application cursor.
            </summary>
    </member>
    <member name="P:TomShane.Neoforce.Controls.Manager.Game">
      <summary>
            Returns associated <see cref="P:TomShane.Neoforce.Controls.Manager.Game" /> component.
            </summary>
    </member>
    <member name="P:TomShane.Neoforce.Controls.Manager.GraphicsDevice">
      <summary>
            Returns associated <see cref="P:TomShane.Neoforce.Controls.Manager.GraphicsDevice" />.
            </summary>
    </member>
    <member name="P:TomShane.Neoforce.Controls.Manager.Graphics">
      <summary>
            Returns associated <see cref="T:Microsoft.Xna.Framework.GraphicsDeviceManager" />.
            </summary>
    </member>
    <member name="P:TomShane.Neoforce.Controls.Manager.Renderer">
      <summary>
            Returns <see cref="P:TomShane.Neoforce.Controls.Manager.Renderer" /> used for rendering controls.
            </summary>
    </member>
    <member name="P:TomShane.Neoforce.Controls.Manager.Content">
      <summary>
            Returns <see cref="!:ArchiveManager" /> used for loading assets.
            </summary>
    </member>
    <member name="P:TomShane.Neoforce.Controls.Manager.Input">
      <summary>
            Returns <see cref="T:TomShane.Neoforce.Controls.InputSystem" /> instance responsible for managing user input.
            </summary>
    </member>
    <member name="P:TomShane.Neoforce.Controls.Manager.Components">
      <summary>
            Returns list of components added to the manager.
            </summary>
    </member>
    <member name="P:TomShane.Neoforce.Controls.Manager.Controls">
      <summary>
            Returns list of controls added to the manager.
            </summary>
    </member>
    <member name="P:TomShane.Neoforce.Controls.Manager.GlobalDepth">
      <summary>
            Gets or sets the depth value used for rendering sprites.
            </summary>
    </member>
    <member name="P:TomShane.Neoforce.Controls.Manager.ToolTipDelay">
      <summary>
            Gets or sets the time that passes before the <see cref="T:TomShane.Neoforce.Controls.ToolTip" /> appears.
            </summary>
    </member>
    <member name="P:TomShane.Neoforce.Controls.Manager.MenuDelay">
      <summary>
            Gets or sets the time that passes before a submenu appears when hovered over menu item.
            </summary>
    </member>
    <member name="P:TomShane.Neoforce.Controls.Manager.DoubleClickTime">
      <summary>
            Gets or sets the maximum number of milliseconds that can elapse between a first click and a second click to consider the mouse action a double-click.
            </summary>
    </member>
    <member name="P:TomShane.Neoforce.Controls.Manager.TextureResizeIncrement">
      <summary>
            Gets or sets texture size increment in pixel while performing controls resizing.
            </summary>
    </member>
    <member name="P:TomShane.Neoforce.Controls.Manager.ToolTipsEnabled">
      <summary>
            Enables or disables showing of tooltips globally.
            </summary>
    </member>
    <member name="P:TomShane.Neoforce.Controls.Manager.LogUnhandledExceptions">
      <summary>
            Enables or disables logging of unhandled exceptions. 
            </summary>
    </member>
    <member name="P:TomShane.Neoforce.Controls.Manager.InputEnabled">
      <summary>
            Enables or disables input processing.                   
            </summary>
    </member>
    <member name="P:TomShane.Neoforce.Controls.Manager.RenderTarget">
      <summary>
            Gets or sets render target for drawing.                 
            </summary>
    </member>
    <member name="P:TomShane.Neoforce.Controls.Manager.TargetFrames">
      <summary>
            Gets or sets update interval for drawing, logic and input.                           
            </summary>
    </member>
    <member name="P:TomShane.Neoforce.Controls.Manager.KeyboardLayouts">
      <summary>
            Gets or sets collection of active keyboard layouts.     
            </summary>
    </member>
    <member name="P:TomShane.Neoforce.Controls.Manager.UseGuide">
      <summary>
            Gets or sets a value indicating if Guide component can be used
            </summary>
    </member>
    <member name="P:TomShane.Neoforce.Controls.Manager.AutoUnfocus">
      <summary>
            Gets or sets a value indicating if a control should unfocus if you click outside on the screen.
            </summary>
    </member>
    <member name="P:TomShane.Neoforce.Controls.Manager.AutoCreateRenderTarget">
      <summary>
            Gets or sets a value indicating wheter Manager should create render target automatically.
            </summary>
    </member>
    <member name="P:TomShane.Neoforce.Controls.Manager.KeyboardLayout">
      <summary>
            Gets or sets current keyboard layout for text input.    
            </summary>
    </member>
    <member name="P:TomShane.Neoforce.Controls.Manager.SkinDirectory">
      <summary>
            Gets or sets the initial directory for looking for the skins in.
            </summary>
    </member>
    <member name="P:TomShane.Neoforce.Controls.Manager.LayoutDirectory">
      <summary>
            Gets or sets the initial directory for looking for the layout files in.
            </summary>
    </member>
    <member name="P:TomShane.Neoforce.Controls.Manager.SkinExtension">
      <summary>
            Gets or sets file extension for archived skin files.
            </summary>
    </member>
    <member name="P:TomShane.Neoforce.Controls.Manager.TargetWidth">
      <summary>
            Gets width of the selected render target in pixels.
            </summary>
    </member>
    <member name="P:TomShane.Neoforce.Controls.Manager.TargetHeight">
      <summary>
            Gets height of the selected render target in pixels.
            </summary>
    </member>
    <member name="P:TomShane.Neoforce.Controls.Manager.ScreenWidth">
      <summary>
            Gets current width of the screen in pixels.
            </summary>
    </member>
    <member name="P:TomShane.Neoforce.Controls.Manager.ScreenHeight">
      <summary>
            Gets current height of the screen in pixels.
            </summary>
    </member>
    <member name="P:TomShane.Neoforce.Controls.Manager.Skin">
      <summary>
            Gets or sets new skin used by all controls.
            </summary>
    </member>
    <member name="P:TomShane.Neoforce.Controls.Manager.ModalWindow">
      <summary>
            Returns currently active modal window.
            </summary>
    </member>
    <member name="P:TomShane.Neoforce.Controls.Manager.FocusedControl">
      <summary>
            Returns currently focused control.
            </summary>
    </member>
    <member name="E:TomShane.Neoforce.Controls.Manager.DeviceSettingsChanged">
      <summary>
            Occurs when the GraphicsDevice settings are changed.
            </summary>
    </member>
    <member name="E:TomShane.Neoforce.Controls.Manager.SkinChanging">
      <summary>
            Occurs when the skin is about to change.
            </summary>
    </member>
    <member name="E:TomShane.Neoforce.Controls.Manager.SkinChanged">
      <summary>
            Occurs when the skin changes.
            </summary>
    </member>
    <member name="E:TomShane.Neoforce.Controls.Manager.WindowClosing">
      <summary>
            Occurs when game window is about to close.
            </summary>
    </member>
    <member name="P:TomShane.Neoforce.Controls.InputSystem.InputOffset">
      <summary>
            Sets or gets input offset and ratio when rescaling controls in render target.
            </summary>
    </member>
    <member name="P:TomShane.Neoforce.Controls.InputSystem.InputMethods">
      <summary>
            Sets or gets input methods allowed for navigation.
            </summary>
    </member>
    <member name="T:PloobsEngine.Utils.VectorUtils">
      <summary>
            Lots of Vector Helpers
            </summary>
    </member>
    <member name="M:PloobsEngine.Utils.VectorUtils.Perpendicular2DNormalized(Microsoft.Xna.Framework.Vector2)">
      <summary>
            Return the Perpendicular 2D normalized vector.
            </summary>
      <param name="vx">The base vector.</param>
      <returns>
      </returns>
    </member>
    <member name="M:PloobsEngine.Utils.VectorUtils.ToVector2(Microsoft.Xna.Framework.Vector3)">
      <summary>
            transforms the 3dvector to 2d, 
            throw away the Y component
            Projects to XZ PLANE
            </summary>
      <param name="vec">The vec.</param>
      <returns>
      </returns>
    </member>
    <member name="M:PloobsEngine.Utils.VectorUtils.ToVector3(Microsoft.Xna.Framework.Vector2)">
      <summary>
            Transforms a 2D vector to vector3.
            THE Y COMPONENT IS SET TO 0 -&gt; Vector3(vec.X, 0,vec.Y);
            </summary>
      <param name="vec">The vec.</param>
      <returns>
      </returns>
    </member>
    <member name="M:PloobsEngine.Utils.VectorUtils.ToVector3(Microsoft.Xna.Framework.Vector2,System.Single)">
      <summary>
            Creates a 3D vector -&gt; Vector3(vec.X, y, vec.Y);
            </summary>
      <param name="vec">The vec.</param>
      <param name="y">The y.</param>
      <returns>
      </returns>
    </member>
    <member name="M:PloobsEngine.Utils.VectorUtils.FindAngleBetweenTwoVectors2D(Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3)">
      <summary>
            Finds the angle between two vectors2.
            </summary>
      <param name="v1">The v1.</param>
      <param name="v2">The v2.</param>
      <returns>
      </returns>
    </member>
    <member name="M:PloobsEngine.Utils.VectorUtils.rotateVector2(Microsoft.Xna.Framework.Vector2,System.Double)">
      <summary>
            Rotates the vector by an arbitrary angle
            </summary>
      <param name="vector">Vector to rotate</param>
      <param name="angle">Rotation angle</param>
      <returns>
            The rotated vector
            </returns>
    </member>
    <member name="M:PloobsEngine.Utils.VectorUtils.FindAngleBetweenTwoVectors2D(Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2)">
      <summary>
            Angle between 2 vectors WITH SIGNAL
            </summary>
      <param name="v1">The v1.</param>
      <param name="v2">The v2.</param>
      <returns>
      </returns>
    </member>
    <member name="M:PloobsEngine.Utils.VectorUtils.GetSignedAngleBetween2DVectors(Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3)">
      <summary>
            Find the angle between two vectors. This will not only give the angle difference, but the direction.
            For example, it may give you -1 radian, or 1 radian, depending on the direction. Angle given will be the
            angle from the FromVector to the DestVector, in radians.
            </summary>
      <param name="FromVector">Vector to start at.</param>
      <param name="DestVector">Destination vector.</param>
      <param name="DestVectorsRight">Right vector of the destination vector</param>
      <returns>
            Signed angle, in radians
            </returns>
      <remarks>
            All three vectors must lie along the same plane.
            </remarks>
    </member>
    <member name="M:PloobsEngine.Utils.VectorUtils.UnsignedAngleBetweenTwoV3(Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3)">
      <summary>
            Unsigneds the angle between two v3.
            </summary>
      <param name="v1">The v1.</param>
      <param name="v2">The v2.</param>
      <returns>
      </returns>
    </member>
    <member name="M:PloobsEngine.Utils.VectorUtils.CalculateDeflection(Microsoft.Xna.Framework.Vector3,System.Single,Microsoft.Xna.Framework.Vector3)">
      <summary>
            Returns velocity of deflection
            </summary>
      <param name="CurrentVelocity">Velocity vector if item to be bounced</param>
      <param name="Elasticity">Elasticity of item to be bounced</param>
      <param name="CollisionNormal">Normal vector of plane the item is bouncing off of</param>
      <returns>
            Velocity vector of deflection
            </returns>
    </member>
    <member name="M:PloobsEngine.Utils.VectorUtils.RotateAroundPoint(Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,System.Single)">
      <summary>
            Translates a point around an origin
            </summary>
      <param name="point">Point that is going to be translated</param>
      <param name="originPoint">Origin of rotation</param>
      <param name="rotationAxis">Axis to rotate around, this Vector should be a unit vector (normalized)</param>
      <param name="radiansToRotate">Radians to rotate</param>
      <returns>
            Translated point
            </returns>
    </member>
    <member name="M:PloobsEngine.Utils.VectorUtils.QuaternionToEuler(Microsoft.Xna.Framework.Quaternion)">
      <summary>
            Quaternions to euler.
            </summary>
      <param name="q">The q.</param>
      <returns>
      </returns>
    </member>
    <member name="M:PloobsEngine.Utils.VectorUtils.LookAt(Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3)">
      <summary>
            Calculate the rotation for one vector to face another vector
            </summary>
      <param name="position">The position.</param>
      <param name="lookat">The lookat.</param>
      <returns>
      </returns>
    </member>
    <member name="M:PloobsEngine.Utils.VectorUtils.ParallelComponent(Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3)">
      <summary>
            return component of vector parallel to a unit basis vector
            IMPORTANT NOTE: assumes "basis" has unit magnitude (length == 1)        
            Parallels the component.
            </summary>
      <param name="vector">The vector.</param>
      <param name="unitBasis">The unit basis.</param>
      <returns>
      </returns>
    </member>
    <member name="M:PloobsEngine.Utils.VectorUtils.PerpendicularComponent(Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3)">
      <summary>
            return component of vector perpendicular to a unit basis vector
            IMPORTANT NOTE: assumes "basis" has unit magnitude(length==1)
            </summary>
      <param name="vector">The vector.</param>
      <param name="unitBasis">The unit basis.</param>
      <returns>
      </returns>
    </member>
    <member name="M:PloobsEngine.Utils.VectorUtils.TruncateLength(Microsoft.Xna.Framework.Vector3,System.Single)">
      <summary>
            clamps the length of a given vector to maxLength.  If the vector is
            shorter its value is returned unaltered, if the vector is longer
            the value returned has length of maxLength and is paralle to the
            original input.
            </summary>
      <param name="vector">The vector.</param>
      <param name="maxLength">Length of the max.</param>
      <returns>
      </returns>
    </member>
    <member name="M:PloobsEngine.Utils.VectorUtils.RotateAboutGlobalY(Microsoft.Xna.Framework.Vector3,System.Single)">
      <summary>
            rotate this vector about the global Y (up) axis by the given angle
            </summary>
      <param name="vector">The vector.</param>
      <param name="angle">The angle.</param>
      <returns>
      </returns>
    </member>
    <member name="M:PloobsEngine.Utils.VectorUtils.RotateAboutGlobalY(Microsoft.Xna.Framework.Vector3,System.Single,System.Single@,System.Single@)">
      <summary>
            version for caching sin/cos computation
            </summary>
      <param name="vector">The vector.</param>
      <param name="angle">The angle.</param>
      <param name="sin">The sin.</param>
      <param name="cos">The cos.</param>
      <returns>
      </returns>
    </member>
    <member name="M:PloobsEngine.Utils.VectorUtils.SphericalWrapAround(Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,System.Single)">
      <summary>
            Spherical WrapAround.
            if this position is outside sphere, push it back in by one diameter
            </summary>
      <param name="vector">The vector.</param>
      <param name="center">The center.</param>
      <param name="radius">The radius.</param>
      <returns>
      </returns>
    </member>
    <member name="M:PloobsEngine.Utils.VectorUtils.RandomVectorOnUnitRadiusXZDisk">
      <summary>
            Returns a position randomly distributed on a disk of unit radius
            on the XZ (Y=0) plane, centered at the origin.  Orientation will be
            random and length will range between 0 and 1
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:PloobsEngine.Utils.VectorUtils.RandomVectorInUnitRadiusSphere">
      <summary>
            Returns a position randomly distributed inside a sphere of unit radius
            centered at the origin.  Orientation will be random and length will range
            between 0 and 1
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:PloobsEngine.Utils.VectorUtils.RandomUnitVector">
      <summary>
            Returns a position randomly distributed on the surface of a sphere
            of unit radius centered at the origin.  Orientation will be random
            and length will be 1
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:PloobsEngine.Utils.VectorUtils.RandomUnitVectorOnXZPlane">
      <summary>
            Returns a position randomly distributed on a circle of unit radius
            on the XZ (Y=0) plane, centered at the origin.  Orientation will be
            random and length will be 1
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:PloobsEngine.Utils.VectorUtils.LimitMaxDeviationAngle(Microsoft.Xna.Framework.Vector3,System.Single,Microsoft.Xna.Framework.Vector3)">
      <summary>
            Enforce an upper bound on the angle by which a given arbitrary vector
            diviates from a given reference direction (specified by a unit basis
            vector).  The effect is to clip the "source" vector to be inside a cone
            defined by the basis and an angle.
            </summary>
      <param name="source">The source.</param>
      <param name="cosineOfConeAngle">The cosine of cone angle.</param>
      <param name="basis">The basis.</param>
      <returns>
      </returns>
    </member>
    <member name="M:PloobsEngine.Utils.VectorUtils.LimitMinDeviationAngle(Microsoft.Xna.Framework.Vector3,System.Single,Microsoft.Xna.Framework.Vector3)">
      <summary>
            Enforce a lower bound on the angle by which a given arbitrary vector
            diviates from a given reference direction (specified by a unit basis
            vector).  The effect is to clip the "source" vector to be outside a cone
            defined by the basis and an angle.
            </summary>
      <param name="source">The source.</param>
      <param name="cosineOfConeAngle">The cosine of cone angle.</param>
      <param name="basis">The basis.</param>
      <returns>
      </returns>
    </member>
    <member name="M:PloobsEngine.Utils.VectorUtils.DistanceFromLine(Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3)">
      <summary>
            Returns the distance between a point and a line.  The line is defined in
            terms of a point on the line ("lineOrigin") and a UNIT vector parallel to
            the line ("lineUnitTangent")
            </summary>
      <param name="point">The point.</param>
      <param name="lineOrigin">The line origin.</param>
      <param name="lineUnitTangent">The line unit tangent.</param>
      <returns>
      </returns>
    </member>
    <member name="M:PloobsEngine.Utils.VectorUtils.FindPerpendicularIn3d(Microsoft.Xna.Framework.Vector3)">
      <summary>
            given a vector, return a vector perpendicular to it (note that this
            arbitrarily selects one of the infinitude of perpendicular vectors)
            </summary>
      <param name="direction">The direction.</param>
      <returns>
      </returns>
    </member>
    <member name="T:PloobsEngine.SceneControl.IPostEffect">
      <summary>
            IPost Effect Specification
            </summary>
    </member>
    <member name="M:PloobsEngine.SceneControl.IPostEffect.Init(PloobsEngine.Engine.GraphicInfo,PloobsEngine.Engine.GraphicFactory)">
      <summary>
            Initiates the specified Post Effect.
            Called by the engine
            </summary>
      <param name="manager">The manager.</param>
      <param name="ginfo">The ginfo.</param>
      <param name="factory">The factory.</param>
    </member>
    <member name="M:PloobsEngine.SceneControl.IPostEffect.Draw(Microsoft.Xna.Framework.Graphics.Texture2D,PloobsEngine.SceneControl.RenderHelper,Microsoft.Xna.Framework.GameTime,PloobsEngine.Engine.GraphicInfo,PloobsEngine.SceneControl.IWorld,System.Boolean)">
      <summary>
            Apply the post effect
            </summary>
      <param name="ImageToProcess">The image to process.</param>
      <param name="rHelper">The r helper.</param>
      <param name="gt">The gt.</param>
      <param name="GraphicInfo">The graphic info.</param>
      <param name="world">The world.</param>
      <param name="useFloatBuffer">if set to <c>true</c> [use float buffer].</param>
    </member>
    <member name="P:PloobsEngine.SceneControl.IPostEffect.PostEffectType">
      <summary>
            Gets or sets the type of the post effect.
            </summary>
      <value>
            The type of the post effect.
            </value>
    </member>
    <member name="P:PloobsEngine.SceneControl.IPostEffect.Priority">
      <summary>
            Gets the priority in relation with others PostEffects        
            Lower the number, first the effect will be applied
            0 By Default
            </summary>
    </member>
    <member name="P:PloobsEngine.SceneControl.IPostEffect.Enabled">
      <summary>
            Gets or sets a value indicating whether this <see cref="T:PloobsEngine.SceneControl.IPostEffect" /> is enabled.
            Enabled by default
            </summary>
      <value>
        <c>true</c> if enabled; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="T:PloobsEngine.SceneControl.ICuller">
      <summary>
            Culler Specification
            </summary>
    </member>
    <member name="M:PloobsEngine.SceneControl.ICuller.GetNotCulledObjectsList(System.Nullable{PloobsEngine.Material.MaterialType})">
      <summary>
            Get all the objects that pass the culling phase
            </summary>
      <param name="Filter">Or Filter, null for all</param>
      <returns>
      </returns>
    </member>
    <member name="M:PloobsEngine.SceneControl.ICuller.StartFrame(Microsoft.Xna.Framework.Matrix,Microsoft.Xna.Framework.Matrix,Microsoft.Xna.Framework.BoundingFrustum)">
      <summary>
            Called by the engine Once in the start of each rendering pass
            </summary>
      <param name="world">
      </param>
    </member>
    <member name="M:PloobsEngine.SceneControl.ICuller.onObjectAdded(PloobsEngine.SceneControl.IObject)">
      <summary>
            Called when an object is added to the world
            </summary>
      <param name="obj">The obj.</param>
    </member>
    <member name="M:PloobsEngine.SceneControl.ICuller.onObjectRemoved(PloobsEngine.SceneControl.IObject)">
      <summary>
            Called when an object s removed from the world
            </summary>
      <param name="obj">The obj.</param>
    </member>
    <member name="P:PloobsEngine.SceneControl.ICuller.RenderedObjectThisFrame">
      <summary>
            Gets the number of objects rendered in this frame.
            </summary>
    </member>
    <member name="T:PloobsEngine.SceneControl.SimpleCuller">
      <summary>
            Culler that uses the bepu scene control
            </summary>
    </member>
    <member name="T:PloobsEngine.Modelo.OnTextureChange">
      <summary>
            Called when the texture change
            </summary>
      <param name="type">The type.</param>
      <param name="model">The model.</param>
    </member>
    <member name="T:PloobsEngine.Modelo.IModelo">
      <summary>
            Model Specification
            </summary>
    </member>
    <member name="M:PloobsEngine.Modelo.IModelo.getTexture(PloobsEngine.Modelo.TextureType,System.Int32,System.Int32)">
      <summary>
            Gets one texture of the model.
            </summary>
      <param name="type">The type.</param>
      <param name="meshIndex">Index of the mesh.</param>
      <param name="meshPartIndex">Index of the mesh part.</param>
      <returns>
      </returns>
    </member>
    <member name="M:PloobsEngine.Modelo.IModelo.SetTexture(System.String,PloobsEngine.Modelo.TextureType,System.Int32,System.Int32)">
      <summary>
            Sets the texture.
            </summary>
      <param name="textureName">Name of the texture.</param>
      <param name="type">The type.</param>
    </member>
    <member name="M:PloobsEngine.Modelo.IModelo.LoadModelo(PloobsEngine.Engine.GraphicFactory)">
      <summary>
            Load the model
            </summary>
      <param name="factory">The factory.</param>
    </member>
    <member name="M:PloobsEngine.Modelo.IModelo.LoadModel(PloobsEngine.Engine.GraphicFactory,PloobsEngine.Modelo.BatchInformation[][]@,PloobsEngine.Modelo.TextureInformation[][]@)">
      <summary>
            Loads the batch info, called by the constructor if callLoadContent is true
            </summary>
      <param name="factory">The factory.</param>
      <param name="BatchInformations">The batch informations.</param>
      <param name="TextureInformation">The texture information.</param>
    </member>
    <member name="M:PloobsEngine.Modelo.IModelo.SetTexture(Microsoft.Xna.Framework.Graphics.Texture2D,PloobsEngine.Modelo.TextureType,System.Int32,System.Int32)">
      <summary>
            Sets the texture.
            </summary>
      <param name="tex">The tex.</param>
      <param name="type">The type.</param>
      <param name="meshIndex">Index of the mesh.</param>S
            <param name="meshPartIndex">Index of the mesh part.</param></member>
    <member name="M:PloobsEngine.Modelo.IModelo.GetModelRadius">
      <summary>
            Gets the model radius.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:PloobsEngine.Modelo.IModelo.GetBatchInformation(System.Int32)">
      <summary>
            Gets the batch information.
            </summary>
      <param name="meshNumber">The mesh number.</param>
      <returns>
      </returns>
    </member>
    <member name="P:PloobsEngine.Modelo.IModelo.Tag">
      <summary>
            Gets or sets the tag.
            </summary>
      <value>
            The tag.
            </value>
      <returns>
      </returns>
    </member>
    <member name="P:PloobsEngine.Modelo.IModelo.MeshNumber">
      <summary>
            Gets the mesh number.
            </summary>
    </member>
    <member name="P:PloobsEngine.Modelo.IModelo.Name">
      <summary>
            Gets the name.
            </summary>
      <value>
            The name.
            </value>
    </member>
    <member name="T:PloobsEngine.Modelo.TextureType">
      <summary>
            Textures Types avaliable
            </summary>
    </member>
    <member name="F:PloobsEngine.Modelo.TextureType.DIFFUSE">
      <summary>
            Diffuse
            </summary>
    </member>
    <member name="F:PloobsEngine.Modelo.TextureType.SPECULAR">
      <summary>
            Specular
            </summary>
    </member>
    <member name="F:PloobsEngine.Modelo.TextureType.BUMP">
      <summary>
            Bump
            </summary>
    </member>
    <member name="F:PloobsEngine.Modelo.TextureType.GLOW">
      <summary>
            GLow
            </summary>
    </member>
    <member name="F:PloobsEngine.Modelo.TextureType.PARALAX">
      <summary>
            Paralax
            </summary>
    </member>
    <member name="F:PloobsEngine.Modelo.TextureType.RELIEF">
      <summary>
            Reliefe Mapping (Not used yet)
            </summary>
    </member>
    <member name="F:PloobsEngine.Modelo.TextureType.MULTITEX1">
      <summary>
            Multitex used in Terrain
            can be used anywhere
            </summary>
    </member>
    <member name="F:PloobsEngine.Modelo.TextureType.MULTITEX2">
      <summary>
            Multitex used in terrain
            can be used anywhere
            </summary>
    </member>
    <member name="F:PloobsEngine.Modelo.TextureType.MULTITEX3">
      <summary>
            Multitex used in terrain
            can be used anywhere
            </summary>
    </member>
    <member name="F:PloobsEngine.Modelo.TextureType.MULTITEX4">
      <summary>
            Multitex used in terrain
            can be used anywhere
            </summary>
    </member>
    <member name="F:PloobsEngine.Modelo.TextureType.HEIGHTMAP">
      <summary>
            HEIGHTMAP, can used anywhere
            </summary>
    </member>
    <member name="T:PloobsEngine.Material.ForwardXNABasicShaderDescription">
      <summary>
            Description that helps building the XNABasicShader
            </summary>
    </member>
    <member name="M:PloobsEngine.Material.ForwardXNABasicShaderDescription.#ctor(Microsoft.Xna.Framework.Color,Microsoft.Xna.Framework.Color,Microsoft.Xna.Framework.Color,System.Single,System.Single,System.Boolean,System.Boolean)">
      <summary>
            Initializes a new instance of the <see cref="T:PloobsEngine.Material.ForwardXNABasicShaderDescription" /> struct.
            </summary>
      <param name="AmbientColor">Color of the ambient.</param>
      <param name="EmissiveColor">Color of the emissive.</param>
      <param name="SpecularColor">Color of the specular.</param>
      <param name="specularPower">The specular power.</param>
      <param name="alpha">The alpha.</param>
      <param name="EnableLightning">if set to <c>true</c> [enable lightning].</param>
      <param name="EnableTexture">if set to <c>true</c> [enable texture].</param>
    </member>
    <member name="M:PloobsEngine.Material.ForwardXNABasicShaderDescription.Default">
      <summary>
            Defaults this instance.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="T:PloobsEngine.Material.IShader">
      <summary>
            Base Class For all Shaders
            </summary>
    </member>
    <member name="F:PloobsEngine.Material.IShader.firstTime">
      <summary>
            is fist time that this shader is updated
            </summary>
    </member>
    <member name="F:PloobsEngine.Material.IShader.shaderId">
      <summary>
            Shader ID that the object rendered by this shader will have        
            </summary>
      <remarks>
            This parameter lets the object not be affect by light, or be recovered in a post proccess phase
            </remarks>
    </member>
    <member name="M:PloobsEngine.Material.IShader.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:PloobsEngine.Material.IShader" /> class.
            </summary>
    </member>
    <member name="M:PloobsEngine.Material.IShader.Initialize(PloobsEngine.Engine.GraphicInfo,PloobsEngine.Engine.GraphicFactory,PloobsEngine.SceneControl.IObject)">
      <summary>
            Initializes this instance.
            </summary>
    </member>
    <member name="M:PloobsEngine.Material.IShader.PreUpdate(PloobsEngine.SceneControl.IObject,System.Collections.Generic.IList{PloobsEngine.Light.ILight})">
      <summary>
            Called Once only, before all draws
            </summary>
      <param name="ent">The current entity.</param>
      <param name="lights">All The lights </param>
    </member>
    <member name="M:PloobsEngine.Material.IShader.Update(Microsoft.Xna.Framework.GameTime,PloobsEngine.SceneControl.IObject,System.Collections.Generic.IList{PloobsEngine.Light.ILight})">
      <summary>
            Updates this shader
            Called every frame once        
            </summary>
      <param name="ent">The ent.</param>
      <param name="lights">The lights.</param>
    </member>
    <member name="M:PloobsEngine.Material.IShader.PreDrawPhase(Microsoft.Xna.Framework.GameTime,PloobsEngine.SceneControl.IWorld,PloobsEngine.SceneControl.IObject,PloobsEngine.SceneControl.RenderHelper,PloobsEngine.Cameras.ICamera)">
      <summary>
            Called every frame before the draw phase.
            In deferred it is called before the GBUFFER is setted
            </summary>
      <param name="gt">The gt.</param>
      <param name="world">The world.</param>
      <param name="obj">The obj.</param>
      <param name="render">The render.</param>
      <param name="cam">The camera</param>
    </member>
    <member name="M:PloobsEngine.Material.IShader.PosDrawPhase(Microsoft.Xna.Framework.GameTime,PloobsEngine.SceneControl.IObject,PloobsEngine.SceneControl.RenderHelper,PloobsEngine.Cameras.ICamera,System.Collections.Generic.IList{PloobsEngine.Light.ILight})">
      <summary>
            Called after the draw phase.
            In deferred its responsible for the Forward Pass, in forward its not called        
            </summary>
      <param name="modelo">The modelo.</param>
      <param name="render">The render.</param>
      <param name="cam">The camera.</param>
      <param name="lights">The lights.</param>
    </member>
    <member name="M:PloobsEngine.Material.IShader.Draw(Microsoft.Xna.Framework.GameTime,PloobsEngine.SceneControl.IObject,PloobsEngine.SceneControl.RenderHelper,PloobsEngine.Cameras.ICamera,System.Collections.Generic.IList{PloobsEngine.Light.ILight})">
      <summary>
            Draw
            </summary>
      <param name="modelo">The modelo.</param>
      <param name="render">The render.</param>
      <param name="cam">The cam.</param>
    </member>
    <member name="M:PloobsEngine.Material.IShader.DepthExtractor(Microsoft.Xna.Framework.GameTime,PloobsEngine.SceneControl.IObject,Microsoft.Xna.Framework.Matrix,Microsoft.Xna.Framework.Matrix,PloobsEngine.SceneControl.RenderHelper)">
      <summary>
            Exctract the depth from an object
            </summary>
      <param name="gt">The gt.</param>
      <param name="obj">The obj.</param>
      <param name="cam">The cam.</param>
      <param name="lights">The lights.</param>
      <param name="render">The render.</param>
    </member>
    <member name="M:PloobsEngine.Material.IShader.BasicDraw(Microsoft.Xna.Framework.GameTime,PloobsEngine.SceneControl.IObject,Microsoft.Xna.Framework.Matrix,Microsoft.Xna.Framework.Matrix,System.Collections.Generic.IList{PloobsEngine.Light.ILight},PloobsEngine.SceneControl.RenderHelper,System.Nullable{Microsoft.Xna.Framework.Plane},System.Boolean)">
      <summary>
            Draw the object in a simple way (WITH MINIMUM EFFECTS,....)
            USED IN RELECTIONS, REFRACTION .....
            </summary>
      <param name="gt">The gt.</param>
      <param name="obj">The obj.</param>
      <param name="cam">The cam.</param>
      <param name="lights">The lights.</param>
      <param name="render">The render.</param>
      <param name="clippingPlane">The clipping plane.</param>
    </member>
    <member name="P:PloobsEngine.Material.IShader.MaterialType">
      <summary>
            Gets the type of the material.
            </summary>
      <value>
            The type of the material.
            </value>
    </member>
    <member name="P:PloobsEngine.Material.IShader.ShaderId">
      <summary>
            Used to Recover the object in PostProcces
            between 0 and 0.9f it will be illuminated, 
            bigger than 0.9 it wont be
            </summary>
    </member>
    <member name="T:PloobsEngine.Material.ForwardXNABasicShader">
      <summary>
            XNA basic shader
            Wrapper to xna basic effect
            </summary>
    </member>
    <member name="M:PloobsEngine.Material.ForwardXNABasicShader.#ctor(PloobsEngine.Material.ForwardXNABasicShaderDescription)">
      <summary>
            Initializes a new instance of the <see cref="T:PloobsEngine.Material.ForwardXNABasicShader" /> class.
            </summary>
      <param name="desc">The desc.</param>
    </member>
    <member name="M:PloobsEngine.Material.ForwardXNABasicShader.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:PloobsEngine.Material.ForwardXNABasicShader" /> class.
            </summary>
    </member>
    <member name="M:PloobsEngine.Material.ForwardXNABasicShader.Initialize(PloobsEngine.Engine.GraphicInfo,PloobsEngine.Engine.GraphicFactory,PloobsEngine.SceneControl.IObject)">
      <summary>
            Initializes this instance.
            </summary>
      <param name="ginfo">
      </param>
      <param name="factory">
      </param>
      <param name="obj">
      </param>
    </member>
    <member name="M:PloobsEngine.Material.ForwardXNABasicShader.SetDescription(PloobsEngine.Material.ForwardXNABasicShaderDescription)">
      <summary>
            Sets the description.
            </summary>
      <param name="desc">The desc.</param>
    </member>
    <member name="M:PloobsEngine.Material.ForwardXNABasicShader.Draw(Microsoft.Xna.Framework.GameTime,PloobsEngine.SceneControl.IObject,PloobsEngine.SceneControl.RenderHelper,PloobsEngine.Cameras.ICamera,System.Collections.Generic.IList{PloobsEngine.Light.ILight})">
      <summary>
            Draw
            </summary>
      <param name="gt">gametime</param>
      <param name="obj">the obj</param>
      <param name="render">The render.</param>
      <param name="cam">The cam.</param>
      <param name="lights">
      </param>
    </member>
    <member name="P:PloobsEngine.Material.ForwardXNABasicShader.MaterialType">
      <summary>
            Gets the type of the material.
            </summary>
      <value>
            The type of the material.
            </value>
    </member>
    <member name="T:PloobsEngine.Input.KeyStateChange">
      <summary>
            Called when a key event is fired
            </summary>
      <param name="ipk">The ipk.</param>
    </member>
    <member name="T:PloobsEngine.Input.IInput">
      <summary>
            Interface for an Input Processor
            </summary>
    </member>
    <member name="T:PloobsEngine.Input.InputPlayableKeyBoard">
      <summary>
            keyboard Input Binding interface
            </summary>
    </member>
    <member name="M:PloobsEngine.Physics2D.I2DPhysicWorld.Update(Microsoft.Xna.Framework.GameTime)">
      <summary>
            Updates 
            </summary>
      <param name="gt">The gt.</param>
    </member>
    <member name="M:PloobsEngine.Physics2D.I2DPhysicWorld.AddObject(PloobsEngine.Physics2D.I2DPhysicObject)">
      <summary>
            Adds the object.
            </summary>
      <param name="obj">The obj.</param>
    </member>
    <member name="M:PloobsEngine.Physics2D.I2DPhysicWorld.RemoveObject(PloobsEngine.Physics2D.I2DPhysicObject)">
      <summary>
            Removes the object.
            </summary>
      <param name="obj">The obj.</param>
    </member>
    <member name="T:PloobsEngine.Material.DeferredAnimatedTextureShader">
      <summary>
            Animated Bilboard.   
            Each one uses a different Instance of this shader (Clonned)
            bitstrip pra gerar imagens horizontais - animacao
            </summary>
    </member>
    <member name="M:PloobsEngine.Material.DeferredAnimatedTextureShader.#ctor(System.Int32,System.Int32,PloobsEngine.Material.BilboardType)">
      <summary>
            Bilboard animada
            </summary>
      <param name="numFrames">numero de frames que tem na textura</param>
      <param name="msBetweenFrames">tempo entre frames em milisegundos</param>
    </member>
    <member name="P:PloobsEngine.Material.DeferredAnimatedTextureShader.Scale">
      <summary>
            Bilboard tem tamanho 1,1 -&gt; deve-se ser multiplicada por um fator de escala
            Default Vector2(100, 100);
            </summary>
    </member>
    <member name="P:PloobsEngine.Material.DeferredAnimatedTextureShader.Atenuation">
      <summary>
            Atenuacao na cor da textura utilizada
            Default Vector4.One
            </summary>
    </member>
    <member name="P:PloobsEngine.Material.DeferredAnimatedTextureShader.AllowRotDir">
      <summary>
            Constraint da bilboard IF CILINDRIC
            SPHERICAL DOES NOT HAVE CONSTRAINT DIRECTION
            Default Vector3(0,1,0)
            </summary>
    </member>
    <member name="P:PloobsEngine.Material.DeferredAnimatedTextureShader.Amplitude">
      <summary>
            Amplitude do movimento (os dois pontos de cima da billboard podem se movimentar)
            Default 1
            </summary>
    </member>
    <member name="P:PloobsEngine.Material.DeferredAnimatedTextureShader.MovimentSpeedControl">
      <summary>
            Velocidade de moviemnto
            Default 5
            </summary>
    </member>
    <member name="T:PloobsEngine.Light.ILight">
      <summary>
            Specification of a Light
            </summary>
    </member>
    <member name="P:PloobsEngine.Light.ILight.CastShadown">
      <summary>
            Gets or sets a value indicating whether [cast shadown].
            </summary>
      <value>
        <c>true</c> if [cast shadown]; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="P:PloobsEngine.Light.ILight.Name">
      <summary>
            Gets or sets the name of the light.
            </summary>
      <value>
            The name.
            </value>
    </member>
    <member name="P:PloobsEngine.Light.ILight.LightType">
      <summary>
            Gets the type of the light.
            </summary>
      <value>
            The type of the light.
            </value>
    </member>
    <member name="T:PloobsEngine.Light.DeferredLight">
      <summary>
            Deferred Light Specification
            </summary>
    </member>
    <member name="P:PloobsEngine.Light.DeferredLight.LightType">
      <summary>
            Gets the type of the light.
            </summary>
      <value>
            The type of the light.
            </value>
    </member>
    <member name="P:PloobsEngine.Light.DeferredLight.SHADOWBIAS">
      <summary>
            Gets or sets the SHADOWBIAS.
            </summary>
      <value>
            The SHADOWBIAS.
            </value>
    </member>
    <member name="P:PloobsEngine.Light.DeferredLight.Color">
      <summary>
            Gets or sets the color.
            </summary>
      <value>
            The color.
            </value>
    </member>
    <member name="P:PloobsEngine.Light.DeferredLight.ViewMatrix">
      <summary>
            Gets or sets the view matrix.
            </summary>
      <value>
            The view matrix.
            </value>
    </member>
    <member name="P:PloobsEngine.Light.DeferredLight.ProjMatrix">
      <summary>
            Gets or sets the proj matrix.
            </summary>
      <value>
            The proj matrix.
            </value>
    </member>
    <member name="P:PloobsEngine.Light.DeferredLight.Name">
      <summary>
            Gets or sets the name of the light.
            </summary>
      <value>
            The name.
            </value>
    </member>
    <member name="P:PloobsEngine.Light.DeferredLight.CastShadown">
      <summary>
            Gets or sets a value indicating whether [cast shadown].
            </summary>
      <value>
        <c>true</c> if [cast shadown]; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="T:PloobsEngine.Light.SpotLightPE">
      <summary>
            Deferred Spot Light
            </summary>
    </member>
    <member name="M:PloobsEngine.Light.SpotLightPE.#ctor">
      <summary>
            Serialization 
            </summary>
    </member>
    <member name="M:PloobsEngine.Light.SpotLightPE.#ctor(Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,System.Single,System.Single,Microsoft.Xna.Framework.Color,System.Single,System.Single)">
      <summary>
            Initializes a new instance of the <see cref="T:PloobsEngine.Light.SpotLightPE" /> class.
            </summary>
      <param name="position">The position.</param>
      <param name="direction">The direction.</param>
      <param name="coneDecay">The cone decay.</param>
      <param name="lightRadius">The light radius.</param>
      <param name="Color">The color.</param>
      <param name="lightAngleCosine">The light angle cosine.</param>
      <param name="lightIntensity">The light intensity.</param>
    </member>
    <member name="P:PloobsEngine.Light.SpotLightPE.ProjMatrix">
      <summary>
            Gets or sets the proj matrix.
            </summary>
      <value>
            The proj matrix.
            </value>
    </member>
    <member name="P:PloobsEngine.Light.SpotLightPE.ViewMatrix">
      <summary>
            Gets or sets the view matrix.
            </summary>
      <value>
            The view matrix.
            </value>
    </member>
    <member name="P:PloobsEngine.Light.SpotLightPE.LightIntensity">
      <summary>
            Gets or sets the light intensity.
            </summary>
      <value>
            The light intensity.
            </value>
    </member>
    <member name="P:PloobsEngine.Light.SpotLightPE.LightAngleCosine">
      <summary>
            Gets or sets the light angle cosine.
            </summary>
      <value>
            The light angle cosine.
            </value>
    </member>
    <member name="P:PloobsEngine.Light.SpotLightPE.Position">
      <summary>
            Gets or sets the position.
            </summary>
      <value>
            The position.
            </value>
    </member>
    <member name="P:PloobsEngine.Light.SpotLightPE.Direction">
      <summary>
            Gets or sets the direction.
            </summary>
      <value>
            The direction.
            </value>
    </member>
    <member name="P:PloobsEngine.Light.SpotLightPE.LightRadius">
      <summary>
            Gets or sets the light radius.
            </summary>
      <value>
            The light radius.
            </value>
    </member>
    <member name="P:PloobsEngine.Light.SpotLightPE.ConeDecay">
      <summary>
            Gets or sets the cone decay.
            </summary>
      <value>
            The cone decay.
            </value>
    </member>
    <member name="P:PloobsEngine.Light.SpotLightPE.Target">
      <summary>
            Gets or sets the target.
            </summary>
      <value>
            The target.
            </value>
    </member>
    <member name="P:PloobsEngine.Light.SpotLightPE.LightType">
      <summary>
            Gets the type of the light.
            </summary>
      <value>
            The type of the light.
            </value>
    </member>
    <member name="F:PloobsEngine.Features.DebugDraw.DebugLine.effect">
      <summary>
            The basic effect used to draw boxes.
            </summary>
    </member>
    <member name="M:PloobsEngine.Features.DebugDraw.DebugLine.#ctor(Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Color)">
      <summary>
            Creates a new box.
            Visible by default
            </summary>
      <param name="BoundingBox">The bounding box.</param>
      <param name="color">The box's color.</param>
    </member>
    <member name="M:PloobsEngine.Features.DebugDraw.DebugLine.Draw(PloobsEngine.SceneControl.RenderHelper,Microsoft.Xna.Framework.Matrix,Microsoft.Xna.Framework.Matrix)">
      <summary>
            Draws the box.
            </summary>
      <param name="view">The viewing matrix.</param>
      <param name="projection">The projection matrix.</param>
    </member>
    <member name="T:PloobsEngine.Utils.Spline.CubicSpline">
      <summary>
            N-dimensional cubic spline interpolator.
            </summary>
    </member>
    <member name="F:PloobsEngine.Utils.Spline.CubicSpline.data">
      <summary>
            Sorted list of data points (x, y[]).
            </summary>
    </member>
    <member name="F:PloobsEngine.Utils.Spline.CubicSpline.dimensions">
      <summary>
            Number of dimensions for y values.
            </summary>
    </member>
    <member name="F:PloobsEngine.Utils.Spline.CubicSpline.xData">
      <summary>
            Current x values of data as a sorted array.
            </summary>
    </member>
    <member name="F:PloobsEngine.Utils.Spline.CubicSpline.yData">
      <summary>
            Current y values of data as sorted array. First index is the dimension.
            </summary>
    </member>
    <member name="F:PloobsEngine.Utils.Spline.CubicSpline.xIntervals">
      <summary>
            Current intervals between x values.
            </summary>
    </member>
    <member name="F:PloobsEngine.Utils.Spline.CubicSpline.bCoeff">
      <summary>
            B Coefficients. First index is the dimension.
            </summary>
    </member>
    <member name="F:PloobsEngine.Utils.Spline.CubicSpline.cCoeff">
      <summary>
            C Coefficients. First index is the dimension.
            </summary>
    </member>
    <member name="F:PloobsEngine.Utils.Spline.CubicSpline.dCoeff">
      <summary>
            D Coefficients. First index is the dimension.
            </summary>
    </member>
    <member name="F:PloobsEngine.Utils.Spline.CubicSpline.needUpdate">
      <summary>
            Flag indicating that spline coefficients need to be updated.
            </summary>
    </member>
    <member name="M:PloobsEngine.Utils.Spline.CubicSpline.#ctor">
      <summary>
            Creates an instance of the cubic spline class with one dimension.
            </summary>
    </member>
    <member name="M:PloobsEngine.Utils.Spline.CubicSpline.#ctor(System.Int32)">
      <summary>
            Creates an instance of the cubic spline class with 
            the specified number of dimensions.
            </summary>
    </member>
    <member name="M:PloobsEngine.Utils.Spline.CubicSpline.Clear">
      <summary>
            Clears the data array of the spline.
            </summary>
    </member>
    <member name="M:PloobsEngine.Utils.Spline.CubicSpline.AddDataPoint(System.Double,System.Double[])">
      <summary>
            Adds a data point to the spline. 
            If the data point is added, the coefficients are recalculated the next time
            Interpolate() is called.
            </summary>
      <param name="x">X coordinate of the spline. Must be unique (i.e. not added before).</param>
      <param name="y">
            Y coordinates of the spline. 
            The number of values in the array must match the number of dimensions if the spline.
            </param>
      <returns>True if the point was added, false otherwise.</returns>
    </member>
    <member name="M:PloobsEngine.Utils.Spline.CubicSpline.Interpolate(System.Double)">
      <summary>
            Interpolate spline at position X.
            May recalculate coefficients if they need to be updated (i.e. after AddDataPoint).
            </summary>
      <param name="x">Position X.</param>
      <returns>Interpolated Y.</returns>
    </member>
    <member name="M:PloobsEngine.Utils.Spline.CubicSpline.BinaryIndexSearch(System.Double[],System.Double)">
      <summary>
            Binary search for the lowest index where values[i] lte x.
            If x lt MIN(values), zero is returned and if x gt MAX(values), N-1 is returned.
            </summary>
      <param name="values">Sorted array of N values.</param>
      <param name="value">Value to find in array</param>
      <returns>The found lowest index in the range from 0 to N-1.</returns>
    </member>
    <member name="M:PloobsEngine.Utils.Spline.CubicSpline.CalculateIntervals(System.Double[])">
      <summary>
            Calculate intervals between values.
            </summary>
      <param name="values">Array of N values, where N&gt;1.</param>
      <returns>Array of N-1 intervals. </returns>
    </member>
    <member name="M:PloobsEngine.Utils.Spline.CubicSpline.CalculateC(System.Double[],System.Double[],System.Double[])">
      <summary>
            Calculates C coefficients from A, X and intervals.
            </summary>
      <param name="a">A coefficients</param>
      <param name="xdata">Array of X data</param>
      <param name="intervals">Intervals</param>
      <returns>C coefficients</returns>
    </member>
    <member name="M:PloobsEngine.Utils.Spline.CubicSpline.CalculateB(System.Double[],System.Double[],System.Double[])">
      <summary>
            Calculates B coefficients from A, C and intervals.
            </summary>
      <param name="a">A coefficients</param>
      <param name="c">C coefficients</param>
      <param name="interval">Intervals</param>
      <returns>B coefficients</returns>
    </member>
    <member name="M:PloobsEngine.Utils.Spline.CubicSpline.CalculateD(System.Double[],System.Double[])">
      <summary>
            Calculates D coefficients from C and interval.
            </summary>
      <param name="c">C coefficients.</param>
      <param name="interval">Intervals.</param>
      <returns>D coefficients.</returns>
    </member>
    <member name="M:PloobsEngine.Utils.Spline.CubicSpline.CalculateCoefficients">
      <summary>
            Calculate coefficients for the spline and the current data array.
            </summary>
    </member>
    <member name="P:PloobsEngine.Utils.Spline.CubicSpline.Dimensions">
      <summary>
            Gets the number of dimensions of the spline.
            </summary>
    </member>
    <member name="P:PloobsEngine.Utils.Spline.CubicSpline.Count">
      <summary>
            Gets the number of points in the spline.
            </summary>
    </member>
    <member name="P:PloobsEngine.Utils.Spline.CubicSpline.CanInterpolate">
      <summary>
            Gets a flag indicating wether sufficient points have been added
            so that interpolation can occur.
            </summary>
    </member>
    <member name="T:PloobsEngine.Utils.Interpolator`1">
      <summary>
            General Interpolator Base
            </summary>
      <typeparam name="T">
      </typeparam>
    </member>
    <member name="M:PloobsEngine.Utils.Interpolator`1.Start(`0,`0,System.Double)">
      <summary>
            Start the Interpolator
            </summary>
      <param name="value1">Value to Start interpolation from</param>
      <param name="value2">Value to interpolate to</param>
      <param name="totalDuration">Time to interpolate from value1 to value2 in seconds</param>
    </member>
    <member name="M:PloobsEngine.Utils.Interpolator`1.Start(`0,`0,System.Double,System.Boolean)">
      <summary>
            Start the interpolator
            </summary>
      <param name="value1">
      </param>
      <param name="value2">
      </param>
      <param name="totalDuration">
      </param>
      <param name="smoothStep">Use smoothstep rather than lerp</param>
    </member>
    <member name="M:PloobsEngine.Utils.Interpolator`1.Update(Microsoft.Xna.Framework.GameTime)">
      <summary>
            Update the interpolator
            </summary>
      <param name="gameTime">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:PloobsEngine.Utils.Interpolator`1.PeekValue(Microsoft.Xna.Framework.GameTime)">
      <summary>
            Peek the next interpolation value without affecting the next update
            </summary>
      <param name="gameTime">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:PloobsEngine.Utils.Interpolator`1.Reset">
      <summary>
            Reset the interpolator
            </summary>
    </member>
    <member name="M:PloobsEngine.Utils.Interpolator`1.Interpolate">
      <summary>
            Override to implement interpolation for a concrete data type
            </summary>
      <returns>
      </returns>
    </member>
    <member name="T:PloobsEngine.Trigger.ITrigger">
      <summary>
            Trigger Specification
            </summary>
    </member>
    <member name="P:PloobsEngine.Trigger.ITrigger.Event">
      <summary>
            Gets or sets the event fired when the trigger is activated.
            </summary>
      <value>
            The event.
            </value>
    </member>
    <member name="P:PloobsEngine.Trigger.ITrigger.Name">
      <summary>
            Gets or sets the name of the trigger.
            </summary>
      <value>
            The name.
            </value>
    </member>
    <member name="P:PloobsEngine.Trigger.ITrigger.GhostObject">
      <summary>
            Gets or sets the ghost object that gives the SHAPE of the trigger.
            </summary>
      <value>
            The ghost object.
            </value>
    </member>
    <member name="T:PloobsEngine.SceneControl.QuadRender">
      <summary>
            Helper class to render full screen quads
            VertexPositionTexture
            </summary>
    </member>
    <member name="M:PloobsEngine.SceneControl.QuadRender.#ctor(Microsoft.Xna.Framework.Graphics.GraphicsDevice)">
      <summary>
            Loads the quad.
            </summary>
      <param name="engine">The engine.</param>
    </member>
    <member name="M:PloobsEngine.SceneControl.QuadRender.DrawQuad(Microsoft.Xna.Framework.Graphics.Effect)">
      <summary>
            Draws the quad.
            </summary>
      <param name="effect">The effect.</param>
    </member>
    <member name="T:PloobsEngine.SceneControl.FogType">
      <summary>
            Fog Attenuation types
            </summary>
    </member>
    <member name="F:PloobsEngine.SceneControl.FogType.LINEAR">
      <summary>
            Linear decaiment
            </summary>
    </member>
    <member name="F:PloobsEngine.SceneControl.FogType.EXPONENCIAL">
      <summary>
            Exponencial decaiment
            </summary>
    </member>
    <member name="F:PloobsEngine.SceneControl.FogType.EXPONENCIALSQUARED">
      <summary>
            Squared Exponencial decaiment
            </summary>
    </member>
    <member name="T:PloobsEngine.SceneControl.FogPostEffect">
      <summary>
            Fog Post Effect
            </summary>
    </member>
    <member name="M:PloobsEngine.SceneControl.FogPostEffect.#ctor(System.Single,System.Single)">
      <summary>
            Create the Post Effect using Linear Fog
            </summary>
      <param name="nearPlane">
      </param>
      <param name="farPlane">
      </param>
    </member>
    <member name="M:PloobsEngine.SceneControl.FogPostEffect.#ctor(System.Single,PloobsEngine.SceneControl.FogType)">
      <summary>
            Create the post effect for using Exponencial or Exponencial Squared
            </summary>
      <param name="density">
      </param>
      <param name="type">
      </param>
    </member>
    <member name="M:PloobsEngine.SceneControl.FogPostEffect.#ctor(PloobsEngine.SceneControl.FogType)">
      <summary>
            Initializes a new instance of the <see cref="T:PloobsEngine.SceneControl.FogPostEffect" /> class.
            Set the density for Exponencial and Exponencial Squared and near/far plane for Linear
            </summary>
      <param name="type">The type.</param>
    </member>
    <member name="P:PloobsEngine.SceneControl.FogPostEffect.Density">
      <summary>
            Default 0.001f;
            </summary>
    </member>
    <member name="P:PloobsEngine.SceneControl.FogPostEffect.NearPlane">
      <summary>
            Gets or sets the near plane.
            Default 1
            </summary>
      <value>
            The near plane.
            </value>
    </member>
    <member name="P:PloobsEngine.SceneControl.FogPostEffect.FarPlane">
      <summary>
            Gets or sets the far plane.
            Default 1000
            </summary>
      <value>
            The far plane.
            </value>
    </member>
    <member name="T:PloobsEngine.Resources">
      <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
    </member>
    <member name="P:PloobsEngine.Resources.ResourceManager">
      <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
    </member>
    <member name="P:PloobsEngine.Resources.Culture">
      <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
    </member>
    <member name="T:PloobsEngine.Entity.EntityMapper">
      <summary>
            Manage all entities
            Responsable for setting the ids, managing tags and RecieverEntities    
            Its a singleton
            </summary>
    </member>
    <member name="M:PloobsEngine.Entity.EntityMapper.getInstance">
      <summary>
            Gets the instance.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:PloobsEngine.Entity.EntityMapper.AddEntity(PloobsEngine.Entity.IEntity)">
      <summary>
            Add and entity and sets its id
            </summary>
      <param name="Agente">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:PloobsEngine.Entity.EntityMapper.getEntity(System.Int32)">
      <summary>
            Return and entity by id
            </summary>
      <param name="id">id</param>
      <returns>
      </returns>
    </member>
    <member name="M:PloobsEngine.Entity.EntityMapper.getRecieveEntity(System.Int32)">
      <summary>
            return a RecieverMessageEntity by ID
            </summary>
      <param name="id">id</param>
      <returns>
      </returns>
    </member>
    <member name="M:PloobsEngine.Entity.EntityMapper.AddgrouptagRecieveEntity(System.String,System.Collections.Generic.IList{PloobsEngine.MessageSystem.IRecieveMessageEntity})">
      <summary>
            Add a list of RecieverMessageEntity 
            int a tag (id the tag do not exist , create it)
            </summary>
      <param name="tag">tag</param>
      <param name="Agente">agents list</param>
    </member>
    <member name="M:PloobsEngine.Entity.EntityMapper.RemovegrouptagRecieveEntity(System.String,PloobsEngine.MessageSystem.IRecieveMessageEntity)">
      <summary>
            Remove one IRecieveMessageEntity from a tag
            </summary>
      <param name="tag">
      </param>
      <param name="Agente">
      </param>
    </member>
    <member name="M:PloobsEngine.Entity.EntityMapper.AddgrouptagRecieveEntity(System.String,PloobsEngine.MessageSystem.IRecieveMessageEntity)">
      <summary>
            Add ont IrecieveMessageEntity int a tag(create the tag if sont exist)
            </summary>
      <param name="tag">
      </param>
      <param name="Agente">
      </param>
    </member>
    <member name="M:PloobsEngine.Entity.EntityMapper.GetTagRecieveEntity(System.String)">
      <summary>
            Return a list of RecieveEntities that has the parameter tag
            </summary>
      <param name="tag">tag</param>
      <returns>
      </returns>
    </member>
    <member name="M:PloobsEngine.Entity.EntityMapper.GetAllEntities">
      <summary>
            return all entities
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:PloobsEngine.Entity.EntityMapper.GetAllRecieveEntities">
      <summary>
            return all IRecieveMessageEntity entities
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:PloobsEngine.Entity.EntityMapper.CheckEntity(System.Int32)">
      <summary>
            Checks if entity with parameter id exist.
            </summary>
      <param name="id">The id.</param>
      <returns>
      </returns>
    </member>
    <member name="M:PloobsEngine.Entity.EntityMapper.RemoveEntity(System.Int32)">
      <summary>
            Remove the entity
            THE ID USED BY THIS ENTITY WILL NOT USED AGAIN (EVEN AFTER THE REMOVE)
            </summary>
      <param name="cod">id</param>
    </member>
    <member name="M:PloobsEngine.Entity.EntityMapper.ClearAllEntries">
      <summary>
            Clears all entries. (REMOVE ALL ENTITIES)
            RESET FUNCTION
            </summary>
    </member>
    <member name="M:PloobsEngine.Entity.EntityMapper.RemoveEntity(PloobsEngine.Entity.IEntity)">
      <summary>
            REMOVE AN ENTITY
            </summary>
      <param name="ent">
      </param>
    </member>
    <member name="T:PloobsEngine.PrincipalConstants">
      <summary>
            Here we have all the importants Engine Constants
            </summary>
    </member>
    <member name="F:PloobsEngine.PrincipalConstants.DefaultInitConfFileName">
      <summary>
            Where to search for the init conf file
            This funcionality is not on yet
            </summary>
    </member>
    <member name="F:PloobsEngine.PrincipalConstants.EventSenderId">
      <summary>
            Id used when an event send a message
            </summary>
    </member>
    <member name="F:PloobsEngine.PrincipalConstants.InvalidId">
      <summary>
            Invalid id constant
            </summary>
    </member>
    <member name="F:PloobsEngine.PrincipalConstants.MessageDeliverId">
      <summary>
            The messegeDeliver component id
            </summary>
    </member>
    <member name="F:PloobsEngine.PrincipalConstants.RecieverNotFound">
      <summary>
            Message recieved when the reciever is not found
            </summary>
    </member>
    <member name="F:PloobsEngine.PrincipalConstants.CombinedImage">
      <summary>
            the combined image alias (Post processing)
            </summary>
    </member>
    <member name="F:PloobsEngine.PrincipalConstants.CurrentImage">
      <summary>
            The current image alias (Post Processing)
            </summary>
    </member>
    <member name="F:PloobsEngine.PrincipalConstants.extra1RT">
      <summary>
            extra render target name
            </summary>
    </member>
    <member name="F:PloobsEngine.PrincipalConstants.colorRT">
      <summary>
            Color (diffuse) render target name
            </summary>
    </member>
    <member name="F:PloobsEngine.PrincipalConstants.normalRt">
      <summary>
            Normal render target name
            </summary>
    </member>
    <member name="F:PloobsEngine.PrincipalConstants.lightRt">
      <summary>
            Light Render target name
            </summary>
    </member>
    <member name="F:PloobsEngine.PrincipalConstants.DephRT">
      <summary>
            Depth Render target name
            </summary>
    </member>
    <member name="F:PloobsEngine.PrincipalConstants.SEPARATOR_CHARACTER">
      <summary>
            Separator character used when parsing files
            </summary>
    </member>
    <member name="F:PloobsEngine.PrincipalConstants.NotEffectByLightIdBiggerThan">
      <summary>
            SHADER ID bigger than this value is Not affect by light
            </summary>
    </member>
    <member name="T:PloobsEngine.DataStructure.IPriorityQueue`1">
      <summary>
            Priority queue specification
            </summary>
      <typeparam name="T">
      </typeparam>
    </member>
    <member name="M:PloobsEngine.DataStructure.IPriorityQueue`1.Push(`0)">
      <summary>
            Pushes the specified item.
            </summary>
      <param name="item">The item.</param>
      <returns>
      </returns>
    </member>
    <member name="M:PloobsEngine.DataStructure.IPriorityQueue`1.Pop">
      <summary>
            Pops an item.
            </summary>
      <returns>item popped</returns>
    </member>
    <member name="M:PloobsEngine.DataStructure.IPriorityQueue`1.Peek">
      <summary>
            Peeks the top
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:PloobsEngine.DataStructure.IPriorityQueue`1.Update(System.Int32)">
      <summary>
            Updates the specified item i.
            </summary>
      <param name="i">The i.</param>
    </member>
    <member name="T:PloobsEngine.DataStructure.PriorityQueueB`1">
      <summary>
            Priority queue implementation
            </summary>
      <typeparam name="T">
      </typeparam>
    </member>
    <member name="M:PloobsEngine.DataStructure.PriorityQueueB`1.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:PloobsEngine.DataStructure.PriorityQueueB`1" /> class.
            </summary>
    </member>
    <member name="M:PloobsEngine.DataStructure.PriorityQueueB`1.#ctor(System.Collections.Generic.IComparer{`0})">
      <summary>
            Initializes a new instance of the <see cref="T:PloobsEngine.DataStructure.PriorityQueueB`1" /> class.
            </summary>
      <param name="comparer">The comparer.</param>
    </member>
    <member name="M:PloobsEngine.DataStructure.PriorityQueueB`1.#ctor(System.Collections.Generic.IComparer{`0},System.Int32)">
      <summary>
            Initializes a new instance of the <see cref="T:PloobsEngine.DataStructure.PriorityQueueB`1" /> class.
            </summary>
      <param name="comparer">The comparer.</param>
      <param name="capacity">The capacity.</param>
    </member>
    <member name="M:PloobsEngine.DataStructure.PriorityQueueB`1.Push(`0)">
      <summary>
            Push an object onto the PQ
            </summary>
      <param name="O">The new object</param>
      <returns>The index in the list where the object is _now_. This will change when objects are taken from or put onto the PQ.</returns>
    </member>
    <member name="M:PloobsEngine.DataStructure.PriorityQueueB`1.Pop">
      <summary>
            Get the smallest object and remove it.
            </summary>
      <returns>The smallest object</returns>
    </member>
    <member name="M:PloobsEngine.DataStructure.PriorityQueueB`1.Update(System.Int32)">
      <summary>
            Notify the PQ that the object at position i has changed
            and the PQ needs to restore order.
            Since you dont have access to any indexes (except by using the
            explicit IList.this) you should not call this function without knowing exactly
            what you do.
            </summary>
      <param name="i">The index of the changed object.</param>
    </member>
    <member name="M:PloobsEngine.DataStructure.PriorityQueueB`1.Peek">
      <summary>
            Get the smallest object without removing it.
            </summary>
      <returns>The smallest object</returns>
    </member>
    <member name="M:PloobsEngine.DataStructure.PriorityQueueB`1.Clear">
      <summary>
            Clears this instance.
            </summary>
    </member>
    <member name="M:PloobsEngine.DataStructure.PriorityQueueB`1.RemoveLocation(`0)">
      <summary>
            Removes the item 
            </summary>
      <param name="item">The item.</param>
    </member>
    <member name="P:PloobsEngine.DataStructure.PriorityQueueB`1.Count">
      <summary>
            Gets number of entities.
            </summary>
    </member>
    <member name="P:PloobsEngine.DataStructure.PriorityQueueB`1.Item(System.Int32)">
      <summary>
            Gets or sets the <see cref="!:T" /> at the specified index.
            </summary>
    </member>
    <member name="T:PloobsEngine.DataStructure.CircularList`1">
      <summary>
            Circular List
            </summary>
      <typeparam name="T">
      </typeparam>
    </member>
    <member name="M:PloobsEngine.DataStructure.CircularList`1.#ctor(System.Int32)">
      <summary>
            Constructor that initializes the list with the 
            required number of items.
            </summary>
    </member>
    <member name="M:PloobsEngine.DataStructure.CircularList`1.Next">
      <summary>
            Advances to the next item or wraps to the first item.
            </summary>
    </member>
    <member name="M:PloobsEngine.DataStructure.CircularList`1.Clear">
      <summary>
            Clears the list, resetting the current index to the 
            beginning of the list and flagging the collection as unloaded.
            </summary>
    </member>
    <member name="M:PloobsEngine.DataStructure.CircularList`1.SetAll(`0)">
      <summary>
            Sets all items in the list to the specified value, resets
            the current index to the beginning of the list and flags the
            collection as loaded.
            </summary>
    </member>
    <member name="M:PloobsEngine.DataStructure.CircularList`1.RangeCheck(System.Int32)">
      <summary>
            Internal indexer range check helper.  Throws
            ArgumentOutOfRange exception if the index is not valid.
            </summary>
    </member>
    <member name="M:PloobsEngine.DataStructure.CircularList`1.Dispose">
      <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
    </member>
    <member name="M:PloobsEngine.DataStructure.CircularList`1.MoveNext">
      <summary>
            Advances the enumerator to the next element of the collection.
            </summary>
      <returns>
            true if the enumerator was successfully advanced to the next element; false if the enumerator has passed the end of the collection.
            </returns>
      <exception cref="T:System.InvalidOperationException">
            The collection was modified after the enumerator was created.
              </exception>
    </member>
    <member name="M:PloobsEngine.DataStructure.CircularList`1.Reset">
      <summary>
            Sets the enumerator to its initial position, which is before the first element in the collection.
            </summary>
      <exception cref="T:System.InvalidOperationException">
            The collection was modified after the enumerator was created.
              </exception>
    </member>
    <member name="P:PloobsEngine.DataStructure.CircularList`1.Value">
      <summary>
            Gets/sets the item value at the current index.
            </summary>
    </member>
    <member name="P:PloobsEngine.DataStructure.CircularList`1.Count">
      <summary>
            Returns the count of the number of loaded items, up to
            and including the total number of items in the collection.
            </summary>
    </member>
    <member name="P:PloobsEngine.DataStructure.CircularList`1.Length">
      <summary>
            Returns the length of the items array.
            </summary>
    </member>
    <member name="P:PloobsEngine.DataStructure.CircularList`1.Item(System.Int32)">
      <summary>
            Gets/sets the value at the specified index.
            </summary>
    </member>
    <member name="P:PloobsEngine.DataStructure.CircularList`1.Current">
      <summary>
            Gets the element in the collection at the current position of the enumerator.
            </summary>
      <returns>
            The element in the collection at the current position of the enumerator.
              </returns>
    </member>
    <member name="T:PloobsEngine.SceneControl.IDeferredLightMap">
      <summary>
            Deferred LightMap generation specification
            </summary>
    </member>
    <member name="M:PloobsEngine.SceneControl.IDeferredLightMap.SetLightMap(PloobsEngine.SceneControl.RenderHelper)">
      <summary>
            Sets the light map.
            </summary>
    </member>
    <member name="M:PloobsEngine.SceneControl.IDeferredLightMap.ResolveLightMap(PloobsEngine.SceneControl.RenderHelper)">
      <summary>
            Resolves the light map.
            </summary>
    </member>
    <member name="M:PloobsEngine.SceneControl.IDeferredLightMap.DrawLights(Microsoft.Xna.Framework.GameTime,PloobsEngine.SceneControl.IWorld,PloobsEngine.SceneControl.IDeferredGBuffer,PloobsEngine.SceneControl.RenderHelper)">
      <summary>
            Draws the lights.
            Perform the light pass
            </summary>
      <param name="gameTime">The game time.</param>
      <param name="world">The world.</param>
      <param name="deferredGBuffer">The deferred G buffer.</param>
    </member>
    <member name="M:PloobsEngine.SceneControl.IDeferredLightMap.LoadContent(PloobsEngine.SceneControl.IContentManager,PloobsEngine.Engine.GraphicInfo,PloobsEngine.Engine.GraphicFactory,System.Boolean,System.Boolean)">
      <summary>
            Loads the content.
            </summary>
      <param name="engine">The engine.</param>
      <param name="useFloatBuffer">if set to <c>true</c> [use float buffer].</param>
    </member>
    <member name="P:PloobsEngine.SceneControl.IDeferredLightMap.Item(PloobsEngine.SceneControl.DeferredLightMapType)">
      <summary>
            Get the generated Images by this pass
            </summary>
    </member>
    <member name="T:PloobsEngine.SceneControl.DeferredLightMapType">
      <summary>
            Generated Buffers by the lightmap pass
            </summary>
    </member>
    <member name="F:PloobsEngine.SceneControl.DeferredLightMapType.LIGHTMAP">
      <summary>
            LightMap
            </summary>
    </member>
    <member name="T:PloobsEngine.SceneControl.IScreen">
      <summary>
            IScreen, base class for all screens
            </summary>
    </member>
    <member name="M:PloobsEngine.SceneControl.IScreen.#ctor(PloobsEngine.SceneControl.GUI.IGui)">
      <summary>
            Initializes a new instance of the <see cref="T:PloobsEngine.SceneControl.IScreen" /> class.
            </summary>
      <param name="gui">The GUI Component, if null you cant use GUI in this screen.</param>
    </member>
    <member name="M:PloobsEngine.SceneControl.IScreen.BindInput(PloobsEngine.Input.InputPlayableKeyBoard)">
      <summary>
            Binds the KeyBoard input.
            </summary>
      <param name="ipk">The InputPlayableKeyBoard.</param>
    </member>
    <member name="M:PloobsEngine.SceneControl.IScreen.BindInput(PloobsEngine.Input.InputPlaybleMouseBottom)">
      <summary>
            Binds the MouseBottom input.
            </summary>
      <param name="ipk">The InputPlaybleMouseBottom.</param>
    </member>
    <member name="M:PloobsEngine.SceneControl.IScreen.BindInput(PloobsEngine.Input.InputPlaybleMousePosition)">
      <summary>
            Binds the MousePosition input.
            </summary>
      <param name="ipk">The InputPlaybleMousePosition.</param>
    </member>
    <member name="M:PloobsEngine.SceneControl.IScreen.RemoveInputBinding(PloobsEngine.Input.InputPlayableKeyBoard)">
      <summary>
            Removes the KeyBoard binding.
            </summary>
      <param name="ipk">The InputPlayableKeyBoard.</param>
    </member>
    <member name="M:PloobsEngine.SceneControl.IScreen.RemoveInputBinding(PloobsEngine.Input.InputPlaybleMouseBottom)">
      <summary>
            Removes the MouseBottom binding.
            </summary>
      <param name="ipk">The InputPlaybleMouseBottom.</param>
    </member>
    <member name="M:PloobsEngine.SceneControl.IScreen.RemoveInputBinding(PloobsEngine.Input.InputPlaybleMousePosition)">
      <summary>
            Removes the MousePosition bindings.
            </summary>
      <param name="ipk">The InputPlaybleMousePosition.</param>
    </member>
    <member name="M:PloobsEngine.SceneControl.IScreen.AddScreenUpdateable(PloobsEngine.IScreenUpdateable)">
      <summary>
            Attach one IScreenUpdateable to this screen
            </summary>
      <param name="updateable">The updateable.</param>
    </member>
    <member name="M:PloobsEngine.SceneControl.IScreen.RemoveScreenUpdateable(PloobsEngine.IScreenUpdateable,System.Boolean)">
      <summary>
            Removes the IScreenUpdateable.
            </summary>
      <param name="updateable">The updateable.</param>
      <param name="callCleanUp">if set to <c>true</c> [call clean up].</param>
    </member>
    <member name="M:PloobsEngine.SceneControl.IScreen.LoadContent(PloobsEngine.Engine.GraphicInfo,PloobsEngine.Engine.GraphicFactory,PloobsEngine.SceneControl.IContentManager)">
      <summary>
            Load graphics content for the screen.
            </summary>
    </member>
    <member name="M:PloobsEngine.SceneControl.IScreen.InitScreen(PloobsEngine.Engine.GraphicInfo,PloobsEngine.Engine.EngineStuff)">
      <summary>
            Init Screen
            </summary>
      <param name="GraphicInfo">The graphic info.</param>
      <param name="engine">The engine.</param>
    </member>
    <member name="M:PloobsEngine.SceneControl.IScreen.AfterLoadContent(PloobsEngine.SceneControl.IContentManager,PloobsEngine.Engine.GraphicInfo,PloobsEngine.Engine.GraphicFactory)">
      <summary>
            Called after all the screens LoadContent is called
            </summary>
    </member>
    <member name="M:PloobsEngine.SceneControl.IScreen.Update(Microsoft.Xna.Framework.GameTime)">
      <summary>
            Update the Screen
            </summary>
    </member>
    <member name="M:PloobsEngine.SceneControl.IScreen.Draw(Microsoft.Xna.Framework.GameTime,PloobsEngine.SceneControl.RenderHelper)">
      <summary>
            This is called when the screen should draw itself.
            </summary>
    </member>
    <member name="M:PloobsEngine.SceneControl.IScreen.CleanUp(PloobsEngine.Engine.EngineStuff)">
      <summary>
            Cleans up resources that dont are exclusive of the screen        
            </summary>
    </member>
    <member name="P:PloobsEngine.SceneControl.IScreen.Gui">
      <summary>
            Gets the GUI interface.
            REMEMBER, you need to provide an implementation in the Screen Constructor, if you dont, you cant access this property
            </summary>
    </member>
    <member name="P:PloobsEngine.SceneControl.IScreen.ScreenState">
      <summary>
            Gets or sets the state of the screen.
            </summary>
      <value>
            The state of the screen.
            </value>
    </member>
    <member name="P:PloobsEngine.SceneControl.IScreen.ScreenManager">
      <summary>
            Gets the manager that this screen belongs to.
            </summary>
    </member>
    <member name="P:PloobsEngine.SceneControl.IScreen.GraphicInfo">
      <summary>
            Gets the graphic info.
            </summary>
    </member>
    <member name="P:PloobsEngine.SceneControl.IScreen.GraphicFactory">
      <summary>
            Gets the graphic factory.
            </summary>
    </member>
    <member name="T:Bnoerj.AI.Steering.LocalityQueryProximityDatabase`1">
      <summary>
            A AbstractProximityDatabase-style wrapper for the LQ bin lattice system
            </summary>
    </member>
    <member name="T:Bnoerj.AI.Steering.ILocalSpace">
      <summary>
            A local coordinate system for 3d space
            <para>
            Provides functionality such as transforming from local space to global
            space and vice versa.  Also regenerates a valid space from a perturbed
            "forward vector" which is the basis of abnstract vehicle turning.
            </para><para>
            These are comparable to a 4x4 homogeneous transformation matrix where the
            3x3 (R) portion is constrained to be a pure rotation (no shear or scale).
            The rows of the 3x3 R matrix are the basis vectors of the space.  They are
            all constrained to be mutually perpendicular and of unit length.  The top
            ("x") row is called "side", the middle ("y") row is called "up" and the
            bottom ("z") row is called forward.  The translation vector is called
            "position".  Finally the "homogeneous column" is always [0 0 0 1].
            </para><code>
            [ R R R  0 ]      [ Sx Sy Sz  0 ]
            [ R R R  0 ]      [ Ux Uy Uz  0 ]
            [ R R R  0 ]  -&gt;  [ Fx Fy Fz  0 ]
            [          ]      [             ]
            [ T T T  1 ]      [ Tx Ty Tz  1 ]
            </code></summary>
    </member>
    <member name="M:Bnoerj.AI.Steering.ILocalSpace.ResetLocalSpace">
      <summary>
            Resets the transform to identity.
            </summary>
    </member>
    <member name="M:Bnoerj.AI.Steering.ILocalSpace.LocalizeDirection(Microsoft.Xna.Framework.Vector3)">
      <summary>
            Transforms a direction in global space to its equivalent in local space.
            </summary>
      <param name="globalDirection">The global space direction to transform.</param>
      <returns>The global space direction transformed to local space .</returns>
    </member>
    <member name="M:Bnoerj.AI.Steering.ILocalSpace.LocalizePosition(Microsoft.Xna.Framework.Vector3)">
      <summary>
            Transforms a point in global space to its equivalent in local space.
            </summary>
      <param name="globalPosition">The global space position to transform.</param>
      <returns>The global space position transformed to local space.</returns>
    </member>
    <member name="M:Bnoerj.AI.Steering.ILocalSpace.GlobalizeDirection(Microsoft.Xna.Framework.Vector3)">
      <summary>
            Transforms a direction in local space to its equivalent in global space.
            </summary>
      <param name="localDirection">The local space direction to tranform.</param>
      <returns>The local space direction transformed to global space</returns>
    </member>
    <member name="M:Bnoerj.AI.Steering.ILocalSpace.GlobalizePosition(Microsoft.Xna.Framework.Vector3)">
      <summary>
            Transforms a point in local space to its equivalent in global space.
            </summary>
      <param name="localPosition">The local space position to tranform.</param>
      <returns>The local space position transformed to global space.</returns>
    </member>
    <member name="M:Bnoerj.AI.Steering.ILocalSpace.SetUnitSideFromForwardAndUp">
      <summary>
            Sets the "side" basis vector to normalized cross product of forward and up.
            </summary>
    </member>
    <member name="M:Bnoerj.AI.Steering.ILocalSpace.RegenerateOrthonormalBasisUF(Microsoft.Xna.Framework.Vector3)">
      <summary>
            Regenerates the orthonormal basis vectors given a new forward.
            </summary>
      <param name="newUnitForward">The new unit-length forward.</param>
    </member>
    <member name="M:Bnoerj.AI.Steering.ILocalSpace.RegenerateOrthonormalBasis(Microsoft.Xna.Framework.Vector3)">
      <summary>
            Regenerates the orthonormal basis vectors given a new forward.
            </summary>
      <param name="newForward">The new forward.</param>
    </member>
    <member name="M:Bnoerj.AI.Steering.ILocalSpace.RegenerateOrthonormalBasis(Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3)">
      <summary>
            Regenerates the orthonormal basis vectors given a new forward and up.
            </summary>
      <param name="newForward">The new forward.</param>
      <param name="newUp">The new up.</param>
    </member>
    <member name="M:Bnoerj.AI.Steering.ILocalSpace.LocalRotateForwardToSide(Microsoft.Xna.Framework.Vector3)">
      <summary>
            Rotates, in the canonical direction, a vector pointing in the
            "forward" (+Z) direction to the "side" (+/-X) direction as implied
            by IsRightHanded.
            </summary>
      <param name="value">The local space vector.</param>
      <returns>The rotated vector.</returns>
    </member>
    <member name="M:Bnoerj.AI.Steering.ILocalSpace.GlobalRotateForwardToSide(Microsoft.Xna.Framework.Vector3)">
      <summary>
            Rotates, in the canonical direction, a vector pointing in the
            "forward" (+Z) direction to the "side" (+/-X) direction as implied
            by IsRightHanded.
            </summary>
      <param name="value">The global space forward.</param>
      <returns>The rotated vector.</returns>
    </member>
    <member name="P:Bnoerj.AI.Steering.ILocalSpace.Side">
      <summary>
            Gets or sets the side.
            </summary>
    </member>
    <member name="P:Bnoerj.AI.Steering.ILocalSpace.Up">
      <summary>
            Gets or sets the up.
            </summary>
    </member>
    <member name="P:Bnoerj.AI.Steering.ILocalSpace.Forward">
      <summary>
            Gets or sets the forward.
            </summary>
    </member>
    <member name="P:Bnoerj.AI.Steering.ILocalSpace.Position">
      <summary>
            Gets or sets the position.
            </summary>
    </member>
    <member name="P:Bnoerj.AI.Steering.ILocalSpace.IsRightHanded">
      <summary>
            Indicates whether the local space is right handed.
            </summary>
    </member>
    <member name="T:Bnoerj.AI.Steering.LocalSpace">
      <summary>
            LocalSpaceMixin is a mixin layer, a class template with a paramterized base
            class.  Allows "LocalSpace-ness" to be layered on any class.
            </summary>
    </member>
    <member name="T:PloobsEngine.Modelo.BilboardInstance">
      <summary>
            Represent each bilboard
            </summary>
    </member>
    <member name="M:PloobsEngine.Modelo.InstancedBilboardModel.#ctor(PloobsEngine.Engine.GraphicFactory,System.String,System.String,PloobsEngine.Modelo.BilboardInstance[])">
      <summary>
            Initializes a new instance of the <see cref="T:PloobsEngine.Modelo.InstancedBilboardModel" /> class.
            </summary>
      <param name="factory">The factory.</param>
      <param name="BilboardsName">Name of the bilboards.</param>
      <param name="diffuseTextuteName">Name of the diffuse textute.</param>
      <param name="instances">The instances.</param>
    </member>
    <member name="M:PloobsEngine.Modelo.InstancedBilboardModel.SetBilboardInstances(PloobsEngine.Modelo.BilboardInstance[])">
      <summary>
            Sets the bilboard instances.
            </summary>
      <param name="instances">The instances.</param>
    </member>
    <member name="M:PloobsEngine.Modelo.InstancedBilboardModel.GetBilboardInstances">
      <summary>
            Gets the bilboard instances.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="T:PloobsEngine.Commands.ICommand">
      <summary>
            Command Pattern
            Its a Class that encapsulates a function call
            </summary>
    </member>
    <member name="M:PloobsEngine.Commands.ICommand.execute">
      <summary>
            Executes the command Call.
            </summary>
    </member>
    <member name="M:PloobsEngine.Commands.ICommand.setTarget(System.Object)">
      <summary>
            Sets the command target.
            </summary>
      <param name="obj">The obj.</param>
    </member>
    <member name="P:PloobsEngine.Commands.ICommand.TargetName">
      <summary>
            Gets the name of the command target.
            </summary>
      <value>
            The name of the target.
            </value>
    </member>
    <member name="T:PloobsEngine.Features.TaskCommand">
      <summary>
            Command that encapsulates a task
            </summary>
    </member>
    <member name="M:PloobsEngine.Features.TaskCommand.#ctor(PloobsEngine.Features.ITask)">
      <summary>
            Initializes a new instance of the <see cref="T:PloobsEngine.Features.TaskCommand" /> class.
            </summary>
      <param name="task">The task.</param>
    </member>
    <member name="M:PloobsEngine.Features.TaskCommand.execute">
      <summary>
            Executes the command Call.
            </summary>
    </member>
    <member name="M:PloobsEngine.Features.TaskCommand.setTarget(System.Object)">
      <summary>
            Sets the command target.
            </summary>
      <param name="obj">The obj.</param>
    </member>
    <member name="P:PloobsEngine.Features.TaskCommand.TargetName">
      <summary>
            Gets the name of the command target.
            </summary>
      <value>
            The name of the target.
            </value>
    </member>
    <member name="T:PloobsEngine.Features.ITask">
      <summary>
            Specification of a task
            Task is a class that operates in ANOTHER THREAD    
            </summary>
    </member>
    <member name="M:PloobsEngine.Features.ITask.Result(System.IAsyncResult)">
      <summary>
            Called when the task ends
            </summary>
      <param name="result">The result.</param>
    </member>
    <member name="M:PloobsEngine.Features.ITask.Process">
      <summary>
            Processes the task.
            </summary>
    </member>
    <member name="T:PloobsEngine.Commands.IReciever">
      <summary>
            Specification for everyone that recieves ICommands    
            </summary>
    </member>
    <member name="M:PloobsEngine.Commands.IReciever.getMyName">
      <summary>
            The name of the reciever
            MUST BE UNIQUE
            </summary>
      <returns>
      </returns>
    </member>
    <member name="T:PloobsEngine.Entity.IEntity">
      <summary>
            Represents a generic entity
            </summary>
    </member>
    <member name="M:PloobsEngine.Entity.IEntity.GetId">
      <summary>
            return the entity id
            </summary>
      <returns>the id</returns>
    </member>
    <member name="M:PloobsEngine.Entity.IEntity.SetId(System.Int32)">
      <summary>
            sets the id
            </summary>
      <param name="id">
      </param>
    </member>
    <member name="T:PloobsEngine.Components.IComponent">
      <summary>
            Component Specification
            Components can Recieve Commands and send messages
            Designed to be VERY low coupled
            </summary>
    </member>
    <member name="M:PloobsEngine.Components.IComponent.Initialize">
      <summary>
            Initializes this instance.
            </summary>
    </member>
    <member name="M:PloobsEngine.Components.IComponent.Update(Microsoft.Xna.Framework.GameTime)">
      <summary>
            Update
            Its called deppending of the ComponentType
            </summary>
      <param name="gt">The gt.</param>
    </member>
    <member name="M:PloobsEngine.Components.IComponent.PreDraw(PloobsEngine.SceneControl.RenderHelper,Microsoft.Xna.Framework.GameTime,Microsoft.Xna.Framework.Matrix,Microsoft.Xna.Framework.Matrix)">
      <summary>
            Pres draw.
            Its called deppending of the ComponentType
            </summary>
      <param name="gt">The gt.</param>
      <param name="activeView">The active view.</param>
      <param name="activeProjection">The active projection.</param>
    </member>
    <member name="M:PloobsEngine.Components.IComponent.PosWithDepthDraw(PloobsEngine.SceneControl.RenderHelper,Microsoft.Xna.Framework.GameTime,Microsoft.Xna.Framework.Matrix,Microsoft.Xna.Framework.Matrix)">
      <summary>
            Pos With Depth draw.
            Its called deppending of the ComponentType
            </summary>
      <param name="gt">The gt.</param>
      <param name="activeView">The active view.</param>
      <param name="activeProjection">The active projection.</param>
    </member>
    <member name="M:PloobsEngine.Components.IComponent.AfterDraw(PloobsEngine.SceneControl.RenderHelper,Microsoft.Xna.Framework.GameTime,Microsoft.Xna.Framework.Matrix,Microsoft.Xna.Framework.Matrix)">
      <summary>
            Afters draw.
            Its called deppending of the ComponentType
            </summary>
      <param name="gt">The gt.</param>
      <param name="activeView">The active view.</param>
      <param name="activeProjection">The active projection.</param>
    </member>
    <member name="M:PloobsEngine.Components.IComponent.LoadContent(PloobsEngine.Engine.GraphicInfo,PloobsEngine.Engine.GraphicFactory)">
      <summary>
            Loads the content.
            </summary>
      <param name="engine">The engine.</param>
    </member>
    <member name="M:PloobsEngine.Components.IComponent.GetId">
      <summary>
            return the entity id
            </summary>
      <returns>
            the id
            </returns>
    </member>
    <member name="M:PloobsEngine.Components.IComponent.SetId(System.Int32)">
      <summary>
            sets the id
            </summary>
      <param name="id">
      </param>
    </member>
    <member name="P:PloobsEngine.Components.IComponent.ComponentType">
      <summary>
            Gets the type of the component type.
            </summary>
      <value>
            The type of the component.
            </value>
    </member>
    <member name="T:PloobsEngine.Features.SkyBox">
      <summary>
            SkyBox Component
            </summary>
    </member>
    <member name="T:PloobsEngine.Commands.CommandProcessor">
      <summary>
            Reponsible for sending Commands
            </summary>
    </member>
    <member name="M:PloobsEngine.Commands.CommandProcessor.getCommandProcessor">
      <summary>
            Gets the command processor.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:PloobsEngine.Commands.CommandProcessor.SendCommandSyncronous(PloobsEngine.Commands.ICommand,System.String)">
      <summary>
            Send a command NOW
            </summary>
      <param name="command">The command.</param>
      <param name="recieverId">The reciever id.</param>
    </member>
    <member name="M:PloobsEngine.Commands.CommandProcessor.SendCommandSyncronous(PloobsEngine.Commands.ICommand)">
      <summary>
            Sends a command Now
            </summary>
      <param name="command">The command.</param>
    </member>
    <member name="M:PloobsEngine.Commands.CommandProcessor.SendCommandAssyncronous(PloobsEngine.Commands.ICommand,System.String)">
      <summary>
            Schedules a Command to be send when possible
            </summary>
      <param name="command">The command.</param>
      <param name="recieverId">The reciever id.</param>
    </member>
    <member name="M:PloobsEngine.Commands.CommandProcessor.SendCommandAssyncronous(PloobsEngine.Commands.ICommand)">
      <summary>
            Schedules a Command to be send when possible
            </summary>
      <param name="command">The command.</param>
    </member>
    <member name="M:PloobsEngine.Commands.CommandProcessor.ProcessCommands">
      <summary>
            Process the Assyncronous Commands        
            </summary>
    </member>
    <member name="M:PloobsEngine.Commands.CommandProcessor.Register(PloobsEngine.Commands.IReciever)">
      <summary>
            Registers the specified reciever.
            </summary>
      <param name="rec">The rec.</param>
    </member>
    <member name="M:PloobsEngine.Commands.CommandProcessor.UnRegister(PloobsEngine.Commands.IReciever)">
      <summary>
            Unregister a specified reciever
            </summary>
      <param name="rec">The rec.</param>
    </member>
    <member name="P:PloobsEngine.IA.IMap.Waypoints">
      <summary>
            Waypoints do Mapa
            </summary>
    </member>
    <member name="T:PloobsEngine.IA.NeuralNetwork.Layer">
      <summary>
            A layer of neurone in a neuronal network
            </summary>
      <remarks>
        <code>
                        / N1 -----&gt;        OUTPUTS
            INPUTS ===&gt; - N2 -----&gt;  (1 output for each 
                        \ Ni -----&gt;  neuron of the layer)
            </code>       
            Each neuron of the layer has the same number of
            inputs, this is the number of inputs of the layer
            itself.
            </remarks>
    </member>
    <member name="F:PloobsEngine.IA.NeuralNetwork.Layer.nn">
      <summary>
            Number of neurons in the layer
            </summary>
    </member>
    <member name="F:PloobsEngine.IA.NeuralNetwork.Layer.ni">
      <summary>
            Number of inputs of the layer
            </summary>
    </member>
    <member name="F:PloobsEngine.IA.NeuralNetwork.Layer.neurons">
      <summary>
            Neurons of the layer
            </summary>
    </member>
    <member name="F:PloobsEngine.IA.NeuralNetwork.Layer.output">
      <summary>
            Last output of the layer
            </summary>
    </member>
    <member name="M:PloobsEngine.IA.NeuralNetwork.Layer.#ctor(System.Int32,System.Int32,PloobsEngine.IA.NeuralNetwork.ActivationFunction)">
      <summary>
            Build a new Layer with neurons neurones. Every neuron 
            has "inputs" inputs and the activation function f.
            </summary>
      <param name="inputs">Number of inputs</param>
      <param name="neurons">Number of neurons</param>
      <param name="f">Activation function of each neuron</param>
    </member>
    <member name="M:PloobsEngine.IA.NeuralNetwork.Layer.#ctor(System.Int32,System.Int32)">
      <summary>
            Build a new Layer with neurons neurones. Every neuron 
            has "inputs" inputs and the sigmoid activation function.
            </summary>
      <param name="inputs">Number of inputs</param>
      <param name="neurons">Number of neurons</param>
    </member>
    <member name="M:PloobsEngine.IA.NeuralNetwork.Layer.setActivationFunction(PloobsEngine.IA.NeuralNetwork.ActivationFunction)">
      <summary>
            Set the activation function f to all neurons of the layer
            </summary>
      <param name="f">An activation function</param>
    </member>
    <member name="M:PloobsEngine.IA.NeuralNetwork.Layer.randomizeWeight">
      <summary>
            Randomize all neurons weights
            </summary>
    </member>
    <member name="M:PloobsEngine.IA.NeuralNetwork.Layer.randomizeThreshold">
      <summary>
            Randomize all neurons thresholds
            </summary>
    </member>
    <member name="M:PloobsEngine.IA.NeuralNetwork.Layer.randomizeAll">
      <summary>
            Randomize all neurons threshold and weights
            </summary>
    </member>
    <member name="M:PloobsEngine.IA.NeuralNetwork.Layer.setRandomizationInterval(System.Single,System.Single)">
      <summary>
            Set the randomization interval for all neurons
            </summary>
      <param name="min">the minimum value</param>
      <param name="max">the maximum value</param>
    </member>
    <member name="M:PloobsEngine.IA.NeuralNetwork.Layer.Output(System.Single[])">
      <summary>
            Compute output of the layer.
            The output vector contains the output of each 
            neuron of the layer.
            </summary>
      <param name="input">input of the layer (size must be N_inputs)</param>
      <returns>the output vector (size = N_neurons)</returns>
    </member>
    <member name="P:PloobsEngine.IA.NeuralNetwork.Layer.N_Neurons">
      <summary>
            Number of neurons in this layer
            </summary>
    </member>
    <member name="P:PloobsEngine.IA.NeuralNetwork.Layer.N_Inputs">
      <summary>
            Number of inputs of this layer
            </summary>
    </member>
    <member name="P:PloobsEngine.IA.NeuralNetwork.Layer.Item(System.Int32)">
      <summary>
            Indexer of layer's neurons
            </summary>
    </member>
    <member name="P:PloobsEngine.IA.NeuralNetwork.Layer.Last_Output">
      <summary>
            Return last output vector of the layer
            </summary>
    </member>
    <member name="T:PloobsEngine.Utils.Spline.UnitTestSpline">
      <summary>
            Unit tests for CubicSpline class.
            </summary>
    </member>
    <member name="M:PloobsEngine.Utils.Spline.UnitTestSpline.SplineExceptionOnNoPointsAdded">
      <summary>
            Test exception when trying to interpolate with no points added.
            </summary>
    </member>
    <member name="M:PloobsEngine.Utils.Spline.UnitTestSpline.SplineExceptionOnOnlyOnePointAdded">
      <summary>
            Test exception when trying to interpolate with only one point added.
            </summary>
    </member>
    <member name="M:PloobsEngine.Utils.Spline.UnitTestSpline.SplineExceptionInvalidDimension">
      <summary>
            Test exception when trying to create spline with wrong dimension.
            </summary>
    </member>
    <member name="M:PloobsEngine.Utils.Spline.UnitTestSpline.SplineExceptionAddingWithDimensionMismatch">
      <summary>
            Test exception when trying to add points with the wrong dimension.
            </summary>
    </member>
    <member name="M:PloobsEngine.Utils.Spline.UnitTestSpline.SplineExceptionOnOnlyTwoPointsAdded">
      <summary>
            Test exception when trying to interpolate with only two points added.
            </summary>
    </member>
    <member name="M:PloobsEngine.Utils.Spline.UnitTestSpline.SplineExceptionOnOnlyThreePointsAdded">
      <summary>
            Test exception when trying to interpolate with only three points added.
            </summary>
    </member>
    <member name="M:PloobsEngine.Utils.Spline.UnitTestSpline.SplineInterpolateFourPointLine">
      <summary>
            Interpolate between 4 points forming a straight line.
            </summary>
    </member>
    <member name="M:PloobsEngine.Utils.Spline.UnitTestSpline.SplineRejectDuplicatePointsWhenAdding">
      <summary>
            Validate that adding duplicate x coordinates will reject the data.
            </summary>
    </member>
    <member name="M:PloobsEngine.Utils.Spline.UnitTestSpline.SplineCanClearDataArrayThenAddAndInterpolate">
      <summary>
            Validate that the data array can be cleared.
            </summary>
    </member>
    <member name="M:PloobsEngine.Utils.Spline.UnitTestSpline.SplineInterpolateFourPointShape">
      <summary>
            Interpolate between 4 points forming Z shape.
            </summary>
    </member>
    <member name="M:PloobsEngine.Utils.Spline.UnitTestSpline.SplineInterpolateFourPointShape2D">
      <summary>
            Interpolate between 4 points forming Z shape in two dimensions.
            </summary>
    </member>
    <member name="M:PloobsEngine.Utils.Spline.UnitTestSpline.SplineInterpolatePastEdgeOfFourPointShape">
      <summary>
            Interpolate left and right of the 4 points forming a Z shape.
            </summary>
    </member>
    <member name="M:PloobsEngine.Utils.Spline.UnitTestSpline.SplineInterpolateSineWave">
      <summary>
            Interpolate points along a sine wave approximated with 12 points.
            </summary>
    </member>
    <member name="T:PloobsEngine.SceneControl.IRenderTechnic">
      <summary>
            Specification of a Render Technic
            </summary>
    </member>
    <member name="F:PloobsEngine.SceneControl.IRenderTechnic.PostEffects">
      <summary>
            List off all PostEffects
            </summary>
    </member>
    <member name="M:PloobsEngine.SceneControl.IRenderTechnic.AddPostEffect(PloobsEngine.SceneControl.IPostEffect)">
      <summary>
            Adds one post effect.
            </summary>
      <param name="postEffect">The post effect.</param>
    </member>
    <member name="M:PloobsEngine.SceneControl.IRenderTechnic.RemovePostEffect(PloobsEngine.SceneControl.IPostEffect)">
      <summary>
            Removes one post effect.
            </summary>
      <param name="postEffect">The post effect.</param>
    </member>
    <member name="M:PloobsEngine.SceneControl.IRenderTechnic.ContainsPostEffect(PloobsEngine.SceneControl.IPostEffect)">
      <summary>
            Determines whether [contains post effect] [the specified post effect].
            </summary>
      <param name="postEffect">The post effect.</param>
      <returns>
        <c>true</c> if [contains post effect] [the specified post effect]; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="M:PloobsEngine.SceneControl.IRenderTechnic.BeforeFirstExecution(PloobsEngine.SceneControl.RenderHelper,PloobsEngine.SceneControl.IWorld)">
      <summary>
            Befores the first execution.
            </summary>
      <param name="render">The render.</param>
      <param name="world">The world.</param>
    </member>
    <member name="M:PloobsEngine.SceneControl.IRenderTechnic.ExecuteTechnic(Microsoft.Xna.Framework.GameTime,PloobsEngine.SceneControl.RenderHelper,PloobsEngine.SceneControl.IWorld)">
      <summary>
            Executes the technic.
            </summary>
      <param name="render">The render.</param>
      <param name="world">The world.</param>
    </member>
    <member name="M:PloobsEngine.SceneControl.IRenderTechnic.AfterLoadContent(PloobsEngine.SceneControl.IContentManager,PloobsEngine.Engine.GraphicInfo,PloobsEngine.Engine.GraphicFactory)">
      <summary>
            Called after the All the Engine stuffs are loaded
            </summary>
    </member>
    <member name="P:PloobsEngine.SceneControl.IRenderTechnic.TechnicName">
      <summary>
            Gets the name of the technic.
            </summary>
      <value>
            The name of the technic.
            </value>
    </member>
    <member name="T:PloobsEngine.SceneControl.GammaCorrectionPostEffect">
      <summary>
            OLHAR http://mynameismjp.wordpress.com/2009/12/31/correcting-xnas-gamma-correction/
            SOLUCAO MAIS ELEGANTE PARA PCS --  mudar o render state pelo effect apos o ultimo efeito aplicado
            </summary>
    </member>
    <member name="P:PloobsEngine.SceneControl.AntiAliasingPostEffect.Weight">
      <summary>
            Default 1
            Bigger value, bigger the effect
            </summary>
    </member>
    <member name="P:PloobsEngine.SceneControl.AntiAliasingPostEffect.PixelSizeMultiplier">
      <summary>
            Default 1
            Change only if you Know what are you doing
            </summary>
    </member>
    <member name="T:PloobsEngine.SceneControl.IDummy">
      <summary>
            Specification of a Dummy
            Dummy is everything that can be put in a world and recovered later
            Its NOT USED by the engine for nothing (the engine just keep it there)
            Usefull to pass information from an editor to the game, cause dummies
            are serializable
            </summary>
    </member>
    <member name="T:PloobsEngine.Modelo.BatchType">
      <summary>
            Batch Type
            </summary>
    </member>
    <member name="F:PloobsEngine.Modelo.BatchType.INDEXED">
      <summary>
            Draw Indexed
            </summary>
    </member>
    <member name="F:PloobsEngine.Modelo.BatchType.NORMAL">
      <summary>
            Draw without index
            </summary>
    </member>
    <member name="F:PloobsEngine.Modelo.BatchType.INSTANCED">
      <summary>
            Draw Instanced Geometry
            </summary>
    </member>
    <member name="T:PloobsEngine.Modelo.BatchInformation">
      <summary>
            Batch Information
            Contains Draw data from a model (vertices, indexes) and info about how to draw them
            The use should just use the Constructor to change Data, dont use the accessor public methods
            </summary>
    </member>
    <member name="F:PloobsEngine.Modelo.BatchInformation.InstanceCount">
      <summary>
            For Instancing, the number of objects
            </summary>
    </member>
    <member name="F:PloobsEngine.Modelo.BatchInformation.PrimitiveType">
      <summary>
            Primitive Type
            </summary>
    </member>
    <member name="F:PloobsEngine.Modelo.BatchInformation.BatchType">
      <summary>
            Batch Type
            </summary>
    </member>
    <member name="F:PloobsEngine.Modelo.BatchInformation.BaseVertex">
      <summary>
            Base Verter
            </summary>
    </member>
    <member name="F:PloobsEngine.Modelo.BatchInformation.NumVertices">
      <summary>
            Num Vertices
            </summary>
    </member>
    <member name="F:PloobsEngine.Modelo.BatchInformation.PrimitiveCount">
      <summary>
            Primitive COunt
            </summary>
    </member>
    <member name="F:PloobsEngine.Modelo.BatchInformation.StartIndex">
      <summary>
            Start Index
            </summary>
    </member>
    <member name="F:PloobsEngine.Modelo.BatchInformation.StartVertex">
      <summary>
            Start Vertex
            </summary>
    </member>
    <member name="F:PloobsEngine.Modelo.BatchInformation.StreamOffset">
      <summary>
            Stream Offset
            </summary>
    </member>
    <member name="F:PloobsEngine.Modelo.BatchInformation.VertexDeclaration">
      <summary>
            Vertex Declaration
            </summary>
    </member>
    <member name="F:PloobsEngine.Modelo.BatchInformation.VertexStride">
      <summary>
            VertexStride
            </summary>
    </member>
    <member name="F:PloobsEngine.Modelo.BatchInformation.VertexBuffer">
      <summary>
            VertexBuffer
            </summary>
    </member>
    <member name="F:PloobsEngine.Modelo.BatchInformation.InstancedVertexBuffer">
      <summary>
            Instanced VertexBuffer
            </summary>
    </member>
    <member name="F:PloobsEngine.Modelo.BatchInformation.IndexBuffer">
      <summary>
            IndexBuffer
            </summary>
    </member>
    <member name="F:PloobsEngine.Modelo.BatchInformation.ModelLocalTransformation">
      <summary>
            Local Transformation
            </summary>
    </member>
    <member name="M:PloobsEngine.Modelo.BatchInformation.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,Microsoft.Xna.Framework.Graphics.VertexDeclaration,System.Int32,PloobsEngine.Modelo.BatchType,Microsoft.Xna.Framework.Graphics.PrimitiveType)">
      <summary>
            Initializes a new instance of the <see cref="T:PloobsEngine.Modelo.BatchInformation" /> class.
            Indexed or Normal
            Use OTHER constructor to created INSTANCED
            </summary>
      <param name="BaseVertex">The base vertex.</param>
      <param name="NumVertices">The num vertices.</param>
      <param name="PrimitiveCount">The primitive count.</param>
      <param name="StartIndexOrVertex">The start index or vertex.</param>
      <param name="StreamOffset">The stream offset.</param>
      <param name="VertexDeclaration">The vertex declaration.</param>
      <param name="VertexStride">The vertex stride.</param>
      <param name="BatchType">Type of the batch.</param>
      <param name="PrimitiveType">Type of the primitive.</param>
    </member>
    <member name="M:PloobsEngine.Modelo.BatchInformation.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,Microsoft.Xna.Framework.Graphics.VertexDeclaration,System.Int32,Microsoft.Xna.Framework.Graphics.PrimitiveType)">
      <summary>
            Initializes a new instance of the <see cref="T:PloobsEngine.Modelo.BatchInformation" /> class.
            Indexed
            </summary>
      <param name="BaseVertex">The base vertex.</param>
      <param name="NumVertices">The num vertices.</param>
      <param name="PrimitiveCount">The primitive count.</param>
      <param name="StartIndex">The start index.</param>
      <param name="StreamOffset">The stream offset.</param>
      <param name="VertexDeclaration">The vertex declaration.</param>
      <param name="VertexStride">The vertex stride.</param>
      <param name="PrimitiveType">Type of the primitive.</param>
    </member>
    <member name="M:PloobsEngine.Modelo.BatchInformation.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,Microsoft.Xna.Framework.Graphics.VertexDeclaration,System.Int32,System.Int32,Microsoft.Xna.Framework.Graphics.PrimitiveType)">
      <summary>
            Initializes a new instance of the <see cref="T:PloobsEngine.Modelo.BatchInformation" /> class.
            INSTACED CONSTRUCTOR
            </summary>
      <param name="BaseVertex">The base vertex.</param>
      <param name="NumVertices">The num vertices.</param>
      <param name="PrimitiveCount">The primitive count.</param>
      <param name="StartIndex">The start index.</param>
      <param name="StreamOffset">The stream offset.</param>
      <param name="VertexDeclaration">The vertex declaration.</param>
      <param name="VertexStride">The vertex stride.</param>
      <param name="instanceCount">The instance count.</param>
      <param name="PrimitiveType">Type of the primitive.</param>
    </member>
    <member name="T:PloobsEngine.Material.IMaterial">
      <summary>
            Material Specification
            </summary>
    </member>
    <member name="M:PloobsEngine.Material.IMaterial.Initialization(PloobsEngine.Engine.GraphicInfo,PloobsEngine.Engine.GraphicFactory,PloobsEngine.SceneControl.IObject)">
      <summary>
            Initializations the specified Material.
            </summary>
      <param name="ginfo">The ginfo.</param>
      <param name="factory">The factory.</param>
      <param name="obj">The obj.</param>
    </member>
    <member name="M:PloobsEngine.Material.IMaterial.PreDrawnPhase(Microsoft.Xna.Framework.GameTime,PloobsEngine.SceneControl.IWorld,PloobsEngine.SceneControl.IObject,PloobsEngine.Cameras.ICamera,System.Collections.Generic.IList{PloobsEngine.Light.ILight},PloobsEngine.SceneControl.RenderHelper)">
      <summary>
            Pre drawn Function.
            Called before all the objects are draw
            </summary>
      <param name="mundo">The mundo.</param>
      <param name="gt">The gt.</param>
      <param name="obj">The obj.</param>
      <param name="cam">The cam.</param>
      <param name="lights">The lights.</param>
      <param name="render">The render.</param>
    </member>
    <member name="M:PloobsEngine.Material.IMaterial.PosDrawnPhase(Microsoft.Xna.Framework.GameTime,PloobsEngine.SceneControl.IObject,PloobsEngine.Cameras.ICamera,System.Collections.Generic.IList{PloobsEngine.Light.ILight},PloobsEngine.SceneControl.RenderHelper)">
      <summary>
            Pos drawn Function.        
            Called after all objects are Draw
            </summary>
      <param name="gt">The gt.</param>
      <param name="obj">The obj.</param>
      <param name="cam">The cam.</param>
      <param name="lights">The lights.</param>
      <param name="render">The render.</param>
    </member>
    <member name="M:PloobsEngine.Material.IMaterial.Drawn(Microsoft.Xna.Framework.GameTime,PloobsEngine.SceneControl.IObject,PloobsEngine.Cameras.ICamera,System.Collections.Generic.IList{PloobsEngine.Light.ILight},PloobsEngine.SceneControl.RenderHelper)">
      <summary>
            Normal Drawn Function.
            </summary>
      <param name="gt">The gt.</param>
      <param name="obj">The obj.</param>
      <param name="cam">The cam.</param>
      <param name="lights">The lights.</param>
      <param name="render">The render.</param>
    </member>
    <member name="M:PloobsEngine.Material.IMaterial.Update(Microsoft.Xna.Framework.GameTime,PloobsEngine.SceneControl.IObject,System.Collections.Generic.IList{PloobsEngine.Light.ILight})">
      <summary>
            Update.
            </summary>
      <param name="gametime">The gametime.</param>
      <param name="obj">The obj.</param>
      <param name="lights">The lights.</param>
    </member>
    <member name="P:PloobsEngine.Material.IMaterial.Shadder">
      <summary>
            Gets or sets the shadder.
            </summary>
      <value>
            The shadder.
            </value>
    </member>
    <member name="P:PloobsEngine.Material.IMaterial.MaterialType">
      <summary>
            Gets or sets the type of the material.
            </summary>
      <value>
            The type of the material.
            </value>
    </member>
    <member name="P:PloobsEngine.Material.IMaterial.CanCreateShadow">
      <summary>
            Gets or sets a value indicating whether this material is [Create shadow on others objects].
            </summary>
      <value>
        <c>true</c> if [affected by shadow]; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="P:PloobsEngine.Material.IMaterial.CanAppearOfReflectionRefraction">
      <summary>
            Gets or sets a value indicating whether this instance can appear of reflection and refraction.
            </summary>
      <value>
        <c>true</c> if this instance can appear of reflection/refraction; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="P:PloobsEngine.Material.IMaterial.IsVisible">
      <summary>
            Gets or sets a value indicating whether this instance is visible.
            </summary>
      <value>
        <c>true</c> if this instance is visible; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="T:PloobsEngine.Material.ForwardMaterial">
      <summary>
            Forward Material
            </summary>
    </member>
    <member name="M:PloobsEngine.Material.ForwardMaterial.#ctor(PloobsEngine.Material.IShader)">
      <summary>
            Initializes a new instance of the <see cref="T:PloobsEngine.Material.ForwardMaterial" /> class.
            </summary>
      <param name="shader">The shader.</param>
    </member>
    <member name="M:PloobsEngine.Material.ForwardMaterial.Initialization(PloobsEngine.Engine.GraphicInfo,PloobsEngine.Engine.GraphicFactory,PloobsEngine.SceneControl.IObject)">
      <summary>
            Initializations the specified Material.
            </summary>
      <param name="ginfo">The ginfo.</param>
      <param name="factory">The factory.</param>
      <param name="obj">The obj.</param>
    </member>
    <member name="M:PloobsEngine.Material.ForwardMaterial.PreDrawnPhase(Microsoft.Xna.Framework.GameTime,PloobsEngine.SceneControl.IWorld,PloobsEngine.SceneControl.IObject,PloobsEngine.Cameras.ICamera,System.Collections.Generic.IList{PloobsEngine.Light.ILight},PloobsEngine.SceneControl.RenderHelper)">
      <summary>
            Pre drawn Function.
            Called before all the objects are draw
            </summary>
      <param name="gt">The gt.</param>
      <param name="mundo">The mundo.</param>
      <param name="obj">The obj.</param>
      <param name="cam">The cam.</param>
      <param name="lights">The lights.</param>
      <param name="render">The render.</param>
    </member>
    <member name="M:PloobsEngine.Material.ForwardMaterial.PosDrawnPhase(Microsoft.Xna.Framework.GameTime,PloobsEngine.SceneControl.IObject,PloobsEngine.Cameras.ICamera,System.Collections.Generic.IList{PloobsEngine.Light.ILight},PloobsEngine.SceneControl.RenderHelper)">
      <summary>
            Pos drawn Function.
            Called after all objects are Draw
            </summary>
      <param name="gt">The gt.</param>
      <param name="obj">The obj.</param>
      <param name="cam">The cam.</param>
      <param name="lights">The lights.</param>
      <param name="render">The render.</param>
    </member>
    <member name="M:PloobsEngine.Material.ForwardMaterial.Drawn(Microsoft.Xna.Framework.GameTime,PloobsEngine.SceneControl.IObject,PloobsEngine.Cameras.ICamera,System.Collections.Generic.IList{PloobsEngine.Light.ILight},PloobsEngine.SceneControl.RenderHelper)">
      <summary>
            Normal Drawn Function.
            </summary>
      <param name="gt">The gt.</param>
      <param name="obj">The obj.</param>
      <param name="cam">The cam.</param>
      <param name="lights">The lights.</param>
      <param name="render">The render.</param>
    </member>
    <member name="M:PloobsEngine.Material.ForwardMaterial.Update(Microsoft.Xna.Framework.GameTime,PloobsEngine.SceneControl.IObject,System.Collections.Generic.IList{PloobsEngine.Light.ILight})">
      <summary>
            Update.
            </summary>
      <param name="gametime">The gametime.</param>
      <param name="obj">The obj.</param>
      <param name="lights">The lights.</param>
    </member>
    <member name="M:PloobsEngine.Material.ForwardMaterial.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Populates a <see cref="T:System.Runtime.Serialization.SerializationInfo" /> with the data needed to serialize the target object.
            </summary>
      <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> to populate with data.</param>
      <param name="context">The destination (see <see cref="T:System.Runtime.Serialization.StreamingContext" />) for this serialization.</param>
      <exception cref="T:System.Security.SecurityException">The caller does not have the required permission. </exception>
    </member>
    <member name="P:PloobsEngine.Material.ForwardMaterial.Shadder">
      <summary>
            Gets or sets the shadder.
            </summary>
      <value>
            The shadder.
            </value>
    </member>
    <member name="P:PloobsEngine.Material.ForwardMaterial.MaterialType">
      <summary>
            Gets the type of the material.
            </summary>
      <value>
            The type of the material.
            </value>
    </member>
    <member name="P:PloobsEngine.Material.ForwardMaterial.CanCreateShadow">
      <summary>
            Gets or sets a value indicating whether this material is [affected by shadow].
            </summary>
      <value>
        <c>true</c> if [affected by shadow]; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="T:PloobsEngine.Light.LightType">
      <summary>
            Light Types
            </summary>
    </member>
    <member name="F:PloobsEngine.Light.LightType.Deferred_Directional">
      <summary>
            Deferred Directional Light
            </summary>
    </member>
    <member name="F:PloobsEngine.Light.LightType.Deferred_Point">
      <summary>
            Deferred Point Light 
            </summary>
    </member>
    <member name="F:PloobsEngine.Light.LightType.Deferred_Spot">
      <summary>
            Deferred Spot Light
            </summary>
    </member>
    <member name="F:PloobsEngine.Light.LightType.OTHER">
      <summary>
            None of these
            </summary>
    </member>
    <member name="T:PloobsEngine.SceneControl.PostEffectType">
      <summary>
            Defines in what render the post effect works
            </summary>
    </member>
    <member name="F:PloobsEngine.SceneControl.PostEffectType.Deferred">
      <summary>
            Only on Deferred
            </summary>
    </member>
    <member name="F:PloobsEngine.SceneControl.PostEffectType.Forward3D">
      <summary>
            only on Forward
            </summary>
    </member>
    <member name="F:PloobsEngine.SceneControl.PostEffectType.Forward2D">
      <summary>
            Works in 2D Also
            </summary>
    </member>
    <member name="F:PloobsEngine.SceneControl.PostEffectType.All">
      <summary>
            Works in both renders
            </summary>
    </member>
    <member name="T:PloobsEngine.SceneControl.IForwardPass">
      <summary>
            Specification of the ForwardPass pass
            </summary>
    </member>
    <member name="M:PloobsEngine.SceneControl.IForwardPass.Draw(Microsoft.Xna.Framework.GameTime,PloobsEngine.SceneControl.IWorld,PloobsEngine.SceneControl.RenderHelper,System.Collections.Generic.List{PloobsEngine.SceneControl.IObject},System.Collections.Generic.List{PloobsEngine.SceneControl.IObject})">
      <summary>
            Draws all the forward Objects 
            </summary>
      <param name="gt">The gt.</param>
      <param name="world">The world.</param>
      <param name="render">The render.</param>
    </member>
    <member name="T:PloobsEngine.SceneControl.IDeferredFinalCombination">
      <summary>
            Deferred final combination specification
            This is the stage number 3, where the light map and the gbuffer are combined
            </summary>
    </member>
    <member name="M:PloobsEngine.SceneControl.IDeferredFinalCombination.SetFinalCombination(PloobsEngine.SceneControl.RenderHelper)">
      <summary>
            Sets the final combination.
            </summary>
      <param name="render">The render.</param>
    </member>
    <member name="M:PloobsEngine.SceneControl.IDeferredFinalCombination.DrawScene(Microsoft.Xna.Framework.GameTime,PloobsEngine.SceneControl.IWorld,PloobsEngine.SceneControl.IDeferredGBuffer,PloobsEngine.SceneControl.IDeferredLightMap,PloobsEngine.SceneControl.RenderHelper)">
      <summary>
            Draws the pass.
            </summary>
      <param name="gameTime">The game time.</param>
      <param name="world">The world.</param>
      <param name="gbuffer">The gbuffer.</param>
      <param name="lightmap">The lightmap.</param>
      <param name="render">The render.</param>
    </member>
    <member name="M:PloobsEngine.SceneControl.IDeferredFinalCombination.LoadContent(PloobsEngine.SceneControl.IContentManager,PloobsEngine.Engine.GraphicInfo,PloobsEngine.Engine.GraphicFactory,System.Boolean,System.Boolean)">
      <summary>
            Loads the content.
            </summary>
      <param name="manager">The manager.</param>
      <param name="ginfo">The ginfo.</param>
      <param name="factory">The factory.</param>
    </member>
    <member name="P:PloobsEngine.SceneControl.IDeferredFinalCombination.AmbientColor">
      <summary>
            Gets or sets the ambient color factor.
            Uniform for all the scene
            </summary>
      <value>
            The color of the ambient.
            </value>
    </member>
    <member name="P:PloobsEngine.SceneControl.IDeferredFinalCombination.Item(PloobsEngine.SceneControl.GBufferTypes)">
      <summary>
            Gets the <see cref="T:Microsoft.Xna.Framework.Graphics.Texture2D" /> with the specified type.
            </summary>
    </member>
    <member name="M:PloobsEngine.SceneControl._2DScene.Camera2D.#ctor(PloobsEngine.Engine.GraphicInfo)">
      <summary>
            The constructor for the Camera2D class.
            </summary>
      <param name="graphics">
      </param>
    </member>
    <member name="M:PloobsEngine.SceneControl._2DScene.Camera2D.ResetCamera">
      <summary>
            Resets the camera to default values.
            </summary>
    </member>
    <member name="M:PloobsEngine.SceneControl._2DScene.Camera2D.Update(Microsoft.Xna.Framework.GameTime)">
      <summary>
            Moves the camera forward one timestep.
            </summary>
    </member>
    <member name="P:PloobsEngine.SceneControl._2DScene.Camera2D.Position">
      <summary>
            The current position of the camera.
            </summary>
    </member>
    <member name="P:PloobsEngine.SceneControl._2DScene.Camera2D.MinPosition">
      <summary>
            The furthest up, and the furthest left the camera can go.
            if this value equals maxPosition, then no clamping will be 
            applied (unless you override that function).
            </summary>
    </member>
    <member name="P:PloobsEngine.SceneControl._2DScene.Camera2D.MaxPosition">
      <summary>
            the furthest down, and the furthest right the camera will go.
            if this value equals minPosition, then no clamping will be 
            applied (unless you override that function).
            </summary>
    </member>
    <member name="P:PloobsEngine.SceneControl._2DScene.Camera2D.Rotation">
      <summary>
            The current rotation of the camera in radians.
            </summary>
    </member>
    <member name="P:PloobsEngine.SceneControl._2DScene.Camera2D.MinRotation">
      <summary>
            Gets or sets the minimum rotation in radians.
            </summary>
      <value>The min rotation.</value>
    </member>
    <member name="P:PloobsEngine.SceneControl._2DScene.Camera2D.MaxRotation">
      <summary>
            Gets or sets the maximum rotation in radians.
            </summary>
      <value>The max rotation.</value>
    </member>
    <member name="P:PloobsEngine.SceneControl._2DScene.Camera2D.Zoom">
      <summary>
            The current rotation of the camera in radians.
            </summary>
    </member>
    <member name="P:PloobsEngine.SceneControl._2DScene.Camera2D.TrackingBody">
      <summary>
            the body that this camera is currently tracking. 
            Null if not tracking any.
            </summary>
    </member>
    <member name="T:PloobsEngine.Physics.IPhysicObject">
      <summary>
            Specification of a physic Object
            </summary>
    </member>
    <member name="M:PloobsEngine.Physics.IPhysicObject.Enable">
      <summary>
            Enables this instance.
            </summary>
    </member>
    <member name="M:PloobsEngine.Physics.IPhysicObject.Disable">
      <summary>
            Disables this instance.
            </summary>
    </member>
    <member name="M:PloobsEngine.Physics.IPhysicObject.ApplyImpulse(Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3)">
      <summary>
            Applies an impulse.
            </summary>
      <param name="force">The force.</param>
    </member>
    <member name="P:PloobsEngine.Physics.IPhysicObject.Position">
      <summary>
            Gets or sets the position.
            </summary>
      <value>
            The position.
            </value>
    </member>
    <member name="P:PloobsEngine.Physics.IPhysicObject.Scale">
      <summary>
            Gets or sets the scale.
            </summary>
      <value>
            The scale.
            </value>
    </member>
    <member name="P:PloobsEngine.Physics.IPhysicObject.Rotation">
      <summary>
            Gets or sets the rotation.
            </summary>
      <value>
            The rotation.
            </value>
    </member>
    <member name="P:PloobsEngine.Physics.IPhysicObject.FaceVector">
      <summary>
            Vector pointing to the front
            </summary>
    </member>
    <member name="P:PloobsEngine.Physics.IPhysicObject.WorldMatrix">
      <summary>
            Gets the world matrix.
            </summary>
    </member>
    <member name="P:PloobsEngine.Physics.IPhysicObject.Velocity">
      <summary>
            Gets or sets the velocity.
            </summary>
      <value>
            The velocity.
            </value>
    </member>
    <member name="P:PloobsEngine.Physics.IPhysicObject.isMotionLess">
      <summary>
            Gets or sets a value indicating whether this instance is motion less.
            </summary>
      <value>
        <c>true</c> if this instance is motion less; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="P:PloobsEngine.Physics.IPhysicObject.ObjectOwner">
      <summary>
            Gets or sets the IObject owner.
            </summary>
      <value>
            The IObject owner.
            </value>
    </member>
    <member name="P:PloobsEngine.Physics.IPhysicObject.PhysicObjectTypes">
      <summary>
            Gets the physic object type.
            </summary>
    </member>
    <member name="P:PloobsEngine.Physics.IPhysicObject.BoundingBox">
      <summary>
            Gets the bounding box IN WORLD COORDINATES
            </summary>
    </member>
    <member name="P:PloobsEngine.Physics.IPhysicObject.AngularVelocity">
      <summary>
            Gets or sets the angular velocity.
            </summary>
      <value>
            The angular velocity.
            </value>
    </member>
    <member name="T:PloobsEngine.Physics.Bepu.BepuEntityObject">
      <summary>
            Base class for Bepu entities
            </summary>
    </member>
    <member name="M:PloobsEngine.Physics.Bepu.BepuEntityObject.SetMaterialDescription(PloobsEngine.Physics.MaterialDescription)">
      <summary>
            Sets the material description.
            </summary>
      <param name="materialDescription">The material description.</param>
    </member>
    <member name="M:PloobsEngine.Physics.Bepu.BepuEntityObject.GetMaterialDescription">
      <summary>
            Gets the material description.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:PloobsEngine.Physics.Bepu.BepuEntityObject.RecoverIPhysicObjectFromEntity(BEPUphysics.Entities.Entity)">
      <summary>
            [Utility] Recovers the physic object from entity.
            </summary>
      <param name="entity">The entity.</param>
      <returns>
      </returns>
    </member>
    <member name="M:PloobsEngine.Physics.Bepu.BepuEntityObject.RecoverObjectFromEntity(BEPUphysics.Entities.Entity)">
      <summary>
            [Utility] Recovers the object from entity.
            </summary>
      <param name="entity">The entity.</param>
      <returns>
      </returns>
    </member>
    <member name="M:PloobsEngine.Physics.Bepu.BepuEntityObject.RecoverObjectFromCollidable(BEPUphysics.Collidables.Collidable)">
      <summary>
            [Utility] Recovers the object from collidable.
            </summary>
      <param name="collidable">The collidable.</param>
      <returns>
      </returns>
    </member>
    <member name="M:PloobsEngine.Physics.Bepu.BepuEntityObject.RecoverObjectFromBroadPhase(BEPUphysics.BroadPhaseSystems.BroadPhaseEntry)">
      <summary>
            Recovers iobject from broad phase entry.
            </summary>
      <param name="entry">The entry.</param>
      <returns>
      </returns>
    </member>
    <member name="M:PloobsEngine.Physics.Bepu.BepuEntityObject.RecoverIPhysicObjectFromBroadPhase(BEPUphysics.BroadPhaseSystems.BroadPhaseEntry)">
      <summary>
            Recovers physicobject from broad phase entry.
            </summary>
      <param name="entry">The entry.</param>
      <returns>
      </returns>
    </member>
    <member name="M:PloobsEngine.Physics.Bepu.BepuEntityObject.#ctor(PloobsEngine.Physics.MaterialDescription,System.Single)">
      <summary>
            Initializes a new instance of the <see cref="T:PloobsEngine.Physics.Bepu.BepuEntityObject" /> class.
            </summary>
      <param name="md">The md.</param>
      <param name="mass">The mass.</param>
    </member>
    <member name="P:PloobsEngine.Physics.Bepu.BepuEntityObject.Entity">
      <summary>
            Gets or sets the entity.
            </summary>
      <value>
            The entity.
            </value>
    </member>
    <member name="P:PloobsEngine.Physics.Bepu.BepuEntityObject.Position">
      <summary>
            Gets or sets the position.
            </summary>
      <value>
            The position.
            </value>
    </member>
    <member name="P:PloobsEngine.Physics.Bepu.BepuEntityObject.Scale">
      <summary>
            Gets or sets the scale.
            CARE USING THIS, the scale will be uniform to all axis
            </summary>
      <value>
            The scale.
            </value>
    </member>
    <member name="P:PloobsEngine.Physics.Bepu.BepuEntityObject.Rotation">
      <summary>
            Gets or sets the rotation.
            </summary>
      <value>
            The rotation.
            </value>
    </member>
    <member name="P:PloobsEngine.Physics.Bepu.BepuEntityObject.FaceVector">
      <summary>
            Vector pointing to the front
            </summary>
    </member>
    <member name="P:PloobsEngine.Physics.Bepu.BepuEntityObject.WorldMatrix">
      <summary>
            Gets the world matrix.
            </summary>
    </member>
    <member name="P:PloobsEngine.Physics.Bepu.BepuEntityObject.Velocity">
      <summary>
            Gets or sets the velocity.
            </summary>
      <value>
            The velocity.
            </value>
    </member>
    <member name="P:PloobsEngine.Physics.Bepu.BepuEntityObject.ObjectOwner">
      <summary>
            Gets or sets the IObject owner.
            </summary>
      <value>
            The IObject owner.
            </value>
    </member>
    <member name="P:PloobsEngine.Physics.Bepu.BepuEntityObject.BoundingBox">
      <summary>
            Gets the bounding box IN WORLD COORDINATES
            </summary>
    </member>
    <member name="T:PloobsEngine.Material.DeferredInstancedBilboardShader">
      <summary>
            Dynamic Bilboard
            </summary>
    </member>
    <member name="M:PloobsEngine.Material.DeferredInstancedBilboardShader.#ctor(PloobsEngine.Material.BilboardType)">
      <summary>
            Bilboard animada
            </summary>
      <param name="bilboardType">Type of the bilboard.</param>
    </member>
    <member name="P:PloobsEngine.Material.DeferredInstancedBilboardShader.Scale">
      <summary>
            Bilboard tem tamanho 1,1 -&gt; deve-se ser multiplicada por um fator de escala
            Default Vector2(100, 100);
            </summary>
    </member>
    <member name="P:PloobsEngine.Material.DeferredInstancedBilboardShader.Atenuation">
      <summary>
            Atenuacao na cor da textura utilizada
            Default Vector4.One
            </summary>
    </member>
    <member name="P:PloobsEngine.Material.DeferredInstancedBilboardShader.AllowRotDir">
      <summary>
            Constraint da bilboard IF CILINDRIC
            SPHERICAL DOES NOT HAVE CONSTRAINT DIRECTION
            Default Vector3(0,1,0)
            </summary>
    </member>
    <member name="P:PloobsEngine.Material.DeferredInstancedBilboardShader.Amplitude">
      <summary>
            Amplitude do movimento (os dois pontos de cima da billboard podem se movimentar)
            Default 1
            </summary>
    </member>
    <member name="P:PloobsEngine.Material.DeferredInstancedBilboardShader.MovimentSpeedControl">
      <summary>
            Velocidade de moviemnto
            Default 5
            </summary>
    </member>
    <member name="T:PloobsEngine.Features.TaskEndType">
      <summary>
            Quando a funcao result sera chamada, qd o process terminar
            </summary>
    </member>
    <member name="T:PloobsEngine.IA.NeuralNetwork.ActivationFunction">
      <summary>
            Interface of the activation function of a neuron.
            </summary>
    </member>
    <member name="M:PloobsEngine.IA.NeuralNetwork.ActivationFunction.Output(System.Single)">
      <summary>
            Compute function value
            </summary>
      <param name="x">x</param>
      <returns>f(x)</returns>
    </member>
    <member name="M:PloobsEngine.IA.NeuralNetwork.ActivationFunction.OutputPrime(System.Single)">
      <summary>
            Compute the diff of the function
            </summary>
      <param name="x">x</param>
      <returns>f'(x)</returns>
    </member>
    <member name="T:PloobsEngine.IA.NeuralNetwork.SigmoidActivationFunction">
      <summary>
            The sigmoid activation function
            </summary>
      <remarks>
            Here is the definition of the sigmoid activation function
            <code>
                           1
            f(x) = -----------------   beta &gt; 0
                    1 + e^(-beta*x)
            
            f'(x) = beta * f(x) * ( 1 - f(x) )   
            </code></remarks>
    </member>
    <member name="F:PloobsEngine.IA.NeuralNetwork.SigmoidActivationFunction.beta">
      <summary>
            The beta parameter of the sigmoid
            </summary>
    </member>
    <member name="M:PloobsEngine.IA.NeuralNetwork.SigmoidActivationFunction.Output(System.Single)">
      <summary>
        <code>
                            1
            f(x) = -----------------   beta &gt; 0
                    1 + e^(-beta*x)
            </code>
      </summary>
      <param name="x">x</param>
      <returns>f(x)</returns>
    </member>
    <member name="M:PloobsEngine.IA.NeuralNetwork.SigmoidActivationFunction.OutputPrime(System.Single)">
      <summary>
        <code>
            f'(x) = beta * f(x) * ( 1 - f(x) )
            </code>
      </summary>
      <param name="x">x</param>
      <returns>f'(x)</returns>
    </member>
    <member name="P:PloobsEngine.IA.NeuralNetwork.SigmoidActivationFunction.Beta">
      <summary>
            Get or set the beta parameter of the function
            ( beta must be positive )
            </summary>
    </member>
    <member name="P:PloobsEngine.IA.NeuralNetwork.SigmoidActivationFunction.Name">
      <summary>
            Get the name of the activation function
            </summary>
    </member>
    <member name="T:PloobsEngine.IA.NeuralNetwork.LinearActivationFunction">
      <summary>
            The linear activation function
            </summary>
      <remarks>
        <code>
                   |1            if x &gt; 0.5/A
            f(x) = |A * x + 0.5  if 0.5/A &gt; x &gt; -0.5/A
                   |0            if -0.5/A &gt; x
            
                        A &gt; 0      
            </code>
      </remarks>
    </member>
    <member name="F:PloobsEngine.IA.NeuralNetwork.LinearActivationFunction.a">
      <summary>
            The A parameter of the linear function
            </summary>
    </member>
    <member name="F:PloobsEngine.IA.NeuralNetwork.LinearActivationFunction.threshold">
      <summary>
            Usefull to compute function value
            </summary>
    </member>
    <member name="M:PloobsEngine.IA.NeuralNetwork.LinearActivationFunction.Output(System.Single)">
      <summary>
             Get the activation function value
            </summary>
      <param name="x">x</param>
      <returns>f(x)</returns>
    </member>
    <member name="M:PloobsEngine.IA.NeuralNetwork.LinearActivationFunction.OutputPrime(System.Single)">
      <summary>
            Get the diff function value
            </summary>
      <param name="x">x</param>
      <returns>f'(x)</returns>
    </member>
    <member name="P:PloobsEngine.IA.NeuralNetwork.LinearActivationFunction.A">
      <summary>
            Get or set the A parameter of the function
            ( A must be positive )
            </summary>
    </member>
    <member name="P:PloobsEngine.IA.NeuralNetwork.LinearActivationFunction.Name">
      <summary>
            Get the name of the activation function
            </summary>
    </member>
    <member name="T:PloobsEngine.IA.NeuralNetwork.HeavisideActivationFunction">
      <summary>
            The heaviside activation function
            </summary>
      <remarks>
        <code>
            f(x) = 0 if 0&gt;x
            f(x) = 1 if x&gt;0
            </code>
      </remarks>
    </member>
    <member name="M:PloobsEngine.IA.NeuralNetwork.HeavisideActivationFunction.Output(System.Single)">
      <summary>
             Get the heaviside function value
            </summary>
      <param name="x">x</param>
      <returns>f(x)</returns>
    </member>
    <member name="M:PloobsEngine.IA.NeuralNetwork.HeavisideActivationFunction.OutputPrime(System.Single)">
      <summary>
            Get the derivative function value
            Simulate an impulse at origin...
            </summary>
      <param name="x">x</param>
      <returns>f'(x)</returns>
    </member>
    <member name="P:PloobsEngine.IA.NeuralNetwork.HeavisideActivationFunction.Name">
      <summary>
            Get the name of the activation function
            </summary>
    </member>
    <member name="T:PloobsEngine.IA.NeuralNetwork.GaussianActivationFunction">
      <summary>
            The gaussian activation function
            </summary>
      <remarks>
        <code>
            
                             1                -(x-mu)^2 / (2 * sigma^2)
            f(x)  =  -------------------- *  e
                     sqrt(2 * pi * sigma)
            
            f'(x)  =  y(x) * -2*K*(x - mu) 
            </code>
            To implement a more efficient computation :
            <code>
            C = 1/sqrt(2 * pi * sigma)
            K = 1/(2 * sigma^2)
            </code></remarks>
    </member>
    <member name="F:PloobsEngine.IA.NeuralNetwork.GaussianActivationFunction.sigma">
      <summary>
            The sigma parameter of the gaussian
            </summary>
    </member>
    <member name="F:PloobsEngine.IA.NeuralNetwork.GaussianActivationFunction.mu">
      <summary>
            The mu parameter of the gaussian
            </summary>
    </member>
    <member name="F:PloobsEngine.IA.NeuralNetwork.GaussianActivationFunction.C">
      <summary>
            C parameter (usfull for computing function value)
            </summary>
    </member>
    <member name="F:PloobsEngine.IA.NeuralNetwork.GaussianActivationFunction.K">
      <summary>
            C parameter (usfull for computing function value)
            </summary>
    </member>
    <member name="M:PloobsEngine.IA.NeuralNetwork.GaussianActivationFunction.computeCK">
      <summary>
            Compute C and K parameters from sigma
            </summary>
    </member>
    <member name="M:PloobsEngine.IA.NeuralNetwork.GaussianActivationFunction.#ctor">
      <summary>
            GaussianActivationFunction constructor
            </summary>
    </member>
    <member name="M:PloobsEngine.IA.NeuralNetwork.GaussianActivationFunction.Output(System.Single)">
      <summary>
            Compute the value of the gaussian function
            <param name="x">x</param><returns>f(x)</returns></summary>
    </member>
    <member name="M:PloobsEngine.IA.NeuralNetwork.GaussianActivationFunction.OutputPrime(System.Single)">
      <summary>
            compute the derivative value of function
            </summary>
      <param name="x">x</param>
      <returns>f'(x)</returns>
    </member>
    <member name="P:PloobsEngine.IA.NeuralNetwork.GaussianActivationFunction.Sigma">
      <summary>
            Get or set the sigma parameter of the function
            (sigma must be positive)
            </summary>
    </member>
    <member name="P:PloobsEngine.IA.NeuralNetwork.GaussianActivationFunction.Mu">
      <summary>
            Get or set the mu parameter of the function
            </summary>
    </member>
    <member name="P:PloobsEngine.IA.NeuralNetwork.GaussianActivationFunction.Name">
      <summary>
            Get the name of the activation function
            </summary>
    </member>
    <member name="T:PloobsEngine.Material.MaterialType">
      <summary>
            Material Type
            </summary>
    </member>
    <member name="F:PloobsEngine.Material.MaterialType.DEFERRED">
      <summary>
            When this type is set AND the render is Deferred,
            Only the Pre Draw and the Draw call are called
            </summary>
    </member>
    <member name="F:PloobsEngine.Material.MaterialType.FORWARD">
      <summary>
            When this type is set AND the render is Deferred,
            Only the Pos Draw call is called.
            </summary>
    </member>
    <member name="T:PloobsEngine.SceneControl.IDeferredGBuffer">
      <summary>
            GBUffer generation specification
            </summary>
    </member>
    <member name="M:PloobsEngine.SceneControl.IDeferredGBuffer.SetGBuffer(PloobsEngine.SceneControl.RenderHelper)">
      <summary>
            Sets the G buffer.
            </summary>
    </member>
    <member name="M:PloobsEngine.SceneControl.IDeferredGBuffer.ResolveGBuffer(PloobsEngine.SceneControl.RenderHelper)">
      <summary>
            Resolves the G buffer.
            </summary>
    </member>
    <member name="M:PloobsEngine.SceneControl.IDeferredGBuffer.ClearGBuffer(PloobsEngine.SceneControl.RenderHelper)">
      <summary>
            Clears the G buffer.
            </summary>
    </member>
    <member name="M:PloobsEngine.SceneControl.IDeferredGBuffer.PreDrawScene(Microsoft.Xna.Framework.GameTime,PloobsEngine.SceneControl.IWorld,PloobsEngine.SceneControl.RenderHelper,PloobsEngine.Engine.GraphicInfo,System.Collections.Generic.List{PloobsEngine.SceneControl.IObject})">
      <summary>
            Pre Draw the scene.
            Responsible to the PreDraw phase
            </summary>
      <param name="gameTime">The game time.</param>
      <param name="world">The world.</param>
    </member>
    <member name="M:PloobsEngine.SceneControl.IDeferredGBuffer.DrawScene(Microsoft.Xna.Framework.GameTime,PloobsEngine.SceneControl.IWorld,PloobsEngine.SceneControl.RenderHelper,PloobsEngine.Engine.GraphicInfo,System.Collections.Generic.List{PloobsEngine.SceneControl.IObject})">
      <summary>
            Draws.
            Generate the GBuffer
            </summary>
      <param name="gameTime">The game time.</param>
      <param name="world">The world.</param>
    </member>
    <member name="M:PloobsEngine.SceneControl.IDeferredGBuffer.LoadContent(PloobsEngine.SceneControl.IContentManager,PloobsEngine.Engine.GraphicInfo,PloobsEngine.Engine.GraphicFactory,Microsoft.Xna.Framework.Color)">
      <summary>
            Loads the content.
            </summary>
      <param name="manager">The manager.</param>
      <param name="ginfo">The ginfo.</param>
      <param name="factory">The factory.</param>
    </member>
    <member name="P:PloobsEngine.SceneControl.IDeferredGBuffer.Item(PloobsEngine.SceneControl.GBufferTypes)">
      <summary>
            Return the generated Buffers
            </summary>
    </member>
    <member name="T:Bnoerj.AI.Steering.Trail">
      <summary>
            Provides support to visualize the recent path of a vehicle.
            </summary>
    </member>
    <member name="M:Bnoerj.AI.Steering.Trail.#ctor">
      <summary>
            Initializes a new instance of Trail.
            </summary>
    </member>
    <member name="M:Bnoerj.AI.Steering.Trail.#ctor(System.Single,System.Int32)">
      <summary>
            Initializes a new instance of Trail.
            </summary>
      <param name="duration">The amount of time the trail represents.</param>
      <param name="vertexCount">The number of smaples along the trails length.</param>
    </member>
    <member name="M:Bnoerj.AI.Steering.Trail.Record(System.Single,Microsoft.Xna.Framework.Vector3)">
      <summary>
            Records a position for the current time, called once per update.
            </summary>
      <param name="currentTime">
      </param>
      <param name="position">
      </param>
    </member>
    <member name="M:Bnoerj.AI.Steering.Trail.Draw(Bnoerj.AI.Steering.IDraw)">
      <summary>
            Draws the trail as a dotted line, fading away with age.
            </summary>
    </member>
    <member name="M:Bnoerj.AI.Steering.Trail.Clear">
      <summary>
            Clear trail history. Used to prevent long streaks due to teleportation.
            </summary>
    </member>
    <member name="P:Bnoerj.AI.Steering.Trail.TrailColor">
      <summary>
            Gets or sets the color of the trail.
            </summary>
    </member>
    <member name="P:Bnoerj.AI.Steering.Trail.TickColor">
      <summary>
            Gets or sets the color of the ticks.
            </summary>
    </member>
    <member name="T:PloobsEngine.Components.ComponentManager">
      <summary>
            Handles the Components
            </summary>
    </member>
    <member name="M:PloobsEngine.Components.ComponentManager.Update(Microsoft.Xna.Framework.GameTime)">
      <summary>
            Updates 
            </summary>
      <param name="gt">The gt.</param>
    </member>
    <member name="M:PloobsEngine.Components.ComponentManager.GetPreDraw">
      <summary>
            Gets all the pre draw components.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:PloobsEngine.Components.ComponentManager.GetPosDraw">
      <summary>
            Gets all the pos draw components.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:PloobsEngine.Components.ComponentManager.GetPosWithDepthDraw">
      <summary>
            Gets the pos with Depth draw.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:PloobsEngine.Components.ComponentManager.PreDraw(PloobsEngine.SceneControl.RenderHelper,Microsoft.Xna.Framework.GameTime,Microsoft.Xna.Framework.Matrix,Microsoft.Xna.Framework.Matrix)">
      <summary>
            Draw the Pre Draw components
            </summary>
      <param name="gt">The gt.</param>
      <param name="activeView">The active view.</param>
      <param name="activeProjection">The active projection.</param>
    </member>
    <member name="M:PloobsEngine.Components.ComponentManager.AfterDraw(PloobsEngine.SceneControl.RenderHelper,Microsoft.Xna.Framework.GameTime,Microsoft.Xna.Framework.Matrix,Microsoft.Xna.Framework.Matrix)">
      <summary>
            Draw the Afters draw.
            </summary>
      <param name="gt">The gt.</param>
      <param name="activeView">The active view.</param>
      <param name="activeProjection">The active projection.</param>
    </member>
    <member name="M:PloobsEngine.Components.ComponentManager.PosWithDepthDraw(PloobsEngine.SceneControl.RenderHelper,Microsoft.Xna.Framework.GameTime,Microsoft.Xna.Framework.Matrix,Microsoft.Xna.Framework.Matrix)">
      <summary>
            Draw the Afters with depth draw.
            </summary>
      <param name="render">The render.</param>
      <param name="gt">The gt.</param>
      <param name="activeView">The active view.</param>
      <param name="activeProjection">The active projection.</param>
    </member>
    <member name="M:PloobsEngine.Components.ComponentManager.LoadContent(PloobsEngine.Engine.GraphicInfo@)">
      <summary>
            Loads the content.
            </summary>
      <param name="engine">The engine.</param>
    </member>
    <member name="M:PloobsEngine.Components.ComponentManager.HasComponent(System.String)">
      <summary>
            Determines whether the component is already added
            </summary>
      <param name="componentName">Name of the component.</param>
      <returns>
        <c>true</c> if the specified component name has component; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="M:PloobsEngine.Components.ComponentManager.AddComponent(PloobsEngine.Components.IComponent)">
      <summary>
            Adds the component.
            </summary>
      <param name="comp">The comp.</param>
      <returns>FALSE if the component already exist, false otherwise </returns>
    </member>
    <member name="M:PloobsEngine.Components.ComponentManager.GetComponent(System.String)">
      <summary>
            Gets the component.
            </summary>
      <param name="componentName">Name of the component.</param>
      <returns>
      </returns>
    </member>
    <member name="M:PloobsEngine.Components.ComponentManager.RemoveComponent(System.String)">
      <summary>
            Removes the component.
            </summary>
      <param name="name">The name.</param>
      <returns>TRUE is the component exist and was remove, false otherwise</returns>
    </member>
    <member name="T:PloobsEngine.Cameras.ICamera">
      <summary>
            Specification of a camera
            </summary>
    </member>
    <member name="M:PloobsEngine.Cameras.ICamera.Update(Microsoft.Xna.Framework.GameTime)">
      <summary>
            Updates .
            </summary>
      <param name="gt">The gt.</param>
    </member>
    <member name="P:PloobsEngine.Cameras.ICamera.Hasmoved">
      <summary>
            Gets a value indicating whether this <see cref="T:PloobsEngine.Cameras.ICamera" /> has moved.
            </summary>
      <value>
        <c>true</c> if hasmoved; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="P:PloobsEngine.Cameras.ICamera.Position">
      <summary>
            Gets or sets the position.
            </summary>
      <value>
            The position.
            </value>
    </member>
    <member name="P:PloobsEngine.Cameras.ICamera.Target">
      <summary>
            Gets or sets the target.
            </summary>
      <value>
            The target.
            </value>
    </member>
    <member name="P:PloobsEngine.Cameras.ICamera.Up">
      <summary>
            Gets or sets up vector.
            </summary>
      <value>
            Up.
            </value>
    </member>
    <member name="P:PloobsEngine.Cameras.ICamera.Rotation">
      <summary>
            Gets or sets the rotation.
            </summary>
      <value>
            The rotation.
            </value>
    </member>
    <member name="P:PloobsEngine.Cameras.ICamera.FieldOfView">
      <summary>
            Gets or sets the field of view.
            </summary>
      <value>
            The field of view.
            </value>
    </member>
    <member name="P:PloobsEngine.Cameras.ICamera.AspectRatio">
      <summary>
            Gets or sets the aspect ratio.
            </summary>
      <value>
            The aspect ratio.
            </value>
    </member>
    <member name="P:PloobsEngine.Cameras.ICamera.NearPlane">
      <summary>
            Gets or sets the near plane.
            </summary>
      <value>
            The near plane.
            </value>
    </member>
    <member name="P:PloobsEngine.Cameras.ICamera.FarPlane">
      <summary>
            Gets or sets the far plane.
            </summary>
      <value>
            The far plane.
            </value>
    </member>
    <member name="P:PloobsEngine.Cameras.ICamera.View">
      <summary>
            Gets the view.
            </summary>
    </member>
    <member name="P:PloobsEngine.Cameras.ICamera.Projection">
      <summary>
            Gets the projection.
            </summary>
    </member>
    <member name="P:PloobsEngine.Cameras.ICamera.ViewProjection">
      <summary>
            Gets the view projection.
            </summary>
    </member>
    <member name="P:PloobsEngine.Cameras.ICamera.BoundingFrustum">
      <summary>
            Gets the bounding frustum.
            </summary>
    </member>
    <member name="P:PloobsEngine.Cameras.ICamera.Name">
      <summary>
            Gets or sets the name.
            </summary>
      <value>
            The name.
            </value>
    </member>
    <member name="T:PloobsEngine.Events.IEvent`1">
      <summary>
            Coloca um objeto em uma mensagem e envia para quem tiver interessado
            Content eh o conteudo (objeto acima mencionado)
            </summary>
    </member>
    <member name="T:PloobsEngine.Trigger.TriggerEvent">
      <summary>
            Special Event used by triggers
            </summary>
    </member>
    <member name="M:PloobsEngine.Trigger.TriggerEvent.#ctor(System.String,System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:PloobsEngine.Trigger.TriggerEvent" /> class.
            </summary>
      <param name="groupName">Name of the group.</param>
      <param name="TriggerName">Name of the trigger.</param>
    </member>
    <member name="M:PloobsEngine.Trigger.TriggerEvent.FireEvent(PloobsEngine.Trigger.ITrigger)">
      <summary>
            Fires the event.
            </summary>
      <param name="trigger">The trigger.</param>
    </member>
    <member name="P:PloobsEngine.Trigger.TriggerEvent.TriggerName">
      <summary>
            Gets or sets the name of the trigger.
            </summary>
      <value>
            The name of the trigger.
            </value>
    </member>
    <member name="P:PloobsEngine.Trigger.TriggerEvent.Code">
      <summary>
            Gets or sets the code.
            </summary>
      <value>
            The code.
            </value>
    </member>
    <member name="T:PloobsEngine.Modelo.ModelBuilderHelper">
      <summary>
            Helper to extract Information from XNA MOdels
            </summary>
    </member>
    <member name="M:PloobsEngine.Modelo.ModelBuilderHelper.Extract(Microsoft.Xna.Framework.Graphics.Model,PloobsEngine.Modelo.BatchInformation[][]@)">
      <summary>
            Creaters a BATCHInformation from a xna Model
            </summary>
      <param name="model">The model.</param>
      <param name="batchInformationS">The batch information S.</param>
    </member>
    <member name="M:PloobsEngine.Modelo.ModelBuilderHelper.Extract(Microsoft.Xna.Framework.Matrix[],Microsoft.Xna.Framework.Graphics.ModelMeshPart,PloobsEngine.Modelo.BatchInformation@)">
      <summary>
            Creates a BatchInformation from a XNA ModelMesh
            </summary>
      <param name="BonesAbsoluteTransforms">The bones absolute transforms.</param>
      <param name="mesh">The mesh.</param>
      <param name="batchInformationS">The batch information S.</param>
    </member>
    <member name="M:PloobsEngine.Modelo.ModelBuilderHelper.ExtractModelMeshPartData(Microsoft.Xna.Framework.Graphics.ModelMeshPart,Microsoft.Xna.Framework.Matrix@,System.Collections.Generic.List{Microsoft.Xna.Framework.Vector3},System.Collections.Generic.List{System.Int32})">
      <summary>
            Extracts the model mesh part data.
            </summary>
      <param name="meshPart">The mesh part.</param>
      <param name="transform">The transform.</param>
      <param name="vertices">The vertices.</param>
      <param name="indices">The indices.</param>
    </member>
    <member name="T:PloobsEngine.MessageSystem.MessageDeliver">
      <summary>
            Responsible to Deliver the messages to the Senders
            o interessante eh q eu uso uma interface combinada com um delegate (fico muito loco , vo patentia ...)
            funciona assim , voce extende um interface q tem um metodo do tipo CanIhandleThisMessage q recebe um
            tipo de mensagem , se ele consegue dar handler ele devolve um delegate pra o tratador de mensagem q ele implementou
            .... veja o exemplo do Sampleagente q ficara mais facil de entender
            o que importa eh q a pessoa implementa apenas 2 funcoezinhas e ja ta OK para enviar
            e receber mensagens e o sistema ja sabe como trata-las...
            o sistema faz o "roteamento" das mensagens pra encontrar o destinatario
            eh possivel fazer broadcast e enviar apenas para um grupo usando as tags 
            USEI components (nassa arquitetura) pra ficar mais facil de "plugar"    
            </summary>
    </member>
    <member name="M:PloobsEngine.MessageSystem.MessageDeliver.Update(Microsoft.Xna.Framework.GameTime)">
      <summary>
            Deliver the messages
            </summary>
      <param name="gt">
      </param>
    </member>
    <member name="M:PloobsEngine.MessageSystem.MessageDeliver.SendMessageWithChecking(PloobsEngine.MessageSystem.Message)">
      <summary>
            Check is performed NOW,if the message is send later problems may occur
            </summary>
      <param name="mem">The mem.</param>
      <returns>
      </returns>
    </member>
    <member name="M:PloobsEngine.MessageSystem.MessageDeliver.SendMessage(PloobsEngine.MessageSystem.Message)">
      <summary>
            Put the message in the Sender Queue
            </summary>
      <param name="mem">The mem.</param>
    </member>
    <member name="M:PloobsEngine.MessageSystem.MessageDeliver.getMyName">
      <summary>
            Gets The component Name.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="P:PloobsEngine.MessageSystem.MessageDeliver.NumMessagerdeliveredByFrame">
      <summary>
            Gets or sets the messagerdelivered by frame.
            </summary>
      <value>
            The num messagerdelivered by frame.
            </value>
    </member>
    <member name="P:PloobsEngine.MessageSystem.MessageDeliver.ComponentType">
      <summary>
            Gets the type of the component.
            </summary>
      <value>
            The type of the component.
            </value>
    </member>
    <member name="T:PloobsEngine.MessageSystem.MessageComparer">
      <summary>
            Message Comparer
            </summary>
    </member>
    <member name="M:PloobsEngine.MessageSystem.MessageComparer.Compare(PloobsEngine.MessageSystem.Message,PloobsEngine.MessageSystem.Message)">
      <summary>
            Compares the messages
            </summary>
      <param name="nodeA">The node A.</param>
      <param name="nodeb">The nodeb.</param>
      <returns>
      </returns>
    </member>
    <member name="T:PloobsEngine.MessageSystem.DelayComparer">
      <summary>
            Delay Comparer
            </summary>
    </member>
    <member name="M:PloobsEngine.MessageSystem.DelayComparer.Compare(PloobsEngine.MessageSystem.Message,PloobsEngine.MessageSystem.Message)">
      <summary>
            Compare the delays of the messages
            </summary>
      <param name="nodeA">The node A.</param>
      <param name="nodeb">The nodeb.</param>
      <returns>
      </returns>
    </member>
    <member name="T:PloobsEngine.Engine.Logger.LogLevel">
      <summary>
            Log Levels
            </summary>
    </member>
    <member name="F:PloobsEngine.Engine.Logger.LogLevel.FatalError">
      <summary>
            WHen a Fatal error occurrs, Normally the application also throw an exception when this happen
            </summary>
    </member>
    <member name="F:PloobsEngine.Engine.Logger.LogLevel.RecoverableError">
      <summary>
            Errors that the engine can handle, but the user should correct
            </summary>
    </member>
    <member name="F:PloobsEngine.Engine.Logger.LogLevel.Warning">
      <summary>
            When something happens that can be an error
            </summary>
    </member>
    <member name="T:PloobsEngine.IScreenUpdateable">
      <summary>
            Updateable component
            Can be atached to a screen, and everytime the screens's update is called
            this class update is also called
            has an id
            </summary>
    </member>
    <member name="M:PloobsEngine.IScreenUpdateable.#ctor(PloobsEngine.SceneControl.IScreen)">
      <summary>
            Initializes a new instance of the <see cref="T:PloobsEngine.IScreenUpdateable" /> class.
            </summary>
      <param name="owner">The screen owner.</param>
    </member>
    <member name="M:PloobsEngine.IScreenUpdateable.Start">
      <summary>
            Starts this instance.
            The update will be called after this call
            </summary>
    </member>
    <member name="M:PloobsEngine.IScreenUpdateable.Stop">
      <summary>
            Stops the updating method being called
            </summary>
    </member>
    <member name="M:PloobsEngine.IScreenUpdateable.Update(Microsoft.Xna.Framework.GameTime)">
      <summary>
            Updates this called
            Should be overloaded
            </summary>
      <param name="gameTime">The game time.</param>
    </member>
    <member name="M:PloobsEngine.IScreenUpdateable.GetId">
      <summary>
            return the entity id
            </summary>
      <returns>
            the id
            </returns>
    </member>
    <member name="M:PloobsEngine.IScreenUpdateable.CleanUp">
      <summary>
            Cleans up.
            </summary>
    </member>
    <member name="M:PloobsEngine.IScreenUpdateable.SetId(System.Int32)">
      <summary>
            sets the id
            </summary>
      <param name="id">
      </param>
    </member>
    <member name="T:PloobsEngine.Physics2D.Farseer.ConvertUnits">
      <summary>
            Convert units between display and simulation units.
            </summary>
    </member>
    <member name="T:Bnoerj.AI.Steering.Pathway">
      <summary>
            Pathway: a pure virtual base class for an abstract pathway in space, as for
            example would be used in path following.
            </summary>
    </member>
    <member name="T:Bnoerj.AI.Steering.IObstacle">
      <summary>
            Obstacle: a pure virtual base class for an abstract shape in space, to be
            used with obstacle avoidance.
            
            XXX this should define generic methods for querying the obstacle shape
            </summary>
    </member>
    <member name="T:PloobsEngine.Physics.SegmentInterceptInfo">
      <summary>
            Interception Info
            RayCast using PhysicEngine directly
            </summary>
    </member>
    <member name="P:PloobsEngine.Physics.SegmentInterceptInfo.PhysicObject">
      <summary>
            Gets or sets the physic object itercepted.
            </summary>
      <value>
            The physic object.
            </value>
    </member>
    <member name="P:PloobsEngine.Physics.SegmentInterceptInfo.Distance">
      <summary>
            Gets or sets the distance from the object to the ray source.
            </summary>
      <value>
            The distance.
            </value>
    </member>
    <member name="P:PloobsEngine.Physics.SegmentInterceptInfo.ImpactPosition">
      <summary>
            Gets or sets the impact position.
            </summary>
      <value>
            The impact position.
            </value>
    </member>
    <member name="P:PloobsEngine.Physics.SegmentInterceptInfo.ImpactNormal">
      <summary>
            Gets or sets the impact normal.
            </summary>
      <value>
            The impact normal.
            </value>
    </member>
    <member name="T:PloobsEngine.Material.TreeMaterial">
      <summary>
            Tree Material
            </summary>
    </member>
    <member name="M:PloobsEngine.Material.TreeMaterial.#ctor(PloobsEngine.Material.DeferredTreeShader)">
      <summary>
            Initializes a new instance of the <see cref="T:PloobsEngine.Material.TreeMaterial" /> class.
            </summary>
      <param name="shader">The shader.</param>
    </member>
    <member name="M:PloobsEngine.Material.TreeMaterial.#ctor(PloobsEngine.Material.ForwardTreeShader)">
      <summary>
            Initializes a new instance of the <see cref="T:PloobsEngine.Material.TreeMaterial" /> class.
            </summary>
      <param name="shader">The shader.</param>
    </member>
    <member name="M:PloobsEngine.Material.TreeMaterial.#ctor(PloobsEngine.Material.DeferredTreeShader,LTreesLibrary.Trees.Wind.WindSource)">
      <summary>
            Initializes a new instance of the <see cref="T:PloobsEngine.Material.TreeMaterial" /> class.
            </summary>
      <param name="shader">The shader.</param>
      <param name="wsource">The wsource.</param>
    </member>
    <member name="M:PloobsEngine.Material.TreeMaterial.#ctor(PloobsEngine.Material.ForwardTreeShader,LTreesLibrary.Trees.Wind.WindSource)">
      <summary>
            Initializes a new instance of the <see cref="T:PloobsEngine.Material.TreeMaterial" /> class.
            </summary>
      <param name="shader">The shader.</param>
      <param name="wsource">The wsource.</param>
    </member>
    <member name="P:PloobsEngine.Material.TreeMaterial.Wsource">
      <summary>
            Gets or sets the wsource.
            </summary>
      <value>
            The wsource.
            </value>
    </member>
    <member name="P:PloobsEngine.Material.TreeMaterial.IsVisible">
      <summary>
            Gets or sets a value indicating whether this instance is visible.
            </summary>
      <value>
        <c>true</c> if this instance is visible; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="F:PloobsEngine.Features.DebugDraw.DebugLines.effect">
      <summary>
            The basic effect used to draw boxes.
            </summary>
    </member>
    <member name="M:PloobsEngine.Features.DebugDraw.DebugLines.AddLine(Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Color)">
      <summary>
            Add a Line
            You cant remove it        
            </summary>
      <param name="StartPoint">The start point.</param>
      <param name="EndPoint">The end point.</param>
      <param name="color">The box's color.</param>
    </member>
    <member name="M:PloobsEngine.Features.DebugDraw.DebugLines.ClearLines">
      <summary>
            Clears the lines.
            </summary>
    </member>
    <member name="M:PloobsEngine.Features.DebugDraw.DebugLines.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:PloobsEngine.Features.DebugDraw.DebugLines" /> class.        
            Use addline to add lines =P
            </summary>
    </member>
    <member name="M:PloobsEngine.Features.DebugDraw.DebugLines.Draw(PloobsEngine.SceneControl.RenderHelper,Microsoft.Xna.Framework.Matrix,Microsoft.Xna.Framework.Matrix)">
      <summary>
            Draws the box.
            </summary>
      <param name="view">The viewing matrix.</param>
      <param name="projection">The projection matrix.</param>
    </member>
    <member name="T:PloobsEngine.Audio.ISoundEmitter3D">
      <summary>
            Generic Sound 3D Emiter 
            </summary>
    </member>
    <member name="M:PloobsEngine.Audio.ISoundEmitter3D.Update(Microsoft.Xna.Framework.GameTime,PloobsEngine.Cameras.ICamera)">
      <summary>
            Updates .
            </summary>
      <param name="gt">The gt.</param>
      <param name="camera">The camera.</param>
    </member>
    <member name="M:PloobsEngine.Audio.ISoundEmitter3D.Pause">
      <summary>
            Pauses the sound
            </summary>
    </member>
    <member name="M:PloobsEngine.Audio.ISoundEmitter3D.Resume">
      <summary>
            Resumes the sound
            </summary>
    </member>
    <member name="M:PloobsEngine.Audio.ISoundEmitter3D.Play">
      <summary>
            Plays the sound
            </summary>
    </member>
    <member name="M:PloobsEngine.Audio.ISoundEmitter3D.Stop(System.Boolean)">
      <summary>
            Stops the sound
            </summary>
    </member>
    <member name="P:PloobsEngine.Audio.ISoundEmitter3D.State">
      <summary>
            Gets the Sound state.
            </summary>
    </member>
    <member name="T:PloobsEngine.IA.WAYPOINTTYPE">
      <summary>
            EXEMPLOS DE TIPOS DE WAYPONIT
            </summary>
    </member>
    <member name="T:PloobsEngine.IA.NeuralNetwork.LearningAlgorithm">
      <summary>
            The abstract class describing a learning
            algorithm for a neural network
            </summary>
    </member>
    <member name="F:PloobsEngine.IA.NeuralNetwork.LearningAlgorithm.nn">
      <summary>
            The neural network
            </summary>
    </member>
    <member name="F:PloobsEngine.IA.NeuralNetwork.LearningAlgorithm.ERROR_THRESHOLD">
      <summary>
            Under this threshold value, learning will be
            considered as complete
            </summary>
    </member>
    <member name="F:PloobsEngine.IA.NeuralNetwork.LearningAlgorithm.MAX_ITER">
      <summary>
            Max number of iteration to learn data
            </summary>
    </member>
    <member name="F:PloobsEngine.IA.NeuralNetwork.LearningAlgorithm.ins">
      <summary>
            Input matrix of data to learn
            </summary>
    </member>
    <member name="F:PloobsEngine.IA.NeuralNetwork.LearningAlgorithm.outs">
      <summary>
            output matrix of data to learn
            </summary>
    </member>
    <member name="F:PloobsEngine.IA.NeuralNetwork.LearningAlgorithm.iter">
      <summary>
            Number of learning iterations done
            </summary>
    </member>
    <member name="F:PloobsEngine.IA.NeuralNetwork.LearningAlgorithm.error">
      <summary>
            Last sum of square errors computed
            </summary>
    </member>
    <member name="M:PloobsEngine.IA.NeuralNetwork.LearningAlgorithm.#ctor(PloobsEngine.IA.NeuralNetwork.NeuralNetwork)">
      <summary>
            Learning algorithm constructor
            </summary>
      <param name="n">The neural network to train</param>
    </member>
    <member name="M:PloobsEngine.IA.NeuralNetwork.LearningAlgorithm.Learn(System.Single[][],System.Single[][])">
      <summary>
            To train the neuronal network on data.
            inputs[n] represents an input vector of 
            the neural network and expected_outputs[n]
            the expected ouput for this vector. 
            </summary>
      <param name="inputs">the input matrix</param>
      <param name="expected_outputs">the expected output matrix</param>
    </member>
    <member name="P:PloobsEngine.IA.NeuralNetwork.LearningAlgorithm.N_Network">
      <summary>
            Get the neural network of the learning algorithm
            </summary>
    </member>
    <member name="P:PloobsEngine.IA.NeuralNetwork.LearningAlgorithm.Error">
      <summary>
            Get the last square error
            </summary>
    </member>
    <member name="P:PloobsEngine.IA.NeuralNetwork.LearningAlgorithm.ErrorTreshold">
      <summary>
            Get or set the maximum sum of square errors value ( &gt;0)
            </summary>
    </member>
    <member name="P:PloobsEngine.IA.NeuralNetwork.LearningAlgorithm.Iteration">
      <summary>
            Get the current number of learning iterations done
            </summary>
    </member>
    <member name="P:PloobsEngine.IA.NeuralNetwork.LearningAlgorithm.MaxIteration">
      <summary>
            Get or set the maximum number of learning iterations.
            </summary>
    </member>
    <member name="T:PloobsEngine.IA.NeuralNetwork.BackPropagationLearningAlgorithm">
      <summary>
            Implementation of stockastic gradient backpropagation
            learning algorithm
            </summary>
      <remarks>
        <code>
            
                                 PROPAGATION WAY IN NN
                               -------------------------&gt;
            
                   o ----- Sj = f(WSj) ----&gt; o ----- Si = f(WSi) ----&gt; o
                 Neuron j                Neuron i                   Neuron k
               (layer L-1)               (layer L)                 (layer L+1)
            
            For the neuron i :
            -------------------
            W[i,j](n+1) = W[i,j](n) + alpha * Ai * Sj + gamma * ( W[i,j](n) - W[i,j](n-1) )
            T[i](n+1) = T[i](n) - alpha * Ai + gamma * ( T[i](n) - T[i](n-1) )
            
            	with :
            			Ai = f'(WSi) * (expected_output_i - si) for output layer
            			Ai = f'(WSi) * SUM( Ak * W[k,i] )       for others
            
            </code>
            NOTE : This is stockastic version of the algorithm because the error
            is back-propaged after every learning case. There is another version
            of this algorithm which works on global error.
            </remarks>
    </member>
    <member name="F:PloobsEngine.IA.NeuralNetwork.BackPropagationLearningAlgorithm.alpha">
      <summary>
            the alpha parameter of the algorithm
            </summary>
    </member>
    <member name="F:PloobsEngine.IA.NeuralNetwork.BackPropagationLearningAlgorithm.gamma">
      <summary>
            the gamma parameter of the algorithm
            </summary>
    </member>
    <member name="F:PloobsEngine.IA.NeuralNetwork.BackPropagationLearningAlgorithm.e">
      <summary>
            The error vector
            </summary>
    </member>
    <member name="M:PloobsEngine.IA.NeuralNetwork.BackPropagationLearningAlgorithm.#ctor(PloobsEngine.IA.NeuralNetwork.NeuralNetwork)">
      <summary>
            Build a new BackPropagation learning algorithm instance
            with alpha = 0,5 and gamma = 0,3
            </summary>
      <param name="nn">The neural network to train</param>
    </member>
    <member name="M:PloobsEngine.IA.NeuralNetwork.BackPropagationLearningAlgorithm.Learn(System.Single[][],System.Single[][])">
      <summary>
            To train the neuronal network on data.
            inputs[n] represents an input vector of 
            the neural network and expected_outputs[n]
            the expected ouput for this vector. 
            </summary>
      <param name="inputs">the input matrix</param>
      <param name="expected_outputs">the expected output matrix</param>
    </member>
    <member name="M:PloobsEngine.IA.NeuralNetwork.BackPropagationLearningAlgorithm.ComputeA(System.Int32)">
      <summary>
            Compute the "A" parameter for each neuron
            of the network
            </summary>
      <param name="i">the index of the curent training data</param>
    </member>
    <member name="M:PloobsEngine.IA.NeuralNetwork.BackPropagationLearningAlgorithm.setWeight(System.Int32)">
      <summary>
            Set new neron's weights
            </summary>
      <param name="i">the index of the curent training data</param>
    </member>
    <member name="P:PloobsEngine.IA.NeuralNetwork.BackPropagationLearningAlgorithm.Alpha">
      <summary>
            get or set the alpha parameter of the algorithm
            between 0 and 1, must be &gt;0
            </summary>
    </member>
    <member name="P:PloobsEngine.IA.NeuralNetwork.BackPropagationLearningAlgorithm.Gamma">
      <summary>
            get or set the gamma parameter of the algorithm
            (Rumelhart coef)
            between 0 and 1.
            </summary>
    </member>
    <member name="T:PloobsEngine.IA.NeuralNetwork.GeneticLearningAlgorithm">
      <summary>
             A genetic learning algorithm
             </summary>
      <remarks>
             This is an aplication of genetic algorithm to train neural networks.
             The population is made of GeneticNeuralNetwork instance which is a
             compact representation of neural network. A genetic neural network
             represent a set of weights and threshold for a particular neural network.
             
             Here is the main loop of the algorithm :
             <code>
            	  Create initial random population of POPULATION_SIZE neural networks
            	   -&gt; Evaluate fitness function (square error on learning values)
            	  |   Select best neural networks
            	  |   Cross selected networks to make new generation
                -- apply mutation operator on new generation
            	  Until error &gt; error_threshold  	   
             </code></remarks>
    </member>
    <member name="T:PloobsEngine.IA.NeuralNetwork.GeneticLearningAlgorithm.GeneticNeuralNetwork">
      <summary>
            Representation of a neural network for the genetic algorithm
            </summary>
    </member>
    <member name="M:PloobsEngine.IA.NeuralNetwork.GeneticLearningAlgorithm.GeneticNeuralNetwork.#ctor(PloobsEngine.IA.NeuralNetwork.NeuralNetwork)">
      <summary>
            Build a new Genetic NeuralNetwork from the Neural Network given as parameter
            </summary>
      <param name="n">The neural network model</param>
    </member>
    <member name="M:PloobsEngine.IA.NeuralNetwork.GeneticLearningAlgorithm.GeneticNeuralNetwork.Init">
      <summary>
            Initialize Genetic network from Neural Network
            </summary>
    </member>
    <member name="M:PloobsEngine.IA.NeuralNetwork.GeneticLearningAlgorithm.GeneticNeuralNetwork.setWeights">
      <summary>
            Set Genetic neural network weights to the real neural network
            </summary>
    </member>
    <member name="M:PloobsEngine.IA.NeuralNetwork.GeneticLearningAlgorithm.GeneticNeuralNetwork.CompareTo(System.Object)">
      <summary>
            Compare 2 genetic neural network on their square error
            </summary>
      <param name="other">another neural network</param>
      <returns>the comparative value</returns>
    </member>
    <member name="P:PloobsEngine.IA.NeuralNetwork.GeneticLearningAlgorithm.GeneticNeuralNetwork.Item(System.Int32)">
      <summary>
            Get or set the genes value
            </summary>
    </member>
    <member name="P:PloobsEngine.IA.NeuralNetwork.GeneticLearningAlgorithm.GeneticNeuralNetwork.Error">
      <summary>
            Get or set the square error of the Network
            </summary>
    </member>
    <member name="P:PloobsEngine.IA.NeuralNetwork.GeneticLearningAlgorithm.GeneticNeuralNetwork.N_Genes">
      <summary>
            Get the number of genes of the Genetic Neural Network
            </summary>
    </member>
    <member name="F:PloobsEngine.IA.NeuralNetwork.GeneticLearningAlgorithm.rand">
      <summary>
            The random number generator
            </summary>
    </member>
    <member name="F:PloobsEngine.IA.NeuralNetwork.GeneticLearningAlgorithm.POPULATION_SIZE">
      <summary>
            The population size
            </summary>
    </member>
    <member name="F:PloobsEngine.IA.NeuralNetwork.GeneticLearningAlgorithm.MUTATION_RATIO">
      <summary>
            The mutation ratio during crossover
            </summary>
    </member>
    <member name="F:PloobsEngine.IA.NeuralNetwork.GeneticLearningAlgorithm.MAX_MUTATION_AMP">
      <summary>
            Maximum mutation amplitude
            </summary>
    </member>
    <member name="F:PloobsEngine.IA.NeuralNetwork.GeneticLearningAlgorithm.SELECTION_RATIO">
      <summary>
            The ratio of population selected for crossover
            </summary>
    </member>
    <member name="F:PloobsEngine.IA.NeuralNetwork.GeneticLearningAlgorithm.population">
      <summary>
            The population of GeneticNeuralNetwork
            </summary>
    </member>
    <member name="M:PloobsEngine.IA.NeuralNetwork.GeneticLearningAlgorithm.CrossOver(System.Int32,System.Int32)">
      <summary>
            Define the crossover operator for 2 GeneticNeuralNetwork
            </summary>
      <param name="i1">index of mother in population</param>
      <param name="i2">index of father in population</param>
      <returns>the child</returns>
    </member>
    <member name="M:PloobsEngine.IA.NeuralNetwork.GeneticLearningAlgorithm.makeNewGeneration">
      <summary>
            Compute the new generation
            </summary>
    </member>
    <member name="M:PloobsEngine.IA.NeuralNetwork.GeneticLearningAlgorithm.ComputeErrors">
      <summary>
            Computes square error for each GeneticNeuralNetwork in population
            </summary>
    </member>
    <member name="M:PloobsEngine.IA.NeuralNetwork.GeneticLearningAlgorithm.#ctor(PloobsEngine.IA.NeuralNetwork.NeuralNetwork)">
      <summary>
            GeneticLearningAlgorithm constructor
            </summary>
      <param name="nn">The neural network to train</param>
    </member>
    <member name="M:PloobsEngine.IA.NeuralNetwork.GeneticLearningAlgorithm.RandomizePopulation">
      <summary>
            Make a new random population
            </summary>
    </member>
    <member name="M:PloobsEngine.IA.NeuralNetwork.GeneticLearningAlgorithm.Learn(System.Single[][],System.Single[][])">
      <summary>
            To train the neuronal network on data.
            inputs[n] represents an input vector of 
            the neural network and expected_outputs[n]
            the expected ouput for this vector. 
            </summary>
      <param name="inputs">the input matrix</param>
      <param name="expected_outputs">the expected output matrix</param>
    </member>
    <member name="P:PloobsEngine.IA.NeuralNetwork.GeneticLearningAlgorithm.PopulationSize">
      <summary>
            Get or set the population size
            </summary>
    </member>
    <member name="P:PloobsEngine.IA.NeuralNetwork.GeneticLearningAlgorithm.MutationRatio">
      <summary>
            Get or set the mutation ratio (between 0 and 100)
            </summary>
    </member>
    <member name="P:PloobsEngine.IA.NeuralNetwork.GeneticLearningAlgorithm.MaxMutationAmplitude">
      <summary>
            Get or set the maximum mutation amplitude
            </summary>
    </member>
    <member name="P:PloobsEngine.IA.NeuralNetwork.GeneticLearningAlgorithm.SelectionRatio">
      <summary>
            get or set the selection ratio
            </summary>
    </member>
    <member name="P:PloobsEngine.IA.NeuralNetwork.GeneticLearningAlgorithm.MutationValue">
      <summary>
            Get the random amplitude of a mutation
            </summary>
    </member>
    <member name="P:PloobsEngine.IA.NeuralNetwork.GeneticLearningAlgorithm.Mute">
      <summary>
            Get a bool with MUTATION_RATIO/100 probability to be true
            </summary>
    </member>
    <member name="P:PloobsEngine.IA.NeuralNetwork.GeneticLearningAlgorithm.RandSelectionIndex">
      <summary>
            Get a random selected neural network in the population
            </summary>
    </member>
    <member name="P:PloobsEngine.IA.NeuralNetwork.GeneticLearningAlgorithm.Muted_NeuralNetwork">
      <summary>
            get a muted GeneticNeuralNetwork from the neural network
            </summary>
    </member>
    <member name="T:PloobsEngine.Utils.XmlContentLoader">
      <summary>
            XML content loader
            </summary>
    </member>
    <member name="M:PloobsEngine.Utils.XmlContentLoader.SaveXmlContent(System.Object,System.Type,System.String)">
      <summary>
            Saves the content of the obj in XML.
            </summary>
      <param name="obj">The obj.</param>
      <param name="tipo">The type.</param>
      <param name="Path">The path.</param>
    </member>
    <member name="M:PloobsEngine.Utils.XmlContentLoader.LoadXmlContent(System.String,System.Type)">
      <summary>
            Loads the content of the XML.
            </summary>
      <param name="name">The name.</param>
      <param name="tipo">The type.</param>
      <returns>object</returns>
    </member>
    <member name="T:PloobsEngine.Utils.TextureCreator">
      <summary>
            Create Procedural textures
            </summary>
    </member>
    <member name="M:PloobsEngine.Utils.TextureCreator.CreateColorTexture(System.Int32,Microsoft.Xna.Framework.Color)">
      <summary>
            Creates the color texture. (one color all texture)
            squared texture
            </summary>
      <param name="size">The size.</param>
      <param name="texCor">The tex cor.</param>
      <returns>
      </returns>
    </member>
    <member name="M:PloobsEngine.Utils.TextureCreator.CreateColorTexture(System.Int32,System.Int32,Microsoft.Xna.Framework.Color,System.Boolean)">
      <summary>
            Creates the color texture. (one color all texture)
            rectangular texture
            </summary>
      <param name="sizex">The sizex.</param>
      <param name="sizey">The sizey.</param>
      <param name="texCor">The tex cor.</param>
      <returns>
      </returns>
    </member>
    <member name="M:PloobsEngine.Utils.TextureCreator.CreateCompleteRandomColorTexture(System.Int32)">
      <summary>
            Creates the complete random color texture.
            squared size
            </summary>
      <param name="size">The size.</param>
      <returns>
      </returns>
    </member>
    <member name="M:PloobsEngine.Utils.TextureCreator.CreateCompleteRandomColorTexture(System.Int32,System.Int32,System.Boolean)">
      <summary>
            Creates the complete random color texture.
            </summary>
      <param name="sizex">The sizex.</param>
      <param name="sizey">The sizey.</param>
      <returns>
      </returns>
    </member>
    <member name="M:PloobsEngine.Utils.TextureCreator.CreateBlackAndWhiteRandomTexture(System.Int32)">
      <summary>
            Creates the black and white random texture. like random, but with the
            same color on all rgb channels
            square
            </summary>
      <param name="size">The size.</param>
      <returns>
      </returns>
    </member>
    <member name="M:PloobsEngine.Utils.TextureCreator.CreateBlackAndWhiteRandomTexture(System.Int32,System.Int32,System.Boolean)">
      <summary>
            Creates the black and white random texture. like random, but with the
            same color on all rgb channels
            </summary>
      <param name="sizex">The sizex.</param>
      <param name="sizey">The sizey.</param>
      <returns>
      </returns>
    </member>
    <member name="M:PloobsEngine.Utils.TextureCreator.CreatePerlinNoiseTexture(System.Int32,System.Single,System.Single,System.Single,System.Int32)">
      <summary>
            Creates the perlin noise texture.
            squared
            </summary>
      <param name="size">The size.</param>
      <param name="frequencia">The frequencia.</param>
      <param name="amplitude">The amplitude.</param>
      <param name="persistence">The persistence.</param>
      <param name="octave">The octave.</param>
      <returns>
      </returns>
    </member>
    <member name="M:PloobsEngine.Utils.TextureCreator.CreatePerlinNoiseTexture(System.Int32,System.Int32,System.Single,System.Single,System.Single,System.Int32,System.Boolean)">
      <summary>
            Creates the perlin noise texture.
            </summary>
      <param name="sizex">The sizex.</param>
      <param name="sizey">The sizey.</param>
      <param name="frequencia">The frequencia.</param>
      <param name="amplitude">The amplitude.</param>
      <param name="persistence">The persistence.</param>
      <param name="octave">The octave.</param>
      <returns>
      </returns>
    </member>
    <member name="P:PloobsEngine.SceneControl.ScatterPostEffect.Density">
      <summary>
            Default 0.1
            </summary>
    </member>
    <member name="P:PloobsEngine.SceneControl.ScatterPostEffect.Weight">
      <summary>
            Defautl 0.1
            </summary>
    </member>
    <member name="P:PloobsEngine.SceneControl.ScatterPostEffect.Decay">
      <summary>
            Default 1;
            </summary>
    </member>
    <member name="P:PloobsEngine.SceneControl.ScatterPostEffect.Exposition">
      <summary>
            Default 0.5f
            </summary>
    </member>
    <member name="M:PloobsEngine.SceneControl.SaturationPostEffect.#ctor(System.Single)">
      <summary>
            Initializes a new instance of the <see cref="T:PloobsEngine.SceneControl.SaturationPostEffect" /> class.
            </summary>
      <param name="saturation">The saturation.</param>
    </member>
    <member name="T:PloobsEngine.MessageSystem.SystemMessageFactory">
      <summary>
            Helper to create system messages
            </summary>
    </member>
    <member name="M:PloobsEngine.MessageSystem.SystemMessageFactory.NotFoundReciever(System.Int32,System.Int32)">
      <summary>
            Not found message.
            </summary>
      <param name="reciever">The reciever.</param>
      <param name="notfoundid">The notfoundid.</param>
      <returns>
      </returns>
    </member>
    <member name="T:PloobsEngine.MessageSystem.Message">
      <summary>
            Message To Be sent
            </summary>
    </member>
    <member name="M:PloobsEngine.MessageSystem.Message.#ctor(System.Int32,System.Int32,System.String,PloobsEngine.MessageSystem.Priority,System.Int32,PloobsEngine.MessageSystem.SenderType,System.Object,System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:PloobsEngine.MessageSystem.Message" /> class.
            </summary>
      <param name="sender">Id of the sender, use -1 to be an undentified sender</param>
      <param name="receiver">Reciever ID, use -1 to send to a Tag group</param>
      <param name="tag">Tag (used to send to a group of entities), if the message will be send to just one reciver, use null here</param>
      <param name="pri">Priority</param>
      <param name="timetodeliver">Time to send the message in MILISECONDS( Use 0 to send in THIS frame and -1 to send NOW)</param>
      <param name="type">Message Type; The engine DONT use this field for NOTHING, its for user control</param>
      <param name="Content">Message Content</param>
      <param name="cod">Message Code, The engine DONT use this field, its for user control</param>
    </member>
    <member name="P:PloobsEngine.MessageSystem.Message.Check">
      <summary>
            Gets or sets the check.
            This is used by the Message deliver to decide id it will check if the
            Reciever exists
            </summary>
      <value>
            The check.
            </value>
    </member>
    <member name="P:PloobsEngine.MessageSystem.Message.Sender">
      <summary>
            Gets or sets the sender ID.
            </summary>
      <value>
            The sender.
            </value>
    </member>
    <member name="P:PloobsEngine.MessageSystem.Message.Receiver">
      <summary>
            Gets or sets the receiver ID.
            </summary>
      <value>
            The receiver.
            </value>
    </member>
    <member name="P:PloobsEngine.MessageSystem.Message.Tag">
      <summary>
            Gets or sets the tag of this message.
            If tag is set, the message will be send to the TAG group, and not to the
            reciever
            </summary>
      <value>
            The tag.
            </value>
    </member>
    <member name="P:PloobsEngine.MessageSystem.Message.Prioridade">
      <summary>
            Gets or sets the Priority.
            </summary>
      <value>
            The prioridade.
            </value>
    </member>
    <member name="P:PloobsEngine.MessageSystem.Message.Timetodeliver">
      <summary>
            Gets or sets the timetodeliver.
            0 for now
            </summary>
      <value>
            The timetodeliver.
            </value>
    </member>
    <member name="P:PloobsEngine.MessageSystem.Message.SenderType">
      <summary>
            Gets or sets the type of the sender.
            </summary>
      <value>
            The type of the sender.
            </value>
    </member>
    <member name="P:PloobsEngine.MessageSystem.Message.Content">
      <summary>
            Gets or sets the content of the message.
            </summary>
      <value>
            The content.
            </value>
    </member>
    <member name="P:PloobsEngine.MessageSystem.Message.Cod">
      <summary>
            Gets or sets the message code.
            </summary>
      <value>
            The cod.
            </value>
    </member>
    <member name="T:PloobsEngine.MessageSystem.Priority">
      <summary>
            Message Priority
            </summary>
    </member>
    <member name="F:PloobsEngine.MessageSystem.Priority.URGENT">
      <summary>
            urgent
            </summary>
    </member>
    <member name="F:PloobsEngine.MessageSystem.Priority.HIGH">
      <summary>
            Hight
            </summary>
    </member>
    <member name="F:PloobsEngine.MessageSystem.Priority.MEDIUM">
      <summary>
            Medium
            </summary>
    </member>
    <member name="F:PloobsEngine.MessageSystem.Priority.LOW">
      <summary>
            Low
            </summary>
    </member>
    <member name="F:PloobsEngine.MessageSystem.Priority.VERYLOW">
      <summary>
            Very low
            </summary>
    </member>
    <member name="T:PloobsEngine.MessageSystem.SenderType">
      <summary>
            Avaliable Sender Types
            </summary>
    </member>
    <member name="T:PloobsEngine.MessageSystem.Checks">
      <summary>
            Types of checking
            </summary>
    </member>
    <member name="T:PloobsEngine.Engine.UnhandledException">
      <summary>
            Delegate Called when a unhandle exception is found in the engine
            </summary>
      <param name="sender">The sender.</param>
      <param name="e">The <see cref="T:System.UnhandledExceptionEventArgs" /> instance containing the event data.</param>
    </member>
    <member name="T:PloobsEngine.Engine.OnExit">
      <summary>
            Delegate Called when the engine exits
            </summary>
      <param name="sender">The sender.</param>
      <param name="e">The <see cref="T:System.EventArgs" /> instance containing the event data.</param>
    </member>
    <member name="T:PloobsEngine.Engine.LoadScreen">
      <summary>
            Delegate resposible to load the first screen
            </summary>
      <param name="ScreenManager">The screen manager.</param>
    </member>
    <member name="T:PloobsEngine.Engine.InitialEngineDescription">
      <summary>
            InitialEngineDescription
            </summary>
    </member>
    <member name="F:PloobsEngine.Engine.InitialEngineDescription.UseAnisotropicFiltering">
      <summary>
            Use Anisotropic Filtering when possible
            </summary>
    </member>
    <member name="F:PloobsEngine.Engine.InitialEngineDescription.ScreenName">
      <summary>
            Screen Name
            </summary>
    </member>
    <member name="F:PloobsEngine.Engine.InitialEngineDescription.UseVerticalSyncronization">
      <summary>
            use V-Sync
            </summary>
    </member>
    <member name="F:PloobsEngine.Engine.InitialEngineDescription.BackBufferHeight">
      <summary>
            BackBufferHeight 
            </summary>
    </member>
    <member name="F:PloobsEngine.Engine.InitialEngineDescription.BackBufferWidth">
      <summary>
            BackBufferWidth
            </summary>
    </member>
    <member name="F:PloobsEngine.Engine.InitialEngineDescription.Logger">
      <summary>
            Logger implementation, can be null for no logging
            </summary>
    </member>
    <member name="F:PloobsEngine.Engine.InitialEngineDescription.isMultiSampling">
      <summary>
            Use Multisampling ?
            </summary>
    </member>
    <member name="F:PloobsEngine.Engine.InitialEngineDescription.useMipMapWhenPossible">
      <summary>
            Use MipMap When creating the Render Targets
            </summary>
    </member>
    <member name="F:PloobsEngine.Engine.InitialEngineDescription.isFullScreen">
      <summary>
            FullScreen Mode ?
            </summary>
    </member>
    <member name="F:PloobsEngine.Engine.InitialEngineDescription.isFixedGameTime">
      <summary>
            If the engine should force 60 fps
            </summary>
    </member>
    <member name="F:PloobsEngine.Engine.InitialEngineDescription.UnhandledException_Handler">
      <summary>
            Handler for unexpected error
            </summary>
    </member>
    <member name="F:PloobsEngine.Engine.InitialEngineDescription.OnExit">
      <summary>
            handler Called when engine exit
            </summary>
    </member>
    <member name="M:PloobsEngine.Engine.InitialEngineDescription.Default">
      <summary>
            Defaults this instance.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:PloobsEngine.Engine.InitialEngineDescription.#ctor(System.String,System.Int32,System.Int32,System.Boolean,Microsoft.Xna.Framework.Graphics.GraphicsProfile,System.Boolean,System.Boolean,System.Boolean,PloobsEngine.Engine.Logger.ILogger,System.Boolean,System.Boolean)">
      <summary>
            Initializes a new instance of the <see cref="T:PloobsEngine.Engine.InitialEngineDescription" /> struct.
            </summary>
      <param name="ScreenName">Name of the screen.</param>
      <param name="BackBufferWidth">Width of the back buffer.</param>
      <param name="BackBufferHeight">Height of the back buffer.</param>
      <param name="isFullScreen">if set to <c>true</c> [is full screen].</param>
      <param name="graphicsProfile">The graphics profile.</param>
      <param name="useVerticalSyncronization">if set to <c>true</c> [use vertical syncronization].</param>
      <param name="isMultiSampling">if set to <c>true</c> [is multi sampling].</param>
      <param name="isFixedGameTime">if set to <c>true</c> [is fixed game time].</param>
      <param name="logger">The logger.</param>
      <param name="useMipMapWhenPossible">if set to <c>true</c> [use mip map when possible].</param>
      <param name="UseAnisotropicFiltering">if set to <c>true</c> [use anisotropic filtering].</param>
    </member>
    <member name="T:PloobsEngine.Engine.SoundMasterOptionDescription">
      <summary>
            Sound Options Desciption
            </summary>
    </member>
    <member name="T:PloobsEngine.Engine.EngineStuff">
      <summary>
            Engine Entry point
            </summary>
    </member>
    <member name="M:PloobsEngine.Engine.EngineStuff.#ctor(PloobsEngine.Engine.InitialEngineDescription@,PloobsEngine.Engine.LoadScreen)">
      <summary>
            Initializes a new instance of the <see cref="T:PloobsEngine.Engine.EngineStuff" /> class.
            </summary>
      <param name="initialDescription">The initial description.</param>
      <param name="LoadScreen">The load screen function.</param>
    </member>
    <member name="M:PloobsEngine.Engine.EngineStuff.GetEngineDescription">
      <summary>
            Gets the engine description.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:PloobsEngine.Engine.EngineStuff.ApplyEngineDescription(PloobsEngine.Engine.InitialEngineDescription@)">
      <summary>
            Applies the engine description.
            </summary>
      <param name="initialDescription">The initial description.</param>
    </member>
    <member name="M:PloobsEngine.Engine.EngineStuff.GetSoundMasterOptionDescription">
      <summary>
            Gets the sound master option description.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:PloobsEngine.Engine.EngineStuff.SetSoundMasterOptionDescription(PloobsEngine.Engine.SoundMasterOptionDescription@)">
      <summary>
            Sets the sound master option description.
            </summary>
      <param name="soundMasterOptionDescription">The sound master option description.</param>
    </member>
    <member name="M:PloobsEngine.Engine.EngineStuff.LoadContent">
      <summary>
            Load the content
            </summary>
    </member>
    <member name="M:PloobsEngine.Engine.EngineStuff.AddComponent(PloobsEngine.Components.IComponent)">
      <summary>
            Adds the component.
            </summary>
      <param name="component">The component.</param>
    </member>
    <member name="M:PloobsEngine.Engine.EngineStuff.RemoveComponent(System.String)">
      <summary>
            Removes the component by name
            </summary>
      <param name="componentName">Name of the component.</param>
    </member>
    <member name="M:PloobsEngine.Engine.EngineStuff.GetComponent``1(System.String)">
      <summary>
            Gets the component by name.
            </summary>
      <typeparam name="T">Component type</typeparam>
      <param name="componentName">Name of the component.</param>
      <returns>
      </returns>
    </member>
    <member name="M:PloobsEngine.Engine.EngineStuff.HasComponent(System.String)">
      <summary>
            Determines whether the specified component name exist.
            </summary>
      <param name="componentName">Name of the component.</param>
      <returns>
        <c>true</c> if the specified component name has component; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="M:PloobsEngine.Engine.EngineStuff.ShowMissingRequirementMessage(System.Exception)">
      <summary>
            This is used to display an error message if there is no suitable graphics device or sound card.
            </summary>
      <param name="exception">The exception to display.</param>
      <returns>
      </returns>
    </member>
    <member name="M:PloobsEngine.Engine.EngineStuff.Update(Microsoft.Xna.Framework.GameTime)">
      <summary>
            Updates the engine, called by XNA
            </summary>
      <param name="gameTime">Time passed since the last call to Update.</param>
    </member>
    <member name="M:PloobsEngine.Engine.EngineStuff.Draw(Microsoft.Xna.Framework.GameTime)">
      <summary>
            Reference page contains code sample.
            </summary>
      <param name="gameTime">Time passed since the last call to Draw.</param>
    </member>
    <member name="T:PloobsEngine.DataStructure.TreeNode`1">
      <summary>
            Tree Node Implementatio
            </summary>
      <typeparam name="E">
      </typeparam>
    </member>
    <member name="F:PloobsEngine.DataStructure.TreeNode`1.value">
      <summary>
            The value of this particular Tree Node.
            </summary>
    </member>
    <member name="F:PloobsEngine.DataStructure.TreeNode`1.listOfSubNodes">
      <summary>
            The array of subnodes.
            </summary>
    </member>
    <member name="M:PloobsEngine.DataStructure.TreeNode`1.#ctor">
      <summary>
            Default Constructor.
            </summary>
    </member>
    <member name="M:PloobsEngine.DataStructure.TreeNode`1.#ctor(`0,`0[])">
      <summary>
            Constructs a new Tree Node.
            </summary>
      <param name="value">Value for this Node.</param>
      <param name="subNodes">Array of SubNode values.</param>
    </member>
    <member name="M:PloobsEngine.DataStructure.TreeNode`1.Get(System.Int32)">
      <summary>
            Returns one TreeNode at a specific index in this TreeNode's Sub Nodes.
            </summary>
      <param name="index">Index of TreeNode to return.</param>
      <returns>TreeNode at index specified.</returns>
    </member>
    <member name="M:PloobsEngine.DataStructure.TreeNode`1.ToString">
      <summary>
            Returns a String representation of this TreeNode and all the Sub Nodes.
            </summary>
    </member>
    <member name="M:PloobsEngine.DataStructure.TreeNode`1.GetString(PloobsEngine.DataStructure.TreeNode{`0})">
      <summary>
            Helper method for ToString().
            </summary>
    </member>
    <member name="P:PloobsEngine.DataStructure.TreeNode`1.Value">
      <summary>
            Gets and sets the value of this Tree Node.
            </summary>
    </member>
    <member name="P:PloobsEngine.DataStructure.TreeNode`1.SubNodes">
      <summary>
            Gets and sets SubNodes.
            </summary>
    </member>
    <member name="T:Bnoerj.AI.Steering.SphericalObstacle">
      <summary>
            SphericalObstacle a simple concrete type of obstacle.
            </summary>
    </member>
    <member name="T:Bnoerj.AI.Steering.LocalityQueryDB">
      <summary>
            This structure represents the spatial database.  Typically one of
            these would be created, by a call to lqCreateDatabase, for a given
            application.
            </summary>
    </member>
    <member name="T:Bnoerj.AI.Steering.LocalityQueryDB.ClientProxy">
      <summary>
            This structure is a proxy for (and contains a pointer to) a client
            (application) obj in the spatial database.  One of these exists
            for each client obj.  This might be included within the
            structure of a client obj, or could be allocated separately.
            </summary>
    </member>
    <member name="M:PloobsEngine.Physics.Bepu.TerrainObject.SetMaterialDescription(PloobsEngine.Physics.MaterialDescription)">
      <summary>
            Sets the material description.
            </summary>
      <param name="materialDescription">The material description.</param>
    </member>
    <member name="M:PloobsEngine.Physics.Bepu.TerrainObject.GetMaterialDescription">
      <summary>
            Gets the material description.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:PloobsEngine.Physics.Bepu.TerrainObject.#ctor(PloobsEngine.Engine.GraphicFactory,System.String,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Matrix,PloobsEngine.Physics.MaterialDescription,System.Single,System.Single,System.Single)">
      <summary>
            Create a Terrain Physic Object
            </summary>
      <param name="gfactory">The gfactory.</param>
      <param name="heighmapName">Name of the heighmap texture</param>
      <param name="translation">The translation.</param>
      <param name="rotation">The rotation.</param>
      <param name="XSpacing">The X spacing.</param>
      <param name="ZSpacing">The Z spacing.</param>
      <param name="heightMultipler">Default 10 - controla a altura, menor mais alto</param>
    </member>
    <member name="P:PloobsEngine.Physics.Bepu.TerrainObject.MaxHeight">
      <summary>
            Gets the height of the max.
            </summary>
      <value>
            The height of the max.
            </value>
    </member>
    <member name="P:PloobsEngine.Physics.Bepu.TerrainObject.MinHeight">
      <summary>
            Gets the height of the min.
            </summary>
      <value>
            The height of the min.
            </value>
    </member>
    <member name="P:PloobsEngine.Physics.Bepu.TerrainObject.Terrain">
      <summary>
            Gets the terrain.
            </summary>
    </member>
    <member name="P:PloobsEngine.Physics.Bepu.TerrainObject.HeightMap">
      <summary>
            Gets the height map.
            </summary>
    </member>
    <member name="M:PloobsEngine.Physic.PhysicObjects.BepuObject.GravitationalFieldObject.#ctor(BEPUphysics.UpdateableSystems.ForceFields.ForceFieldShape,Microsoft.Xna.Framework.Vector3,System.Single,System.Single,PloobsEngine.Physics.BepuPhysicWorld)">
      <summary>
            Creates a gravitational field.
            </summary>
      <param name="shape">Shape representing the volume of the force field.</param>
      <param name="origin">Location that entities will be pushed toward.</param>
      <param name="multiplier">Represents the gravitational constant of the field times the effective mass at the center of the field.</param>
      <param name="maxForce">Maximum force the field can apply.</param>
      <param name="physicWorld">The physic world.</param>
    </member>
    <member name="M:PloobsEngine.Physic.PhysicObjects.BepuObject.GravitationalFieldObject.CalculateImpulse(BEPUphysics.Entities.Entity,System.Single,Microsoft.Xna.Framework.Vector3@)">
      <summary>
            Calculates the gravitational force to apply to the entity.
            </summary>
      <param name="e">Target of the impulse.</param>
      <param name="dt">Time since the last frame in simulation seconds.</param>
      <param name="impulse">Force to apply at the given position.</param>
    </member>
    <member name="P:PloobsEngine.Physic.PhysicObjects.BepuObject.GravitationalFieldObject.Multiplier">
      <summary>
            Gets or sets the gravitational constant of the field times the effective mass at the center of the field.
            </summary>
    </member>
    <member name="P:PloobsEngine.Physic.PhysicObjects.BepuObject.GravitationalFieldObject.MaxForce">
      <summary>
            Gets or sets the maximum force that can be applied by the field.
            </summary>
    </member>
    <member name="P:PloobsEngine.Physic.PhysicObjects.BepuObject.GravitationalFieldObject.Origin">
      <summary>
            Gets or sets the center of the field that entities will be pushed toward.
            </summary>
    </member>
    <member name="T:PloobsEngine.Material.DeferredWaterShader">
      <summary>
            Ocean Water
            </summary>
    </member>
    <member name="M:PloobsEngine.Material.DeferredWaterShader.SetDefault">
      <summary>
            Set Default Parameters
            </summary>
    </member>
    <member name="P:PloobsEngine.Material.DeferredWaterShader.BumpHeight">
      <summary>
            Height of water bump texture.
            Min 0.0 Max 2.0 Default = .5
            </summary>
      <value>
            The height of the bump.
            </value>
    </member>
    <member name="P:PloobsEngine.Material.DeferredWaterShader.TextureScale">
      <summary>
            Scale of bump texture.
            </summary>
      <value>
            The texture scale.
            </value>
    </member>
    <member name="P:PloobsEngine.Material.DeferredWaterShader.BumpSpeed">
      <summary>
            Velocity of water flow
            </summary>
      <value>
            The bump speed.
            </value>
    </member>
    <member name="P:PloobsEngine.Material.DeferredWaterShader.FresnelBias">
      <summary>
            Min 0.0 Max 1.0 Default = .025
            </summary>
      <value>
            The fresnel bias.
            </value>
    </member>
    <member name="P:PloobsEngine.Material.DeferredWaterShader.FresnelPower">
      <summary>
            Min 0.0 Max 10.0 Default = 1.0;
            </summary>
      <value>
            The fresnel power.
            </value>
    </member>
    <member name="P:PloobsEngine.Material.DeferredWaterShader.HDRMultiplier">
      <summary>
            Min = 0.0 Max = 100 Default = 1.0
            </summary>
      <value>
            The HDR multiplier.
            </value>
    </member>
    <member name="P:PloobsEngine.Material.DeferredWaterShader.DeepWaterColor">
      <summary>
            Color of deep water Default = Black;
            </summary>
      <value>
            The color of the deep water.
            </value>
    </member>
    <member name="P:PloobsEngine.Material.DeferredWaterShader.ShallowWaterColor">
      <summary>
            Color of shallow water Default = SkyBlue
            </summary>
      <value>
            The color of the shallow water.
            </value>
    </member>
    <member name="P:PloobsEngine.Material.DeferredWaterShader.ReflectionColor">
      <summary>
            Default = White
            </summary>
      <value>
            The color of the reflection.
            </value>
    </member>
    <member name="P:PloobsEngine.Material.DeferredWaterShader.ReflectionAmount">
      <summary>
            Min = 0.0 Max = 2.0 Default = .5
            </summary>
      <value>
            The reflection amount.
            </value>
    </member>
    <member name="P:PloobsEngine.Material.DeferredWaterShader.WaterAmount">
      <summary>
            Amount of water color to use.
            Min = 0 Max = 2 Default = 0;
            </summary>
      <value>
            The water amount.
            </value>
    </member>
    <member name="P:PloobsEngine.Material.DeferredWaterShader.WaveAmplitude">
      <summary>
            Min = 0.0 Max = 10 Defatult = 0.5
            </summary>
      <value>
            The wave amplitude.
            </value>
    </member>
    <member name="P:PloobsEngine.Material.DeferredWaterShader.WaveFrequency">
      <summary>
            Min = 0 Max = 1 Default .1
            </summary>
      <value>
            The wave frequency.
            </value>
    </member>
    <member name="P:PloobsEngine.Material.DeferredWaterShader.MaterialType">
      <summary>
            Gets the type of the material.
            </summary>
      <value>
            The type of the material.
            </value>
    </member>
    <member name="P:PloobsEngine.Material.DeferredCilindricGPUBilboardShader.AllowRotationDirection">
      <summary>
            Default Vector3(0, 1, 0)
            </summary>
    </member>
    <member name="P:PloobsEngine.Material.DeferredCilindricGPUBilboardShader.Scale">
      <summary>
            Default Vector2(100, 100)
            </summary>
    </member>
    <member name="P:PloobsEngine.Material.DeferredCilindricGPUBilboardShader.Atenuation">
      <summary>
            Default Vector4.One
            </summary>
    </member>
    <member name="T:PloobsEngine.Events.SimpleEvent">
      <summary>
            Evento Simples com alvos simples
            </summary>
    </member>
    <member name="T:PloobsEngine.Audio.SoundAudioPlayer">
      <summary>
            SoundPlayer
            </summary>
    </member>
    <member name="M:PloobsEngine.Audio.SoundAudioPlayer.#ctor(PloobsEngine.SceneControl.IContentManager)">
      <summary>
            Initializes a new instance of the <see cref="T:PloobsEngine.Audio.SoundAudioPlayer" /> class.
            </summary>
      <param name="cmanager">The cmanager.</param>
    </member>
    <member name="M:PloobsEngine.Audio.SoundAudioPlayer.PlaySoundEffect(System.String)">
      <summary>
            Plays the effect song.
            </summary>
      <param name="songName">Name of the song.</param>
    </member>
    <member name="M:PloobsEngine.Audio.SoundAudioPlayer.PauseSoundEffect(System.String)">
      <summary>
            Pauses the effect song.
            </summary>
      <param name="songName">Name of the song.</param>
    </member>
    <member name="M:PloobsEngine.Audio.SoundAudioPlayer.ResumeSoundEffect(System.String)">
      <summary>
            Resumes the specified song name.
            </summary>
      <param name="songName">Name of the song.</param>
    </member>
    <member name="M:PloobsEngine.Audio.SoundAudioPlayer.StopSoundEffect(System.String)">
      <summary>
            Stops the effect song.
            </summary>
      <param name="songName">Name of the song.</param>
    </member>
    <member name="M:PloobsEngine.Audio.SoundAudioPlayer.SoundState(System.String)">
      <summary>
            State of the parameter songName
            </summary>
      <param name="songName">Name of the song.</param>
      <returns>
      </returns>
    </member>
    <member name="M:PloobsEngine.Audio.SoundAudioPlayer.AddSoundToRepository(System.String,System.String,System.Single,System.Single,System.Single,System.Boolean)">
      <summary>
            Add A Sound Effect to the Repo
            </summary>
      <param name="musicNamePath">filepath</param>
      <param name="musicName">Name used to refer to this effect latter</param>
      <param name="volume">between 0 - 1</param>
      <param name="pitch">between -1 to 1 (octaves)</param>
      <param name="pan">between -1 to 1 (left - right)</param>
      <param name="isLooped">if set to <c>true</c> [is looped].</param>
    </member>
    <member name="M:PloobsEngine.Audio.SoundAudioPlayer.RemoveSoundFromRepository(System.String)">
      <summary>
            Removes the effect from repository.
            </summary>
      <param name="soundEffectName">Name of the sound effect.</param>
    </member>
    <member name="M:PloobsEngine.Audio.SoundAudioPlayer.HasSoundEffect(System.String)">
      <summary>
            Determines whether [This Audio Player has] [the specified sound effect name].
            </summary>
      <param name="soundEffectName">Name of the sound effect.</param>
      <returns>
        <c>true</c> if [has the specified sound effect] otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="M:PloobsEngine.Audio.SoundAudioPlayer.GetSoundEffectInstance(System.String)">
      <summary>
            Gets the sound effect instance.
            The SimpleSoundEffect MUST BE ALREADY IN THE REPO !!!
            TO CREATE A Non SHARED SIMPLESOUNDEFFECT, USE THE SIMPLESOUNDEFFECT CONSTRUTOR.
            </summary>
      <param name="soundEffectName">Name of the sound effect.</param>
      <returns>
      </returns>
    </member>
    <member name="M:PloobsEngine.Audio.SoundAudioPlayer.RemoveAllSounds">
      <summary>
            Removes all sounds.
            </summary>
    </member>
    <member name="M:PloobsEngine.IA.WaypointHandler.Clear">
      <summary>
            ReInicia a Instancia do handler
            </summary>
    </member>
    <member name="M:PloobsEngine.IA.WaypointHandler.LoadUnconnectedWaypoints(System.String)">
      <summary>
            Loads the unconnected waypoints.
            If it is connected, it will be unconnected
            </summary>
      <param name="FileName">Name of the file.</param>
    </member>
    <member name="T:PloobsEngine.IA.Genetic.GA">
      <summary>
            Genetic Algorithm class
            </summary>
    </member>
    <member name="M:PloobsEngine.IA.Genetic.GA.#ctor">
      <summary>
            Default constructor sets mutation rate to 5%, crossover to 80%, population to 100,
            and generations to 2000.
            </summary>
    </member>
    <member name="M:PloobsEngine.IA.Genetic.GA.Go">
      <summary>
            PlayMusic which starts the GA executing.
            </summary>
    </member>
    <member name="M:PloobsEngine.IA.Genetic.GA.RouletteSelection">
      <summary>
            After ranking all the genomes by fitness, use a 'roulette wheel' selection
            method.  This allocates a large probability of selection to those with the 
            highest fitness.
            </summary>
      <returns>Random individual biased towards highest fitness</returns>
    </member>
    <member name="M:PloobsEngine.IA.Genetic.GA.RankPopulation">
      <summary>
            Rank population and sort in order of fitness.
            </summary>
    </member>
    <member name="M:PloobsEngine.IA.Genetic.GA.CreateGenomes">
      <summary>
            Create the *initial* genomes by repeated calling the supplied fitness function
            </summary>
    </member>
    <member name="P:PloobsEngine.IA.Genetic.GA.Elitism">
      <summary>
            Keep previous generation's fittest individual in place of worst in current
            </summary>
    </member>
    <member name="T:PloobsEngine.Utils.BundleHandler">
      <summary>
            Handles Bundle like files
            </summary>
    </member>
    <member name="M:PloobsEngine.Utils.BundleHandler.getBundle(System.String)">
      <summary>
            Parse files info of the type a=b and t=return a dicionary with keys and values
            % is a comentary
            </summary>
      <param name="filename">file name</param>
      <returns>dic with the parse info</returns>
    </member>
    <member name="F:PloobsEngine.SceneControl.SunPostEffect.sunColor">
      <summary>
            default = Color.White
            </summary>
    </member>
    <member name="F:PloobsEngine.SceneControl.SunPostEffect.sunIntensity">
      <summary>
            default = 1
            </summary>
    </member>
    <member name="F:PloobsEngine.SceneControl.SunPostEffect.sunSunSize">
      <summary>
            default = 1500
            </summary>
    </member>
    <member name="F:PloobsEngine.SceneControl.SunPostEffect.sunPosition">
      <summary>
            default = Vector3(1000,1000,0)
            </summary>
    </member>
    <member name="M:PloobsEngine.SceneControl.SunPostEffect.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:PloobsEngine.SceneControl.SunPostEffect" /> class.
            </summary>
      <param name="flareTexture">The flare texture, null to use default.</param>
    </member>
    <member name="T:PloobsEngine.Modelo.SimpleModel">
      <summary>
            Implementation of the most simple Model in the engine
            </summary>
    </member>
    <member name="M:PloobsEngine.Modelo.SimpleModel.#ctor(PloobsEngine.Engine.GraphicFactory,System.String,System.String,System.String,System.String,System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:PloobsEngine.Modelo.SimpleModel" /> class.
            </summary>
      <param name="factory">The graphic factory.</param>
      <param name="modelName">Name of the model.</param>
      <param name="diffuseTextureName">Name of the diffuse texture.</param>
      <param name="bumpTextureName">Name of the bump texture.</param>
      <param name="specularTextureName">Name of the specular texture.</param>
      <param name="glowTextureName">Name of the glow texture.</param>
      <param name="CallLoadContent">if set to <c>true</c> [call load content].</param>
    </member>
    <member name="T:PloobsEngine.Modelo.Animation.IAnimatedModel">
      <summary>
            New Kind of Model specific for Animations
            </summary>
    </member>
    <member name="M:PloobsEngine.Modelo.Animation.IAnimatedModel.GetAnimation">
      <summary>
            Gets the animation Information from Model
            It can be for example the Bone hierarchy of the model
            The result need to be casted (vary toooo much between animation APIs, better to keep as Object)
            </summary>
      <returns>
      </returns>
    </member>
    <member name="T:PloobsEngine.Modelo.Animation.IAnimatedController">
      <summary>
            Animation Controler Interface
            User interact with animated model by this controller
            </summary>
    </member>
    <member name="M:PloobsEngine.Modelo.Animation.IAnimatedController.ChangeAnimation(System.String,PloobsEngine.Modelo.Animation.AnimationChangeMode)">
      <summary>
            Changes the animation.
            </summary>
      <param name="animationName">Name of the animation.</param>
      <param name="mode">The interpolation mode.</param>
    </member>
    <member name="M:PloobsEngine.Modelo.Animation.IAnimatedController.Update(Microsoft.Xna.Framework.GameTime)">
      <summary>
            Updates the controller.
            CAlled by the API
            </summary>
      <param name="gt">The gt.</param>
    </member>
    <member name="M:PloobsEngine.Modelo.Animation.IAnimatedController.ChangeInterpolationMode(PloobsEngine.Modelo.Animation.AnimationInterpolationMode)">
      <summary>
            Changes the interpolation mode.
            </summary>
      <param name="im">The im.</param>
    </member>
    <member name="M:PloobsEngine.Modelo.Animation.IAnimatedController.GetBoneTransformations">
      <summary>
            Gets the bone transformations.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:PloobsEngine.Modelo.Animation.IAnimatedController.TransformBone(System.String,Microsoft.Xna.Framework.Quaternion)">
      <summary>
            Transforms the bone.
            </summary>
      <param name="boneName">Name of the bone.</param>
      <param name="rot">The rot.</param>
    </member>
    <member name="M:PloobsEngine.Modelo.Animation.IAnimatedController.GetBoneAbsoluteTransform(System.String)">
      <summary>
            Gets the bone absolute transform.
            </summary>
      <param name="boneName">Name of the bone.</param>
      <returns>
      </returns>
    </member>
    <member name="T:PloobsEngine.Modelo.Animation.AnimationChangeMode">
      <summary>
            AnimationChangeMode
            </summary>
    </member>
    <member name="F:PloobsEngine.Modelo.Animation.AnimationChangeMode.Blend">
      <summary>
            Use Blending
            </summary>
    </member>
    <member name="F:PloobsEngine.Modelo.Animation.AnimationChangeMode.Normal">
      <summary>
            Dont use blending
            </summary>
    </member>
    <member name="T:PloobsEngine.Modelo.Animation.AnimationInterpolationMode">
      <summary>
            interpolations Modes
            </summary>
    </member>
    <member name="F:PloobsEngine.Modelo.Animation.AnimationInterpolationMode.No_Interpolation">
      <summary>
            No interpolation, Dont use this !!!
            </summary>
    </member>
    <member name="F:PloobsEngine.Modelo.Animation.AnimationInterpolationMode.Linear_Interpolation">
      <summary>
            Linear
            </summary>
    </member>
    <member name="F:PloobsEngine.Modelo.Animation.AnimationInterpolationMode.Cubic_Interpolation">
      <summary>
            Cubic
            </summary>
    </member>
    <member name="F:PloobsEngine.Modelo.Animation.AnimationInterpolationMode.Spherical_Interpolation">
      <summary>
            Spherical
            </summary>
    </member>
    <member name="T:PloobsEngine.Input.SimpleConcreteMousePositionInputPlayable">
      <summary>
            InputPlaybleMousePosition Implementation for mouse position
            </summary>
    </member>
    <member name="M:PloobsEngine.Input.SimpleConcreteMousePositionInputPlayable.#ctor(PloobsEngine.Input.MouseStateChangeComplete,PloobsEngine.Input.InputMask,PloobsEngine.Input.EntityType)">
      <summary>
            Initializes a new instance of the <see cref="T:PloobsEngine.Input.SimpleConcreteMousePositionInputPlayable" /> class.
            </summary>
      <param name="mst">The MST.</param>
      <param name="mask">The mask.</param>
      <param name="et">The et.</param>
    </member>
    <member name="T:PloobsEngine.Physics.Bepu.TriangleMeshObject">
      <summary>
            Static Triangle Mesh Physic Object
            </summary>
    </member>
    <member name="M:PloobsEngine.Physics.Bepu.TriangleMeshObject.#ctor(PloobsEngine.Modelo.IModelo,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Matrix,Microsoft.Xna.Framework.Vector3,PloobsEngine.Physics.MaterialDescription)">
      <summary>
            Initializes a new instance of the <see cref="T:PloobsEngine.Physics.Bepu.TriangleMeshObject" /> class.
            </summary>
      <param name="model">The model.</param>
      <param name="pos">The pos.</param>
      <param name="rotation">The rotation.</param>
      <param name="scale">The scale.</param>
      <param name="materialDescription">The material description.</param>
    </member>
    <member name="M:PloobsEngine.Physics.Bepu.TriangleMeshObject.#ctor(Microsoft.Xna.Framework.Graphics.Model,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Matrix,Microsoft.Xna.Framework.Vector3,PloobsEngine.Physics.MaterialDescription)">
      <summary>
            Initializes a new instance of the <see cref="T:PloobsEngine.Physics.Bepu.TriangleMeshObject" /> class.
            </summary>
      <param name="model">The model.</param>
      <param name="pos">The pos.</param>
      <param name="rotation">The rotation.</param>
      <param name="scale">The scale.</param>
      <param name="materialDescription">The material description.</param>
    </member>
    <member name="M:PloobsEngine.Physics.Bepu.TriangleMeshObject.ExtractData(Microsoft.Xna.Framework.Vector3[]@,System.Int32[]@,PloobsEngine.Modelo.IModelo)">
      <summary>
            Helper to get the vertex and index List from the model.
            </summary>
      <param name="vert">The vert.</param>
      <param name="ind">The ind.</param>
      <param name="model">The model.</param>
    </member>
    <member name="M:PloobsEngine.Physics.Bepu.TriangleMeshObject.Enable">
      <summary>
            Always enabled
            </summary>
    </member>
    <member name="M:PloobsEngine.Physics.Bepu.TriangleMeshObject.Disable">
      <summary>
            Always enabled
            </summary>
    </member>
    <member name="M:PloobsEngine.Physics.Bepu.TriangleMeshObject.ApplyImpulse(Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3)">
      <summary>
            Cant Aply Impulse on Static Object
            </summary>
      <param name="position">
      </param>
      <param name="force">The force.</param>
    </member>
    <member name="M:PloobsEngine.Physics.Bepu.TriangleMeshObject.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Serialization
            </summary>
      <param name="info">The info.</param>
      <param name="context">The context.</param>
    </member>
    <member name="P:PloobsEngine.Physics.Bepu.TriangleMeshObject.StaticMesh">
      <summary>
            Gets or sets the static mesh.
            </summary>
      <value>
            The static mesh.
            </value>
    </member>
    <member name="P:PloobsEngine.Physics.Bepu.TriangleMeshObject.PhysicObjectTypes">
      <summary>
            Gets the physic object type.
            </summary>
    </member>
    <member name="P:PloobsEngine.Physics.Bepu.TriangleMeshObject.Position">
      <summary>
            Gets or sets the position.
            </summary>
      <value>
            The position.
            </value>
    </member>
    <member name="P:PloobsEngine.Physics.Bepu.TriangleMeshObject.Scale">
      <summary>
            Gets or sets the scale.
            </summary>
      <value>
            The scale.
            </value>
    </member>
    <member name="P:PloobsEngine.Physics.Bepu.TriangleMeshObject.Rotation">
      <summary>
            Gets or sets the rotation.
            </summary>
      <value>
            The rotation.
            </value>
    </member>
    <member name="P:PloobsEngine.Physics.Bepu.TriangleMeshObject.FaceVector">
      <summary>
            Vector pointing to the front
            </summary>
    </member>
    <member name="P:PloobsEngine.Physics.Bepu.TriangleMeshObject.WorldMatrix">
      <summary>
            Gets the world matrix.
            </summary>
    </member>
    <member name="P:PloobsEngine.Physics.Bepu.TriangleMeshObject.AngularVelocity">
      <summary>
            Gets or sets the angular velocity.
            </summary>
      <value>
            The angular velocity.
            </value>
    </member>
    <member name="P:PloobsEngine.Physics.Bepu.TriangleMeshObject.Velocity">
      <summary>
            Gets velocity. Always Zero cause this object is static
            </summary>
      <value>
            The velocity.
            </value>
    </member>
    <member name="P:PloobsEngine.Physics.Bepu.TriangleMeshObject.isMotionLess">
      <summary>
            This object is always motion less
            </summary>
      <value>
        <c>true</c> if this instance is motion less; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="P:PloobsEngine.Physics.Bepu.TriangleMeshObject.ObjectOwner">
      <summary>
            Gets or sets the IObject owner.
            </summary>
      <value>
            The IObject owner.
            </value>
    </member>
    <member name="P:PloobsEngine.Physics.Bepu.TriangleMeshObject.BoundingBox">
      <summary>
            Gets the bounding box IN WORLD COORDINATES
            </summary>
    </member>
    <member name="T:PloobsEngine.IA.NeuralNetwork.NeuralNetwork">
      <summary>
            Implementation of artificial neural network
            </summary>
      <remarks>
        <code>
            
            
                                   o
                                   o  o  o  
               INPUT VECTOR =====&gt; o  o  o =====&gt; OUTPUT VECTOR
                                   o  o  o  
                                   o
                                 NERON LAYERS
            
            </code> 
            Each neuron of the layer N-1 is conected to 
            every neuron of the layer N.
            At the begining the neural network needs to
            learn using couples (INPUT, EXPECTED OUTPUT)
            and a learnig algorithm.
            </remarks>
    </member>
    <member name="F:PloobsEngine.IA.NeuralNetwork.NeuralNetwork.layers">
      <summary>
            Layers of neuron in the network
            </summary>
    </member>
    <member name="F:PloobsEngine.IA.NeuralNetwork.NeuralNetwork.ni">
      <summary>
            Number of inputs of the network
            (number of inputs of the first layer)
            </summary>
    </member>
    <member name="F:PloobsEngine.IA.NeuralNetwork.NeuralNetwork.la">
      <summary>
            Learning algorithm used by the network
            </summary>
    </member>
    <member name="M:PloobsEngine.IA.NeuralNetwork.NeuralNetwork.#ctor(System.Int32,System.Int32[],PloobsEngine.IA.NeuralNetwork.ActivationFunction,PloobsEngine.IA.NeuralNetwork.LearningAlgorithm)">
      <summary>
            Create a new neural network
            with "inputs" inputs and size of "layers"
            layers of neurones.
            The layer i is made with layers_desc[i] neurones.
            The activation function of each neuron is set to n_act.
            The lerning algorithm is set to learn.
            </summary>
      <param name="inputs">Number of inputs of the network</param>
      <param name="layers_desc">Number of neurons for each layer of the network</param>
      <param name="n_act">Activation function for each neuron in the network</param>
      <param name="learn">Learning algorithm to be used by the neural network</param>
    </member>
    <member name="M:PloobsEngine.IA.NeuralNetwork.NeuralNetwork.#ctor(System.Int32,System.Int32[],PloobsEngine.IA.NeuralNetwork.ActivationFunction)">
      <summary>
            Create a new neural network
            with "inputs" inputs and size of "layers"
            layers of neurones.
            The layer i is made with layers_desc[i] neurones.
            The activation function of each neuron is set to n_act.
            The lerning algorithm is set to default (Back Propagation).
            </summary>
      <param name="inputs">Number of inputs of the network</param>
      <param name="layers_desc">Number of neurons for each layer of the network</param>
      <param name="n_act">Activation function for each neuron in the network</param>
    </member>
    <member name="M:PloobsEngine.IA.NeuralNetwork.NeuralNetwork.#ctor(System.Int32,System.Int32[])">
      <summary>
            Create a new neural network
            with "inputs" inputs and size of "layers"
            layers of neurones.
            The layer i is made with layers_desc[i] neurones.
            The activation function of each neuron is set to default (Sigmoid with beta = 1).
            The lerning algorithm is set to default (Back Propagation).
            </summary>
      <param name="inputs">Number of inputs of the network</param>
      <param name="layers_desc">Number of neurons for each layer of the network</param>
    </member>
    <member name="M:PloobsEngine.IA.NeuralNetwork.NeuralNetwork.randomizeWeight">
      <summary>
            Randomize all neurones weights between -0.5 and 0.5
            </summary>
    </member>
    <member name="M:PloobsEngine.IA.NeuralNetwork.NeuralNetwork.randomizeThreshold">
      <summary>
            Randomize all neurones threholds between 0 and 1
            </summary>
    </member>
    <member name="M:PloobsEngine.IA.NeuralNetwork.NeuralNetwork.randomizeAll">
      <summary>
            Randomize all neurones threholds between 0 and 1
            and weights between -0.5 and 0.5
            </summary>
    </member>
    <member name="M:PloobsEngine.IA.NeuralNetwork.NeuralNetwork.setActivationFunction(PloobsEngine.IA.NeuralNetwork.ActivationFunction)">
      <summary>
            Set an activation function to all neurons of the network
            </summary>
      <param name="f">An activation function</param>
    </member>
    <member name="M:PloobsEngine.IA.NeuralNetwork.NeuralNetwork.setRandomizationInterval(System.Single,System.Single)">
      <summary>
            Set the interval in which weights and threshold will be randomized
            </summary>
      <param name="min">
      </param>
      <param name="max">
      </param>
    </member>
    <member name="M:PloobsEngine.IA.NeuralNetwork.NeuralNetwork.Output(System.Single[])">
      <summary>
            Compute the value for the specified input
            </summary>
      <param name="input">the input vector</param>
      <returns>the output vector of the neuronal network</returns>
    </member>
    <member name="M:PloobsEngine.IA.NeuralNetwork.NeuralNetwork.save(System.String)">
      <summary>
            Save the Neural Network in a binary formated file
            </summary>
      <param name="file">the target file path</param>
    </member>
    <member name="M:PloobsEngine.IA.NeuralNetwork.NeuralNetwork.load(System.String)">
      <summary>
            Load a neural network from a binary formated file
            </summary>
      <param name="file">the neural network file file</param>
      <returns>
      </returns>
    </member>
    <member name="P:PloobsEngine.IA.NeuralNetwork.NeuralNetwork.N_Inputs">
      <summary>
            Get number of inputs of the network
            (network input vector size)
            </summary>
    </member>
    <member name="P:PloobsEngine.IA.NeuralNetwork.NeuralNetwork.N_Outputs">
      <summary>
            Get number of output of the network
            (network output vector size)
            </summary>
    </member>
    <member name="P:PloobsEngine.IA.NeuralNetwork.NeuralNetwork.N_Layers">
      <summary>
            Get number of inputs of the network
            (network input vector size)
            </summary>
    </member>
    <member name="P:PloobsEngine.IA.NeuralNetwork.NeuralNetwork.LearningAlg">
      <summary>
            Get or set network learning algorithm
            </summary>
    </member>
    <member name="P:PloobsEngine.IA.NeuralNetwork.NeuralNetwork.Item(System.Int32)">
      <summary>
            Get the n th Layer of the network 
            </summary>
    </member>
    <member name="T:PloobsEngine.SceneControl.OnPicked">
      <summary>
            Fired when Picking something
            </summary>
      <param name="SegmentInterceptInfo">The segment intercept info.</param>
    </member>
    <member name="T:PloobsEngine.SceneControl.Picking">
      <summary>
            Picking Helper
            </summary>
    </member>
    <member name="M:PloobsEngine.SceneControl.Picking.#ctor(PloobsEngine.SceneControl.IScene,System.Single)">
      <summary>
            Initializes a new instance of the <see cref="T:PloobsEngine.SceneControl.Picking" /> class.
            </summary>
      <param name="owner">The owner.</param>
      <param name="pickingRayDistance">The picking ray distance.</param>
    </member>
    <member name="F:PloobsEngine.Physics.Bepu.CharacterController.collisionPairCollector">
      <summary>
            A box positioned relative to the character's body used to identify collision pairs with nearby objects that could be possibly stood upon.
            </summary>
    </member>
    <member name="F:PloobsEngine.Physics.Bepu.CharacterController.collisionPairCollectorPositionOffset">
      <summary>
            The displacement vector from the center of the character body capsule to the center of the collision pair collector box entity.
            </summary>
    </member>
    <member name="F:PloobsEngine.Physics.Bepu.CharacterController.rayOriginOffset">
      <summary>
            The displacement vector from the center of the character body capsule to the origin of the ray used to find supports.
            </summary>
    </member>
    <member name="F:PloobsEngine.Physics.Bepu.CharacterController.supportHeight">
      <summary>
            The distance above the ground that the bottom of the character's body floats.
            </summary>
    </member>
    <member name="F:PloobsEngine.Physics.Bepu.CharacterController.Acceleration">
      <summary>
            Rate of increase in the character's speed in the movementDirection.
            </summary>
    </member>
    <member name="F:PloobsEngine.Physics.Bepu.CharacterController.Body">
      <summary>
            The character's physical representation that handles iteractions with the environment.
            </summary>
    </member>
    <member name="F:PloobsEngine.Physics.Bepu.CharacterController.HasTraction">
      <summary>
            Whether or not the character is currently standing on anything that can be walked upon.
            False if there exists no support or the support is too heavily sloped, otherwise true.
            </summary>
    </member>
    <member name="F:PloobsEngine.Physics.Bepu.CharacterController.IsSupported">
      <summary>
            Whether or not the character is currently standing on anything.
            </summary>
    </member>
    <member name="F:PloobsEngine.Physics.Bepu.CharacterController.JumpSpeed">
      <summary>
            Initial vertical speed when jumping.
            </summary>
    </member>
    <member name="F:PloobsEngine.Physics.Bepu.CharacterController.MaxSlope">
      <summary>
            The maximum slope under which walking forces can be applied.
            </summary>
    </member>
    <member name="F:PloobsEngine.Physics.Bepu.CharacterController.MaxSpeed">
      <summary>
            Maximum speed in the movementDirection that can be attained.
            </summary>
    </member>
    <member name="F:PloobsEngine.Physics.Bepu.CharacterController.MovementDirection">
      <summary>
            Normalized direction which the character tries to move.
            </summary>
    </member>
    <member name="F:PloobsEngine.Physics.Bepu.CharacterController.SlidingDeceleration">
      <summary>
            Deceleration applied to oppose horizontal movement when the character does not have a steady foothold on the ground (hasTraction == false).
            </summary>
    </member>
    <member name="F:PloobsEngine.Physics.Bepu.CharacterController.TractionDeceleration">
      <summary>
            Deceleration applied to oppose uncontrolled horizontal movement when the character has a steady foothold on the ground (hasTraction == true).
            </summary>
    </member>
    <member name="M:PloobsEngine.Physics.Bepu.CharacterController.#ctor(Microsoft.Xna.Framework.Vector3,System.Single,System.Single,System.Single,System.Single,Microsoft.Xna.Framework.Vector3)">
      <summary>
            Constructs a simple character controller.
            </summary>
      <param name="position">Location to initially place the character.</param>
      <param name="characterHeight">The height of the character.</param>
      <param name="characterWidth">The diameter of the character.</param>
      <param name="supportHeight">The distance above the ground that the bottom of the character's body floats.</param>
      <param name="mass">Total mass of the character.</param>
      <param name="scale">The scale.</param>
    </member>
    <member name="M:PloobsEngine.Physics.Bepu.CharacterController.FindSupport(BEPUphysics.Entities.Entity@,Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Vector3@,System.Single@)">
      <summary>
            Locates the closest support entity by performing a raycast at collected candidates.
            </summary>
      <param name="supportEntity">The closest supporting entity.</param>
      <param name="supportLocation">The support location where the ray hit the entity.</param>
      <param name="supportNormal">The normal at the surface where the ray hit the entity.</param>
      <param name="supportDistance">Distance from the character to the support location.</param>
      <returns>Whether or not a support was located.</returns>
    </member>
    <member name="M:PloobsEngine.Physics.Bepu.CharacterController.IsSupportSlopeWalkable(Microsoft.Xna.Framework.Vector3)">
      <summary>
            Determines if the ground supporting the character is sloped gently enough to allow for normal walking.
            </summary>
      <param name="supportNormal">Normal of the surface being stood upon.</param>
      <returns>Whether or not the slope is walkable.</returns>
    </member>
    <member name="M:PloobsEngine.Physics.Bepu.CharacterController.Support(Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,System.Single)">
      <summary>
            Maintains the position of the character's body above the ground.
            </summary>
      <param name="supportLocationVelocity">Velocity of the support point connected to the supportEntity.</param>
      <param name="supportNormal">The normal at the surface where the ray hit the entity.</param>
      <param name="supportDistance">Distance from the character to the support location.</param>
    </member>
    <member name="M:PloobsEngine.Physics.Bepu.CharacterController.HandleHorizontalMotion(Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,System.Single)">
      <summary>
            Manages movement acceleration, deceleration, and sliding.
            </summary>
      <param name="supportLocationVelocity">Velocity of the support point connected to the supportEntity.</param>
      <param name="supportNormal">The normal at the surface where the ray hit the entity.</param>
      <param name="dt">Timestep of the simulation.</param>
    </member>
    <member name="M:PloobsEngine.Physics.Bepu.CharacterController.Jump">
      <summary>
            If the character has a support, it leaps into the air based on its jumpSpeed.
            </summary>
    </member>
    <member name="M:PloobsEngine.Physics.Bepu.CharacterController.Activate">
      <summary>
            Activates the character, adding its components to the space. 
            </summary>
    </member>
    <member name="M:PloobsEngine.Physics.Bepu.CharacterController.Deactivate">
      <summary>
            Deactivates the character, removing its components from the space.
            </summary>
    </member>
    <member name="M:PloobsEngine.Physics.Bepu.CharacterController.OnAdditionToSpace(BEPUphysics.ISpace)">
      <summary>
            Called by the engine when the character is added to the space.
            Activates the character.
            </summary>
      <param name="newSpace">Space to which the character was added.</param>
    </member>
    <member name="M:PloobsEngine.Physics.Bepu.CharacterController.OnRemovalFromSpace(BEPUphysics.ISpace)">
      <summary>
            Called by the engine when the character is removed from the space.
            Deactivates the character.
            </summary>
    </member>
    <member name="P:PloobsEngine.Physics.Bepu.CharacterController.Position">
      <summary>
            Gets and sets the position of the character.
            </summary>
    </member>
    <member name="T:PloobsEngine.Material.DeferredAnimatedMaterial">
      <summary>
            Deferred Animated Material
            </summary>
    </member>
    <member name="M:PloobsEngine.Material.DeferredAnimatedMaterial.#ctor(PloobsEngine.Modelo.Animation.IAnimatedController,PloobsEngine.Material.DeferredSimpleAnimationShader)">
      <summary>
            Initializes a new instance of the <see cref="T:PloobsEngine.Material.ForwardMaterial" /> class.
            </summary>
      <param name="shader">The shader.</param>
    </member>
    <member name="M:PloobsEngine.Material.DeferredAnimatedMaterial.Initialization(PloobsEngine.Engine.GraphicInfo,PloobsEngine.Engine.GraphicFactory,PloobsEngine.SceneControl.IObject)">
      <summary>
            Initializations the specified Material.
            </summary>
      <param name="ginfo">The ginfo.</param>
      <param name="factory">The factory.</param>
      <param name="obj">The obj.</param>
    </member>
    <member name="M:PloobsEngine.Material.DeferredAnimatedMaterial.PreDrawnPhase(Microsoft.Xna.Framework.GameTime,PloobsEngine.SceneControl.IWorld,PloobsEngine.SceneControl.IObject,PloobsEngine.Cameras.ICamera,System.Collections.Generic.IList{PloobsEngine.Light.ILight},PloobsEngine.SceneControl.RenderHelper)">
      <summary>
            Pre drawn Function.
            Called before all the objects are draw
            </summary>
      <param name="gt">The gt.</param>
      <param name="mundo">The mundo.</param>
      <param name="obj">The obj.</param>
      <param name="cam">The cam.</param>
      <param name="lights">The lights.</param>
      <param name="render">The render.</param>
    </member>
    <member name="M:PloobsEngine.Material.DeferredAnimatedMaterial.PosDrawnPhase(Microsoft.Xna.Framework.GameTime,PloobsEngine.SceneControl.IObject,PloobsEngine.Cameras.ICamera,System.Collections.Generic.IList{PloobsEngine.Light.ILight},PloobsEngine.SceneControl.RenderHelper)">
      <summary>
            Pos drawn Function.
            Called after all objects are Draw
            </summary>
      <param name="gt">The gt.</param>
      <param name="obj">The obj.</param>
      <param name="cam">The cam.</param>
      <param name="lights">The lights.</param>
      <param name="render">The render.</param>
    </member>
    <member name="M:PloobsEngine.Material.DeferredAnimatedMaterial.Drawn(Microsoft.Xna.Framework.GameTime,PloobsEngine.SceneControl.IObject,PloobsEngine.Cameras.ICamera,System.Collections.Generic.IList{PloobsEngine.Light.ILight},PloobsEngine.SceneControl.RenderHelper)">
      <summary>
            Normal Drawn Function.
            </summary>
      <param name="gt">The gt.</param>
      <param name="obj">The obj.</param>
      <param name="cam">The cam.</param>
      <param name="lights">The lights.</param>
      <param name="render">The render.</param>
    </member>
    <member name="M:PloobsEngine.Material.DeferredAnimatedMaterial.Update(Microsoft.Xna.Framework.GameTime,PloobsEngine.SceneControl.IObject,System.Collections.Generic.IList{PloobsEngine.Light.ILight})">
      <summary>
            Update.
            </summary>
      <param name="gametime">The gametime.</param>
      <param name="obj">The obj.</param>
      <param name="lights">The lights.</param>
    </member>
    <member name="M:PloobsEngine.Material.DeferredAnimatedMaterial.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Populates a <see cref="T:System.Runtime.Serialization.SerializationInfo" /> with the data needed to serialize the target object.
            </summary>
      <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> to populate with data.</param>
      <param name="context">The destination (see <see cref="T:System.Runtime.Serialization.StreamingContext" />) for this serialization.</param>
      <exception cref="T:System.Security.SecurityException">The caller does not have the required permission. </exception>
    </member>
    <member name="P:PloobsEngine.Material.DeferredAnimatedMaterial.Shadder">
      <summary>
            Gets or sets the shadder.
            </summary>
      <value>
            The shadder.
            </value>
    </member>
    <member name="P:PloobsEngine.Material.DeferredAnimatedMaterial.MaterialType">
      <summary>
            Gets the type of the material.
            </summary>
      <value>
            The type of the material.
            </value>
    </member>
    <member name="P:PloobsEngine.Material.DeferredAnimatedMaterial.CanCreateShadow">
      <summary>
            Gets or sets a value indicating whether this material is [affected by shadow].
            </summary>
      <value>
        <c>true</c> if [affected by shadow]; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="M:PloobsEngine.Cameras.CameraRecordPath.#ctor(PloobsEngine.SceneControl.IScreen,PloobsEngine.Cameras.ICamera,Microsoft.Xna.Framework.CurveLoopType)">
      <summary>
            CameraRecordPath
            </summary>
      <param name="CurveLoopType">Attenuation in the path curves</param>
    </member>
    <member name="T:PloobsEngine.SceneControl.IScene">
      <summary>
            Describe a 3D World
            </summary>
    </member>
    <member name="M:PloobsEngine.SceneControl.IScene.AfterLoadContent(PloobsEngine.SceneControl.IContentManager,PloobsEngine.Engine.GraphicInfo,PloobsEngine.Engine.GraphicFactory)">
      <summary>
            Function called After all the stuffs LoadContent is called
            </summary>
    </member>
    <member name="M:PloobsEngine.SceneControl.IScene.Update(Microsoft.Xna.Framework.GameTime)">
      <summary>
            Update the Screen
            </summary>
      <param name="gameTime">
      </param>
    </member>
    <member name="M:PloobsEngine.SceneControl.IScene.Draw(Microsoft.Xna.Framework.GameTime,PloobsEngine.SceneControl.RenderHelper)">
      <summary>
            This is called when the screen should draw itself.
            </summary>
      <param name="gameTime">
      </param>
      <param name="render">
      </param>
    </member>
    <member name="M:PloobsEngine.SceneControl.IScene.LoadContent(PloobsEngine.Engine.GraphicInfo,PloobsEngine.Engine.GraphicFactory,PloobsEngine.SceneControl.IContentManager)">
      <summary>
            Load content for the screen.        
            </summary>
      <param name="GraphicInfo">
      </param>
      <param name="factory">
      </param>
      <param name="contentManager">
      </param>
    </member>
    <member name="M:PloobsEngine.SceneControl.IScene.InitScreen(PloobsEngine.Engine.GraphicInfo,PloobsEngine.Engine.EngineStuff)">
      <summary>
            Init Screen
            </summary>
      <param name="GraphicInfo">The graphic info.</param>
      <param name="engine">
      </param>
    </member>
    <member name="M:PloobsEngine.SceneControl.IScene.SetWorldAndRenderTechnich(PloobsEngine.SceneControl.IRenderTechnic@,PloobsEngine.SceneControl.IWorld@)">
      <summary>
            Sets the world and render technich.
            </summary>
      <param name="renderTech">The render tech.</param>
      <param name="world">The world.</param>
    </member>
    <member name="P:PloobsEngine.SceneControl.IScene.RenderTechnic">
      <summary>
            Gets the render technics.
            </summary>
    </member>
    <member name="P:PloobsEngine.SceneControl.IScene.World">
      <summary>
            Gets or sets the world instance.
            </summary>
      <value>
            The world.
            </value>
    </member>
    <member name="T:PloobsEngine.SceneControl.IContentManager">
      <summary>
            Specification of a Content Loader
            </summary>
    </member>
    <member name="M:PloobsEngine.SceneControl.IContentManager.GetAsset``1(System.String,System.Boolean)">
      <summary>
            Gets the asset.
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="fileName">Name of the file.</param>
      <returns>
      </returns>
    </member>
    <member name="T:PloobsEngine.Input.TurnOnInputMaskCommand">
      <summary>
            Turn a Input Mask On
            </summary>
    </member>
    <member name="M:PloobsEngine.Input.TurnOnInputMaskCommand.#ctor(PloobsEngine.Input.InputMask)">
      <summary>
            Initializes a new instance of the <see cref="T:PloobsEngine.Input.TurnOnInputMaskCommand" /> class.
            </summary>
      <param name="mask">The mask.</param>
    </member>
    <member name="M:PloobsEngine.Input.TurnOnInputMaskCommand.execute">
      <summary>
            Executes the command Call.
            </summary>
    </member>
    <member name="M:PloobsEngine.Input.TurnOnInputMaskCommand.setTarget(System.Object)">
      <summary>
            Sets the command target.
            </summary>
      <param name="obj">The obj.</param>
    </member>
    <member name="P:PloobsEngine.Input.TurnOnInputMaskCommand.TargetName">
      <summary>
            Gets the name of the command target.
            </summary>
      <value>
            The name of the target.
            </value>
    </member>
    <member name="T:PloobsEngine.Physics.Bepu.ObjectMover">
      <summary>
            Specialized Object Proper to Movimentation
            </summary>
    </member>
    <member name="T:PloobsEngine.Modelo.Animation.AnimatedModel">
      <summary>
            Concrete Animated Model
            </summary>
    </member>
    <member name="M:PloobsEngine.Modelo.Animation.AnimatedModel.#ctor(PloobsEngine.Engine.GraphicFactory,System.String,System.String,System.String,System.String,System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:PloobsEngine.Modelo.Animation.AnimatedModel" /> class.
            </summary>
      <param name="factory">The factory.</param>
      <param name="modelName">Name of the model.</param>
      <param name="diffuseTextureName">Name of the diffuse texture.</param>
      <param name="bumpTextureName">Name of the bump texture.</param>
      <param name="specularTextureName">Name of the specular texture.</param>
      <param name="glowTextureName">Name of the glow texture.</param>
    </member>
    <member name="M:PloobsEngine.Modelo.Animation.AnimatedModel.GetAnimation">
      <summary>
            Gets the animation Information from Model
            It can be for example the Bone hierarchy of the model
            The result need to be casted (vary toooo much between animation APIs, better to keep as Object)
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:PloobsEngine.Modelo.Animation.AnimatedModel.getModelTag">
      <summary>
            Gets the model tag.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="P:PloobsEngine.Modelo.Animation.AnimatedModel.MeshNumber">
      <summary>
            Gets the mesh number.
            </summary>
    </member>
    <member name="T:PloobsEngine.Material.ForwardTreeShader">
      <summary>
            Tree Shader, used by the Tree Material, interacts with the LTree
            </summary>
    </member>
    <member name="P:PloobsEngine.Material.ForwardTreeShader.MaterialType">
      <summary>
            Gets the type of the material.
            </summary>
      <value>
            The type of the material.
            </value>
    </member>
    <member name="T:PloobsEngine.Material.TerrainType">
      <summary>
            Terrain Type
            </summary>
    </member>
    <member name="F:PloobsEngine.Material.TerrainType.MULTITEXTURE">
      <summary>
            Use multitexture (THE TEXTURES MUST BE SPECIFIED IN THE IMODELO)
            </summary>
    </member>
    <member name="F:PloobsEngine.Material.TerrainType.SINGLETEXTURE">
      <summary>
            Use only one texture for all the terrain
            </summary>
    </member>
    <member name="T:PloobsEngine.Material.DeferredTerrainShader">
      <summary>
            Terrain Shader
            </summary>
    </member>
    <member name="P:PloobsEngine.Material.DeferredTerrainShader.NivelBaixoAltura">
      <summary>
            Default 0 
            </summary>
    </member>
    <member name="P:PloobsEngine.Material.DeferredTerrainShader.NivelBaixoEspalhamento">
      <summary>
            Default 15
            </summary>
    </member>
    <member name="P:PloobsEngine.Material.DeferredTerrainShader.NivelMedioAltura">
      <summary>
            Default 20
            </summary>
    </member>
    <member name="P:PloobsEngine.Material.DeferredTerrainShader.NivelMedioEspalhamento">
      <summary>
            Default 20
            </summary>
    </member>
    <member name="P:PloobsEngine.Material.DeferredTerrainShader.NivelAltoAltura">
      <summary>
            Default 80
            </summary>
    </member>
    <member name="P:PloobsEngine.Material.DeferredTerrainShader.NivelAltoEspalhamento">
      <summary>
            Default 40
            </summary>
    </member>
    <member name="P:PloobsEngine.Material.DeferredTerrainShader.NivelBaseAltura">
      <summary>
            Default 40
            </summary>
    </member>
    <member name="P:PloobsEngine.Material.DeferredTerrainShader.NivelBaseEspalhamento">
      <summary>
            Default 25
            </summary>
    </member>
    <member name="P:PloobsEngine.Material.DeferredTerrainShader.NearTextureEspalhamento">
      <summary>
            Default 0
            </summary>
    </member>
    <member name="P:PloobsEngine.Material.DeferredTerrainShader.FarTextureEspalhamento">
      <summary>
            Default 100
            </summary>
    </member>
    <member name="P:PloobsEngine.Material.DeferredTerrainShader.BlendDistance">
      <summary>
            Default 0.99f
            </summary>
    </member>
    <member name="P:PloobsEngine.Material.DeferredTerrainShader.BlendWidth">
      <summary>
            Default 0.009f
            </summary>
    </member>
    <member name="F:PloobsEngine.Material.DeferredEMReflectiveShader.reflectionIndex">
      <summary>
            from 0 to 1 
            default 0.5f
            1 = perfect mirror
            </summary>
    </member>
    <member name="M:PloobsEngine.Material.DeferredEMReflectiveShader.#ctor(System.String,PloobsEngine.Material.ReflectionType)">
      <summary>
            Initializes a new instance of the <see cref="T:PloobsEngine.Material.DeferredEMReflectiveShader" /> class.
            </summary>
      <param name="texName">Name of the tex.</param>
      <param name="type">The type.</param>
    </member>
    <member name="M:PloobsEngine.Material.DeferredEMReflectiveShader.#ctor(System.String,System.Single)">
      <summary>
            Initializes a new instance of the <see cref="T:PloobsEngine.Material.DeferredEMReflectiveShader" /> class.
            Reflexive Surface implicity
            </summary>
      <param name="texName">Name of the tex.</param>
      <param name="reflectionIndex">Index of the reflection.</param>
    </member>
    <member name="F:PloobsEngine.Loader.WorldLoader.objects">
      <summary>
            Used to retrieve objects to
            </summary>
    </member>
    <member name="F:PloobsEngine.Features.DebugDraw.DebugSphere.effect">
      <summary>
            The basic effect used to draw boxes.
            </summary>
    </member>
    <member name="M:PloobsEngine.Features.DebugDraw.DebugSphere.#ctor(Microsoft.Xna.Framework.Vector3,System.Single,Microsoft.Xna.Framework.Color)">
      <summary>
            Creates a new box.
            Visible by default
            </summary>
      <param name="BoundingBox">The bounding box.</param>
      <param name="color">The box's color.</param>
    </member>
    <member name="M:PloobsEngine.Features.DebugDraw.DebugSphere.Draw(PloobsEngine.SceneControl.RenderHelper,Microsoft.Xna.Framework.Matrix,Microsoft.Xna.Framework.Matrix)">
      <summary>
            Draws the box.
            </summary>
      <param name="view">The viewing matrix.</param>
      <param name="projection">The projection matrix.</param>
    </member>
    <member name="T:PloobsEngine.Audio.LocalMediaAudioPlayer">
      <summary>
            MusicPlayer
            IMPORTANT
            On Windows, MediaLibrary can find songs only if the Windows Media Player previously found songs on the system.
            This means that Windows Media Player first must search the system for music before any songs can be accessed through MediaLibrary.
            </summary>
    </member>
    <member name="M:PloobsEngine.Audio.LocalMediaAudioPlayer.StartQueue">
      <summary>
            Starts the queue of songs
            </summary>
    </member>
    <member name="M:PloobsEngine.Audio.LocalMediaAudioPlayer.PlayAlbum(Microsoft.Xna.Framework.Media.Album)">
      <summary>
            Plays the album.
            </summary>
      <param name="album">The album.</param>
    </member>
    <member name="M:PloobsEngine.Audio.LocalMediaAudioPlayer.PlaySpecificMusic(System.String)">
      <summary>
            Plays the specific music.
            </summary>
      <param name="name">The name.</param>
    </member>
    <member name="M:PloobsEngine.Audio.LocalMediaAudioPlayer.AdvanceOneMusicInQueue">
      <summary>
            Advances one music in queue.
            </summary>
    </member>
    <member name="M:PloobsEngine.Audio.LocalMediaAudioPlayer.BackOneMusicInQueue">
      <summary>
            Backs one music in queue.
            </summary>
    </member>
    <member name="M:PloobsEngine.Audio.LocalMediaAudioPlayer.CurrentMusicState">
      <summary>
            Current state of the current music.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:PloobsEngine.Audio.LocalMediaAudioPlayer.PauseCurrentMusic">
      <summary>
            Pauses the current music.
            </summary>
    </member>
    <member name="M:PloobsEngine.Audio.LocalMediaAudioPlayer.ResumeCurrentMusic">
      <summary>
            Resumes the current music.
            </summary>
    </member>
    <member name="M:PloobsEngine.Audio.LocalMediaAudioPlayer.StopCurrentMusic">
      <summary>
            Stops the current music.
            </summary>
    </member>
    <member name="P:PloobsEngine.Audio.LocalMediaAudioPlayer.Loop">
      <summary>
            Gets or sets a value indicating whether this <see cref="!:BackGroundAudioPlayer" /> is loop.
            </summary>
      <value>
        <c>true</c> if loop; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="P:PloobsEngine.Audio.LocalMediaAudioPlayer.SongCollection">
      <summary>
            Gets the song collection.
            </summary>
    </member>
    <member name="M:PloobsEngine.Audio.SimpleSoundEffect.#ctor(PloobsEngine.SceneControl.IContentManager,System.String,System.Single,System.Single,System.Single,System.Boolean)">
      <summary>
            Initializes a new instance of the <see cref="T:PloobsEngine.Audio.SimpleSoundEffect" /> class.
            </summary>
      <param name="cmanager">The cmanager.</param>
      <param name="name">The name.</param>
      <param name="volume">The volume.</param>
      <param name="pitch">The pitch(-1 to 1).</param>
      <param name="pan">The pan (-1 to 1).</param>
      <param name="isLooped">if set to <c>true</c> [is looped].</param>
    </member>
    <member name="T:PloobsEngine.Utils.StaticRandom">
      <summary>
            Lots of Random Helpers
            </summary>
    </member>
    <member name="M:PloobsEngine.Utils.StaticRandom.Random(System.Single,System.Single)">
      <summary>
            Returns a float randomly distributed between lowerBound and upperBound
            </summary>
      <param name="lowerBound">The lower bound.</param>
      <param name="upperBound">The upper bound.</param>
      <returns>
      </returns>
    </member>
    <member name="M:PloobsEngine.Utils.StaticRandom.RandomChoice(System.Single)">
      <summary>
            Return True or false depending of the probability passed in the parameter
            </summary>
      <param name="chanceOfTrue">Entre 0 e 1</param>
      <returns>
      </returns>
    </member>
    <member name="M:PloobsEngine.Utils.StaticRandom.RandomIntInterval(System.Int32,System.Int32)">
      <summary>
            Random between two parameters
            </summary>
      <param name="min">The min.</param>
      <param name="max">The max.</param>
      <returns>
      </returns>
    </member>
    <member name="M:PloobsEngine.Utils.StaticRandom.PickRandomPoint(Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3)">
      <summary>
            Helper function chooses a random location on a triangle.
            </summary>
      <param name="position1">The position1.</param>
      <param name="position2">The position2.</param>
      <param name="position3">The position3.</param>
      <returns>
      </returns>
    </member>
    <member name="M:PloobsEngine.Utils.StaticRandom.RandomDirection">
      <summary>
            Pick a 3D Random Direction
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:PloobsEngine.Utils.StaticRandom.RandomBetween(System.Double,System.Double)">
      <summary>
            Returns a number between two values.
            </summary>
      <param name="min">Lower bound value</param>
      <param name="max">Upper bound value</param>
      <returns>
            Random number between bounds.
            </returns>
    </member>
    <member name="M:PloobsEngine.Utils.StaticRandom.RandomColor">
      <summary>
            Return a Random Color
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:PloobsEngine.Utils.StaticRandom.RandomPosition(Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3)">
      <summary>
            Random Position inside a Box
            </summary>
      <param name="minBoxPos">The min box pos.</param>
      <param name="maxBoxPos">The max box pos.</param>
      <returns>
      </returns>
    </member>
    <member name="P:PloobsEngine.Utils.StaticRandom.RandomInstance">
      <summary>
            Gets or sets the random instance.
            </summary>
      <value>
            The random instance.
            </value>
    </member>
    <member name="T:PloobsEngine.SceneControl.IWorld">
      <summary>
            Specification of a world
            </summary>
    </member>
    <member name="M:PloobsEngine.SceneControl.IWorld.#ctor(PloobsEngine.Physics.IPhysicWorld,PloobsEngine.SceneControl.ICuller,PloobsEngine.Particles.IParticleManager)">
      <summary>
            Initializes a new instance of the <see cref="T:PloobsEngine.SceneControl.IWorld" /> class.
            </summary>
      <param name="PhysicWorld">The physic world.</param>
      <param name="Culler">The culler.</param>
      <param name="particleManager">The particle manager.</param>
    </member>
    <member name="M:PloobsEngine.SceneControl.IWorld.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Initializes a new instance of the <see cref="T:PloobsEngine.SceneControl.IWorld" /> class.
            Desserialization
            </summary>
      <param name="info">The info.</param>
      <param name="context">The context.</param>
    </member>
    <member name="M:PloobsEngine.SceneControl.IWorld.AddObject(PloobsEngine.SceneControl.IObject)">
      <summary>
            Adds an object to the world.
            </summary>
      <param name="obj">The obj.</param>
      <returns>
      </returns>
    </member>
    <member name="M:PloobsEngine.SceneControl.IWorld.ContainsObject(PloobsEngine.SceneControl.IObject)">
      <summary>
            Contains the specified obj.
            </summary>
      <param name="obj">The obj.</param>
      <returns>
      </returns>
    </member>
    <member name="M:PloobsEngine.SceneControl.IWorld.RemoveObject(PloobsEngine.SceneControl.IObject)">
      <summary>
            Removes an object from the world.
            </summary>
      <param name="obj">The obj.</param>
    </member>
    <member name="M:PloobsEngine.SceneControl.IWorld.UpdateWorld(Microsoft.Xna.Framework.GameTime)">
      <summary>
            Updates the world.
            </summary>
      <param name="gt">The gt.</param>
    </member>
    <member name="M:PloobsEngine.SceneControl.IWorld.AddLight(PloobsEngine.Light.ILight)">
      <summary>
            Adds the light.
            </summary>
      <param name="light">The light.</param>
    </member>
    <member name="M:PloobsEngine.SceneControl.IWorld.RemoveLight(PloobsEngine.Light.ILight)">
      <summary>
            Removes the light.
            </summary>
      <param name="light">The light.</param>
    </member>
    <member name="M:PloobsEngine.SceneControl.IWorld.AddTrigger(PloobsEngine.Trigger.ITrigger)">
      <summary>
            Adds the trigger.
            </summary>
      <param name="trigger">The trigger.</param>
    </member>
    <member name="M:PloobsEngine.SceneControl.IWorld.RemoveTrigger(PloobsEngine.Trigger.ITrigger)">
      <summary>
            Removes the trigger.
            </summary>
      <param name="trigger">The trigger.</param>
    </member>
    <member name="M:PloobsEngine.SceneControl.IWorld.AddDummy(PloobsEngine.SceneControl.IDummy)">
      <summary>
            Add a Dummy to the world
            Its like a position, 
            usefull to serializable position from a world editor
            </summary>
      <param name="dummy">The dummy.</param>
    </member>
    <member name="M:PloobsEngine.SceneControl.IWorld.RemoveDummy(PloobsEngine.SceneControl.IDummy)">
      <summary>
            Removes the dummy.
            </summary>
      <param name="dummy">The dummy.</param>
    </member>
    <member name="M:PloobsEngine.SceneControl.IWorld.AddSoundEmitter(PloobsEngine.Audio.ISoundEmitter3D,System.Boolean)">
      <summary>
            Adds the sound emitter.
            </summary>
      <param name="em">The em.</param>
      <param name="play">if set to <c>true</c> [play].</param>
    </member>
    <member name="M:PloobsEngine.SceneControl.IWorld.RemoveSoundEmitter(PloobsEngine.Audio.ISoundEmitter3D)">
      <summary>
            Removes the sound emitter.
            </summary>
      <param name="e">The e.</param>
    </member>
    <member name="M:PloobsEngine.SceneControl.IWorld.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            TODO
            Populates a <see cref="T:System.Runtime.Serialization.SerializationInfo" /> with the data needed to serialize the target object.
            </summary>
      <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> to populate with data.</param>
      <param name="context">The destination (see <see cref="T:System.Runtime.Serialization.StreamingContext" />) for this serialization.</param>
      <exception cref="T:System.Security.SecurityException">The caller does not have the required permission. </exception>
    </member>
    <member name="P:PloobsEngine.SceneControl.IWorld.GraphicsInfo">
      <summary>
            Gets or sets the graphics info.
            </summary>
      <value>
            The graphics info.
            </value>
    </member>
    <member name="P:PloobsEngine.SceneControl.IWorld.GraphicsFactory">
      <summary>
            Gets or sets the graphics factory.
            </summary>
      <value>
            The graphics factory.
            </value>
    </member>
    <member name="P:PloobsEngine.SceneControl.IWorld.CameraManager">
      <summary>
            Camera Managment
            </summary>
    </member>
    <member name="P:PloobsEngine.SceneControl.IWorld.PhysicWorld">
      <summary>
            Gets or sets the physic world.
            </summary>
      <value>
            The physic world.
            </value>
    </member>
    <member name="P:PloobsEngine.SceneControl.IWorld.Dummies">
      <summary>
            Gets all the dummyes.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="P:PloobsEngine.SceneControl.IWorld.Lights">
      <summary>
            Gets the lights.
            </summary>
    </member>
    <member name="P:PloobsEngine.SceneControl.IWorld.Culler">
      <summary>
            Gets or sets the culler.
            </summary>
      <value>
            The culler.
            </value>
    </member>
    <member name="P:PloobsEngine.SceneControl.IWorld.Objects">
      <summary>
            Gets the objects.
            </summary>
    </member>
    <member name="P:PloobsEngine.SceneControl.IWorld.SoundEmiters3D">
      <summary>
            Gets the objects.
            </summary>
    </member>
    <member name="T:Bnoerj.AI.Steering.PolylinePathway">
      <summary>
            PolylinePathway: a simple implementation of the Pathway protocol.  The path
            is a "polyline" a series of line segments between specified points.  A
            radius defines a volume for the path which is the union of a sphere at each
            point and a cylinder along each segment.
            </summary>
    </member>
    <member name="P:Bnoerj.AI.Steering.IVehicle.Acceleration">
      <summary>
            Gets the acceleration of the vehicle.
            </summary>
    </member>
    <member name="T:PloobsEngine.Physic.Constraints.IPhysicConstraint">
      <summary>
            Specification of a physic Constraint
            </summary>
    </member>
    <member name="P:PloobsEngine.Physic.Constraints.IPhysicConstraint.Position">
      <summary>
            Gets or sets the position.
            </summary>
      <value>
            The position.
            </value>
    </member>
    <member name="T:PloobsEngine.Loader.IModelLoader">
      <summary>
            Specification for Classes that can Load a Model from a file/stream ...
            </summary>
    </member>
    <member name="M:PloobsEngine.Loader.IModelLoader.Load(PloobsEngine.Engine.GraphicFactory,PloobsEngine.Engine.GraphicInfo,System.String)">
      <summary>
            Extract infos about models
            </summary>
      <param name="name">The name of the File - assume that models is in /Models, textures in /Textures and ModelInfos (when needed) in /ModelInfos</param>
      <returns>
      </returns>
    </member>
    <member name="M:PloobsEngine.Loader.ExtractXmlModelLoader.#ctor(System.String,System.String,System.String)">
      <summary>
            Combine the xmlBasePath + Name + .xml
            when using load, just pass the Name
            </summary>
      <param name="xmlBasePath">The XML base path.</param>
      <param name="modelPath">The model path.</param>
      <param name="texturePath">The texture path.</param>
    </member>
    <member name="T:PloobsEngine.Light.DirectionalLightPE">
      <summary>
            Deferred Directional Light
            </summary>
    </member>
    <member name="F:PloobsEngine.Light.DirectionalLightPE.nearClipOffset">
      <summary>
            experimentalllll
            </summary>
    </member>
    <member name="M:PloobsEngine.Light.DirectionalLightPE.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:PloobsEngine.Light.DirectionalLightPE" /> class.
            </summary>
    </member>
    <member name="M:PloobsEngine.Light.DirectionalLightPE.#ctor(Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Color)">
      <summary>
            Initializes a new instance of the <see cref="T:PloobsEngine.Light.DirectionalLightPE" /> class.
            </summary>
      <param name="direction">The direction.</param>
      <param name="color">The color.</param>
    </member>
    <member name="M:PloobsEngine.Light.DirectionalLightPE.FakeViewProjection(PloobsEngine.Cameras.ICamera)">
      <summary>
            Create a Fake view projection matrixes to use in Shadow.
            Calculate a Box that englobes the cam frustrum, put the eye near the center
            and calculates the view matrix, after use an ortograph projection to create
            the projection matrix
            Classic Algorith, dont make assumption on the scene orgnization, but also dont generate an optimal
            depth map (lots of none used pixels)
            </summary>
      <param name="cam">The cam.</param>
    </member>
    <member name="P:PloobsEngine.Light.DirectionalLightPE.NearClipOffset">
      <summary>
            Parameter to Tune the Shadow Mapping Generation
            Default 800
            </summary>
    </member>
    <member name="P:PloobsEngine.Light.DirectionalLightPE.Target">
      <summary>
            Used With the Position to generate a Direction
            </summary>
    </member>
    <member name="P:PloobsEngine.Light.DirectionalLightPE.LightIntensity">
      <summary>
            Gets or sets the light intensity.
            YOU MUST SET BOTH
            </summary>
      <value>
            The light intensity.
            </value>
    </member>
    <member name="P:PloobsEngine.Light.DirectionalLightPE.Position">
      <summary>
            Used with the target to generate a Direction
            YOU MUST SET BOTH
            </summary>
      <value>
            The position.
            </value>
    </member>
    <member name="P:PloobsEngine.Light.DirectionalLightPE.LightDirection">
      <summary>
            Gets or sets the light direction.
            </summary>
      <value>
            The light direction.
            </value>
    </member>
    <member name="P:PloobsEngine.Light.DirectionalLightPE.LightType">
      <summary>
            Gets the type of the light.
            </summary>
      <value>
            The type of the light.
            </value>
    </member>
    <member name="T:PloobsEngine.Features.TaskProcessor">
      <summary>
            Task Command Executor
            </summary>
    </member>
    <member name="F:PloobsEngine.Features.TaskProcessor.MyName">
      <summary>
            The Name of the Component
            </summary>
    </member>
    <member name="M:PloobsEngine.Features.TaskProcessor.StartTask(PloobsEngine.Features.ITask)">
      <summary>
            Starts the task.
            </summary>
      <param name="task">The task.</param>
    </member>
    <member name="M:PloobsEngine.Features.TaskProcessor.getMyName">
      <summary>
            The name of the reciever
            MUST BE UNIQUE
            </summary>
      <returns>
      </returns>
    </member>
    <member name="P:PloobsEngine.Features.TaskProcessor.ComponentType">
      <summary>
            Gets the type of the component type.
            </summary>
      <value>
            The type of the component.
            </value>
    </member>
    <member name="T:PloobsEngine.IA.NeuralNetwork.Neuron">
      <summary>
             Class representing an artificial neuron
             </summary>
      <remarks>
        <code>
              
              --------------&gt; * W[0] \                              -----  
              --------------&gt; * W[1] - + -------&gt; -threshold -------| f | ---------&gt; O
              --------------&gt; * W[i] /                              -----
                 SYNAPSES      WEIGHT             THRESHOLD       ACTIVATION       OUTPUT
            
             </code>
      </remarks>
    </member>
    <member name="F:PloobsEngine.IA.NeuralNetwork.Neuron.rand">
      <summary>
            Pseudo random number generator to initialize neuron weight
            </summary>
    </member>
    <member name="F:PloobsEngine.IA.NeuralNetwork.Neuron.R_MIN">
      <summary>
            Minimum value for randomisation of weights and threshold
            </summary>
    </member>
    <member name="F:PloobsEngine.IA.NeuralNetwork.Neuron.R_MAX">
      <summary>
            Maximum value for randomization of weights and threshold
            </summary>
    </member>
    <member name="F:PloobsEngine.IA.NeuralNetwork.Neuron.w">
      <summary>
            Weight of every synapse
            </summary>
    </member>
    <member name="F:PloobsEngine.IA.NeuralNetwork.Neuron.last_w">
      <summary>
            Last weight of every synapse
            </summary>
    </member>
    <member name="F:PloobsEngine.IA.NeuralNetwork.Neuron.threshold">
      <summary>
            Threshold of the neuron
            </summary>
    </member>
    <member name="F:PloobsEngine.IA.NeuralNetwork.Neuron.last_threshold">
      <summary>
            Last threshold of the neuron
            </summary>
    </member>
    <member name="F:PloobsEngine.IA.NeuralNetwork.Neuron.f">
      <summary>
            Activation function of the neuron
            </summary>
    </member>
    <member name="F:PloobsEngine.IA.NeuralNetwork.Neuron.o">
      <summary>
            Value of the last neuron ouput
            </summary>
    </member>
    <member name="F:PloobsEngine.IA.NeuralNetwork.Neuron.ws">
      <summary>
            Last value of synapse sum minus threshold
            </summary>
    </member>
    <member name="F:PloobsEngine.IA.NeuralNetwork.Neuron.a">
      <summary>
            Usefull for backpropagation algorithm
            </summary>
    </member>
    <member name="M:PloobsEngine.IA.NeuralNetwork.Neuron.#ctor(System.Int32,PloobsEngine.IA.NeuralNetwork.ActivationFunction)">
      <summary>
            Build a neurone with Ni inputs
            </summary>
      <param name="Ni">number of inputs</param>
      <param name="af">The activation function of the neuron</param>
    </member>
    <member name="M:PloobsEngine.IA.NeuralNetwork.Neuron.#ctor(System.Int32)">
      <summary>
            Build a neurone with Ni inputs whith a default 
            activation function (SIGMOID)
            </summary>
      <param name="Ni">number of inputs</param>
    </member>
    <member name="M:PloobsEngine.IA.NeuralNetwork.Neuron.randomizeWeight">
      <summary>
            Randomize Weight for each input between R_MIN and R_MAX
            </summary>
    </member>
    <member name="M:PloobsEngine.IA.NeuralNetwork.Neuron.randomizeThreshold">
      <summary>
            Randomize the threshold (between R_MIN and R_MAX)
            </summary>
    </member>
    <member name="M:PloobsEngine.IA.NeuralNetwork.Neuron.randomizeAll">
      <summary>
            Randomize the threshold and the weights
            </summary>
    </member>
    <member name="M:PloobsEngine.IA.NeuralNetwork.Neuron.ComputeOutput(System.Single[])">
      <summary>
            Compute the output of the neurone
            </summary>
      <param name="input">The input vector</param>
      <returns>The output value of the neuron ( =f(ws) )</returns>
    </member>
    <member name="P:PloobsEngine.IA.NeuralNetwork.Neuron.N_Inputs">
      <summary>
             Number of neuron inputs (synapses)
            </summary>
    </member>
    <member name="P:PloobsEngine.IA.NeuralNetwork.Neuron.Item(System.Int32)">
      <summary>
            Indexer of the neuron to get or set weight of synapses
            </summary>
    </member>
    <member name="P:PloobsEngine.IA.NeuralNetwork.Neuron.Threshold">
      <summary>
            To get or set the threshold value of the neuron
            </summary>
    </member>
    <member name="P:PloobsEngine.IA.NeuralNetwork.Neuron.Output">
      <summary>
            Get the last output of the neuron
            </summary>
    </member>
    <member name="P:PloobsEngine.IA.NeuralNetwork.Neuron.OutputPrime">
      <summary>
            Get the last output prime of the neuron (f'(ws))
            </summary>
    </member>
    <member name="P:PloobsEngine.IA.NeuralNetwork.Neuron.WS">
      <summary>
            Get the last sum of inputs
            </summary>
    </member>
    <member name="P:PloobsEngine.IA.NeuralNetwork.Neuron.F">
      <summary>
            Get or set the neuron activation function
            </summary>
    </member>
    <member name="P:PloobsEngine.IA.NeuralNetwork.Neuron.A">
      <summary>
            Get or set a value of the neuron
            (usefull for backpropagation learning algorithm)
            </summary>
    </member>
    <member name="P:PloobsEngine.IA.NeuralNetwork.Neuron.Last_Threshold">
      <summary>
            Get the last threshold value of the neuron
            </summary>
    </member>
    <member name="P:PloobsEngine.IA.NeuralNetwork.Neuron.Last_W">
      <summary>
            Get the last weights of the neuron
            </summary>
    </member>
    <member name="P:PloobsEngine.IA.NeuralNetwork.Neuron.Randomization_Min">
      <summary>
            Get or set the minimum value for randomisation of weights and threshold
            </summary>
    </member>
    <member name="P:PloobsEngine.IA.NeuralNetwork.Neuron.Randomization_Max">
      <summary>
            Get or set the maximum value for randomization of weights and threshold
            </summary>
    </member>
    <member name="T:PloobsEngine.Utils.MathUtils">
      <summary>
            Lots of Math Helper Functions
            </summary>
    </member>
    <member name="M:PloobsEngine.Utils.MathUtils.PointInsideBoundingBox(Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.BoundingBox)">
      <summary>
            Check if a point lies inside a <see cref="T:Microsoft.Xna.Framework.BoundingBox" /></summary>
      <param name="point">3D Point</param>
      <param name="box">Bounding box</param>
      <returns>
            True if point lies inside the bounding box
            </returns>
    </member>
    <member name="M:PloobsEngine.Utils.MathUtils.PointInsideCone(Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,System.Double)">
      <summary>
            Check if a point lies inside a conical region. Good for checking if a point lies in something's
            field-of-view cone.
            </summary>
      <param name="point">Point to check</param>
      <param name="coneOrigin">Cone's origin</param>
      <param name="coneDirection">Cone's forward direction</param>
      <param name="coneAngle">Cone's theta angle (radians)</param>
      <returns>
            True if point is inside the conical region
            </returns>
    </member>
    <member name="M:PloobsEngine.Utils.MathUtils.PointInsideBoundingSphere(Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.BoundingSphere)">
      <summary>
            Check if a point lies inside of a <see cref="T:Microsoft.Xna.Framework.BoundingSphere" />.
            </summary>
      <param name="point">3D Point</param>
      <param name="sphere">Sphere to check against</param>
      <returns>
            True if point is inside of the sphere
            </returns>
    </member>
    <member name="M:PloobsEngine.Utils.MathUtils.PointInsideSphere(Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,System.Single)">
      <summary>
            Check if a point lies in a sphere. Good for checking is a point lies within a specific
            distance of another point, like proximity checking.
            </summary>
      <param name="point">3D Point</param>
      <param name="sphereCenter">Sphere's center</param>
      <param name="sphereRadius">Sphere's radius</param>
      <returns>
            True if point is inside of the sphere
            </returns>
    </member>
    <member name="M:PloobsEngine.Utils.MathUtils.IsPowerOfTwo(System.Int32)">
      <summary>
            Check if the parameter is power of two
            </summary>
      <param name="Value">The value.</param>
      <returns>
        <c>true</c> if [is power of two] [the specified value]; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="M:PloobsEngine.Utils.MathUtils.Interpolate(System.Single,System.Single,System.Single)">
      <summary>
            SImple Linear interpolation
            </summary>
      <param name="alpha">The alpha.</param>
      <param name="x0">The x0.</param>
      <param name="x1">The x1.</param>
      <returns>
      </returns>
    </member>
    <member name="M:PloobsEngine.Utils.MathUtils.Interpolate(System.Single,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3)">
      <summary>
            Linear Interpolates with the specified alpha.
            </summary>
      <param name="alpha">The alpha.</param>
      <param name="x0">The x0.</param>
      <param name="x1">The x1.</param>
      <returns>
      </returns>
    </member>
    <member name="M:PloobsEngine.Utils.MathUtils.Clip(System.Single,System.Single,System.Single)">
      <summary>
            Constrain a given value (x) to be between two (ordered) bounds min
            and max.
            </summary>
      <param name="x">The x.</param>
      <param name="min">The min.</param>
      <param name="max">The max.</param>
      <returns>
            Returns x if it is between the bounds, otherwise returns the nearer bound.
            </returns>
    </member>
    <member name="M:PloobsEngine.Utils.MathUtils.RemapInterval(System.Single,System.Single,System.Single,System.Single,System.Single)">
      <summary>
            remap a value specified relative to a pair of bounding values
            to the corresponding value relative to another pair of bounds.
            Inspired by (dyna:remap-interval y y0 y1 z0 z1)
            </summary>
      <param name="x">The x.</param>
      <param name="in0">The in0.</param>
      <param name="in1">The in1.</param>
      <param name="out0">The out0.</param>
      <param name="out1">The out1.</param>
      <returns>
      </returns>
    </member>
    <member name="M:PloobsEngine.Utils.MathUtils.RemapIntervalClip(System.Single,System.Single,System.Single,System.Single,System.Single)">
      <summary>
            Like remapInterval but the result is clipped to remain between
            out0 and out1
            </summary>
      <param name="x">The x.</param>
      <param name="in0">The in0.</param>
      <param name="in1">The in1.</param>
      <param name="out0">The out0.</param>
      <param name="out1">The out1.</param>
      <returns>
      </returns>
    </member>
    <member name="M:PloobsEngine.Utils.MathUtils.IntervalComparison(System.Single,System.Single,System.Single)">
      <summary>
            classify a value relative to the interval between two bounds:
                returns -1 when below the lower bound
                returns  0 when between the bounds (inside the interval)
                returns +1 when above the upper bound
            </summary>
      <param name="x">The x.</param>
      <param name="lowerBound">The lower bound.</param>
      <param name="upperBound">The upper bound.</param>
      <returns>
      </returns>
    </member>
    <member name="M:PloobsEngine.Utils.MathUtils.ScalarRandomWalk(System.Single,System.Single,System.Single,System.Single)">
      <summary>
            Scalar random walk.
            </summary>
      <param name="initial">The initial.</param>
      <param name="walkspeed">The walkspeed.</param>
      <param name="min">The min.</param>
      <param name="max">The max.</param>
      <returns>
      </returns>
    </member>
    <member name="M:PloobsEngine.Utils.MathUtils.BlendIntoAccumulator(System.Single,System.Single,System.Single@)">
      <summary>
            blends new values into an accumulator to produce a smoothed time series
            </summary>
      <param name="smoothRate">The smooth rate.</param>
      <param name="newValue">The new value.</param>
      <param name="smoothedAccumulator">The smoothed accumulator.</param>
      <example>blendIntoAccumulator (dt * 0.4f, currentFPS, smoothedFPS)</example>
      <remarks>
            Modifies its third argument, a reference to the float accumulator holding
            the "smoothed time series."
            The first argument (smoothRate) is typically made proportional to "dt" the
            simulation time step.  If smoothRate is 0 the accumulator will not change,
            if smoothRate is 1 the accumulator will be set to the new value with no
            smoothing.  Useful values are "near zero".
            </remarks>
    </member>
    <member name="M:PloobsEngine.Utils.MathUtils.BlendIntoAccumulator(System.Single,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3@)">
      <summary>
            Blends the parameter into the accumulator.
            </summary>
      <param name="smoothRate">The smooth rate.</param>
      <param name="newValue">The new value.</param>
      <param name="smoothedAccumulator">The smoothed accumulator.</param>
    </member>
    <member name="T:PloobsEngine.SceneControl.BeingRemoved">
      <summary>
            Called when the object is being removed
            </summary>
      <param name="obj">The obj.</param>
    </member>
    <member name="T:PloobsEngine.SceneControl.OnUpdate">
      <summary>
            Called on every update
            </summary>
      <param name="obj">The obj.</param>
    </member>
    <member name="T:PloobsEngine.SceneControl.OnRecieveMessage">
      <summary>
            called when the object recieves a message
            </summary>
      <param name="Reciever">The reciever.</param>
      <param name="mes">The mes.</param>
    </member>
    <member name="T:PloobsEngine.SceneControl.OnHasMoved">
      <summary>
            Called when the object moves
            </summary>
      <param name="Reciever">The reciever.</param>
    </member>
    <member name="T:PloobsEngine.MessageSystem.IRecieveMessageEntity">
      <summary>
            Entity that can recieve a message
            </summary>
    </member>
    <member name="M:PloobsEngine.MessageSystem.IRecieveMessageEntity.HandleThisMessageType(PloobsEngine.MessageSystem.SenderType)">
      <summary>
            Handles a message from determined sender type.
            </summary>
      <param name="type">Sender type.</param>
      <returns>
      </returns>
    </member>
    <member name="M:PloobsEngine.MessageSystem.IRecieveMessageEntity.HandleMessage(PloobsEngine.MessageSystem.Message)">
      <summary>
            Handles the message.
            </summary>
      <param name="mes">The mes.</param>
    </member>
    <member name="T:PloobsEngine.SceneControl.IObject">
      <summary>
            Basic Object 
            </summary>
    </member>
    <member name="M:PloobsEngine.SceneControl.IObject.#ctor(PloobsEngine.Material.IMaterial,PloobsEngine.Modelo.IModelo,PloobsEngine.Physics.IPhysicObject)">
      <summary>
            Initializes a new instance of the <see cref="T:PloobsEngine.SceneControl.IObject" /> class.
            </summary>
      <param name="Material">The material.</param>
      <param name="Modelo">The modelo.</param>
      <param name="PhysicObject">The physic object.</param>
    </member>
    <member name="M:PloobsEngine.SceneControl.IObject.UpdateObject(Microsoft.Xna.Framework.GameTime,PloobsEngine.Cameras.ICamera,System.Collections.Generic.IList{PloobsEngine.Light.ILight})">
      <summary>
            Updates the object.
            </summary>
      <param name="gt">The gt.</param>
      <param name="cam">The cam.</param>
      <param name="luzes">The luzes.</param>
    </member>
    <member name="M:PloobsEngine.SceneControl.IObject.HandleThisMessageType(PloobsEngine.MessageSystem.SenderType)">
      <summary>
            Handles a message from determined sender type.
            </summary>
      <param name="type">Sender type.</param>
      <returns>
      </returns>
    </member>
    <member name="M:PloobsEngine.SceneControl.IObject.HandleMessage(PloobsEngine.MessageSystem.Message)">
      <summary>
            Handles the message.
            </summary>
      <param name="mes">The mes.</param>
    </member>
    <member name="M:PloobsEngine.SceneControl.IObject.RemoveThisObject">
      <summary>
            Removes this object.
            Called internally
            </summary>
    </member>
    <member name="M:PloobsEngine.SceneControl.IObject.GetId">
      <summary>
            return the entity id
            </summary>
      <returns>
            the id
            </returns>
    </member>
    <member name="M:PloobsEngine.SceneControl.IObject.SetId(System.Int32)">
      <summary>
            sets the id
            </summary>
      <param name="id">
      </param>
    </member>
    <member name="M:PloobsEngine.SceneControl.IObject.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Populates a <see cref="T:System.Runtime.Serialization.SerializationInfo" /> with the data needed to serialize the target object.
            </summary>
      <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> to populate with data.</param>
      <param name="context">The destination (see <see cref="T:System.Runtime.Serialization.StreamingContext" />) for this serialization.</param>
      <exception cref="T:System.Security.SecurityException">The caller does not have the required permission. </exception>
    </member>
    <member name="P:PloobsEngine.SceneControl.IObject.PhysicObject">
      <summary>
            Gets or sets the physic object.
            </summary>
      <value>
            The physic object.
            </value>
    </member>
    <member name="P:PloobsEngine.SceneControl.IObject.Modelo">
      <summary>
            Gets or sets the modelo.
            </summary>
      <value>
            The modelo.
            </value>
    </member>
    <member name="P:PloobsEngine.SceneControl.IObject.Material">
      <summary>
            Gets or sets the material.
            </summary>
      <value>
            The material.
            </value>
    </member>
    <member name="P:PloobsEngine.SceneControl.IObject.WorldMatrix">
      <summary>
            Gets the world matrix.
            </summary>
    </member>
    <member name="P:PloobsEngine.SceneControl.IObject.Name">
      <summary>
            Gets or sets the name of the object.
            </summary>
      <value>
            The name.
            </value>
    </member>
    <member name="P:PloobsEngine.SceneControl.IObject.IObjectAttachment">
      <summary>
            Gets or sets the Iobject atachtment.
            </summary>
      <value>
            The I object atachtment.
            </value>
    </member>
    <member name="E:PloobsEngine.SceneControl.IObject.OnRecieveMessage">
      <summary>
            Occurs when [on recieve message].
            </summary>
    </member>
    <member name="E:PloobsEngine.SceneControl.IObject.OnBeingRemoved">
      <summary>
            Called when this object is removed from the world
            </summary>
    </member>
    <member name="E:PloobsEngine.SceneControl.IObject.OnHasMoved">
      <summary>
            Raised when objects moves
            </summary>
    </member>
    <member name="E:PloobsEngine.SceneControl.IObject.OnUpdate">
      <summary>
            Called all the time the object is updated
            </summary>
    </member>
    <member name="T:PloobsEngine.Input.MouseButtons">
      <summary>
            Mouse Buttoms
            </summary>
    </member>
    <member name="T:PloobsEngine.Input.InputAdvanced">
      <summary>
            Component responsible for processing Keyboard and Mouse 
            </summary>
    </member>
    <member name="M:PloobsEngine.Input.InputAdvanced.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:PloobsEngine.Input.InputAdvanced" /> class.
            </summary>
      <param name="es">The es.</param>
    </member>
    <member name="M:PloobsEngine.Input.InputAdvanced.Update(Microsoft.Xna.Framework.GameTime)">
      <summary>
            Updates the specified game time.
            </summary>
      <param name="gameTime">The game time.</param>
    </member>
    <member name="M:PloobsEngine.Input.InputAdvanced.getMyName">
      <summary>
            The name of the reciever
            MUST BE UNIQUE
            </summary>
      <returns>
      </returns>
    </member>
    <member name="P:PloobsEngine.Input.InputAdvanced.ComponentType">
      <summary>
            Gets the type of the component type.
            </summary>
      <value>
            The type of the component.
            </value>
    </member>
    <member name="T:PloobsEngine.Input.BindAction">
      <summary>
            Possibles Binding Options
            </summary>
    </member>
    <member name="F:PloobsEngine.Input.BindAction.ADD">
      <summary>
            add a bind
            </summary>
    </member>
    <member name="F:PloobsEngine.Input.BindAction.REMOVE">
      <summary>
            Remove a bind
            </summary>
    </member>
    <member name="T:PloobsEngine.Input.InputMask">
      <summary>
            Input Chanels that can be used
            When you register a Command, it will be bind to a mask, you can turn the mask of and all the binds of this mask are 
            turned off, you can turn a mask on and ....
            Usefull When you have Menus and Screens, and you need to change between then, just set the corresponding inputs
            to diferent masks and turn one on and the other off when necessary
            </summary>
    </member>
    <member name="F:PloobsEngine.Input.InputMask.GALL">
      <summary>
            All Binds ON
            </summary>
    </member>
    <member name="F:PloobsEngine.Input.InputMask.GNONE">
      <summary>
            NONE BINDS ON
            </summary>
    </member>
    <member name="F:PloobsEngine.Input.InputMask.GSYSTEM">
      <summary>
            ALWAYS ON, no matter the mask forced
            </summary>
    </member>
    <member name="T:PloobsEngine.SceneControl.GBufferTypes">
      <summary>
            Buffer Types used
            </summary>
    </member>
    <member name="F:PloobsEngine.SceneControl.GBufferTypes.DEPH">
      <summary>
            Depth
            </summary>
    </member>
    <member name="F:PloobsEngine.SceneControl.GBufferTypes.COLOR">
      <summary>
            Color
            </summary>
    </member>
    <member name="F:PloobsEngine.SceneControl.GBufferTypes.NORMAL">
      <summary>
            Normal
            </summary>
    </member>
    <member name="F:PloobsEngine.SceneControl.GBufferTypes.Extra1">
      <summary>
            Glow
            </summary>
    </member>
    <member name="F:PloobsEngine.SceneControl.GBufferTypes.FINALIMAGE">
      <summary>
            Final image
            </summary>
    </member>
    <member name="F:Bnoerj.AI.Steering.SteerLibrary.hisPositionAtNearestApproach">
            XXX globals only for the sake of graphical annotation
        </member>
    <member name="T:Bnoerj.AI.Steering.IAnnotationService">
      <summary>
            Provides methods to annotate the steering behaviors.
            </summary>
    </member>
    <member name="M:Bnoerj.AI.Steering.IAnnotationService.AddTrail(Bnoerj.AI.Steering.Trail)">
      <summary>
            Adds a Trail.
            </summary>
      <param name="trail">
      </param>
    </member>
    <member name="M:Bnoerj.AI.Steering.IAnnotationService.RemoveTrail(Bnoerj.AI.Steering.Trail)">
      <summary>
            Removes the specified Trail.
            </summary>
      <param name="trail">
      </param>
    </member>
    <member name="M:Bnoerj.AI.Steering.IAnnotationService.DrawTrails(Bnoerj.AI.Steering.IDraw)">
      <summary>
            Draws all registered Trails.
            </summary>
    </member>
    <member name="M:Bnoerj.AI.Steering.IAnnotationService.Line(Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Color)">
      <summary>
            Draws an opaque colored line segment between two locations in space.
            </summary>
      <param name="startPoint">The start point of the line.</param>
      <param name="endPoint">The end point of the line.</param>
      <param name="color">The color of the line.</param>
    </member>
    <member name="M:Bnoerj.AI.Steering.IAnnotationService.CircleXZ(System.Single,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Color,System.Int32)">
      <summary>
            Draws a circle on the XZ plane.
            </summary>
      <param name="radius">The radius of the circle.</param>
      <param name="center">The center of the circle.</param>
      <param name="color">The color of the circle.</param>
      <param name="segments">The number of segments to use to draw the circle.</param>
    </member>
    <member name="M:Bnoerj.AI.Steering.IAnnotationService.DiskXZ(System.Single,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Color,System.Int32)">
      <summary>
            Draws a disk on the XZ plane.
            </summary>
      <param name="radius">The radius of the disk.</param>
      <param name="center">The center of the disk.</param>
      <param name="color">The color of the disk.</param>
      <param name="segments">The number of segments to use to draw the disk.</param>
    </member>
    <member name="M:Bnoerj.AI.Steering.IAnnotationService.Circle3D(System.Single,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Color,System.Int32)">
      <summary>
            Draws a circle perpendicular to the given axis.
            </summary>
      <param name="radius">The radius of the circle.</param>
      <param name="center">The center of the circle.</param>
      <param name="axis">The axis of the circle.</param>
      <param name="color">The color of the circle.</param>
      <param name="segments">The number of segments to use to draw the circle.</param>
    </member>
    <member name="M:Bnoerj.AI.Steering.IAnnotationService.Disk3D(System.Single,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Color,System.Int32)">
      <summary>
            Draws a disk perpendicular to the given axis.
            </summary>
      <param name="radius">The radius of the disk.</param>
      <param name="center">The center of the disk.</param>
      <param name="axis">The axis of the disk.</param>
      <param name="color">The color of the disk.</param>
      <param name="segments">The number of segments to use to draw the disk.</param>
    </member>
    <member name="M:Bnoerj.AI.Steering.IAnnotationService.CircleOrDiskXZ(System.Single,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Color,System.Int32,System.Boolean)">
      <summary>
            Draws a circle (not filled) or disk (filled) on the XZ plane.
            </summary>
      <param name="radius">The radius of the circle/disk.</param>
      <param name="center">The center of the circle/disk.</param>
      <param name="color">The color of the circle/disk.</param>
      <param name="segments">The number of segments to use to draw the circle/disk.</param>
      <param name="filled">Flag indicating whether to draw a disk or circle.</param>
    </member>
    <member name="M:Bnoerj.AI.Steering.IAnnotationService.CircleOrDisk3D(System.Single,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Color,System.Int32,System.Boolean)">
      <summary>
            Draws a circle (not filled) or disk (filled) perpendicular to the given axis.
            </summary>
      <param name="radius">The radius of the circle/disk.</param>
      <param name="center">The center of the circle/disk.</param>
      <param name="axis">The axis of the circle/disk.</param>
      <param name="color">The color of the circle/disk.</param>
      <param name="segments">The number of segments to use to draw the circle/disk.</param>
      <param name="filled">Flag indicating whether to draw a disk or circle.</param>
    </member>
    <member name="M:Bnoerj.AI.Steering.IAnnotationService.CircleOrDisk(System.Single,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Color,System.Int32,System.Boolean,System.Boolean)">
      <summary>
            Draws a circle (not filled) or disk (filled) perpendicular to the given axis.
            </summary>
      <param name="radius">The radius of the circle/disk.</param>
      <param name="axis">The axis of the circle/disk.</param>
      <param name="center">The center of the circle/disk.</param>
      <param name="color">The color of the circle/disk.</param>
      <param name="segments">The number of segments to use to draw the circle/disk.</param>
      <param name="filled">Flag indicating whether to draw a disk or circle.</param>
      <param name="in3d">Flag indicating whether to draw the disk/circle in 3D or the XZ plane.</param>
    </member>
    <member name="M:Bnoerj.AI.Steering.IAnnotationService.AvoidObstacle(System.Single)">
      <summary>
            Called when steerToAvoidObstacles decides steering is required.
            </summary>
      <param name="minDistanceToCollision">
      </param>
    </member>
    <member name="M:Bnoerj.AI.Steering.IAnnotationService.PathFollowing(Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,System.Single)">
      <summary>
            Called when steerToFollowPath decides steering is required.
            </summary>
      <param name="future">
      </param>
      <param name="onPath">
      </param>
      <param name="target">
      </param>
      <param name="outside">
      </param>
    </member>
    <member name="M:Bnoerj.AI.Steering.IAnnotationService.AvoidCloseNeighbor(Bnoerj.AI.Steering.IVehicle,System.Single)">
      <summary>
            Called when steerToAvoidCloseNeighbors decides steering is required.
            </summary>
      <param name="other">
      </param>
      <param name="additionalDistance">
      </param>
    </member>
    <member name="M:Bnoerj.AI.Steering.IAnnotationService.AvoidNeighbor(Bnoerj.AI.Steering.IVehicle,System.Single,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3)">
      <summary>
            Called when steerToAvoidNeighbors decides steering is required.
            </summary>
      <param name="threat">
      </param>
      <param name="steer">
      </param>
      <param name="ourFuture">
      </param>
      <param name="threatFuture">
      </param>
    </member>
    <member name="M:Bnoerj.AI.Steering.IAnnotationService.VelocityAcceleration(Bnoerj.AI.Steering.IVehicle)">
      <summary>
            Draws lines from the vehicle's position showing its velocity and acceleration.
            </summary>
      <param name="vehicle">The vehicle to annotate.</param>
    </member>
    <member name="M:Bnoerj.AI.Steering.IAnnotationService.VelocityAcceleration(Bnoerj.AI.Steering.IVehicle,System.Single)">
      <summary>
            Draws lines from the vehicle's position showing its velocity and acceleration.
            </summary>
      <param name="vehicle">The vehicle to annotate.</param>
      <param name="maxLength">The maximum length for the acceleration and velocity lines.</param>
    </member>
    <member name="M:Bnoerj.AI.Steering.IAnnotationService.VelocityAcceleration(Bnoerj.AI.Steering.IVehicle,System.Single,System.Single)">
      <summary>
            Draws lines from the vehicle's position showing its velocity and acceleration.
            </summary>
      <param name="vehicle">The vehicle to annotate.</param>
      <param name="maxLengthAcceleration">The maximum length for the acceleration line.</param>
      <param name="maxLengthVelocity">The maximum length for the velocity line.</param>
    </member>
    <member name="P:Bnoerj.AI.Steering.IAnnotationService.IsEnabled">
      <summary>
            Indicates whether annotation is enabled.
            </summary>
    </member>
    <member name="M:Bnoerj.AI.Steering.Annotation.AddTrail(Bnoerj.AI.Steering.Trail)">
      <summary>
            Adds a Trail.
            </summary>
      <param name="trail">The trail to add.</param>
    </member>
    <member name="M:Bnoerj.AI.Steering.Annotation.RemoveTrail(Bnoerj.AI.Steering.Trail)">
      <summary>
            Removes the specified Trail.
            </summary>
      <param name="trail">The trail to remove.</param>
    </member>
    <member name="M:Bnoerj.AI.Steering.Annotation.DrawTrails(Bnoerj.AI.Steering.IDraw)">
      <summary>
            Draws all registered Trails.
            </summary>
    </member>
    <member name="P:Bnoerj.AI.Steering.Annotation.IsEnabled">
      <summary>
            Indicates whether annotation is enabled.
            </summary>
    </member>
    <member name="T:PloobsEngine.Physics.Bepu.GhostObject">
      <summary>
            Fake Physic object, not simulated
            </summary>
    </member>
    <member name="M:PloobsEngine.Physics.Bepu.GhostObject.#ctor(Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Matrix,Microsoft.Xna.Framework.Vector3)">
      <summary>
            Initializes a new instance of the <see cref="T:PloobsEngine.Physics.Bepu.GhostObject" /> class.
            </summary>
      <param name="position">The position.</param>
      <param name="orientation">The orientation.</param>
      <param name="scale">The scale.</param>
    </member>
    <member name="M:PloobsEngine.Physics.Bepu.GhostObject.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:PloobsEngine.Physics.Bepu.GhostObject" /> class.
            DEfault Object in 0,0,0 identity rotation and 1,1,1 scale
            </summary>
    </member>
    <member name="T:PloobsEngine.Physics.IPhysicWorld">
      <summary>
            Physic Object Specification
            </summary>
    </member>
    <member name="M:PloobsEngine.Physics.IPhysicWorld.DebugDrawn(Microsoft.Xna.Framework.GameTime,PloobsEngine.Cameras.ICamera)">
      <summary>
            Draw the physic world in debug mode.
            </summary>
      <param name="gt">The gt.</param>
      <param name="cam">The cam.</param>
    </member>
    <member name="M:PloobsEngine.Physics.IPhysicWorld.Update(Microsoft.Xna.Framework.GameTime)">
      <summary>
            Updates 
            </summary>
      <param name="gt">The gt.</param>
    </member>
    <member name="M:PloobsEngine.Physics.IPhysicWorld.AddObject(PloobsEngine.Physics.IPhysicObject)">
      <summary>
            Adds the object.
            </summary>
      <param name="obj">The obj.</param>
    </member>
    <member name="M:PloobsEngine.Physics.IPhysicWorld.RemoveObject(PloobsEngine.Physics.IPhysicObject)">
      <summary>
            Removes the object.
            </summary>
      <param name="obj">The obj.</param>
    </member>
    <member name="M:PloobsEngine.Physics.IPhysicWorld.AddConstraint(PloobsEngine.Physic.Constraints.IPhysicConstraint)">
      <summary>
             Adds the constraint
            </summary>
      <param name="ctn">
      </param>
    </member>
    <member name="M:PloobsEngine.Physics.IPhysicWorld.RemoveConstraint(PloobsEngine.Physic.Constraints.IPhysicConstraint)">
      <summary>
            Removes the constraints
            </summary>
      <param name="ctn">
      </param>
    </member>
    <member name="M:PloobsEngine.Physics.IPhysicWorld.SegmentIntersect(Microsoft.Xna.Framework.Ray,System.Func{PloobsEngine.Physics.IPhysicObject,System.Boolean},System.Single)">
      <summary>
            Raycast
            </summary>
      <param name="raio">The raio.</param>
      <param name="method">The method.</param>
      <param name="maxDistance">The max distance.</param>
      <returns>
      </returns>
    </member>
    <member name="M:PloobsEngine.Physics.IPhysicWorld.DetectCollisions(PloobsEngine.Physics.IPhysicObject,System.Collections.Generic.List{PloobsEngine.Physics.IPhysicObject})">
      <summary>
            Detects the collisions of a physic object
            </summary>
      <param name="po">The po.</param>
      <param name="resp">The resp.</param>
    </member>
    <member name="M:PloobsEngine.Physics.IPhysicWorld.GetPhysicsObjectsInRange(PloobsEngine.Physics.IPhysicObject,System.Single,PloobsEngine.Physics.CullerConditionAvaliator{PloobsEngine.Physics.IPhysicObject,PloobsEngine.SceneControl.IObject},System.Collections.Generic.List{PloobsEngine.Physics.IPhysicObject})">
      <summary>
            Get the objects near the object passed as parameter
            </summary>
      <param name="po">The po.</param>
      <param name="distance">The distance.</param>
      <param name="CullerAvaliator">The culler avaliator.</param>
      <param name="resp">The resp.</param>
    </member>
    <member name="P:PloobsEngine.Physics.IPhysicWorld.isDebugDraw">
      <summary>
            Gets or sets a value indicating whether this instance is debug draw.
            </summary>
      <value>
        <c>true</c> if this instance is debug draw; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="P:PloobsEngine.Physics.IPhysicWorld.PhysicObjects">
      <summary>
            Gets the physic objects.
            </summary>
    </member>
    <member name="P:PloobsEngine.Physics.IPhysicWorld.PhysicConstraints">
      <summary>
            Gets the physic constraints.
            </summary>
    </member>
    <member name="T:PloobsEngine.Loader.ObjectInformation">
      <summary>
            Struct that represents a Model
            By Now, It creates just pieces of a model, 
            IN THE NEXT RELEASE IT WILL CREATE THE FULL MODEL, RETURN AN IMODELO AND A TRANSFORMATION
            </summary>
    </member>
    <member name="M:PloobsEngine.Loader.ObjectInformation.HasTexture(PloobsEngine.Modelo.TextureType)">
      <summary>
            Determines whether this model has the specified texture type.
            </summary>
      <param name="type">The type.</param>
      <returns>
        <c>true</c> if the specified type has texture; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="T:PloobsEngine.Loader.CameraInfo">
      <summary>
            Camera Info
            </summary>
    </member>
    <member name="T:PloobsEngine.Loader.DummyInfo">
      <summary>
            Dummy Info
            </summary>
    </member>
    <member name="T:PloobsEngine.Loader.ModelLoaderData">
      <summary>
            Data that represents a Model Loaded
            </summary>
    </member>
    <member name="P:PloobsEngine.Loader.ModelLoaderData.DummyInfo">
      <summary>
            Gets or sets the dummyinfo list.
            </summary>
      <value>
            The dummy info.
            </value>
    </member>
    <member name="P:PloobsEngine.Loader.ModelLoaderData.CameraInfo">
      <summary>
            Gets or sets the camera info list.
            </summary>
      <value>
            The camera info.
            </value>
    </member>
    <member name="P:PloobsEngine.Loader.ModelLoaderData.LightsInfo">
      <summary>
            Gets or sets the lights info list.
            </summary>
      <value>
            The lights info.
            </value>
    </member>
    <member name="P:PloobsEngine.Loader.ModelLoaderData.ModelMeshesInfo">
      <summary>
            Gets or sets the model meshes info list.
            </summary>
      <value>
            The model meshes info.
            </value>
    </member>
    <member name="T:PloobsEngine.SceneControl.RenderHelper">
      <summary>
            Renderer
            </summary>
    </member>
    <member name="M:PloobsEngine.SceneControl.RenderHelper.#ctor(Microsoft.Xna.Framework.Graphics.GraphicsDevice,PloobsEngine.Components.ComponentManager,PloobsEngine.SceneControl.IContentManager)">
      <summary>
            Initializes a new instance of the <see cref="T:PloobsEngine.SceneControl.RenderHelper" /> class.
            </summary>
      <param name="device">The device.</param>
      <param name="componentManager">The component manager.</param>
      <param name="cmanager">The cmanager.</param>
    </member>
    <member name="M:PloobsEngine.SceneControl.RenderHelper.RenderPreComponents(Microsoft.Xna.Framework.GameTime,Microsoft.Xna.Framework.Matrix,Microsoft.Xna.Framework.Matrix)">
      <summary>
            Renders the pre components.
            </summary>
      <param name="gametime">The gametime.</param>
      <param name="view">The view.</param>
      <param name="projection">The projection.</param>
    </member>
    <member name="M:PloobsEngine.SceneControl.RenderHelper.RenderPosComponents(Microsoft.Xna.Framework.GameTime,Microsoft.Xna.Framework.Matrix,Microsoft.Xna.Framework.Matrix)">
      <summary>
            Renders the pos components.
            </summary>
      <param name="gametime">The gametime.</param>
      <param name="view">The view.</param>
      <param name="projection">The projection.</param>
    </member>
    <member name="M:PloobsEngine.SceneControl.RenderHelper.RenderPosWithDepthComponents(Microsoft.Xna.Framework.GameTime,Microsoft.Xna.Framework.Matrix,Microsoft.Xna.Framework.Matrix)">
      <summary>
            Renders the pos with depth components.
            </summary>
      <param name="gametime">The gametime.</param>
      <param name="view">The view.</param>
      <param name="projection">The projection.</param>
    </member>
    <member name="M:PloobsEngine.SceneControl.RenderHelper.PushRasterizerState(Microsoft.Xna.Framework.Graphics.RasterizerState)">
      <summary>
            Pushes the state of the rasterizer.
            </summary>
      <param name="state">The state.</param>
    </member>
    <member name="M:PloobsEngine.SceneControl.RenderHelper.PeekRasterizerState">
      <summary>
            Peeks the state of the rasterizer.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:PloobsEngine.SceneControl.RenderHelper.PopRasterizerState">
      <summary>
            Pops the state of the rasterizer.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:PloobsEngine.SceneControl.RenderHelper.PushBlendState(Microsoft.Xna.Framework.Graphics.BlendState)">
      <summary>
            Pushes one blendstate.
            </summary>
      <param name="state">The state.</param>
    </member>
    <member name="M:PloobsEngine.SceneControl.RenderHelper.PeekBlendState">
      <summary>
            Peeks the blendstate..
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:PloobsEngine.SceneControl.RenderHelper.PopBlendState">
      <summary>
            Pops one blendstate.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:PloobsEngine.SceneControl.RenderHelper.SetSamplerState(Microsoft.Xna.Framework.Graphics.SamplerState,System.Int32)">
      <summary>
            Sets the state of the sampler.
            </summary>
      <param name="SamplerState">State of the sampler.</param>
      <param name="index">The index.</param>
    </member>
    <member name="M:PloobsEngine.SceneControl.RenderHelper.SetVertexSamplerStates(Microsoft.Xna.Framework.Graphics.SamplerState,System.Int32)">
      <summary>
            Sets the vertex sampler states.
            </summary>
      <param name="SamplerState">State of the sampler.</param>
      <param name="index">The index.</param>
    </member>
    <member name="M:PloobsEngine.SceneControl.RenderHelper.GetSamplerState(System.Int32)">
      <summary>
            Gets the state of the sampler.
            </summary>
      <param name="index">The index.</param>
      <returns>
      </returns>
    </member>
    <member name="M:PloobsEngine.SceneControl.RenderHelper.PushDepthStencilState(Microsoft.Xna.Framework.Graphics.DepthStencilState)">
      <summary>
            Pushes the DepthState.
            </summary>
      <param name="state">The state.</param>
    </member>
    <member name="M:PloobsEngine.SceneControl.RenderHelper.PeekDepthState">
      <summary>
            Peeks the DepthState.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:PloobsEngine.SceneControl.RenderHelper.PopDepthStencilState">
      <summary>
            Pops the DepthState.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:PloobsEngine.SceneControl.RenderHelper.PushRenderTarget(Microsoft.Xna.Framework.Graphics.RenderTarget2D[])">
      <summary>
            Pushes the render target.
            </summary>
      <param name="renderTarget">The render target.</param>
    </member>
    <member name="M:PloobsEngine.SceneControl.RenderHelper.PopRenderTarget">
      <summary>
            Pops the render target.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:PloobsEngine.SceneControl.RenderHelper.PopRenderTargetAsSingleRenderTarget2D">
      <summary>
            Pops the render target.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:PloobsEngine.SceneControl.RenderHelper.Clear(Microsoft.Xna.Framework.Color,Microsoft.Xna.Framework.Graphics.ClearOptions,System.Single,System.Int32)">
      <summary>
            Clears actual target.
            </summary>
      <param name="color">The color.</param>
      <param name="options">The options.</param>
      <param name="depth">The depth.</param>
      <param name="stencil">The stencil.</param>
    </member>
    <member name="M:PloobsEngine.SceneControl.RenderHelper.RenderBatch(PloobsEngine.Modelo.BatchInformation,Microsoft.Xna.Framework.Graphics.Effect)">
      <summary>
            Renders the batch.
            </summary>
      <param name="bi">The BatchInformation</param>
      <param name="effect">The effect.</param>
    </member>
    <member name="M:PloobsEngine.SceneControl.RenderHelper.RenderUserPrimitive``1(Microsoft.Xna.Framework.Graphics.Effect,Microsoft.Xna.Framework.Graphics.PrimitiveType,``0[],System.Int32,System.Int32)">
      <summary>
            Renders user primitive.
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="effect">The effect.</param>
      <param name="PrimitiveType">Type of the primitive.</param>
      <param name="verts">The verts.</param>
      <param name="vertexOffset">The vertex offset.</param>
      <param name="primitiveCount">The primitive count.</param>
    </member>
    <member name="M:PloobsEngine.SceneControl.RenderHelper.RenderUserIndexedPrimitive``1(Microsoft.Xna.Framework.Graphics.Effect,Microsoft.Xna.Framework.Graphics.PrimitiveType,``0[],System.Int32,System.Int32,System.Int16[],System.Int32,System.Int32)">
      <summary>
            Renders user indexed primitive. 16 bits indices
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="effect">The effect.</param>
      <param name="PrimitiveType">Type of the primitive.</param>
      <param name="verts">The verts.</param>
      <param name="vertexOffset">The vertex offset.</param>
      <param name="vertesCount">The vertes count.</param>
      <param name="indices">The indices.</param>
      <param name="indexOffset">The index offset.</param>
      <param name="primitiveCount">The primitive count.</param>
    </member>
    <member name="M:PloobsEngine.SceneControl.RenderHelper.RenderUserIndexedPrimitive``1(Microsoft.Xna.Framework.Graphics.Effect,Microsoft.Xna.Framework.Graphics.PrimitiveType,``0[],System.Int32,System.Int32,System.Int32[],System.Int32,System.Int32)">
      <summary>
            Renders user indexed primitive. 32 bits indices
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="effect">The effect.</param>
      <param name="PrimitiveType">Type of the primitive.</param>
      <param name="verts">The verts.</param>
      <param name="vertexOffset">The vertex offset.</param>
      <param name="vertesCount">The vertes count.</param>
      <param name="indices">The indices.</param>
      <param name="indexOffset">The index offset.</param>
      <param name="primitiveCount">The primitive count.</param>
    </member>
    <member name="M:PloobsEngine.SceneControl.RenderHelper.RenderBatch(PloobsEngine.Modelo.BatchInformation)">
      <summary>
            Renders the batch.
            </summary>
      <param name="bi">The BatchInformation .</param>
    </member>
    <member name="M:PloobsEngine.SceneControl.RenderHelper.RenderTextComplete(System.String,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Color,Microsoft.Xna.Framework.Matrix,Microsoft.Xna.Framework.Graphics.SpriteFont,System.Boolean,Microsoft.Xna.Framework.Graphics.SpriteSortMode,Microsoft.Xna.Framework.Graphics.SamplerState,Microsoft.Xna.Framework.Graphics.BlendState,Microsoft.Xna.Framework.Graphics.RasterizerState,Microsoft.Xna.Framework.Graphics.DepthStencilState,Microsoft.Xna.Framework.Graphics.Effect)">
      <summary>
            Renders the text complete. (THIS FUNCTION ALREADY CALLS BEGIN AND END)
            </summary>
      <param name="text">The text.</param>
      <param name="position">The position.</param>
      <param name="color">The color.</param>
      <param name="transform">The transform.</param>
      <param name="font">The font.</param>
      <param name="resyncState">if set to <c>true</c> [resync state].</param>
      <param name="SpriteSortMode">The sprite sort mode.</param>
      <param name="samplerState">State of the sampler.</param>
      <param name="blenderState">State of the blender.</param>
      <param name="rasterizerState">State of the rasterizer.</param>
      <param name="depthState">State of the depth.</param>
      <param name="effect">The effect.</param>
    </member>
    <member name="M:PloobsEngine.SceneControl.RenderHelper.RenderText(System.Text.StringBuilder,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Color,Microsoft.Xna.Framework.Graphics.SpriteFont,System.Single,Microsoft.Xna.Framework.Graphics.SpriteEffects,System.Single)">
      <summary>
            Renders the texture.
            CALL THIS ONLY AFTER RenderBegin
            AFTER DRAWING ALL THE TEXTURES CALL RenderEnd
            </summary>
      <param name="text">The text.</param>
      <param name="position">The position.</param>
      <param name="scale">The scale.</param>
      <param name="color">The color.</param>
      <param name="font">The font.</param>
      <param name="rotation">The rotation.</param>
      <param name="effects">The effects.</param>
      <param name="layerDepth">The layer depth.</param>
    </member>
    <member name="M:PloobsEngine.SceneControl.RenderHelper.RenderText(System.String,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Color,Microsoft.Xna.Framework.Graphics.SpriteFont,System.Single,Microsoft.Xna.Framework.Graphics.SpriteEffects,System.Single)">
      <summary>
            Renders the text.
            </summary>
      <param name="text">The text.</param>
      <param name="position">The position.</param>
      <param name="scale">The scale.</param>
      <param name="color">The color.</param>
      <param name="font">The font.</param>
      <param name="rotation">The rotation.</param>
      <param name="effects">The effects.</param>
      <param name="layerDepth">The layer depth.</param>
    </member>
    <member name="M:PloobsEngine.SceneControl.RenderHelper.RenderBegin(Microsoft.Xna.Framework.Matrix,System.Nullable{Microsoft.Xna.Framework.Rectangle},Microsoft.Xna.Framework.Graphics.SpriteSortMode,Microsoft.Xna.Framework.Graphics.SamplerState,Microsoft.Xna.Framework.Graphics.BlendState,Microsoft.Xna.Framework.Graphics.RasterizerState,Microsoft.Xna.Framework.Graphics.DepthStencilState,Microsoft.Xna.Framework.Graphics.Effect)">
      <summary>
            Begin render Texture.
            DO NOT USE THIS WITH RenderTextureComplete (RenderTextureComplete does all the job inside)
            </summary>
      <param name="transform">The transform.</param>
      <param name="source">The source.</param>
      <param name="SpriteSortMode">The sprite sort mode.</param>
      <param name="samplerState">State of the sampler.</param>
      <param name="blenderState">State of the blender.</param>
      <param name="rasterizerState">State of the rasterizer.</param>
      <param name="depthState">State of the depth.</param>
      <param name="effect">The effect.</param>
    </member>
    <member name="M:PloobsEngine.SceneControl.RenderHelper.RenderTexture(Microsoft.Xna.Framework.Graphics.Texture2D,Microsoft.Xna.Framework.Color,Microsoft.Xna.Framework.Rectangle,System.Nullable{Microsoft.Xna.Framework.Rectangle})">
      <summary>
            Renders the texture.
            CALL THIS ONLY AFTER RenderBegin
            AFTER DRAWING ALL THE TEXTURES CALL RenderEnd
            </summary>
      <param name="texture">The texture.</param>
      <param name="color">The color.</param>
      <param name="destination">The destination.</param>
      <param name="source">The source.</param>
    </member>
    <member name="M:PloobsEngine.SceneControl.RenderHelper.RenderTexture(Microsoft.Xna.Framework.Graphics.Texture2D,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Color,System.Single,Microsoft.Xna.Framework.Vector2,System.Single,Microsoft.Xna.Framework.Graphics.SpriteEffects,System.Single)">
      <summary>
            Renders the texture.
            CALL THIS ONLY AFTER RenderBegin
            AFTER DRAWING ALL THE TEXTURES CALL RenderEnd
            </summary>
      <param name="texture">The texture.</param>
      <param name="position">The position.</param>
      <param name="color">The color.</param>
      <param name="rotation">The rotation.</param>
      <param name="origin">The origin.</param>
      <param name="scale">The scale.</param>
      <param name="SpriteEffects">The sprite effects.</param>
      <param name="layerdepth">The layerdepth.</param>
    </member>
    <member name="M:PloobsEngine.SceneControl.RenderHelper.RenderTexture(Microsoft.Xna.Framework.Graphics.Texture2D,Microsoft.Xna.Framework.Vector2,System.Nullable{Microsoft.Xna.Framework.Rectangle},Microsoft.Xna.Framework.Color,System.Single,Microsoft.Xna.Framework.Vector2,System.Single,Microsoft.Xna.Framework.Graphics.SpriteEffects,System.Single)">
      <summary>
            Renders the texture.
            CALL THIS ONLY AFTER RenderBegin
            AFTER DRAWING ALL THE TEXTURES CALL RenderEnd
            </summary>
      <param name="texture">The texture.</param>
      <param name="position">The position.</param>
      <param name="sourceRectangle">The source rectangle.</param>
      <param name="color">The color.</param>
      <param name="rotation">The rotation.</param>
      <param name="origin">The origin.</param>
      <param name="scale">The scale.</param>
      <param name="SpriteEffects">The sprite effects.</param>
      <param name="layerdepth">The layerdepth.</param>
    </member>
    <member name="M:PloobsEngine.SceneControl.RenderHelper.RenderEnd(System.Boolean)">
      <summary>
            End Rendering the texture
            ONLY USE THIS if you call RenderBegin BEFORE
            </summary>
    </member>
    <member name="M:PloobsEngine.SceneControl.RenderHelper.RenderTextureComplete(Microsoft.Xna.Framework.Graphics.Texture2D,System.Boolean)">
      <summary>
            Renders the texture (Begin, Texture,End).
            </summary>
      <param name="texture">The texture.</param>
      <param name="resyncState">if set to <c>true</c> [resync state].</param>
    </member>
    <member name="M:PloobsEngine.SceneControl.RenderHelper.RenderTextureComplete(Microsoft.Xna.Framework.Graphics.Texture2D,Microsoft.Xna.Framework.Color,Microsoft.Xna.Framework.Rectangle,Microsoft.Xna.Framework.Matrix,System.Nullable{Microsoft.Xna.Framework.Rectangle},System.Boolean,Microsoft.Xna.Framework.Graphics.SpriteSortMode,Microsoft.Xna.Framework.Graphics.SamplerState,Microsoft.Xna.Framework.Graphics.BlendState,Microsoft.Xna.Framework.Graphics.RasterizerState,Microsoft.Xna.Framework.Graphics.DepthStencilState,Microsoft.Xna.Framework.Graphics.Effect)">
      <summary>
            Renders the texture (Begin, render , End)
            </summary>
      <param name="texture">The texture.</param>
      <param name="color">The color.</param>
      <param name="destination">The destination.</param>
      <param name="transform">The transform.</param>
      <param name="source">The source.</param>
      <param name="SpriteSortMode">The sprite sort mode.</param>
      <param name="samplerState">State of the sampler.</param>
      <param name="blenderState">State of the blender.</param>
      <param name="rasterizerState">State of the rasterizer.</param>
      <param name="depthState">State of the depth.</param>
      <param name="effect">The effect.</param>
    </member>
    <member name="M:PloobsEngine.SceneControl.RenderHelper.ResyncStates">
      <summary>
            Resyncs the Device States
            THIS IS BECAUSE THE SPRITEBATCH KILL THE RENDER STATES, NO SAVE STATE. XNA DOCUMENTATION FAILS !!!!
            </summary>
    </member>
    <member name="M:PloobsEngine.SceneControl.RenderHelper.RenderFullScreenQuadVertexPixel(Microsoft.Xna.Framework.Graphics.Effect,Microsoft.Xna.Framework.Graphics.SamplerState[])">
      <summary>
            Renders the texture to full screen using vertex and pixel shader .
            </summary>
      <param name="effect">The effect.</param>
    </member>
    <member name="M:PloobsEngine.SceneControl.RenderHelper.RenderFullScreenQuadVertexPixel(Microsoft.Xna.Framework.Graphics.Effect)">
      <summary>
            Renders the full screen quad vertex pixel.
            </summary>
      <param name="effect">The effect.</param>
    </member>
    <member name="M:PloobsEngine.SceneControl.RenderHelper.RenderTextureToFullScreenSpriteBatch(Microsoft.Xna.Framework.Graphics.Texture2D,Microsoft.Xna.Framework.Graphics.Effect,Microsoft.Xna.Framework.Rectangle,Microsoft.Xna.Framework.Graphics.SamplerState,Microsoft.Xna.Framework.Graphics.BlendState,System.Boolean)">
      <summary>
            Renders the texture to full screen using sprite batch.
            </summary>
      <param name="scene">The scene.</param>
      <param name="effect">The effect.</param>
    </member>
    <member name="M:PloobsEngine.SceneControl.RenderHelper.RenderTextureToFullScreenSpriteBatch(System.String,Microsoft.Xna.Framework.Graphics.Effect,Microsoft.Xna.Framework.Graphics.SamplerState,Microsoft.Xna.Framework.Graphics.BlendState,System.Boolean)">
      <summary>
            Renders the texture to full screen using sprite batch.
            </summary>
      <param name="texture">The texture name (already in this class).</param>
      <param name="effect">The effect.</param>
    </member>
    <member name="M:PloobsEngine.SceneControl.RenderHelper.RenderSceneWithBasicMaterial(PloobsEngine.SceneControl.IWorld,Microsoft.Xna.Framework.GameTime,System.Collections.Generic.List{PloobsEngine.SceneControl.IObject},Microsoft.Xna.Framework.Matrix,Microsoft.Xna.Framework.Matrix,System.Boolean,System.Boolean)">
      <summary>
            Renders the scene without material.
            Uses XNA Basic Effect
            </summary>
      <param name="world">The world.</param>
      <param name="gt">The gt.</param>
      <param name="objListException">The obj list exception.(objects in this list wont be rendered) - can be null</param>
      <param name="view">The view.</param>
      <param name="projection">The projection.</param>
      <param name="drawComponentsPreDraw">if set to <c>true</c> [draw components with pre draw setting also].</param>
      <param name="useCuller">if set to <c>true</c> [use culler].</param>
    </member>
    <member name="M:PloobsEngine.SceneControl.RenderHelper.RenderSceneWithCustomMaterial(Microsoft.Xna.Framework.Graphics.Effect,PloobsEngine.SceneControl.OnDrawingSceneCustomMaterial,PloobsEngine.SceneControl.IWorld,Microsoft.Xna.Framework.GameTime,System.Collections.Generic.List{PloobsEngine.SceneControl.IObject},Microsoft.Xna.Framework.Matrix,Microsoft.Xna.Framework.Matrix,System.Boolean,System.Boolean)">
      <summary>
            Renders the scene with custom material.
            </summary>
      <param name="effect">The effect.</param>
      <param name="setupShaderCallback">The setup shader callback.</param>
      <param name="world">The world.</param>
      <param name="gt">The gt.</param>
      <param name="objListException">The obj list exception.</param>
      <param name="view">The view.</param>
      <param name="projection">The projection.</param>
      <param name="drawComponentsPreDraw">if set to <c>true</c> [draw components pre draw].</param>
      <param name="useCuller">if set to <c>true</c> [use culler].</param>
    </member>
    <member name="P:PloobsEngine.SceneControl.RenderHelper.Item(System.String)">
      <summary>
            Gets or sets a scene with the specified name.
            </summary>
    </member>
    <member name="T:PloobsEngine.SceneControl.BlurMode">
      <summary>
            gaussian Blur Modes
            </summary>
    </member>
    <member name="F:PloobsEngine.SceneControl._2DScene.RenderTechnich2D.PostEffects">
      <summary>
            List off all PostEffects
            </summary>
    </member>
    <member name="M:PloobsEngine.SceneControl._2DScene.RenderTechnich2D.AddPostEffect(PloobsEngine.SceneControl.IPostEffect)">
      <summary>
            Adds one post effect.
            </summary>
      <param name="postEffect">The post effect.</param>
    </member>
    <member name="M:PloobsEngine.SceneControl._2DScene.RenderTechnich2D.RemovePostEffect(PloobsEngine.SceneControl.IPostEffect)">
      <summary>
            Removes one post effect.
            </summary>
      <param name="postEffect">The post effect.</param>
    </member>
    <member name="M:PloobsEngine.SceneControl._2DScene.RenderTechnich2D.ContainsPostEffect(PloobsEngine.SceneControl.IPostEffect)">
      <summary>
            Determines whether [contains post effect] [the specified post effect].
            </summary>
      <param name="postEffect">The post effect.</param>
      <returns>
        <c>true</c> if [contains post effect] [the specified post effect]; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="M:PloobsEngine.SceneControl._2DScene.RenderTechnich2D.BeforeFirstExecution(PloobsEngine.SceneControl.RenderHelper,PloobsEngine.SceneControl._2DScene.I2DWorld)">
      <summary>
            Befores the first execution.
            </summary>
      <param name="render">The render.</param>
      <param name="world">The world.</param>
    </member>
    <member name="M:PloobsEngine.SceneControl._2DScene.RenderTechnich2D.ExecuteTechnic(Microsoft.Xna.Framework.GameTime,PloobsEngine.SceneControl.RenderHelper,PloobsEngine.SceneControl._2DScene.I2DWorld)">
      <summary>
            Executes the technic.
            </summary>
      <param name="render">The render.</param>
      <param name="world">The world.</param>
    </member>
    <member name="M:PloobsEngine.SceneControl._2DScene.RenderTechnich2D.AfterLoadContent(PloobsEngine.SceneControl.IContentManager,PloobsEngine.Engine.GraphicInfo,PloobsEngine.Engine.GraphicFactory)">
      <summary>
            Called after the All the Engine stuffs are loaded
            </summary>
    </member>
    <member name="P:PloobsEngine.SceneControl._2DScene.RenderTechnich2D.TechnicName">
      <summary>
            Gets the name of the technic.
            </summary>
      <value>
            The name of the technic.
            </value>
    </member>
    <member name="F:PloobsEngine.SceneControl._2DScene.Basic2DRenderTechnich.UsePreDrawPhase">
      <summary>
            Default false
            </summary>
    </member>
    <member name="F:PloobsEngine.SceneControl._2DScene.Basic2DRenderTechnich.UseDrawComponents">
      <summary>
            Default false
            </summary>
    </member>
    <member name="F:PloobsEngine.SceneControl._2DScene.Basic2DRenderTechnich.AmbientColor">
      <summary>
            Default
            Color.FromNonPremultiplied(10, 10, 10, 255)
            WHEN NOT USING LIGHTS, this is the background color
            </summary>
    </member>
    <member name="F:PloobsEngine.SceneControl._2DScene.Basic2DRenderTechnich.LightMaskAttenuation">
      <summary>
            Default
            Color.Gray
            </summary>
    </member>
    <member name="F:PloobsEngine.SceneControl._2DScene.Basic2DRenderTechnich.UseLights">
      <summary>
            Default true
            </summary>
    </member>
    <member name="F:PloobsEngine.SceneControl._2DScene.Basic2DRenderTechnich.UsePostProcessing">
      <summary>
            Default true
            </summary>
    </member>
    <member name="M:PloobsEngine.Physics.Bepu.SphereObject.#ctor(Microsoft.Xna.Framework.Vector3,System.Single,System.Single,System.Single,PloobsEngine.Physics.MaterialDescription)">
      <summary>
            Initializes a new instance of the <see cref="T:PloobsEngine.Physics.Bepu.SphereObject" /> class.
            </summary>
      <param name="pos">The pos.</param>
      <param name="raio">The raio.</param>
      <param name="mass">The mass.</param>
      <param name="scale">The scale.</param>
      <param name="materialDescription">The material description.</param>
    </member>
    <member name="T:PloobsEngine.Material.DeferredCustomShader">
      <summary>
            Shader that uses branching to use Glow,Bump, Specular and Paralax
            Dont need to use all of them at once
            </summary>
    </member>
    <member name="M:PloobsEngine.Material.DeferredCustomShader.#ctor(System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Single,System.Single)">
      <summary>
            Initializes a new instance of the <see cref="T:PloobsEngine.Material.DeferredCustomShader" /> class.
            </summary>
      <param name="useGlow">if set to <c>true</c> [use glow].</param>
      <param name="useBump">if set to <c>true</c> [use bump].</param>
      <param name="useSpecular">if set to <c>true</c> [use specular].</param>
      <param name="useParalax">if set to <c>true</c> [use paralax].</param>
      <param name="specularIntensity">The specular intensity.</param>
      <param name="specularPower">The specular power.</param>
    </member>
    <member name="M:PloobsEngine.Material.DeferredCustomShader.Draw(Microsoft.Xna.Framework.GameTime,PloobsEngine.SceneControl.IObject,PloobsEngine.SceneControl.RenderHelper,PloobsEngine.Cameras.ICamera,System.Collections.Generic.IList{PloobsEngine.Light.ILight})">
      <summary>
            Draw
            </summary>
      <param name="gt">
      </param>
      <param name="obj">
      </param>
      <param name="render">The render.</param>
      <param name="cam">The cam.</param>
      <param name="lights">
      </param>
    </member>
    <member name="M:PloobsEngine.Material.DeferredCustomShader.Initialize(PloobsEngine.Engine.GraphicInfo,PloobsEngine.Engine.GraphicFactory,PloobsEngine.SceneControl.IObject)">
      <summary>
            Initializes this instance.
            </summary>
      <param name="ginfo">
      </param>
      <param name="factory">
      </param>
      <param name="obj">
      </param>
    </member>
    <member name="P:PloobsEngine.Material.DeferredCustomShader.UseParalax">
      <summary>
            Gets or sets a value indicating whether [use paralax].
            </summary>
      <value>
        <c>true</c> if [use paralax]; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="P:PloobsEngine.Material.DeferredCustomShader.UseGlow">
      <summary>
            Gets or sets a value indicating whether [use glow].
            </summary>
      <value>
        <c>true</c> if [use glow]; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="P:PloobsEngine.Material.DeferredCustomShader.UseBump">
      <summary>
            Gets or sets a value indicating whether [use bump].
            </summary>
      <value>
        <c>true</c> if [use bump]; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="P:PloobsEngine.Material.DeferredCustomShader.UseSpecular">
      <summary>
            Gets or sets a value indicating whether [use specular].
            </summary>
      <value>
        <c>true</c> if [use specular]; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="P:PloobsEngine.Material.DeferredCustomShader.SpecularIntensity">
      <summary>
            Gets or sets the specular intensity. Default 0
            </summary>
      <value>
            The specular intensity.
            </value>
    </member>
    <member name="P:PloobsEngine.Material.DeferredCustomShader.SpecularPower">
      <summary>
            Gets or sets the specular power. Default 0
            </summary>
      <value>
            The specular power.
            </value>
    </member>
    <member name="P:PloobsEngine.Material.DeferredCustomShader.MaterialType">
      <summary>
            Gets the type of the material.
            </summary>
      <value>
            The type of the material.
            </value>
    </member>
    <member name="P:PloobsEngine.Material.DeferredCustomShader.ScaleBias">
      <summary>
            Default  Vector2(0.04f, -0.03f);
            used for paralax
            </summary>
      <value>
            The scale bias.
            </value>
    </member>
    <member name="T:PloobsEngine.Cameras.CameraStatic">
      <summary>
            Static camera
            </summary>
    </member>
    <member name="M:PloobsEngine.Cameras.CameraStatic.#ctor(Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3)">
      <summary>
            Static Camera Constructor
            </summary>
      <param name="position">Position</param>
      <param name="Target">Target Vector (Used to create the view matriz - LookAt method)</param>
    </member>
    <member name="T:PloobsEngine.Cameras.CameraFirstPerson">
      <summary>
            First Person Camera
            </summary>
    </member>
    <member name="M:PloobsEngine.Cameras.CameraFirstPerson.#ctor(Microsoft.Xna.Framework.Graphics.Viewport)">
      <summary>
            Initializes a new instance of the <see cref="T:PloobsEngine.Cameras.CameraFirstPerson" /> class.
            </summary>
      <param name="viewport">The viewport.</param>
    </member>
    <member name="M:PloobsEngine.Cameras.CameraFirstPerson.#ctor(System.Boolean,Microsoft.Xna.Framework.Graphics.Viewport)">
      <summary>
            Initializes a new instance of the <see cref="T:PloobsEngine.Cameras.CameraFirstPerson" /> class.
            </summary>
      <param name="useMouse">if set to <c>true</c> [use mouse].</param>
      <param name="viewport">The viewport.</param>
    </member>
    <member name="M:PloobsEngine.Cameras.CameraFirstPerson.#ctor(System.Boolean,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Graphics.Viewport)">
      <summary>
            Initializes a new instance of the <see cref="T:PloobsEngine.Cameras.CameraFirstPerson" /> class.
            </summary>
      <param name="useMouse">if set to <c>true</c> [use mouse].</param>
      <param name="position">The position.</param>
      <param name="viewport">The viewport.</param>
    </member>
    <member name="M:PloobsEngine.Cameras.CameraFirstPerson.EnableMouse(System.Boolean)">
      <summary>
            Enables the mouse control.
            </summary>
      <param name="status">if set to <c>true</c> [status].</param>
    </member>
    <member name="M:PloobsEngine.Cameras.CameraFirstPerson.#ctor(System.Single,System.Single,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Graphics.Viewport)">
      <summary>
            Initializes a new instance of the <see cref="T:PloobsEngine.Cameras.CameraFirstPerson" /> class.
            </summary>
      <param name="lrRot">The leftright rotation.</param>
      <param name="udRot">The updown rotation.</param>
      <param name="startingPos">The starting pos.</param>
      <param name="viewport">The viewport.</param>
    </member>
    <member name="T:PloobsEngine.Utils.PerlinNoise">
      <summary>
            Perlin Noise
            </summary>
    </member>
    <member name="M:PloobsEngine.Utils.PerlinNoise.#ctor(System.Int32,System.Int32)">
      <summary>
            Perlin Noise Constructot
            </summary>
      <param name="width">max</param>
      <param name="height">max</param>
    </member>
    <member name="M:PloobsEngine.Utils.PerlinNoise.GetRandomHeight(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Int32)">
      <summary>
            Gets the value for a specific X and Y coordinate
            results in range [-1, 1] * maxHeight
            </summary>
      <param name="X">
      </param>
      <param name="Y">
      </param>
      <param name="MaxHeight">
      </param>
      <param name="Frequency">
      </param>
      <param name="Amplitude">
      </param>
      <param name="Persistance">
      </param>
      <param name="Octaves">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:PloobsEngine.Utils.PerlinNoise.GenerateNoise">
      <summary>
            create a array of randoms
            </summary>
    </member>
    <member name="M:PloobsEngine.Utils.StatisticsUtils.GetAverage(System.Double[])">
      <summary>
            Get average
            </summary>
    </member>
    <member name="M:PloobsEngine.Utils.StatisticsUtils.GetVariance(System.Double[])">
      <summary>
            Get variance
            </summary>
    </member>
    <member name="M:PloobsEngine.Utils.StatisticsUtils.GetStdev(System.Double[])">
      <summary>
            Get standard deviation
            </summary>
    </member>
    <member name="M:PloobsEngine.Utils.StatisticsUtils.GetCorrelation(System.Double[],System.Double[],System.Double@,System.Double@,System.Double@,System.Double@)">
      <summary>
            Get the correlation between X and Y
            </summary>
      <param name="x">X</param>
      <param name="y">Y</param>
      <param name="covXY">Covariance X,Y</param>
      <param name="pearson">Pearson X,Y</param>
      <param name="MultiplierX">Multiplier of X ( COVXY / VARX )</param>
            /// <param name="MultiplierY">Multiplier of Y ( COVXY / VARY )</param></member>
    <member name="T:PloobsEngine.Trigger.BepuTrigger">
      <summary>
            Bepu Implementation of a trigger
            </summary>
    </member>
    <member name="M:PloobsEngine.Trigger.BepuTrigger.#ctor(PloobsEngine.Physics.BepuPhysicWorld,PloobsEngine.Physics.Bepu.TriangleMeshObject,PloobsEngine.Trigger.TriggerEvent,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
      <summary>
            Trigger creation
            </summary>
      <param name="physicWorld">The physic world.</param>
      <param name="triangleMesh">Triangle mesh representing the Volume of the Trigger</param>
      <param name="evt">Event to be fired</param>
      <param name="fireBeginsTouching">if set to <c>true</c> [fire begins touching].</param>
      <param name="fireEndsTouching">if set to <c>true</c> [fire ends touching].</param>
      <param name="fireBeginsContaining">if set to <c>true</c> [fire begins containing].</param>
      <param name="fireEndsContaining">if set to <c>true</c> [fire ends containing].</param>
    </member>
    <member name="P:PloobsEngine.Trigger.BepuTrigger.ContactEntity">
      <summary>
            Gets the contact entity.
            </summary>
    </member>
    <member name="P:PloobsEngine.Trigger.BepuTrigger.Name">
      <summary>
            Gets or sets the name of the trigger.
            </summary>
      <value>
            The name.
            </value>
    </member>
    <member name="P:PloobsEngine.Trigger.BepuTrigger.Event">
      <summary>
            Gets or sets the event fired when the trigger is activated.
            </summary>
      <value>
            The event.
            </value>
    </member>
    <member name="P:PloobsEngine.Trigger.BepuTrigger.GhostObject">
      <summary>
            Gets or sets the ghost object that gives the SHAPE of the trigger.
            </summary>
      <value>
            The ghost object.
            </value>
    </member>
    <member name="T:PloobsEngine.Engine.GraphicFactory">
      <summary>
            Creates everything related to Graphics.
            FunctionNameConvention:
            Use Get... To load something and Create... to create something
            </summary>
    </member>
    <member name="T:PloobsEngine.DataStructure.MergeSort">
      <summary>
            Implementation of stable merge sort.
            </summary>
    </member>
    <member name="M:PloobsEngine.DataStructure.MergeSort.Sort``1(``0[])">
      <summary>
            Sorts the specified entities.
            </summary>
      <typeparam name="T">is an ICOMPARABLE</typeparam>
      <param name="entities">The entities.</param>
    </member>
    <member name="M:PloobsEngine.DataStructure.MergeSort.Sort``1(``0[],System.Comparison{``0})">
      <summary>
            Sorts the specified entities.
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="entities">The entities.</param>
      <param name="comparer">The comparer.</param>
    </member>
    <member name="M:PloobsEngine.DataStructure.MergeSort.Merge``1(``0[],``0[],``0[],System.Comparison{``0})">
      <summary>
            Merges the specified left and right.
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="left">The left.</param>
      <param name="right">The right.</param>
      <param name="entities">The entities.</param>
      <param name="comparer">The comparer.</param>
    </member>
    <member name="T:PloobsEngine.Physic.Constraints.PhysicConstraintTypes">
      <summary>
            Physic Types allowed
            </summary>
    </member>
    <member name="T:PloobsEngine.Material.DeferredWaterCompleteShader">
      <summary>
            Water with Reflection, refraction and animation shader
            </summary>
    </member>
    <member name="M:PloobsEngine.Material.DeferredWaterCompleteShader.#ctor(System.Int32,System.Int32,Microsoft.Xna.Framework.Plane,System.Single,System.Boolean)">
      <summary>
            Initializes a new instance of the <see cref="T:PloobsEngine.Material.DeferredWaterCompleteShader" /> class.
            </summary>
      <param name="width">The width.</param>
      <param name="height">The height.</param>
      <param name="plane">The plane.</param>
      <param name="Height">The height.</param>
      <param name="affectedByLight">if set to <c>true</c> the watter is [affected by light].</param>
    </member>
    <member name="P:PloobsEngine.Material.DeferredWaterCompleteShader.TimeModulation">
      <summary>
            Default 100
            </summary>
      <value>
            The time modulation.
            </value>
    </member>
    <member name="P:PloobsEngine.Material.DeferredWaterCompleteShader.WaveLength">
      <summary>
            Default 0.2f
            </summary>
      <value>
            The length of the wave.
            </value>
    </member>
    <member name="P:PloobsEngine.Material.DeferredWaterCompleteShader.WaveHeight">
      <summary>
            Default 0.02f
            </summary>
      <value>
            The height of the wave.
            </value>
    </member>
    <member name="P:PloobsEngine.Material.DeferredWaterCompleteShader.WindForce">
      <summary>
            Default 0.002f
            </summary>
      <value>
            The wind force.
            </value>
    </member>
    <member name="P:PloobsEngine.Material.DeferredWaterCompleteShader.WaterColor">
      <summary>
            Default Vector4(0.5f, 0.8f, 0.8f, 1.0f);
            </summary>
      <value>
            The color of the water.
            </value>
    </member>
    <member name="P:PloobsEngine.Material.DeferredWaterCompleteShader.WindDirection">
      <summary>
            Default Vector3(0, 0, 1);
            </summary>
      <value>
            The wind direction.
            </value>
    </member>
    <member name="P:PloobsEngine.Material.DeferredWaterCompleteShader.SpecularIntensity">
      <summary>
            Gets or sets the specular intensity.
            </summary>
      <value>
            The specular intensity.
            </value>
    </member>
    <member name="P:PloobsEngine.Material.DeferredWaterCompleteShader.SpecularPower">
      <summary>
            Gets or sets the specular power.
            </summary>
      <value>
            The specular power.
            </value>
    </member>
    <member name="P:PloobsEngine.Material.DeferredWaterCompleteShader.MaterialType">
      <summary>
            Gets the type of the material.
            </summary>
      <value>
            The type of the material.
            </value>
    </member>
    <member name="P:PloobsEngine.Material2D.Basic2DTextureMaterial.CastShadow">
      <summary>
            Gets or sets a value indicating whether [cast shadow].
            Default true
            </summary>
      <value>
        <c>true</c> if [cast shadow]; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="T:PloobsEngine.Components.ComponentType">
      <summary>
            The component Type
            Its very important, The type decides what methods of the component will be called
            </summary>
    </member>
    <member name="F:PloobsEngine.Components.ComponentType.PRE_DRAWABLE">
      <summary>
            Only the Pre Draw method will be call
            </summary>
    </member>
    <member name="F:PloobsEngine.Components.ComponentType.POS_DRAWABLE">
      <summary>
            Only the Pos draw method will be called
            </summary>
    </member>
    <member name="F:PloobsEngine.Components.ComponentType.UPDATEABLE">
      <summary>
            Only the Update method will be called
            </summary>
    </member>
    <member name="F:PloobsEngine.Components.ComponentType.PRE_DRAWABLE_AND_UPDATEABLE">
      <summary>
            Only the Pre Draw and Update will be called
            </summary>
    </member>
    <member name="F:PloobsEngine.Components.ComponentType.POS_DRAWABLE_AND_UPDATEABLE">
      <summary>
            Only the Pos Draw and Update will be called
            </summary>
    </member>
    <member name="F:PloobsEngine.Components.ComponentType.POS_WITHDEPTH_DRAWABLE_AND_UPDATEABLE">
      <summary>
            Only the Pos With Depth Draw and Update will be called
            </summary>
    </member>
    <member name="F:PloobsEngine.Components.ComponentType.POS_WITHDEPTH_DRAWABLE">
      <summary>
            Only the Pos With Depth Draw will be called
            </summary>
    </member>
    <member name="F:PloobsEngine.Components.ComponentType.NONE">
      <summary>
            None of the methods will be called
            </summary>
    </member>
    <member name="M:PloobsEngine.Cameras.CameraManager.AddCamera(PloobsEngine.Cameras.ICamera,System.String)">
      <summary>
            Adiciona uma camera
            Se a camera tiver o nome DEFAULTCAMERA ela vira a camera atual tb
            </summary>
      <param name="cam">
      </param>
      <param name="name">
      </param>
    </member>
    <member name="M:PloobsEngine.Cameras.CameraManager.AddCamera(PloobsEngine.Cameras.ICamera)">
      <summary>
            Add a camera and set it active if not yet was setted
            </summary>
      <param name="cam">
      </param>
    </member>
    <member name="M:PloobsEngine.Cameras.CameraManager.RemoveCamera(System.String)">
      <summary>
            Remove uma Camera
            Cuidado, pois ela pode estar Ativa !!!
            </summary>
      <param name="name">nome da camera</param>
    </member>
    <member name="M:PloobsEngine.Cameras.CameraManager.HasCamera(System.String)">
      <summary>
            Determines whether the specified camera name was added.
            </summary>
      <param name="name">The name.</param>
      <returns>
        <c>true</c> if the specified name exist; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="M:PloobsEngine.Cameras.CameraManager.SetActiveCamera(System.String)">
      <summary>
            Seta uma camera ativa
            modo de transicao Imediata
            </summary>
      <param name="name">
      </param>
    </member>
    <member name="M:PloobsEngine.Cameras.CameraManager.SetActiveCamera(System.String,PloobsEngine.Cameras.InterpolationType,System.Single)">
      <summary>
            Seta uma camera ativa
            modo de transicao Imediata
            </summary>
      <param name="name">
      </param>
      <param name="time">tempo de demora ou velocidade  -&gt; para controlar o interpolador</param>
    </member>
    <member name="M:PloobsEngine.Cameras.CameraManager.GetActiveCameraName">
      <summary>
            Retorna o nome da camera ativa
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:PloobsEngine.Cameras.CameraManager.GetCamerasDescription">
      <summary>
            Retorna uma lista das cameras ativas
            </summary>
      <returns>
      </returns>
    </member>
    <member name="P:PloobsEngine.Cameras.CameraManager.ActiveCamera">
      <summary>
            Retorna a Camera ativa
            </summary>
    </member>
    <member name="T:PloobsEngine.Utils.SerializerHelper">
      <summary>
            Helper functions to serialize and deserialize XML
            </summary>
    </member>
    <member name="M:PloobsEngine.Utils.SerializerHelper.ChangeDecimalSymbolToPoint">
      <summary>
            Sets the number format.
            MUST BE CALLED ONCE IF YOUR SYSTEM USES "," for decimal separator
            </summary>
    </member>
    <member name="M:PloobsEngine.Utils.SerializerHelper.ChangeDecimalSymbolToSystemDefault">
      <summary>
            Changes the decimal symbol to system default.
            </summary>
    </member>
    <member name="M:PloobsEngine.Utils.SerializerHelper.SerializeVector3(Microsoft.Xna.Framework.Vector3,System.String,System.Xml.XmlTextWriter)">
      <summary>
            Serializa a vector
            </summary>
      <param name="vector">vetor</param>
      <param name="fieldName">Field name</param>
      <param name="textWriter">textwriter</param>
    </member>
    <member name="M:PloobsEngine.Utils.SerializerHelper.SerializeVector3(System.Nullable{Microsoft.Xna.Framework.Vector3},System.String,System.Xml.XmlTextWriter)">
      <summary>
            Serializes the vector3.
            </summary>
      <param name="vector">The vector.</param>
      <param name="fieldName">Name of the field.</param>
      <param name="textWriter">The text writer.</param>
    </member>
    <member name="M:PloobsEngine.Utils.SerializerHelper.SerializeVector2(Microsoft.Xna.Framework.Vector2,System.String,System.Xml.XmlTextWriter)">
      <summary>
            Serializes the vector2.
            </summary>
      <param name="vector">The vector.</param>
      <param name="fieldName">Name of the field.</param>
      <param name="textWriter">The text writer.</param>
    </member>
    <member name="M:PloobsEngine.Utils.SerializerHelper.SerializeNewElement(System.String,System.Xml.XmlTextWriter)">
      <summary>
            Serializes the new element.
            </summary>
      <param name="fieldName">Name of the field.</param>
      <param name="textWriter">The text writer.</param>
    </member>
    <member name="M:PloobsEngine.Utils.SerializerHelper.SerializeEndElement(System.Xml.XmlTextWriter)">
      <summary>
            Serializes the end element.
            </summary>
      <param name="textWriter">The text writer.</param>
    </member>
    <member name="M:PloobsEngine.Utils.SerializerHelper.SerializeBaseType``1(``0,System.String,System.Xml.XmlTextWriter)">
      <summary>
            Serializes the type of the base.
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="param">The param.</param>
      <param name="fieldName">Name of the field.</param>
      <param name="textWriter">The text writer.</param>
    </member>
    <member name="M:PloobsEngine.Utils.SerializerHelper.SerializeAttributeBaseType``1(``0,System.String,System.Xml.XmlTextWriter)">
      <summary>
            Serializes the type of the attribute base.
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="param">The param.</param>
      <param name="fieldName">Name of the field.</param>
      <param name="textWriter">The text writer.</param>
    </member>
    <member name="M:PloobsEngine.Utils.SerializerHelper.SerializeListbaseType``1(System.Collections.Generic.IList{``0},System.String,System.Xml.XmlTextWriter)">
      <summary>
            Serializes the type of the listbase.
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="list">The list.</param>
      <param name="fieldName">Name of the field.</param>
      <param name="textWriter">The text writer.</param>
    </member>
    <member name="M:PloobsEngine.Utils.SerializerHelper.SerializeDictionary``2(System.Collections.Generic.IDictionary{``0,``1},System.String,System.Xml.XmlTextWriter)">
      <summary>
            Serializes the dictionary.
            </summary>
      <typeparam name="X">
      </typeparam>
      <typeparam name="Y">
      </typeparam>
      <param name="dic">The dic.</param>
      <param name="fieldName">Name of the field.</param>
      <param name="textWriter">The text writer.</param>
    </member>
    <member name="M:PloobsEngine.Utils.SerializerHelper.DeSerializeDictionary``2(System.String,System.Xml.XmlNode)">
      <summary>
            Des the serialize dictionary.
            </summary>
      <typeparam name="X">
      </typeparam>
      <typeparam name="Y">
      </typeparam>
      <param name="fieldName">Name of the field.</param>
      <param name="node">The node.</param>
      <returns>
      </returns>
    </member>
    <member name="M:PloobsEngine.Utils.SerializerHelper.DeserializeSerializeListbaseType``1(System.String,System.Xml.XmlNode)">
      <summary>
            Deserializes the type of the serialize listbase.
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="fieldName">Name of the field.</param>
      <param name="node">The node.</param>
      <returns>
      </returns>
    </member>
    <member name="M:PloobsEngine.Utils.SerializerHelper.SerializeMatrix(Microsoft.Xna.Framework.Matrix,System.String,System.Xml.XmlTextWriter)">
      <summary>
            Serializes the matrix.
            </summary>
      <param name="matrix">The matrix.</param>
      <param name="fieldName">Name of the field.</param>
      <param name="textWriter">The text writer.</param>
    </member>
    <member name="M:PloobsEngine.Utils.SerializerHelper.DeserializeVector3Nullable(System.String,System.Xml.XmlNode)">
      <summary>
            Deserializes the vector3 nullable.
            </summary>
      <param name="fieldName">Name of the field.</param>
      <param name="node">The node.</param>
      <returns>
      </returns>
    </member>
    <member name="M:PloobsEngine.Utils.SerializerHelper.DeserializeVector3(System.String,System.Xml.XmlNode)">
      <summary>
            Deserializes the vector3.
            </summary>
      <param name="fieldName">Name of the field.</param>
      <param name="node">The node.</param>
      <returns>
      </returns>
    </member>
    <member name="M:PloobsEngine.Utils.SerializerHelper.DeserializeVector2(System.String,System.Xml.XmlNode)">
      <summary>
            Deserializes the vector2.
            </summary>
      <param name="fieldName">Name of the field.</param>
      <param name="node">The node.</param>
      <returns>
      </returns>
    </member>
    <member name="M:PloobsEngine.Utils.SerializerHelper.DeserializeBaseType``1(System.String,System.Xml.XmlNode)">
      <summary>
            Parses a basic Type
            Very Deep Dark Magic
            </summary>
      <typeparam name="T">basic type</typeparam>
      <param name="fieldName">Name of the field.</param>
      <param name="node">The node.</param>
      <returns>
      </returns>
    </member>
    <member name="M:PloobsEngine.Utils.SerializerHelper.DeserializeAttributeBaseType``1(System.String,System.Xml.XmlNode)">
      <summary>
            Deserializes attributes .
            </summary>
      <typeparam name="T">base type</typeparam>
      <param name="fieldName">Name of the field.</param>
      <param name="node">The node.</param>
      <returns>
      </returns>
    </member>
    <member name="M:PloobsEngine.Utils.SerializerHelper.DeSerializeMatrix(System.String,System.Xml.XmlNode)">
      <summary>
            Desserialize matrix.
            </summary>
      <param name="fieldName">Name of the field.</param>
      <param name="node">The node.</param>
      <returns>
      </returns>
    </member>
    <member name="T:PloobsEngine.Utils.BinaryContentLoader">
      <summary>
            Binary Content Loader
            </summary>
    </member>
    <member name="M:PloobsEngine.Utils.BinaryContentLoader.SaveBinaryContent(System.Object,System.Type,System.String)">
      <summary>
            Saves the content of the object in a binary format.
            </summary>
      <param name="obj">The obj.</param>
      <param name="tipo">The type.</param>
      <param name="Path">The path.</param>
    </member>
    <member name="M:PloobsEngine.Utils.BinaryContentLoader.LoadBynaryContent(System.String,System.Type)">
      <summary>
            Loads the content of the bynary file.
            </summary>
      <param name="name">The name.</param>
      <param name="tipo">The type.</param>
      <returns>
      </returns>
    </member>
    <member name="T:PloobsEngine.Utils.InitConfiguration">
      <summary>
            Global Configurations of the app
            Not used yet
            </summary>
    </member>
    <member name="M:PloobsEngine.Utils.InitConfiguration.getConf(System.String)">
      <summary>
            Pega uma configuracao do arquivo de configuracao.
            confs sao do tipo confname = value
            </summary>
      <param name="confName">confname</param>
      <returns>value</returns>
    </member>
    <member name="T:PloobsEngine.SceneControl.BloomPostEffect">
      <summary>
            Bloom Post Effect
            </summary>
    </member>
    <member name="P:PloobsEngine.SceneControl.BloomPostEffect.BloomThreshold">
      <summary>
            Bloom Parameter
            </summary>
    </member>
    <member name="M:PloobsEngine.SceneControl.ScreenManager.#ctor(PloobsEngine.Engine.GraphicInfo@,PloobsEngine.Engine.GraphicFactory,PloobsEngine.SceneControl.IContentManager,PloobsEngine.SceneControl.RenderHelper,PloobsEngine.Engine.EngineStuff)">
      <summary>
            Initializes a new instance of the <see cref="T:PloobsEngine.SceneControl.ScreenManager" /> class.
            </summary>
      <param name="GraphicInfo">The graphic info.</param>
      <param name="factory">The factory.</param>
      <param name="contentManager">The content manager.</param>
      <param name="render">The render.</param>
      <param name="engine">The engine.</param>
    </member>
    <member name="M:PloobsEngine.SceneControl.ScreenManager.Update(Microsoft.Xna.Framework.GameTime)">
      <summary>
            Allows each screen to run logic.
            </summary>
    </member>
    <member name="M:PloobsEngine.SceneControl.ScreenManager.Draw(Microsoft.Xna.Framework.GameTime)">
      <summary>
            Tells each screen to draw itself.
            </summary>
    </member>
    <member name="M:PloobsEngine.SceneControl.ScreenManager.AddScreen(PloobsEngine.SceneControl.IScreen,PloobsEngine.SceneControl.IScreen,System.Boolean)">
      <summary>
            Adds a new screen to the screen manager.
            </summary>
      <param name="definitiveScreen">The definitive screen.</param>
      <param name="LoadingScreen">The loading screen.</param>
      <param name="loadAndInitScreen">if set to <c>true</c> [load and init definitiveScreen].</param>
    </member>
    <member name="M:PloobsEngine.SceneControl.ScreenManager.RemoveScreen(PloobsEngine.SceneControl.IScreen,System.Boolean)">
      <summary>
            Removes a screen from the screen manager. You should normally
            use GameScreen.ExitScreen instead of calling this directly, so
            the screen can gradually transition off rather than just being
            instantly removed.
            </summary>
      <param name="screen">The screen.</param>
      <param name="cleanUp">if set to <c>true</c> [clean up the screen].</param>
    </member>
    <member name="M:PloobsEngine.SceneControl.ScreenManager.GetScreens">
      <summary>
            Expose an array holding all the screens. We return a copy rather
            than the real master list, because screens should only ever be added
            or removed using the AddScreen and RemoveScreen methods.
            </summary>
    </member>
    <member name="T:PloobsEngine.SceneControl._2DScene.BeingRemoved">
      <summary>
            Called when the object is being removed
            </summary>
      <param name="obj">The obj.</param>
    </member>
    <member name="T:PloobsEngine.SceneControl._2DScene.OnUpdate">
      <summary>
            Called on every update
            </summary>
      <param name="obj">The obj.</param>
    </member>
    <member name="T:PloobsEngine.SceneControl._2DScene.OnRecieveMessage">
      <summary>
            called when the object recieves a message
            </summary>
      <param name="Reciever">The reciever.</param>
      <param name="mes">The mes.</param>
    </member>
    <member name="T:PloobsEngine.SceneControl._2DScene.OnHasMoved">
      <summary>
            Called when the object moves
            </summary>
      <param name="Reciever">The reciever.</param>
    </member>
    <member name="M:PloobsEngine.SceneControl._2DScene.I2DObject.UpdateObject(Microsoft.Xna.Framework.GameTime)">
      <summary>
            Updates the object.
            </summary>
      <param name="gt">The gt.</param>
      <param name="cam">The cam.</param>
      <param name="luzes">The luzes.</param>
    </member>
    <member name="M:PloobsEngine.SceneControl._2DScene.I2DObject.HandleThisMessageType(PloobsEngine.MessageSystem.SenderType)">
      <summary>
            Handles a message from determined sender type.
            </summary>
      <param name="type">Sender type.</param>
      <returns>
      </returns>
    </member>
    <member name="M:PloobsEngine.SceneControl._2DScene.I2DObject.HandleMessage(PloobsEngine.MessageSystem.Message)">
      <summary>
            Handles the message.
            </summary>
      <param name="mes">The mes.</param>
    </member>
    <member name="M:PloobsEngine.SceneControl._2DScene.I2DObject.RemoveThisObject">
      <summary>
            Removes this object.
            Called internally
            </summary>
    </member>
    <member name="M:PloobsEngine.SceneControl._2DScene.I2DObject.GetId">
      <summary>
            return the entity id
            </summary>
      <returns>
            the id
            </returns>
    </member>
    <member name="M:PloobsEngine.SceneControl._2DScene.I2DObject.SetId(System.Int32)">
      <summary>
            sets the id
            </summary>
      <param name="id">
      </param>
    </member>
    <member name="P:PloobsEngine.SceneControl._2DScene.I2DObject.PhysicObject">
      <summary>
            Gets or sets the physic object.
            </summary>
      <value>
            The physic object.
            </value>
    </member>
    <member name="P:PloobsEngine.SceneControl._2DScene.I2DObject.Name">
      <summary>
            Gets or sets the name of the object.
            </summary>
      <value>
            The name.
            </value>
    </member>
    <member name="P:PloobsEngine.SceneControl._2DScene.I2DObject.I2DObjectAtachtment">
      <summary>
            Gets or sets the Iobject atachtment.
            </summary>
      <value>
            The I object atachtment.
            </value>
    </member>
    <member name="E:PloobsEngine.SceneControl._2DScene.I2DObject.OnRecieveMessage">
      <summary>
            Occurs when [on recieve message].
            </summary>
    </member>
    <member name="E:PloobsEngine.SceneControl._2DScene.I2DObject.OnBeingRemoved">
      <summary>
            Called when this object is removed from the world
            </summary>
    </member>
    <member name="E:PloobsEngine.SceneControl._2DScene.I2DObject.OnHasMoved">
      <summary>
            Raised when objects moves
            </summary>
    </member>
    <member name="E:PloobsEngine.SceneControl._2DScene.I2DObject.OnUpdate">
      <summary>
            Called all the time the object is updated
            </summary>
    </member>
    <member name="T:PloobsEngine.Physics.PhysicObjectTypes">
      <summary>
            Physic Types allowed
            </summary>
    </member>
    <member name="F:PloobsEngine.Physics.PhysicObjectTypes.TERRAIN">
      <summary>
            Terrain
            </summary>
    </member>
    <member name="F:PloobsEngine.Physics.PhysicObjectTypes.DETECTOROBJECT">
      <summary>
            Detector object like a trigger, dont has physic part
            </summary>
    </member>
    <member name="F:PloobsEngine.Physics.PhysicObjectTypes.COMPOUNDOBJECT">
      <summary>
            Compound (lots of shapes)
            </summary>
    </member>
    <member name="F:PloobsEngine.Physics.PhysicObjectTypes.CYLINDEROBJECT">
      <summary>
            Cilinder
            </summary>
    </member>
    <member name="F:PloobsEngine.Physics.PhysicObjectTypes.BOXOBJECT">
      <summary>
            Box
            </summary>
    </member>
    <member name="F:PloobsEngine.Physics.PhysicObjectTypes.CAROBJECT">
      <summary>
            Car
            </summary>
    </member>
    <member name="F:PloobsEngine.Physics.PhysicObjectTypes.CAPSULEOBJECT">
      <summary>
            Capsule
            </summary>
    </member>
    <member name="F:PloobsEngine.Physics.PhysicObjectTypes.CHARACTEROBJECT">
      <summary>
            Character
            </summary>
    </member>
    <member name="F:PloobsEngine.Physics.PhysicObjectTypes.PLANEOBJECT">
      <summary>
            Plane
            </summary>
    </member>
    <member name="F:PloobsEngine.Physics.PhysicObjectTypes.SPHEREOBJECT">
      <summary>
            Sphere
            </summary>
    </member>
    <member name="F:PloobsEngine.Physics.PhysicObjectTypes.TRIANGLEMESHOBJECT">
      <summary>
            Triangle Mesh
            </summary>
    </member>
    <member name="F:PloobsEngine.Physics.PhysicObjectTypes.HEIGHMAPOBJECT">
      <summary>
            HeightMap
            </summary>
    </member>
    <member name="F:PloobsEngine.Physics.PhysicObjectTypes.GHOST">
      <summary>
            Not added to physicWorld,
            cant colide, cant be detected by raycast or triggers
            </summary>
    </member>
    <member name="F:PloobsEngine.Physics.PhysicObjectTypes.SPECIALIZEDMOVER">
      <summary>
            Object that moves kinematicaly
            </summary>
    </member>
    <member name="F:PloobsEngine.Physics.PhysicObjectTypes.OTHER">
      <summary>
            None of those before
            </summary>
    </member>
    <member name="F:PloobsEngine.Physics.PhysicObjectTypes.NONE">
      <summary>
            Should not be used, here for compatibility
            </summary>
    </member>
    <member name="M:PloobsEngine.Modelo.TextureInformation.getTexture(PloobsEngine.Modelo.TextureType)">
      <summary>
            Gets one texture of the model.
            </summary>
      <param name="type">The type.</param>
      <returns>
      </returns>
    </member>
    <member name="M:PloobsEngine.Modelo.TextureInformation.SetTexture(System.String,PloobsEngine.Modelo.TextureType)">
      <summary>
            Sets the texture.
            </summary>
      <param name="textureName">Name of the texture.</param>
      <param name="type">The type.</param>
    </member>
    <member name="M:PloobsEngine.Modelo.TextureInformation.LoadTexture">
      <summary>
            Load the model
            </summary>
      <param name="factory">The factory.</param>
    </member>
    <member name="M:PloobsEngine.Modelo.TextureInformation.SetTexture(Microsoft.Xna.Framework.Graphics.Texture2D,PloobsEngine.Modelo.TextureType)">
      <summary>
            Sets the texture.
            </summary>
      <param name="tex">The tex.</param>
      <param name="type">The type.</param>
    </member>
    <member name="P:PloobsEngine.Modelo.TextureInformation.ParalaxName">
      <summary>
            Gets or sets the name of the paralax texture.
            </summary>
      <value>
            The name of the paralax.
            </value>
    </member>
    <member name="P:PloobsEngine.Modelo.TextureInformation.GlowName">
      <summary>
            Gets or sets the name of the glow texture.
            </summary>
      <value>
            The name of the glow.
            </value>
    </member>
    <member name="P:PloobsEngine.Modelo.TextureInformation.BumpMapName">
      <summary>
            Gets or sets the name of the bump map.
            </summary>
      <value>
            The name of the bump map.
            </value>
    </member>
    <member name="P:PloobsEngine.Modelo.TextureInformation.SpecularMapName">
      <summary>
            Gets or sets the name of the specular map.
            </summary>
      <value>
            The name of the specular map.
            </value>
    </member>
    <member name="P:PloobsEngine.Modelo.TextureInformation.DiffuseMapName">
      <summary>
            Gets or sets the name of the diffuse map.
            </summary>
      <value>
            The name of the diffuse map.
            </value>
    </member>
    <member name="P:PloobsEngine.Modelo.TextureInformation.MultiTexture1MapName">
      <summary>
            Gets or sets the name of the multi texture1 map.
            </summary>
      <value>
            The name of the multi texture1 map.
            </value>
    </member>
    <member name="P:PloobsEngine.Modelo.TextureInformation.MultiTexture2MapName">
      <summary>
            Gets or sets the name of the multi texture2 map.
            </summary>
      <value>
            The name of the multi texture2 map.
            </value>
    </member>
    <member name="P:PloobsEngine.Modelo.TextureInformation.MultiTexture3MapName">
      <summary>
            Gets or sets the name of the multi texture3 map.
            </summary>
      <value>
            The name of the multi texture3 map.
            </value>
    </member>
    <member name="P:PloobsEngine.Modelo.TextureInformation.MultiTexture4MapName">
      <summary>
            Gets or sets the name of the multi texture4 map.
            </summary>
      <value>
            The name of the multi texture4 map.
            </value>
    </member>
    <member name="P:PloobsEngine.Modelo.TextureInformation.HeightMapName">
      <summary>
            Gets or sets the name of the height map.
            </summary>
      <value>
            The name of the height map.
            </value>
    </member>
    <member name="E:PloobsEngine.Modelo.TextureInformation.OnTextureChange">
      <summary>
            Occurs when [on texture change].
            </summary>
    </member>
    <member name="T:PloobsEngine.Modelo.TreeModel">
      <summary>
            Tree Model
            Interacts with the LTREE API
            </summary>
    </member>
    <member name="M:PloobsEngine.Modelo.TreeModel.#ctor(PloobsEngine.Engine.GraphicFactory,System.String,System.String,System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:PloobsEngine.Modelo.TreeModel" /> class.
            </summary>
      <param name="profileName">Name of the profile (LTREE content pipeline processed file).</param>
      <param name="trunktextureName">Name of the trunktexture.</param>
      <param name="LeaftextureName">Name of the leaftexture.</param>
    </member>
    <member name="P:PloobsEngine.Modelo.TreeModel.Tree">
      <summary>
            Gets or sets the tree.
            </summary>
      <value>
            The tree.
            </value>
    </member>
    <member name="P:PloobsEngine.Modelo.TreeModel.MeshNumber">
      <summary>
            Gets the mesh number.
            </summary>
    </member>
    <member name="P:PloobsEngine.Modelo.TreeModel.Name">
      <summary>
            Gets the name.
            CANNOT SET
            </summary>
      <value>
            The name.
            </value>
    </member>
    <member name="T:PloobsEngine.Material.DeferredNormalShader">
      <summary>
            Most Basic Deferred Shader (uses only diffuse texture and specular power/intensity properties)
            </summary>
    </member>
    <member name="M:PloobsEngine.Material.DeferredNormalShader.#ctor(System.Single,System.Single)">
      <summary>
            Initializes a new instance of the <see cref="T:PloobsEngine.Material.DeferredNormalShader" /> class.
            </summary>
    </member>
    <member name="M:PloobsEngine.Material.DeferredNormalShader.Draw(Microsoft.Xna.Framework.GameTime,PloobsEngine.SceneControl.IObject,PloobsEngine.SceneControl.RenderHelper,PloobsEngine.Cameras.ICamera,System.Collections.Generic.IList{PloobsEngine.Light.ILight})">
      <summary>
            Draw.
            </summary>
      <param name="gt">The gt.</param>
      <param name="obj">The obj.</param>
      <param name="render">The render.</param>
      <param name="camera">The camera.</param>
    </member>
    <member name="M:PloobsEngine.Material.DeferredNormalShader.Initialize(PloobsEngine.Engine.GraphicInfo,PloobsEngine.Engine.GraphicFactory,PloobsEngine.SceneControl.IObject)">
      <summary>
            Initializes this instance.
            </summary>
      <param name="ginfo">
      </param>
      <param name="factory">
      </param>
      <param name="obj">
      </param>
    </member>
    <member name="P:PloobsEngine.Material.DeferredNormalShader.SpecularIntensity">
      <summary>
            Gets or sets the specular intensity. Default 0
            </summary>
      <value>
            The specular intensity.
            </value>
    </member>
    <member name="P:PloobsEngine.Material.DeferredNormalShader.SpecularPower">
      <summary>
            Gets or sets the specular power. Default 0
            </summary>
      <value>
            The specular power.
            </value>
    </member>
    <member name="P:PloobsEngine.Material.DeferredNormalShader.MaterialType">
      <summary>
            Gets the type of the material.
            </summary>
      <value>
            The type of the material.
            </value>
    </member>
    <member name="T:PloobsEngine.Material.DeferredCustomAnimationShader">
      <summary>
            Animation Shader that supports advanced effects
            </summary>
    </member>
    <member name="M:PloobsEngine.Material.DeferredCustomAnimationShader.#ctor">
      <summary>
            Serialization
            </summary>
    </member>
    <member name="M:PloobsEngine.Material.DeferredCustomAnimationShader.#ctor(PloobsEngine.Modelo.Animation.IAnimatedController,System.Boolean,System.Boolean,System.Boolean)">
      <summary>
            Initializes a new instance of the <see cref="T:PloobsEngine.Material.DeferredCustomAnimationShader" /> class.
            </summary>
      <param name="ac">The ac.</param>
      <param name="useBump">if set to <c>true</c> [use bump].</param>
      <param name="useSpecular">if set to <c>true</c> [use specular].</param>
      <param name="useGlow">if set to <c>true</c> [use glow].</param>
    </member>
    <member name="M:PloobsEngine.Material.DeferredCustomAnimationShader.#ctor(PloobsEngine.Modelo.Animation.IAnimatedController,System.Boolean,System.Boolean,System.Boolean,PloobsEngine.SceneControl.IObject,PloobsEngine.Modelo.Animation.IAnimatedController,System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:PloobsEngine.Material.DeferredCustomAnimationShader" /> class.
            </summary>
      <param name="ac">The ac.</param>
      <param name="useBump">if set to <c>true</c> [use bump].</param>
      <param name="useSpecular">if set to <c>true</c> [use specular].</param>
      <param name="useGlow">if set to <c>true</c> [use glow].</param>
      <param name="obj">The obj.</param>
      <param name="Followed">The followed.</param>
      <param name="boneName">Name of the bone.</param>
    </member>
    <member name="P:PloobsEngine.Material.DeferredCustomAnimationShader.MaterialType">
      <summary>
            Gets the type of the material.
            </summary>
      <value>
            The type of the material.
            </value>
    </member>
    <member name="T:PloobsEngine.Material.DeferredMaterial">
      <summary>
            Deferred Material
            </summary>
    </member>
    <member name="M:PloobsEngine.Material.DeferredMaterial.#ctor(PloobsEngine.Material.IShader)">
      <summary>
            Initializes a new instance of the <see cref="T:PloobsEngine.Material.ForwardMaterial" /> class.
            </summary>
      <param name="shader">The shader.</param>
    </member>
    <member name="M:PloobsEngine.Material.DeferredMaterial.Initialization(PloobsEngine.Engine.GraphicInfo,PloobsEngine.Engine.GraphicFactory,PloobsEngine.SceneControl.IObject)">
      <summary>
            Initializations the specified Material.
            </summary>
      <param name="ginfo">The ginfo.</param>
      <param name="factory">The factory.</param>
      <param name="obj">The obj.</param>
    </member>
    <member name="M:PloobsEngine.Material.DeferredMaterial.PreDrawnPhase(Microsoft.Xna.Framework.GameTime,PloobsEngine.SceneControl.IWorld,PloobsEngine.SceneControl.IObject,PloobsEngine.Cameras.ICamera,System.Collections.Generic.IList{PloobsEngine.Light.ILight},PloobsEngine.SceneControl.RenderHelper)">
      <summary>
            Pre drawn Function.
            Called before all the objects are draw
            </summary>
      <param name="gt">The gt.</param>
      <param name="mundo">The mundo.</param>
      <param name="obj">The obj.</param>
      <param name="cam">The cam.</param>
      <param name="lights">The lights.</param>
      <param name="render">The render.</param>
    </member>
    <member name="M:PloobsEngine.Material.DeferredMaterial.PosDrawnPhase(Microsoft.Xna.Framework.GameTime,PloobsEngine.SceneControl.IObject,PloobsEngine.Cameras.ICamera,System.Collections.Generic.IList{PloobsEngine.Light.ILight},PloobsEngine.SceneControl.RenderHelper)">
      <summary>
            Pos drawn Function.
            Called after all objects are Draw
            </summary>
      <param name="gt">The gt.</param>
      <param name="obj">The obj.</param>
      <param name="cam">The cam.</param>
      <param name="lights">The lights.</param>
      <param name="render">The render.</param>
    </member>
    <member name="M:PloobsEngine.Material.DeferredMaterial.Drawn(Microsoft.Xna.Framework.GameTime,PloobsEngine.SceneControl.IObject,PloobsEngine.Cameras.ICamera,System.Collections.Generic.IList{PloobsEngine.Light.ILight},PloobsEngine.SceneControl.RenderHelper)">
      <summary>
            Normal Drawn Function.
            </summary>
      <param name="gt">The gt.</param>
      <param name="obj">The obj.</param>
      <param name="cam">The cam.</param>
      <param name="lights">The lights.</param>
      <param name="render">The render.</param>
    </member>
    <member name="M:PloobsEngine.Material.DeferredMaterial.Update(Microsoft.Xna.Framework.GameTime,PloobsEngine.SceneControl.IObject,System.Collections.Generic.IList{PloobsEngine.Light.ILight})">
      <summary>
            Update.
            </summary>
      <param name="gametime">The gametime.</param>
      <param name="obj">The obj.</param>
      <param name="lights">The lights.</param>
    </member>
    <member name="M:PloobsEngine.Material.DeferredMaterial.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Populates a <see cref="T:System.Runtime.Serialization.SerializationInfo" /> with the data needed to serialize the target object.
            </summary>
      <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> to populate with data.</param>
      <param name="context">The destination (see <see cref="T:System.Runtime.Serialization.StreamingContext" />) for this serialization.</param>
      <exception cref="T:System.Security.SecurityException">The caller does not have the required permission. </exception>
    </member>
    <member name="P:PloobsEngine.Material.DeferredMaterial.Shadder">
      <summary>
            Gets or sets the shadder.
            </summary>
      <value>
            The shadder.
            </value>
    </member>
    <member name="P:PloobsEngine.Material.DeferredMaterial.MaterialType">
      <summary>
            Gets the type of the material.
            </summary>
      <value>
            The type of the material.
            </value>
    </member>
    <member name="P:PloobsEngine.Material.DeferredMaterial.CanCreateShadow">
      <summary>
            Gets or sets a value indicating whether this material is [affected by shadow].
            </summary>
      <value>
        <c>true</c> if [affected by shadow]; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="T:PloobsEngine.Events.GroupedEvent`1">
      <summary>
            Evento que tem como alvo um grupo , nao precisa adicionar targets
            </summary>
    </member>
    <member name="T:PloobsEngine.Utils.TimePassed">
      <summary>
            Helper to wait for a period
            When off always return false in hasPassed Method
            </summary>
    </member>
    <member name="M:PloobsEngine.Utils.TimePassed.#ctor(System.Single)">
      <summary>
            Initializes a new instance of the <see cref="T:PloobsEngine.Utils.TimePassed" /> class.
            Starts on by Default
            </summary>
      <param name="intervalInSeconds">
      </param>
    </member>
    <member name="M:PloobsEngine.Utils.TimePassed.#ctor(System.Single,System.Boolean)">
      <summary>
            Initializes a new instance of the <see cref="T:PloobsEngine.Utils.TimePassed" /> class.
            </summary>
      <param name="intervalInSeconds">The interval in seconds.</param>
      <param name="startOn">if set to <c>true</c> [start on].</param>
    </member>
    <member name="M:PloobsEngine.Utils.TimePassed.InitOrRestart(Microsoft.Xna.Framework.GameTime)">
      <summary>
            Inits or restart.
            </summary>
    </member>
    <member name="M:PloobsEngine.Utils.TimePassed.hasPassed(Microsoft.Xna.Framework.GameTime)">
      <summary>
            Determines whether the interval has passed.        
            </summary>
      <returns>
        <c>true</c> if this instance has passed; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="P:PloobsEngine.Utils.TimePassed.State">
      <summary>
            On or Off
            </summary>
    </member>
    <member name="P:PloobsEngine.Utils.TimePassed.Interval">
      <summary>
            Gets or sets the interval in seconds
            </summary>
      <value>
            The interval.
            </value>
    </member>
    <member name="T:PloobsEngine.SceneControl.EngineContentManager">
      <summary>
            Content Manager, used to load stuffs like Model, Textures
            Cache the results
            </summary>
    </member>
    <member name="T:PloobsEngine.DataStructure.Pool`1">
      <summary>
            A collection that maintains a set of class instances to allow for recycling
            instances and minimizing the effects of garbage collection.
            </summary>
      <typeparam name="T">The type of object to store in the Pool. Pools can only hold class types.</typeparam>
    </member>
    <member name="M:PloobsEngine.DataStructure.Pool`1.#ctor(System.Int32,System.Boolean,System.Predicate{`0},System.Func{`0})">
      <summary>
            Creates a new pool with a specific starting size.
            </summary>
      <param name="initialSize">The initial size of the pool.</param>
      <param name="resizes">Whether or not the pool is allowed to increase its size as needed.</param>
      <param name="validateFunc">A predicate used to determine if a given object is still valid.</param>
      <param name="allocateFunc">A function used to allocate an instance for the pool.</param>
    </member>
    <member name="M:PloobsEngine.DataStructure.Pool`1.CleanUp">
      <summary>
            Cleans up the pool by checking each valid object to ensure it is still actually valid.
            </summary>
    </member>
    <member name="M:PloobsEngine.DataStructure.Pool`1.New">
      <summary>
            Returns a new object from the Pool.
            </summary>
      <returns>The next object in the pool if available, null if all instances are valid.</returns>
    </member>
    <member name="P:PloobsEngine.DataStructure.Pool`1.Initialize">
      <summary>
            Gets or sets a delegate used for initializing objects before returning them from the New method.
            </summary>
    </member>
    <member name="P:PloobsEngine.DataStructure.Pool`1.Deinitialize">
      <summary>
            Gets or sets a delegate that is run when an object is moved from being valid to invalid
            in the CleanUp method.
            </summary>
    </member>
    <member name="P:PloobsEngine.DataStructure.Pool`1.ValidCount">
      <summary>
            Gets the number of valid objects in the pool.
            </summary>
    </member>
    <member name="P:PloobsEngine.DataStructure.Pool`1.InvalidCount">
      <summary>
            Gets the number of invalid objects in the pool.
            </summary>
    </member>
    <member name="P:PloobsEngine.DataStructure.Pool`1.Item(System.Int32)">
      <summary>
            Returns a valid object at the given index. The index must fall in the range of [0, ValidCount].
            </summary>
      <param name="index">The index of the valid object to get</param>
      <returns>A valid object found at the index</returns>
    </member>
    <member name="M:PloobsEngine.SceneControl.DirectionalShadowRenderer.#ctor(System.Int32)">
      <summary>
            Creates the renderer
            </summary>
    </member>
    <member name="M:PloobsEngine.SceneControl.DirectionalShadowRenderer.Render(Microsoft.Xna.Framework.GameTime,PloobsEngine.SceneControl.RenderHelper,PloobsEngine.Engine.GraphicInfo,PloobsEngine.Light.DirectionalLightPE,PloobsEngine.Cameras.ICamera,PloobsEngine.SceneControl.IWorld,PloobsEngine.SceneControl.IDeferredGBuffer)">
      <summary>
            Renders a list of models to the shadow map, and returns a surface
            containing the shadow occlusion factor
            </summary>
      <param name="gameTime">The game time.</param>
      <param name="render">The render.</param>
      <param name="ginfo">The ginfo.</param>
      <param name="light">The light for which the shadow is being calculated</param>
      <param name="mainCamera">The camera viewing the scene containing the light</param>
      <param name="world">The world.</param>
      <param name="deferredGBuffer">The deferred G buffer.</param>
      <returns>
            The shadow occlusion texture
            </returns>
    </member>
    <member name="M:PloobsEngine.SceneControl.DirectionalShadowRenderer.CalculateFrustum(PloobsEngine.Light.DirectionalLightPE,PloobsEngine.Cameras.ICamera,System.Single,System.Single,Microsoft.Xna.Framework.Matrix@,Microsoft.Xna.Framework.Matrix@,Microsoft.Xna.Framework.Matrix@)">
      <summary>
            Determines the size of the frustum needed to cover the viewable area,
            then creates an appropriate orthographic projection.
            </summary>
      <param name="light">The directional light to use</param>
      <param name="mainCamera">The camera viewing the scene</param>
    </member>
    <member name="M:PloobsEngine.SceneControl.DirectionalShadowRenderer.RenderShadowMap(Microsoft.Xna.Framework.GameTime,PloobsEngine.SceneControl.RenderHelper,System.Int32,PloobsEngine.SceneControl.IWorld)">
      <summary>
            Renders the shadow map using the orthographic camera created in
            CalculateFrustum.
            </summary>
      <param name="modelList">The list of models to be rendered</param>
    </member>
    <member name="M:PloobsEngine.SceneControl.DirectionalShadowRenderer.RenderShadowOcclusion(PloobsEngine.SceneControl.RenderHelper,PloobsEngine.Cameras.ICamera,PloobsEngine.Light.DirectionalLightPE,PloobsEngine.SceneControl.IDeferredGBuffer)">
      <summary>
            Renders a texture containing the final shadow occlusion
            </summary>
    </member>
    <member name="P:PloobsEngine.SceneControl.DirectionalShadowRenderer.ShadowMapSize">
      <summary>
            Default 512
            </summary>
    </member>
    <member name="P:PloobsEngine.SceneControl.DirectionalShadowRenderer.SplitConstant">
      <summary>
            Default 0.95
            Tune the sizes of the splits (exponecial constant)
            </summary>
    </member>
    <member name="M:PloobsEngine.SceneControl._2DScene.I2DScene.AfterLoadContent(PloobsEngine.SceneControl.IContentManager,PloobsEngine.Engine.GraphicInfo,PloobsEngine.Engine.GraphicFactory)">
      <summary>
            Function called After all the stuffs LoadContent is called
            </summary>
    </member>
    <member name="M:PloobsEngine.SceneControl._2DScene.I2DScene.Update(Microsoft.Xna.Framework.GameTime)">
      <summary>
            Update the Screen
            </summary>
      <param name="gameTime">
      </param>
    </member>
    <member name="M:PloobsEngine.SceneControl._2DScene.I2DScene.Draw(Microsoft.Xna.Framework.GameTime,PloobsEngine.SceneControl.RenderHelper)">
      <summary>
            This is called when the screen should draw itself.
            </summary>
      <param name="gameTime">
      </param>
      <param name="render">
      </param>
    </member>
    <member name="M:PloobsEngine.SceneControl._2DScene.I2DScene.LoadContent(PloobsEngine.Engine.GraphicInfo,PloobsEngine.Engine.GraphicFactory,PloobsEngine.SceneControl.IContentManager)">
      <summary>
            Load content for the screen.        
            </summary>
      <param name="GraphicInfo">
      </param>
      <param name="factory">
      </param>
      <param name="contentManager">
      </param>
    </member>
    <member name="M:PloobsEngine.SceneControl._2DScene.I2DScene.InitScreen(PloobsEngine.Engine.GraphicInfo,PloobsEngine.Engine.EngineStuff)">
      <summary>
            Init Screen
            </summary>
      <param name="GraphicInfo">The graphic info.</param>
      <param name="engine">
      </param>
    </member>
    <member name="M:PloobsEngine.SceneControl._2DScene.I2DScene.SetWorldAndRenderTechnich(PloobsEngine.SceneControl._2DScene.RenderTechnich2D@,PloobsEngine.SceneControl._2DScene.I2DWorld@)">
      <summary>
            Sets the world and render technich.
            </summary>
      <param name="renderTech">The render tech.</param>
      <param name="world">The world.</param>
    </member>
    <member name="P:PloobsEngine.SceneControl._2DScene.I2DScene.RenderTechnic">
      <summary>
            Gets the render technics.
            </summary>
    </member>
    <member name="P:PloobsEngine.SceneControl._2DScene.I2DScene.World">
      <summary>
            Gets or sets the world instance.
            </summary>
      <value>
            The world.
            </value>
    </member>
    <member name="T:PloobsEngine.Modelo.VertexMultitextured">
      <summary>
            Vertex Struct used in the Water shader
            </summary>
    </member>
    <member name="F:PloobsEngine.Modelo.VertexMultitextured.SizeInBytes">
      <summary>
            Size in bytes
            </summary>
    </member>
    <member name="F:PloobsEngine.Modelo.VertexMultitextured.VertexElements">
      <summary>
            Vertex Elements
            </summary>
    </member>
    <member name="T:PloobsEngine.Material.ForwardTransparenteShader">
      <summary>
            Forward Material
            </summary>
    </member>
    <member name="M:PloobsEngine.Material.ForwardTransparenteShader.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:PloobsEngine.Material.ForwardTransparenteShader" /> class.
            Use Texture Alpha
            </summary>
    </member>
    <member name="M:PloobsEngine.Material.ForwardTransparenteShader.#ctor(System.Single)">
      <summary>
            Initializes a new instance of the <see cref="T:PloobsEngine.Material.ForwardTransparenteShader" /> class.
            Use custom alpha
            </summary>
      <param name="transparencyLevel">The transparency level.</param>
    </member>
    <member name="P:PloobsEngine.Material.ForwardTransparenteShader.CullModeToUse">
      <summary>
            Default None
            </summary>
    </member>
    <member name="P:PloobsEngine.Material.ForwardTransparenteShader.TransparencyLevel">
      <summary>
            Between 0 and 1 
            If not setted, the texture alpha will be used instead
            </summary>
    </member>
    <member name="T:PloobsEngine.Light.PointLightPE">
      <summary>
            Deferred Point Light
            </summary>
    </member>
    <member name="M:PloobsEngine.Light.PointLightPE.#ctor">
      <summary>
            Serialization 
            </summary>
    </member>
    <member name="M:PloobsEngine.Light.PointLightPE.#ctor(Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Color,System.Single,System.Single)">
      <summary>
            Point Light
            </summary>
      <param name="lightPosition">Position in World</param>
      <param name="color">Color</param>
      <param name="lightRadius">Radius</param>
      <param name="lightIntensity">Intensity</param>
    </member>
    <member name="P:PloobsEngine.Light.PointLightPE.LightPosition">
      <summary>
            Gets or sets the light position.
            </summary>
      <value>
            The light position.
            </value>
    </member>
    <member name="P:PloobsEngine.Light.PointLightPE.LightRadius">
      <summary>
            Gets or sets the light radius.
            </summary>
      <value>
            The light radius.
            </value>
    </member>
    <member name="P:PloobsEngine.Light.PointLightPE.LightIntensity">
      <summary>
            Gets or sets the light intensity.
            </summary>
      <value>
            The light intensity.
            </value>
    </member>
    <member name="P:PloobsEngine.Light.PointLightPE.UsePointLightQuadraticAttenuation">
      <summary>
            Gets or sets a value indicating whether [use point light quadratic attenuation].
            </summary>
      <value>
        <c>true</c> if [use point light quadratic attenuation]; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="P:PloobsEngine.Light.PointLightPE.LightType">
      <summary>
            Gets the type of the light.
            </summary>
      <value>
            The type of the light.
            </value>
    </member>
    <member name="M:PloobsEngine.Light2D.SpotLight2D.#ctor(Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Color,Microsoft.Xna.Framework.Vector2,System.Single,System.Single,PloobsEngine.Light2D.ShadowmapSize)">
      <summary>
            Initializes a new instance of the <see cref="T:PloobsEngine.Light2D.SpotLight2D" /> class.
            </summary>
      <param name="position">The position.</param>
      <param name="color">The color.</param>
      <param name="direction">The direction.</param>
      <param name="angle">The angle. IN RADIANS !!!!!!!!!!!!!!!</param>
      <param name="intensity">The intensity.</param>
      <param name="ShadowmapSize">Size of the shadowmap.</param>
    </member>
    <member name="T:PloobsEngine.Utils.Curve3D">
      <summary>
            Represents a Curve3D 
            using one XNA Curve for each axis
            </summary>
    </member>
    <member name="M:PloobsEngine.Utils.Curve3D.#ctor(Microsoft.Xna.Framework.CurveLoopType)">
      <summary>
            Initializes a new instance of the <see cref="T:PloobsEngine.Utils.Curve3D" /> class.
            </summary>
      <param name="CurveLoopType">Type of the curve loop.</param>
    </member>
    <member name="M:PloobsEngine.Utils.Curve3D.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:PloobsEngine.Utils.Curve3D" /> class.
            Linear Curve Loop Type
            </summary>
    </member>
    <member name="M:PloobsEngine.Utils.Curve3D.SetTangents">
      <summary>
            Sets the tangents.
            </summary>
    </member>
    <member name="M:PloobsEngine.Utils.Curve3D.SetCurveKeyTangent(Microsoft.Xna.Framework.CurveKey@,Microsoft.Xna.Framework.CurveKey@,Microsoft.Xna.Framework.CurveKey@)">
      <summary>
            Sets the curve key tangent.
            </summary>
      <param name="prev">The prev.</param>
      <param name="cur">The cur.</param>
      <param name="next">The next.</param>
    </member>
    <member name="M:PloobsEngine.Utils.Curve3D.AddPoint(Microsoft.Xna.Framework.Vector3,System.Single)">
      <summary>
            Adds the point.
            </summary>
      <param name="point">The point.</param>
      <param name="time">The time.</param>
    </member>
    <member name="M:PloobsEngine.Utils.Curve3D.GetPointOnCurve(System.Single)">
      <summary>
            Gets the point on curve.
            </summary>
      <param name="time">The time.</param>
      <returns>
      </returns>
    </member>
    <member name="M:PloobsEngine.SceneControl.ColorCorrectionPostEffect.#ctor(Microsoft.Xna.Framework.Color,System.Single)">
      <summary>
            Initializes a new instance of the <see cref="T:PloobsEngine.SceneControl.ColorCorrectionPostEffect" /> class.
            </summary>
      <param name="colorAdd">The color add.</param>
      <param name="colorCorrect">The color correct.</param>
    </member>
    <member name="T:PloobsEngine.SceneControl.IObjectAttachment">
      <summary>    
            You can bind one IObjectAtachtment to one IObject
            The IObjectAtachtment method Update will be called everytime 
            the method Update of the object is called
            </summary>
    </member>
    <member name="M:PloobsEngine.SceneControl.IObjectAttachment.Update(PloobsEngine.SceneControl.IObject,Microsoft.Xna.Framework.GameTime)">
      <summary>
            Updates the atachment.
            </summary>
      <param name="obj">The obj.</param>
      <param name="gt">The gt.</param>
    </member>
    <member name="T:PloobsEngine.SceneControl.Octree`1">
      <summary>
            Represents an octree spatial partioning system.
            </summary>
    </member>
    <member name="F:PloobsEngine.SceneControl.Octree`1.ChildCount">
      <summary>
            The number of children in an octree.
            </summary>
    </member>
    <member name="F:PloobsEngine.SceneControl.Octree`1.looseness">
      <summary>
            The octree's looseness value.
            </summary>
    </member>
    <member name="F:PloobsEngine.SceneControl.Octree`1.depth">
      <summary>
            The octree's depth.
            </summary>
    </member>
    <member name="F:PloobsEngine.SceneControl.Octree`1.center">
      <summary>
            The octree's center coordinates.
            </summary>
    </member>
    <member name="F:PloobsEngine.SceneControl.Octree`1.length">
      <summary>
            The octree's length.
            </summary>
    </member>
    <member name="F:PloobsEngine.SceneControl.Octree`1.bounds">
      <summary>
            The bounding box that represents the octree.
            </summary>
    </member>
    <member name="F:PloobsEngine.SceneControl.Octree`1.objects">
      <summary>
            The objects in the octree.
            </summary>
    </member>
    <member name="F:PloobsEngine.SceneControl.Octree`1.children">
      <summary>
            The octree's child nodes.
            </summary>
    </member>
    <member name="F:PloobsEngine.SceneControl.Octree`1.worldSize">
      <summary>
            The octree's world size.
            </summary>
    </member>
    <member name="M:PloobsEngine.SceneControl.Octree`1.#ctor(System.Single,System.Single,System.Int32)">
      <summary>
            Creates a new octree.
            </summary>
      <param name="worldSize">The octree's world size.</param>
      <param name="looseness">The octree's looseness value.</param>
      <param name="depth">The octree recursion depth.</param>
    </member>
    <member name="M:PloobsEngine.SceneControl.Octree`1.#ctor(System.Single,System.Single,System.Int32,System.Int32,Microsoft.Xna.Framework.Vector3)">
      <summary>
            Creates a new octree.
            </summary>
      <param name="worldSize">The octree's world size.</param>
      <param name="looseness">The octree's looseness value.</param>
      <param name="maxDepth">The maximum depth to recurse to.</param>
      <param name="depth">The octree recursion depth.</param>
      <param name="center">The octree's center coordinates.</param>
    </member>
    <member name="M:PloobsEngine.SceneControl.Octree`1.Add(`0,Microsoft.Xna.Framework.Vector3,System.Single)">
      <summary>
            Adds the given object to the octree.
            </summary>
      <param name="o">The object to add.</param>
      <param name="center">The object's center coordinates.</param>
      <param name="radius">The object's radius.</param>
    </member>
    <member name="M:PloobsEngine.SceneControl.Octree`1.Add(`0,Microsoft.Xna.Framework.BoundingBox)">
      <summary>
            Adds the given object to the octree.
            </summary>
    </member>
    <member name="M:PloobsEngine.SceneControl.Octree`1.Add(`0,Microsoft.Xna.Framework.BoundingBox,Microsoft.Xna.Framework.Vector3,System.Single)">
      <summary>
            Adds the given object to the octree.
            </summary>
      <param name="o">The object to add.</param>
      <param name="bounds">The object's bounds.</param>
      <param name="center">The object's center coordinates.</param>
      <param name="radius">The object's radius.</param>
    </member>
    <member name="M:PloobsEngine.SceneControl.Octree`1.Draw(Microsoft.Xna.Framework.Matrix,Microsoft.Xna.Framework.Matrix,System.Collections.Generic.List{`0})">
      <summary>
            Draws the octree.
            </summary>
      <param name="view">The viewing matrix.</param>
      <param name="projection">The projection matrix.</param>
      <param name="objects">The objects in the octree.</param>
      <returns>The number of octrees drawn.</returns>
    </member>
    <member name="M:PloobsEngine.SceneControl.Octree`1.Draw(Microsoft.Xna.Framework.BoundingFrustum,Microsoft.Xna.Framework.Matrix,Microsoft.Xna.Framework.Matrix,Microsoft.Xna.Framework.ContainmentType,System.Collections.Generic.List{`0})">
      <summary>
            Draws the octree.
            </summary>
      <param name="frustum">The viewing frustum used to determine if the octree is in view.</param>
      <param name="view">The viewing matrix.</param>
      <param name="projection">The projection matrix.</param>
      <param name="containment">Determines how much of the octree is visible.</param>
      <param name="objects">The objects in the octree.</param>
      <returns>The number of octrees drawn.</returns>
    </member>
    <member name="M:PloobsEngine.SceneControl.Octree`1.Split(System.Int32)">
      <summary>
            Splits the octree into eight children.
            </summary>
      <param name="maxDepth">The maximum depth to recurse to.</param>
    </member>
    <member name="T:PloobsEngine.SceneControl.ScreenState">
      <summary>
            Enum describes the screen transition state.
            </summary>
    </member>
    <member name="F:PloobsEngine.SceneControl.ScreenState.Active">
      <summary>
            Updates and Draw called (normal operation)
            </summary>
    </member>
    <member name="F:PloobsEngine.SceneControl.ScreenState.Paused">
      <summary>
            Updates is not called
            </summary>
    </member>
    <member name="F:PloobsEngine.SceneControl.ScreenState.Hidden">
      <summary>
            Draw is not called
            </summary>
    </member>
    <member name="F:PloobsEngine.SceneControl.ScreenState.Inactive">
      <summary>
            draw and update not called
            </summary>
    </member>
    <member name="M:PloobsEngine.Input.SimpleConcreteKeyboardInputPlayable.#ctor(PloobsEngine.Input.StateKey,Microsoft.Xna.Framework.Input.Keys,PloobsEngine.Input.KeyStateChange,PloobsEngine.Input.InputMask,PloobsEngine.Input.EntityType)">
      <summary>
            Initializes a new instance of the <see cref="T:PloobsEngine.Input.SimpleConcreteKeyboardInputPlayable" /> class.
            
            </summary>
      <param name="state">The state.</param>
      <param name="key">The key.</param>
      <param name="callback">The callback.</param>
      <param name="mask">The mask.</param>
      <param name="type">The type.</param>
    </member>
    <member name="M:PloobsEngine.Input.SimpleConcreteKeyboardInputPlayable.#ctor(PloobsEngine.Input.StateKey,Microsoft.Xna.Framework.Input.Keys[],PloobsEngine.Input.KeyStateChange,PloobsEngine.Input.InputMask,PloobsEngine.Input.EntityType)">
      <summary>
            Initializes a new instance of the <see cref="T:PloobsEngine.Input.SimpleConcreteKeyboardInputPlayable" /> class.
            For Combo
            </summary>
      <param name="state">The state.</param>
      <param name="key">The key.</param>
      <param name="callback">The callback.</param>
      <param name="mask">The mask.</param>
      <param name="type">The type.</param>
    </member>
    <member name="T:PloobsEngine.Engine.OnGraphicInfoChange">
      <summary>
            When GraphicInfo changes
            </summary>
      <param name="newGraphicInfo">The new graphic info.</param>
    </member>
    <member name="T:PloobsEngine.Engine.GraphicInfo">
      <summary>
            Contains Graphics Informations about the current execution
            </summary>
    </member>
    <member name="M:PloobsEngine.Engine.GraphicInfo.CheckIfRenderTargetFormatIsSupported(Microsoft.Xna.Framework.Graphics.SurfaceFormat,Microsoft.Xna.Framework.Graphics.DepthFormat,System.Boolean,System.Int32,Microsoft.Xna.Framework.Graphics.GraphicsProfile)">
      <summary>
            Checks if render target properties combination is supported.
            </summary>
      <param name="format">The format.</param>
      <param name="depthFormat">The depth format.</param>
      <param name="useMipMap">if set to <c>true</c> [use mip map].</param>
      <param name="multisample">The multisample.</param>
      <returns>
      </returns>
    </member>
    <member name="M:PloobsEngine.Engine.GraphicInfo.GetRenderTargetSupportedFormat(Microsoft.Xna.Framework.Graphics.SurfaceFormat@,Microsoft.Xna.Framework.Graphics.DepthFormat@,System.Boolean@,System.Int32@,Microsoft.Xna.Framework.Graphics.GraphicsProfile)">
      <summary>
            Gets the render target supported format.
            </summary>
      <param name="format">The format.</param>
      <param name="depthFormat">The depth format.</param>
      <param name="useMipMap">if set to <c>true</c> [use mip map].</param>
      <param name="multisample">The multisample.</param>
      <param name="GraphicsProfile">The graphics profile.</param>
    </member>
    <member name="M:PloobsEngine.Engine.GraphicInfo.GetBackBufferSupportedFormat(Microsoft.Xna.Framework.Graphics.SurfaceFormat@,Microsoft.Xna.Framework.Graphics.DepthFormat@,System.Boolean@,System.Int32@,Microsoft.Xna.Framework.Graphics.GraphicsProfile)">
      <summary>
            Gets the back buffer supported format.
            </summary>
      <param name="format">The format.</param>
      <param name="depthFormat">The depth format.</param>
      <param name="useMipMap">if set to <c>true</c> [use mip map].</param>
      <param name="multisample">The multisample.</param>
      <param name="GraphicsProfile">The graphics profile.</param>
    </member>
    <member name="P:PloobsEngine.Engine.GraphicInfo.GraphicsAdapter">
      <summary>
            Graphic Adapter
            </summary>
    </member>
    <member name="P:PloobsEngine.Engine.GraphicInfo.UseAnisotropicFiltering">
      <summary>
            Gets a value indicating whether [use anisotropic filtering].
            </summary>
      <value>
        <c>true</c> if [use anisotropic filtering]; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="P:PloobsEngine.Engine.GraphicInfo.SamplerState">
      <summary>
            Sampler to be used when possible
            </summary>
    </member>
    <member name="P:PloobsEngine.Engine.GraphicInfo.UseMipMap">
      <summary>
            Gets a value indicating whether [use mip map].
            </summary>
      <value>
        <c>true</c> if [use mip map]; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="P:PloobsEngine.Engine.GraphicInfo.DepthFormat">
      <summary>
            BackBuffer Depth Format
            </summary>
    </member>
    <member name="P:PloobsEngine.Engine.GraphicInfo.MultiSample">
      <summary>
            Back Buffer Multisample
            </summary>
    </member>
    <member name="P:PloobsEngine.Engine.GraphicInfo.BackBufferHeight">
      <summary>
            BackBufferHeight
            </summary>
    </member>
    <member name="P:PloobsEngine.Engine.GraphicInfo.BackBufferWidth">
      <summary>
            BackBufferWidth
            </summary>
    </member>
    <member name="P:PloobsEngine.Engine.GraphicInfo.FullScreenRectangle">
      <summary>
            FullScreenRectangle
            </summary>
    </member>
    <member name="P:PloobsEngine.Engine.GraphicInfo.HalfPixel">
      <summary>
            HalfPixel (used in DX 9 shaders)
            </summary>
    </member>
    <member name="P:PloobsEngine.Engine.GraphicInfo.Viewport">
      <summary>
            Viewport
            </summary>
    </member>
    <member name="P:PloobsEngine.Engine.GraphicInfo.Window">
      <summary>
            Game Window.
            </summary>
    </member>
    <member name="E:PloobsEngine.Engine.GraphicInfo.OnGraphicInfoChange">
      <summary>
            Occurs when [on graphic info change].
            </summary>
    </member>
    <member name="E:PloobsEngine.Engine.GraphicInfo.DeviceReset">
      <summary>
            Occurs when [device reset].
            </summary>
    </member>
    <member name="T:PloobsEngine.DataStructure.SerializableDictionary`2">
      <summary>
            XML serializabe dictionary (the .net dictionary is not)
            </summary>
      <typeparam name="TKey">The type of the key.</typeparam>
      <typeparam name="TValue">The type of the value.</typeparam>
    </member>
    <member name="M:PloobsEngine.DataStructure.SerializableDictionary`2.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:PloobsEngine.DataStructure.SerializableDictionary`2" /> class.
            Serialization purpose
            </summary>
    </member>
    <member name="M:PloobsEngine.DataStructure.SerializableDictionary`2.#ctor(System.Collections.Generic.IDictionary{`0,`1})">
      <summary>
            Initializes a new instance of the <see cref="T:PloobsEngine.DataStructure.SerializableDictionary`2" /> class.
            </summary>
      <param name="dic">The dic.</param>
    </member>
    <member name="M:PloobsEngine.DataStructure.SerializableDictionary`2.Concate(PloobsEngine.DataStructure.SerializableDictionary{`0,`1})">
      <summary>
            Concates the specified dic.
            </summary>
      <param name="dic">The dic.</param>
    </member>
    <member name="M:PloobsEngine.DataStructure.SerializableDictionary`2.GetSchema">
      <summary>
            This method is reserved and should not be used. When implementing the IXmlSerializable interface, you should return null (Nothing in Visual Basic) from this method, and instead, if specifying a custom schema is required, apply the <see cref="T:System.Xml.Serialization.XmlSchemaProviderAttribute" /> to the class.
            </summary>
      <returns>
            An <see cref="T:System.Xml.Schema.XmlSchema" /> that describes the XML representation of the object that is produced by the <see cref="M:System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)" /> method and consumed by the <see cref="M:System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)" /> method.
            </returns>
    </member>
    <member name="M:PloobsEngine.DataStructure.SerializableDictionary`2.ReadXml(System.Xml.XmlReader)">
      <summary>
            Generates an object from its XML representation.
            </summary>
      <param name="reader">The <see cref="T:System.Xml.XmlReader" /> stream from which the object is deserialized.</param>
    </member>
    <member name="M:PloobsEngine.DataStructure.SerializableDictionary`2.WriteXml(System.Xml.XmlWriter)">
      <summary>
            Converts an object into its XML representation.
            </summary>
      <param name="writer">The <see cref="T:System.Xml.XmlWriter" /> stream to which the object is serialized.</param>
    </member>
    <member name="T:PloobsEngine.Physics.BepuPhysicWorld">
      <summary>
            Bepu Implementation of a Physic World
            </summary>
    </member>
    <member name="M:PloobsEngine.Physics.BepuPhysicWorld.#ctor(System.Single,System.Boolean,System.Single,System.Boolean)">
      <summary>
            Initializes a new instance of the <see cref="T:PloobsEngine.Physics.BepuPhysicWorld" /> class.
            </summary>
      <param name="gravity">The gravity.</param>
      <param name="useRealElapsedTimeStep">if set to <c>true</c> [use real elapsed time step] in the simulation.</param>
      <param name="PhysicElapsedTimeMultiplier">If useRealElapsedTimeStep is true, multiply the elapsedtime by this value.</param>
      <param name="multiThread">if set to <c>true</c> [multi thread].</param>
    </member>
    <member name="M:PloobsEngine.Physics.BepuPhysicWorld.Update(Microsoft.Xna.Framework.GameTime)">
      <summary>
            Updates
            </summary>
      <param name="gt">The gt.</param>
    </member>
    <member name="M:PloobsEngine.Physics.BepuPhysicWorld.AddObject(PloobsEngine.Physics.IPhysicObject)">
      <summary>
            Adds the object.
            </summary>
      <param name="obj">The obj.</param>
    </member>
    <member name="M:PloobsEngine.Physics.BepuPhysicWorld.RemoveObject(PloobsEngine.Physics.IPhysicObject)">
      <summary>
            Removes the object.
            </summary>
      <param name="obj">The obj.</param>
    </member>
    <member name="M:PloobsEngine.Physics.BepuPhysicWorld.RemoveConstraint(PloobsEngine.Physic.Constraints.IPhysicConstraint)">
      <summary>
            Removes the constraint.
            </summary>
      <param name="ctn">The CTN.</param>
    </member>
    <member name="M:PloobsEngine.Physics.BepuPhysicWorld.DebugDrawn(Microsoft.Xna.Framework.GameTime,PloobsEngine.Cameras.ICamera)">
      <summary>
            Draw the physic world in debug mode.
            </summary>
      <param name="gt">The gt.</param>
      <param name="cam">The cam.</param>
    </member>
    <member name="M:PloobsEngine.Physics.BepuPhysicWorld.SegmentIntersect(Microsoft.Xna.Framework.Ray,System.Func{PloobsEngine.Physics.IPhysicObject,System.Boolean},System.Single)">
      <summary>
            Raycast
            </summary>
      <param name="raio">The raio.</param>
      <param name="filter">
      </param>
      <param name="maxDistance">The max distance.</param>
      <returns>
      </returns>
    </member>
    <member name="M:PloobsEngine.Physics.BepuPhysicWorld.DetectCollisions(PloobsEngine.Physics.IPhysicObject,System.Collections.Generic.List{PloobsEngine.Physics.IPhysicObject})">
      <summary>
            Detects the collisions.
            </summary>
      <param name="po">The po.</param>
      <param name="col">The col.</param>
    </member>
    <member name="M:PloobsEngine.Physics.BepuPhysicWorld.GetPhysicsObjectsInRange(PloobsEngine.Physics.IPhysicObject,System.Single,PloobsEngine.Physics.CullerConditionAvaliator{PloobsEngine.Physics.IPhysicObject,PloobsEngine.SceneControl.IObject},System.Collections.Generic.List{PloobsEngine.Physics.IPhysicObject})">
      <summary>
            Gets the physics objects in range.
            </summary>
      <param name="po">The po.</param>
      <param name="distance">The distance.</param>
      <param name="condition">The condition.</param>
      <param name="resp">The resp.</param>
    </member>
    <member name="M:PloobsEngine.Physics.BepuPhysicWorld.GetIObjectsInRange(Microsoft.Xna.Framework.BoundingFrustum,PloobsEngine.Physics.CullerConditionAvaliator{PloobsEngine.Physics.IPhysicObject,PloobsEngine.SceneControl.IObject},System.Collections.Generic.List{PloobsEngine.SceneControl.IObject})">
      <summary>
            Gets the Iobjects in range.
            </summary>
      <param name="frustrum">The frustrum.</param>
      <param name="condition">The condition.</param>
      <param name="resp">The resp.</param>
    </member>
    <member name="M:PloobsEngine.Physics.BepuPhysicWorld.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Gets the object data.
            </summary>
      <param name="info">The info.</param>
      <param name="context">The context.</param>
    </member>
    <member name="M:PloobsEngine.Physics.BepuPhysicWorld.ApplyDefaultSettings(PloobsEngine.Physics.BepuPhysicWorld)">
      <summary>
            Applies the default settings to the space.
            These values are what the engine starts with; they don't have to be applied unless you just want to get back to the defaults.
            This doesn't cover every single tunable field in the entire engine, just the main ones that this helper class is messing with.
            </summary>
      <param name="world">The world.</param>
    </member>
    <member name="M:PloobsEngine.Physics.BepuPhysicWorld.ApplyRotationSettings">
      <summary>
            Applies some rotation-related settings.
            With these settings enabled, rotation generally behaves better with long shapes.
            Angular motion is more realistic since the momentum is conserved.
            However, these settings can also cause some instability to sneak into the simulation.
            Try using these settings on the Saw Contraption demo to see an example of what can go
            wrong when conservation is enabled.
            </summary>
    </member>
    <member name="M:PloobsEngine.Physics.BepuPhysicWorld.ApplySemiSpeedySettings">
      <summary>
            Applies slightly higher speed settings.
            The only change here is the default minimum iterations.
            In many simulations, having a minimum iteration count of 0 works just fine.
            It's a quick and still fairly robust way to get some extra performance.
            An example of where this might introduce some issues is sphere stacking.
            </summary>
    </member>
    <member name="M:PloobsEngine.Physics.BepuPhysicWorld.ApplySuperSpeedySettings(PloobsEngine.Physics.BepuPhysicWorld)">
      <summary>
            Applies some low quality, high speed settings.
            The main benefit comes from the very low iteration cap.
            By enabling simplex caching, general convex collision detection
            gets a nice chunk faster, but some curved shapes lose collision detection robustness.
            </summary>
      <param name="world">The world.</param>
    </member>
    <member name="M:PloobsEngine.Physics.BepuPhysicWorld.ApplyMediumHighStabilitySettings(PloobsEngine.Physics.BepuPhysicWorld)">
      <summary>
            Applies some higher quality settings.
            By using universal continuous collision detection, missed collisions
            will be much, much rarer.  This actually doesn't have a huge performance cost.
            The increased iterations put this as a midpoint between the normal and high stability settings.
            </summary>
      <param name="space">Space to configure.</param>
    </member>
    <member name="M:PloobsEngine.Physics.BepuPhysicWorld.ApplyHighStabilitySettings(PloobsEngine.Physics.BepuPhysicWorld)">
      <summary>
            Applies some high quality, low performance settings.
            By using universal continuous collision detection, missed collisions
            will be much, much rarer.  This actually doesn't have a huge performance cost.
            However, increasing the iteration limit and the minimum iterations to 5x the default
            will incur a pretty hefty overhead.
            On the upside, pretty much every simulation will be rock-solid.
            </summary>
      <param name="space">Space to configure.</param>
    </member>
    <member name="P:PloobsEngine.Physics.BepuPhysicWorld.Space">
      <summary>
            Gets or sets the space.
            </summary>
      <value>
            The space.
            </value>
    </member>
    <member name="P:PloobsEngine.Physics.BepuPhysicWorld.PhysicObjects">
      <summary>
            Gets the physic objects.
            </summary>
    </member>
    <member name="P:PloobsEngine.Physics.BepuPhysicWorld.PhysicConstraints">
      <summary>
            Gets the constraint objects.
            </summary>
    </member>
    <member name="T:PloobsEngine.Modelo.Animation.AnimatedController">
      <summary>
            Animated Controller concrete
            </summary>
    </member>
    <member name="M:PloobsEngine.Modelo.Animation.AnimatedController.#ctor(PloobsEngine.Modelo.Animation.IAnimatedModel,System.String,System.Boolean)">
      <summary>
            Initializes a new instance of the <see cref="T:PloobsEngine.Modelo.Animation.AnimatedController" /> class.
            </summary>
      <param name="model">The model.</param>
      <param name="StartAnimationName">Start name of the animation.</param>
      <param name="changeOnlyWhenDifferentAnimation">if set to <c>true</c> [change the current animationonly only when different animation is set].</param>
    </member>
    <member name="M:PloobsEngine.Modelo.Animation.AnimatedController.MappActionAnimation(System.String,System.String)">
      <summary>
            Mapps one action to animation.
            When using behaviors for example
            </summary>
      <param name="actionName">Name of the action.</param>
      <param name="animation">The animation.</param>
    </member>
    <member name="M:PloobsEngine.Modelo.Animation.AnimatedController.TransformBone(System.String,Microsoft.Xna.Framework.Quaternion)">
      <summary>
            Transforms the bone.
            </summary>
      <param name="boneName">Name of the bone.</param>
      <param name="rot">The rot.</param>
    </member>
    <member name="M:PloobsEngine.Modelo.Animation.AnimatedController.GetBoneAbsoluteTransform(System.String)">
      <summary>
            Gets the bone absolute transform.
            </summary>
      <param name="boneName">Name of the bone.</param>
      <returns>
      </returns>
    </member>
    <member name="M:PloobsEngine.Modelo.Animation.AnimatedController.ChangeAnimation(System.String,PloobsEngine.Modelo.Animation.AnimationChangeMode)">
      <summary>
            Changes the animation.
            </summary>
      <param name="animationName">Name of the animation.</param>
      <param name="mode">The interpolation mode.</param>
    </member>
    <member name="M:PloobsEngine.Modelo.Animation.AnimatedController.Update(Microsoft.Xna.Framework.GameTime)">
      <summary>
            Updates the controller.
            CAlled by the API
            </summary>
      <param name="gt">The gt.</param>
    </member>
    <member name="M:PloobsEngine.Modelo.Animation.AnimatedController.ChangeInterpolationMode(PloobsEngine.Modelo.Animation.AnimationInterpolationMode)">
      <summary>
            Changes the interpolation mode.
            </summary>
      <param name="im">The im.</param>
    </member>
    <member name="M:PloobsEngine.Modelo.Animation.AnimatedController.GetBoneTransformations">
      <summary>
            Gets the bone transformations.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="P:PloobsEngine.Modelo.Animation.AnimatedController.TransitionBetweenAnimationTimeInSeconds">
      <summary>
            Gets or sets the transition between animation time in seconds.
            </summary>
      <value>
            The transition between animation time in seconds.
            </value>
    </member>
    <member name="P:PloobsEngine.Modelo.Animation.AnimatedController.Speed">
      <summary>
            Gets or sets the animation speed.
            </summary>
      <value>
            The speed.
            </value>
    </member>
    <member name="P:PloobsEngine.Modelo.Animation.AnimatedController.isLoop">
      <summary>
            Gets or sets a value indicating whether this instance is in loop.
            </summary>
      <value>
        <c>true</c> if this instance is loop; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="T:PloobsEngine.Material.DeferredProceduralAnimatedcilindricBilboardShader">
      <summary>
            Simple Procedural Animated Bilboard.     
            </summary>
    </member>
    <member name="P:PloobsEngine.Material.DeferredProceduralAnimatedcilindricBilboardShader.Scale">
      <summary>
            Default Vector2(10, 10);
            </summary>
    </member>
    <member name="P:PloobsEngine.Material.DeferredProceduralAnimatedcilindricBilboardShader.Atenuation">
      <summary>
            Default Vector4.One
            </summary>
    </member>
    <member name="P:PloobsEngine.Material.DeferredProceduralAnimatedcilindricBilboardShader.AllowRotDir">
      <summary>
            Default Vector3(0,1,0)
            </summary>
    </member>
    <member name="P:PloobsEngine.Material.DeferredProceduralAnimatedcilindricBilboardShader.Amplitude">
      <summary>
            Default 1
            </summary>
    </member>
    <member name="P:PloobsEngine.Material.DeferredProceduralAnimatedcilindricBilboardShader.MovimentSpeedControl">
      <summary>
            Default 5
            </summary>
    </member>
    <member name="T:PloobsEngine.Material.DeferredSimpleAnimationShader">
      <summary>
            Animation shader with simple effects
            </summary>
    </member>
    <member name="M:PloobsEngine.Material.DeferredSimpleAnimationShader.#ctor">
      <summary>
            Serialization
            </summary>
    </member>
    <member name="M:PloobsEngine.Material.DeferredSimpleAnimationShader.#ctor(PloobsEngine.Modelo.Animation.IAnimatedController)">
      <summary>
            Initializes a new instance of the <see cref="T:PloobsEngine.Material.DeferredSimpleAnimationShader" /> class.
            </summary>
      <param name="ac">The ac.</param>
    </member>
    <member name="M:PloobsEngine.Material.DeferredSimpleAnimationShader.#ctor(PloobsEngine.Modelo.Animation.IAnimatedController,PloobsEngine.SceneControl.IObject,PloobsEngine.Modelo.Animation.IAnimatedController,System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:PloobsEngine.Material.DeferredSimpleAnimationShader" /> class.
            THIS IS A SPECIAL CONSTRUCTOR, it is used to ATACH this shader to a external BONE
            Can be used for example to put a gun in the hand of a character
            </summary>
      <param name="ac">The ac.</param>
      <param name="obj">The obj.</param>
      <param name="Followed">The followed.</param>
      <param name="boneName">Name of the bone.</param>
    </member>
    <member name="M:PloobsEngine.Material.DeferredSimpleAnimationShader.Update(Microsoft.Xna.Framework.GameTime,PloobsEngine.SceneControl.IObject,System.Collections.Generic.IList{PloobsEngine.Light.ILight})">
      <summary>
            Updates this shader
            Called every frame once
            </summary>
      <param name="gt">
      </param>
      <param name="ent">The ent.</param>
      <param name="lights">The lights.</param>
    </member>
    <member name="P:PloobsEngine.Material.DeferredSimpleAnimationShader.MaterialType">
      <summary>
            Gets the type of the material.
            </summary>
      <value>
            The type of the material.
            </value>
    </member>
    <member name="F:PloobsEngine.Features.DebugDraw.DebugBox.effect">
      <summary>
            The basic effect used to draw boxes.
            </summary>
    </member>
    <member name="M:PloobsEngine.Features.DebugDraw.DebugBox.#ctor(Microsoft.Xna.Framework.BoundingBox,Microsoft.Xna.Framework.Color)">
      <summary>
            Creates a new box.
            Visible by default
            </summary>
      <param name="BoundingBox">The bounding box.</param>
      <param name="color">The box's color.</param>
    </member>
    <member name="M:PloobsEngine.Features.DebugDraw.DebugBox.Draw(PloobsEngine.SceneControl.RenderHelper,Microsoft.Xna.Framework.Matrix,Microsoft.Xna.Framework.Matrix)">
      <summary>
            Draws the box.
            </summary>
      <param name="render">The render.</param>
      <param name="view">The viewing matrix.</param>
      <param name="projection">The projection matrix.</param>
    </member>
    <member name="T:PloobsEngine.IA.Genetic.GenomeComparer">
      <summary>
            Compares genomes by fitness
            </summary>
    </member>
    <member name="T:PloobsEngine.IA.Genetic.Genome">
      <summary>
            Summary description for Genome.
            </summary>
    </member>
    <member name="T:PloobsEngine.Utils.MovingAverage">
      <summary>
            Moving Average class
            </summary>
    </member>
    <member name="F:PloobsEngine.Utils.MovingAverage.m_Data">
      <summary>
            Array of elements
            </summary>
    </member>
    <member name="F:PloobsEngine.Utils.MovingAverage.m_Total">
      <summary>
            Total amount
            </summary>
    </member>
    <member name="F:PloobsEngine.Utils.MovingAverage.m_Size">
      <summary>
            Fixed size of the array
            </summary>
    </member>
    <member name="F:PloobsEngine.Utils.MovingAverage.m_Count">
      <summary>
            How many elements we've got so far
            </summary>
    </member>
    <member name="M:PloobsEngine.Utils.MovingAverage.#ctor(System.Int32)">
      <summary>
            Constructor
            </summary>
      <param name="size">Set the fixed size of the array here</param>
    </member>
    <member name="M:PloobsEngine.Utils.MovingAverage.Add(System.Double)">
      <summary>
            Add an element
            </summary>
    </member>
    <member name="P:PloobsEngine.Utils.MovingAverage.Data">
      <summary>
            Get data
            </summary>
    </member>
    <member name="P:PloobsEngine.Utils.MovingAverage.Count">
      <summary>
            Get count
            </summary>
    </member>
    <member name="P:PloobsEngine.Utils.MovingAverage.Value">
      <summary>
            Get value
            </summary>
    </member>
    <member name="M:PloobsEngine.SceneControl.ContrastPostEffect.#ctor(System.Single)">
      <summary>
            Initializes a new instance of the <see cref="T:PloobsEngine.SceneControl.ContrastPostEffect" /> class.
            </summary>
      <param name="contrast">-1 a 1</param>
    </member>
    <member name="M:PloobsEngine.SceneControl.OctreeCuller.#ctor(System.Single,System.Single,System.Int32,Microsoft.Xna.Framework.Vector3,PloobsEngine.Features.DebugDraw.DebugShapesDrawer)">
      <summary>
            Initializes a new instance of the <see cref="T:PloobsEngine.SceneControl.OctreeCuller" /> class.
            </summary>
      <param name="worldSize">Size of the world.</param>
      <param name="loose">The loose.</param>
      <param name="maxDepth">The max depth.</param>
      <param name="center">The center.</param>
      <param name="DebugDrawer">The debug drawer. We strong recomend you to DONT JUST this DebugDrawer for nothing anymore, if you need, create another</param>
    </member>
    <member name="T:PloobsEngine.MessageSystem.SystemRecieverMessage">
      <summary>    
            Helper to Handle some message
            </summary>
    </member>
    <member name="M:PloobsEngine.MessageSystem.SystemRecieverMessage.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:PloobsEngine.MessageSystem.SystemRecieverMessage" /> class.
            </summary>
    </member>
    <member name="M:PloobsEngine.MessageSystem.SystemRecieverMessage.HandleThisMessageType(PloobsEngine.MessageSystem.SenderType)">
      <summary>
            Handles a message from determined sender type.
            </summary>
      <param name="type">Sender type.</param>
      <returns>
      </returns>
    </member>
    <member name="M:PloobsEngine.MessageSystem.SystemRecieverMessage.HandleMessage(PloobsEngine.MessageSystem.Message)">
      <summary>
            Handles the message.
            </summary>
      <param name="mes">The mes.</param>
    </member>
    <member name="M:PloobsEngine.MessageSystem.SystemRecieverMessage.GetId">
      <summary>
            return the entity id
            </summary>
      <returns>
            the id
            </returns>
    </member>
    <member name="M:PloobsEngine.MessageSystem.SystemRecieverMessage.SetId(System.Int32)">
      <summary>
            sets the id
            </summary>
      <param name="id">
      </param>
    </member>
    <member name="M:PloobsEngine.MessageSystem.SystemRecieverMessage.Dispose">
      <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
    </member>
    <member name="T:PloobsEngine.Input.TurnOffInputMaskCommand">
      <summary>
            Turn n Input Mask OFF
            </summary>
    </member>
    <member name="M:PloobsEngine.Input.TurnOffInputMaskCommand.#ctor(PloobsEngine.Input.InputMask)">
      <summary>
            Initializes a new instance of the <see cref="T:PloobsEngine.Input.TurnOffInputMaskCommand" /> class.
            </summary>
      <param name="mask">The mask.</param>
    </member>
    <member name="M:PloobsEngine.Input.TurnOffInputMaskCommand.execute">
      <summary>
            Executes the command Call.
            </summary>
    </member>
    <member name="M:PloobsEngine.Input.TurnOffInputMaskCommand.setTarget(System.Object)">
      <summary>
            Sets the command target.
            </summary>
      <param name="obj">The obj.</param>
    </member>
    <member name="P:PloobsEngine.Input.TurnOffInputMaskCommand.TargetName">
      <summary>
            Gets the name of the command target.
            </summary>
      <value>
            The name of the target.
            </value>
    </member>
    <member name="T:PloobsEngine.SceneControl.RestoreDepth">
      <summary>
            Helper To Restore Depth in deferred Pass
            In XNA its needed cause when we change Render Targets, the depth buffer is erased
            </summary>
    </member>
    <member name="M:PloobsEngine.SceneControl.RestoreDepth.#ctor(System.Boolean,PloobsEngine.SceneControl.IContentManager,PloobsEngine.Engine.GraphicFactory,PloobsEngine.Engine.GraphicInfo)">
      <summary>
            Initializes a new instance of the <see cref="T:PloobsEngine.SceneControl.RestoreDepth" /> class.
            </summary>
      <param name="useFloatBuffer">if set to <c>true</c> [use float buffer].</param>
      <param name="manager">The manager.</param>
      <param name="factory">The factory.</param>
      <param name="ginfo">The ginfo.</param>
    </member>
    <member name="M:PloobsEngine.SceneControl.RestoreDepth.PerformForwardPass(Microsoft.Xna.Framework.Graphics.Texture2D,Microsoft.Xna.Framework.Graphics.Texture2D,PloobsEngine.SceneControl.RenderHelper,PloobsEngine.Engine.GraphicInfo)">
      <summary>
            Performs the forward pass.
            </summary>
      <param name="combined">The combined.</param>
      <param name="depth">The depth.</param>
      <param name="render">The render.</param>
    </member>
    <member name="M:PloobsEngine.SceneControl.RestoreDepth.EndForwardPass(PloobsEngine.SceneControl.RenderHelper)">
      <summary>
            Ends the forward pass.
            Clean Up
            </summary>
      <returns>
      </returns>
    </member>
    <member name="T:PloobsEngine.SceneControl.RestoreDepthOption">
      <summary>
            When to restore the depth Buffer
            REMEMBER, the forward pass is performed when the Depth Buffer is restored
            </summary>
    </member>
    <member name="F:PloobsEngine.SceneControl.RestoreDepthOption.NONE">
      <summary>
            Dont restore
            </summary>
    </member>
    <member name="F:PloobsEngine.SceneControl.RestoreDepthOption.BEFORE_POSTEFFECT">
      <summary>
            Before applying the post effects
            The Forward will be affected by the Post Effects
            </summary>
    </member>
    <member name="F:PloobsEngine.SceneControl.RestoreDepthOption.AFTER_POSTEFFECT">
      <summary>
            After the Post effects
            The Forward pass wont be affected by the Post Effects
            </summary>
    </member>
    <member name="T:PloobsEngine.SceneControl.DeferredRenderTechnicInitDescription">
      <summary>
            Deferred Render Technic Init Description
            </summary>
    </member>
    <member name="M:PloobsEngine.SceneControl.DeferredRenderTechnicInitDescription.Default">
      <summary>
            Defaults this instance.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:PloobsEngine.SceneControl.DeferredRenderTechnicInitDescription.#ctor(PloobsEngine.SceneControl.IDeferredGBuffer,PloobsEngine.SceneControl.IDeferredLightMap,PloobsEngine.SceneControl.IDeferredFinalCombination,PloobsEngine.SceneControl.ForwardPass,Microsoft.Xna.Framework.Color,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.String[],PloobsEngine.SceneControl.RestoreDepthOption)">
      <summary>
            Initializes a new instance of the <see cref="T:PloobsEngine.SceneControl.DeferredRenderTechnicInitDescription" /> struct.
            </summary>
      <param name="DeferredGBuffer">The deferred G buffer.</param>
      <param name="DeferredLightMap">The deferred light map.</param>
      <param name="DeferredFinalCombination">The deferred final combination.</param>
      <param name="ForwardPass">The forward pass.</param>
      <param name="BackGroundColor">Color of the back ground.</param>
      <param name="PhysicDebug">if set to <c>true</c> [physic debug].</param>
      <param name="LightDebug">if set to <c>true</c> [light debug].</param>
      <param name="DefferedDebug">if set to <c>true</c> [deffered debug].</param>
      <param name="UseFloatingBufferForLightMap">if set to <c>true</c> [use floating buffer for light map].</param>
      <param name="CullPointLight">if set to <c>true</c> [cull point light].</param>
      <param name="ExtraForwardPass">if set to <c>true</c> [extra forward pass].</param>
      <param name="RenderTargetsNameToDefferedDebug">The render targets name to deffered debug.</param>
      <param name="RestoreDepthOption">The restore depth option.</param>
    </member>
    <member name="T:PloobsEngine.SceneControl.DeferredRenderTechnic">
      <summary>
            Implementation of the Deferred Render Technic
            </summary>
    </member>
    <member name="F:PloobsEngine.SceneControl.DeferredRenderTechnic.PostEffectTarget">
            for ping pong with target       
        </member>
    <member name="M:PloobsEngine.SceneControl.DeferredRenderTechnic.ExecuteTechnic(Microsoft.Xna.Framework.GameTime,PloobsEngine.SceneControl.RenderHelper,PloobsEngine.SceneControl.IWorld)">
      <summary>
            Executes the technic.
            </summary>
      <param name="gameTime">
      </param>
      <param name="render">The render.</param>
      <param name="world">The world.</param>
    </member>
    <member name="M:PloobsEngine.SceneControl.DeferredRenderTechnic.Draw(Microsoft.Xna.Framework.GameTime,PloobsEngine.SceneControl.IWorld,PloobsEngine.SceneControl.RenderHelper)">
      <summary>
            Draws the specified game time.
            </summary>
      <param name="gameTime">The game time.</param>
      <param name="world">The world.</param>
      <param name="render">The render.</param>
    </member>
    <member name="P:PloobsEngine.SceneControl.DeferredRenderTechnic.TechnicName">
      <summary>
            Gets the name of the technic.
            </summary>
      <value>
            The name of the technic.
            </value>
    </member>
    <member name="M:PloobsEngine.SceneControl._2DScene.IObject2DAtachtment.Update(PloobsEngine.SceneControl._2DScene.I2DObject,Microsoft.Xna.Framework.GameTime)">
      <summary>
            Updates the atachment.
            </summary>
      <param name="obj">The obj.</param>
      <param name="gt">The gt.</param>
    </member>
    <member name="M:PloobsEngine.SceneControl._2DScene.I2DWorld.#ctor(PloobsEngine.Physics2D.I2DPhysicWorld,PloobsEngine.Particles.IParticleManager)">
      <summary>
            Initializes a new instance of the <see cref="T:PloobsEngine.SceneControl.IWorld" /> class.
            </summary>
      <param name="PhysicWorld">The physic world.</param>
      <param name="particleManager">The particle manager.</param>
    </member>
    <member name="M:PloobsEngine.SceneControl._2DScene.I2DWorld.AddObject(PloobsEngine.SceneControl._2DScene.I2DObject)">
      <summary>
            Adds an object to the world.
            </summary>
      <param name="obj">The obj.</param>
      <returns>
      </returns>
    </member>
    <member name="M:PloobsEngine.SceneControl._2DScene.I2DWorld.ContainsObject(PloobsEngine.SceneControl._2DScene.I2DObject)">
      <summary>
            Contains the specified obj.
            </summary>
      <param name="obj">The obj.</param>
      <returns>
      </returns>
    </member>
    <member name="M:PloobsEngine.SceneControl._2DScene.I2DWorld.RemoveObject(PloobsEngine.SceneControl._2DScene.I2DObject)">
      <summary>
            Removes an object from the world.
            </summary>
      <param name="obj">The obj.</param>
    </member>
    <member name="M:PloobsEngine.SceneControl._2DScene.I2DWorld.UpdateWorld(Microsoft.Xna.Framework.GameTime)">
      <summary>
            Updates the world.
            </summary>
      <param name="gt">The gt.</param>
    </member>
    <member name="M:PloobsEngine.SceneControl._2DScene.I2DWorld.AddDummy(PloobsEngine.SceneControl.IDummy)">
      <summary>
            Add a Dummy to the world
            Its like a position, 
            usefull to serializable position from a world editor
            </summary>
      <param name="dummy">The dummy.</param>
    </member>
    <member name="M:PloobsEngine.SceneControl._2DScene.I2DWorld.RemoveDummy(PloobsEngine.SceneControl.IDummy)">
      <summary>
            Removes the dummy.
            </summary>
      <param name="dummy">The dummy.</param>
    </member>
    <member name="P:PloobsEngine.SceneControl._2DScene.I2DWorld.GraphicsInfo">
      <summary>
            Gets or sets the graphics info.
            </summary>
      <value>
            The graphics info.
            </value>
    </member>
    <member name="P:PloobsEngine.SceneControl._2DScene.I2DWorld.GraphicsFactory">
      <summary>
            Gets or sets the graphics factory.
            </summary>
      <value>
            The graphics factory.
            </value>
    </member>
    <member name="P:PloobsEngine.SceneControl._2DScene.I2DWorld.PhysicWorld">
      <summary>
            Gets or sets the physic world.
            </summary>
      <value>
            The physic world.
            </value>
    </member>
    <member name="P:PloobsEngine.SceneControl._2DScene.I2DWorld.Dummies">
      <summary>
            Gets all the dummyes.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="P:PloobsEngine.SceneControl._2DScene.I2DWorld.Objects">
      <summary>
            Gets the objects.
            </summary>
    </member>
    <member name="T:PloobsEngine.Material.DeferredSphericalBilboardShader">
      <summary>
            Spherical Bilboard
            </summary>
    </member>
    <member name="P:PloobsEngine.Material.DeferredSphericalBilboardShader.Scale">
      <summary>
            Default Vector2(100, 100);
            </summary>
    </member>
    <member name="P:PloobsEngine.Material.DeferredSphericalBilboardShader.Atenuation">
      <summary>
            Default Vector4.One
            </summary>
    </member>
    <member name="T:PloobsEngine.Material.DeferredTreeShader">
      <summary>
            Tree Shader, used by the Tree Material, interacts with the LTree
            </summary>
    </member>
    <member name="P:PloobsEngine.Material.DeferredTreeShader.MaterialType">
      <summary>
            Gets the type of the material.
            </summary>
      <value>
            The type of the material.
            </value>
    </member>
    <member name="M:PloobsEngine.Light2D.ShadowmapResolver.#ctor(PloobsEngine.Engine.GraphicFactory,PloobsEngine.SceneControl.QuadRender,PloobsEngine.Light2D.ShadowmapSize,PloobsEngine.Light2D.ShadowmapSize)">
      <summary>
            Creates a new shadowmap resolver
            </summary>
      <param name="factory">The factory.</param>
      <param name="quadRender">The quad render.</param>
      <param name="maxShadowmapSize">Size of the max shadowmap.</param>
      <param name="maxDepthBufferSize">Size of the max depth buffer.</param>
    </member>
    <member name="T:BEPUphysics.DeactivationManagement.ISimulationIslandConnection">
      <summary>
             Defines an object which connects simulation islands together.
            </summary>
    </member>
    <member name="M:BEPUphysics.DeactivationManagement.ISimulationIslandConnection.AddReferencesToConnectedMembers">
      <summary>
             Adds references to the connection to all connected members.
            </summary>
    </member>
    <member name="M:BEPUphysics.DeactivationManagement.ISimulationIslandConnection.RemoveReferencesFromConnectedMembers">
      <summary>
             Removes references to the connection from all connected members.
            </summary>
    </member>
    <member name="P:BEPUphysics.DeactivationManagement.ISimulationIslandConnection.DeactivationManager">
      <summary>
             Gets and sets the deactivation member tha owns this connection.
            </summary>
    </member>
    <member name="P:BEPUphysics.DeactivationManagement.ISimulationIslandConnection.ConnectedMembers">
      <summary>
             Gets the simulation island members associated with this connection.
            </summary>
    </member>
    <member name="T:BEPUphysics.ISpaceObject">
      <summary>
             Defines an object which can be managed by an ISpace.
            </summary>
    </member>
    <member name="M:BEPUphysics.ISpaceObject.OnAdditionToSpace(BEPUphysics.ISpace)">
      <summary>
            Called after the object is added to a space.
            </summary>
      <param name="newSpace">
      </param>
    </member>
    <member name="M:BEPUphysics.ISpaceObject.OnRemovalFromSpace(BEPUphysics.ISpace)">
      <summary>
            Called before an object is removed from its space.
            </summary>
    </member>
    <member name="P:BEPUphysics.ISpaceObject.Space">
      <summary>
            Gets the Space to which the object belongs.
            </summary>
    </member>
    <member name="P:BEPUphysics.ISpaceObject.Tag">
      <summary>
            Gets or sets the user data associated with this object.
            </summary>
    </member>
    <member name="T:BEPUphysics.SolverSystems.SolverUpdateable">
      <summary>
             Superclass of all objects that live in the solver.
            </summary>
    </member>
    <member name="M:BEPUphysics.SolverSystems.SolverUpdateable.Update(System.Single)">
      <summary>
             Performs the frame's configuration step.
            </summary>
      <param name="dt">Timestep duration.</param>
    </member>
    <member name="M:BEPUphysics.SolverSystems.SolverUpdateable.ExclusiveUpdate">
      <summary>
            Performs any pre-solve iteration work that needs exclusive
            access to the members of the solver updateable.
            Usually, this is used for applying warmstarting impulses.
            </summary>
    </member>
    <member name="M:BEPUphysics.SolverSystems.SolverUpdateable.SolveIteration">
      <summary>
            Computes one iteration of the constraint to meet the solver updateable's goal.
            </summary>
      <returns>The rough applied impulse magnitude.</returns>
    </member>
    <member name="M:BEPUphysics.SolverSystems.SolverUpdateable.TryEnterLock">
      <summary>
            Attempts to acquire a lock on the solver updateable.
            This allows operations that need exclusive access to the solver updateable's members.
            If it is contested, it aborts the attempt.
            </summary>
      <returns>Whether or not the lock could be acquired.</returns>
    </member>
    <member name="M:BEPUphysics.SolverSystems.SolverUpdateable.EnterLock">
      <summary>
            Acquires a lock on the solver updateable.
            This allows operations that need exclusive access to the solver updateable's members.
            </summary>
    </member>
    <member name="M:BEPUphysics.SolverSystems.SolverUpdateable.ExitLock">
      <summary>
            Releases the lock on the solver updateable.
            </summary>
    </member>
    <member name="M:BEPUphysics.SolverSystems.SolverUpdateable.UpdateSolverActivity">
      <summary>
            Updates the activity state of the solver updateable based on its members.
            </summary>
    </member>
    <member name="M:BEPUphysics.SolverSystems.SolverUpdateable.OnAdditionToSpace(BEPUphysics.ISpace)">
      <summary>
            Called after the object is added to a space.
            </summary>
      <param name="newSpace">
      </param>
    </member>
    <member name="M:BEPUphysics.SolverSystems.SolverUpdateable.OnRemovalFromSpace(BEPUphysics.ISpace)">
      <summary>
            Called before an object is removed from its space.
            </summary>
    </member>
    <member name="M:BEPUphysics.SolverSystems.SolverUpdateable.OnAdditionToSolver(BEPUphysics.SolverSystems.Solver)">
      <summary>
             Called when the updateable is added to a solver.
            </summary>
      <param name="newSolver">Solver to which the updateable was added.</param>
    </member>
    <member name="M:BEPUphysics.SolverSystems.SolverUpdateable.OnRemovalFromSolver(BEPUphysics.SolverSystems.Solver)">
      <summary>
            Called when the updateable is removed from its solver.
            </summary>
      <param name="oldSolver">Solver from which the updateable was removed.</param>
    </member>
    <member name="P:BEPUphysics.SolverSystems.SolverUpdateable.Solver">
      <summary>
             Gets the solver to which the solver updateable belongs.
            </summary>
    </member>
    <member name="P:BEPUphysics.SolverSystems.SolverUpdateable.SolverSettings">
      <summary>
             Gets the solver settings that manage how the solver updates.
            </summary>
    </member>
    <member name="P:BEPUphysics.SolverSystems.SolverUpdateable.IsActive">
      <summary>
            Gets or sets whether or not this solver updateable is active.
            
            When set to false, this solver updateable will be idle and its 
            isActiveInSolver field will always be false.
            
            When set to true, the solver updateable will run normally and update if
            the type's activity conditions allow it.
            </summary>
    </member>
    <member name="P:BEPUphysics.SolverSystems.SolverUpdateable.IsActiveInSolver">
      <summary>
            Gets whether or not the space's solver should try to solve this object.
            Depends on conditions specific to each solver updateable type and whether or not
            it has completed its computations early.  Recomputed each frame.
            </summary>
    </member>
    <member name="P:BEPUphysics.SolverSystems.SolverUpdateable.Tag">
      <summary>
            Gets or sets the user data associated with this object.
            </summary>
    </member>
    <member name="T:BEPUphysics.Constraints.EntitySolverUpdateable">
      <summary>
            Superclass of objects types which require solving by the velocity solver.
            These are updated within the internal iterative solver when owned by a space.
            </summary>
    </member>
    <member name="F:BEPUphysics.Constraints.EntitySolverUpdateable.involvedEntities">
      <summary>
            List of all entities affected by this updateable.
            </summary>
    </member>
    <member name="F:BEPUphysics.Constraints.EntitySolverUpdateable.numberOfInvolvedEntities">
      <summary>
            Number of entities used in the solver updateable.
            Note that this is set automatically by the sortInvolvedEntities method
            if it is called.
            </summary>
    </member>
    <member name="M:BEPUphysics.Constraints.EntitySolverUpdateable.EnterLock">
      <summary>
            Acquires exclusive access to all entities involved in the solver updateable.
            </summary>
    </member>
    <member name="M:BEPUphysics.Constraints.EntitySolverUpdateable.ExitLock">
      <summary>
            Releases exclusive access to the updateable's entities.
            This should be called within a 'finally' block following a 'try' block containing the locked operations.
            </summary>
    </member>
    <member name="M:BEPUphysics.Constraints.EntitySolverUpdateable.TryEnterLock">
      <summary>
            Attempts to acquire exclusive access to all entities involved in the solver updateable.
            </summary>
      <returns>Whether or not the lock was entered successfully.</returns>
    </member>
    <member name="M:BEPUphysics.Constraints.EntitySolverUpdateable.CollectInvolvedEntities(BEPUphysics.DataStructures.RawList{BEPUphysics.Entities.Entity})">
      <summary>
            Adds entities associated with the solver item to the involved entities list.
            This allows the non-batched multithreading system to lock properly.
            </summary>
    </member>
    <member name="M:BEPUphysics.Constraints.EntitySolverUpdateable.OnInvolvedEntitiesChanged">
      <summary>
            Handle any bookkeeping needed when the entities involved in this SolverUpdateable change.
            </summary>
    </member>
    <member name="M:BEPUphysics.Constraints.EntitySolverUpdateable.CollectInvolvedEntities">
      <summary>
            Collects the entities involved in a solver updateable and sets up the internal listings.
            </summary>
    </member>
    <member name="M:BEPUphysics.Constraints.EntitySolverUpdateable.SortInvolvedEntities">
      <summary>
            Sorts the involved entities according to their hashcode to allow non-batched multithreading to avoid deadlocks.
            </summary>
    </member>
    <member name="M:BEPUphysics.Constraints.EntitySolverUpdateable.UpdateSolverActivity">
      <summary>
            Sets the activity state of the constraint based on the activity state of its connections.
            Called automatically by the space owning a constaint.  If a constraint is a sub-constraint that hasn't been directly added to the space,
            this may need to be called alongside the preStep from within the parent constraint.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.EntitySolverUpdateable.InvolvedEntities">
      <summary>
             Gets the entities that this solver updateable is involved with.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.EntitySolverUpdateable.SolverGroup">
      <summary>
            Gets the solver group that manages this solver updateable, if any.
            Null if not owned by a solver group.
            </summary>
    </member>
    <member name="T:BEPUphysics.UpdateableSystems.ISpaceUpdateable">
      <summary>
             Defines an object which is updated by the space.
             These refer to the special Updateable types which
             allow for easier integration into the update flow of the space.
            </summary>
    </member>
    <member name="P:BEPUphysics.UpdateableSystems.ISpaceUpdateable.IsUpdatedSequentially">
      <summary>
            Gets and sets whether or not the updateable should be updated sequentially even in a multithreaded space.
            If this is true, the updateable can make use of the space's ThreadManager for internal multithreading.
            </summary>
    </member>
    <member name="P:BEPUphysics.UpdateableSystems.ISpaceUpdateable.IsUpdating">
      <summary>
            Gets and sets whether or not the updateable should be updated by the space.
            </summary>
    </member>
    <member name="P:BEPUphysics.UpdateableSystems.ISpaceUpdateable.Managers">
      <summary>
             List of managers owning the updateable.
            </summary>
    </member>
    <member name="T:BEPUphysics.UpdateableSystems.CombinedUpdateable">
      <summary>
             A class which is both a space updateable and a Solver Updateable.
            </summary>
    </member>
    <member name="P:BEPUphysics.UpdateableSystems.CombinedUpdateable.IsUpdatedSequentially">
      <summary>
            Gets and sets whether or not the updateable should be updated sequentially even in a multithreaded space.
            If this is true, the updateable can make use of the space's ThreadManager for internal multithreading.
            </summary>
    </member>
    <member name="P:BEPUphysics.UpdateableSystems.CombinedUpdateable.IsUpdating">
      <summary>
            Gets and sets whether or not the updateable should be updated by the space.
            </summary>
    </member>
    <member name="P:BEPUphysics.UpdateableSystems.CombinedUpdateable.Tag">
      <summary>
            Gets or sets the user data associated with this object.
            </summary>
    </member>
    <member name="T:BEPUphysics.DeactivationManagement.SimulationIsland">
      <summary>
             A collection of simulation island members bound together with connections.
             An island is activated and deactivated as a group.
            </summary>
    </member>
    <member name="M:BEPUphysics.DeactivationManagement.SimulationIsland.#ctor">
      <summary>
             Constructs a simulation island.
            </summary>
    </member>
    <member name="M:BEPUphysics.DeactivationManagement.SimulationIsland.Activate">
      <summary>
             Activates the simulation island.
            </summary>
    </member>
    <member name="M:BEPUphysics.DeactivationManagement.SimulationIsland.TryToDeactivate">
      <summary>
             Attempts to deactivate the simulation island.
            </summary>
      <returns>Whether or not the simulation island was successfully deactivated.</returns>
    </member>
    <member name="M:BEPUphysics.DeactivationManagement.SimulationIsland.Add(BEPUphysics.DeactivationManagement.ISimulationIslandMember)">
      <summary>
             Adds a member to the simulation island.
            </summary>
      <param name="member">Member to add.</param>
      <exception cref="T:System.Exception">Thrown when the member being added is either non-dynamic or already has a simulation island.</exception>
    </member>
    <member name="M:BEPUphysics.DeactivationManagement.SimulationIsland.Remove(BEPUphysics.DeactivationManagement.ISimulationIslandMember)">
      <summary>
             Removes a member from the simulation island.
            </summary>
      <param name="member">Member to remove.</param>
      <exception cref="T:System.Exception">Thrown when the member does not belong to this simulation island.</exception>
    </member>
    <member name="P:BEPUphysics.DeactivationManagement.SimulationIsland.IsActive">
      <summary>
             Gets whether or not the island is currently active.
            </summary>
    </member>
    <member name="P:BEPUphysics.DeactivationManagement.SimulationIsland.Members">
      <summary>
             Gets the list of members in the island.
            </summary>
    </member>
    <member name="T:BEPUphysics.NarrowPhaseSystems.TypePair">
      <summary>
             Pair of types.
            </summary>
    </member>
    <member name="F:BEPUphysics.NarrowPhaseSystems.TypePair.A">
      <summary>
             First type in the pair.
            </summary>
    </member>
    <member name="F:BEPUphysics.NarrowPhaseSystems.TypePair.B">
      <summary>
             Second type in the pair.
            </summary>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.TypePair.#ctor(System.Type,System.Type)">
      <summary>
             Constructs a new type pair.
            </summary>
      <param name="a">First type in the pair.</param>
      <param name="b">Second type in the pair.</param>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.TypePair.GetHashCode">
      <summary>
            Returns the hash code for this instance.
            </summary>
      <returns>
            A 32-bit signed integer that is the hash code for this instance.
            </returns>
      <filterpriority>2</filterpriority>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.TypePair.Equals(BEPUphysics.NarrowPhaseSystems.TypePair)">
      <summary>
            Indicates whether the current object is equal to another object of the same type.
            </summary>
      <returns>
            true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false.
            </returns>
      <param name="other">An object to compare with this object.</param>
    </member>
    <member name="T:BEPUphysics.MultithreadedProcessingStage">
      <summary>
             Superclass of processing systems which can use multiple threads.
            </summary>
    </member>
    <member name="M:BEPUphysics.MultithreadedProcessingStage.Update">
      <summary>
             Runs the processing stage.
            </summary>
    </member>
    <member name="P:BEPUphysics.MultithreadedProcessingStage.Enabled">
      <summary>
             Gets or sets whether or not the processing stage is active.
            </summary>
    </member>
    <member name="P:BEPUphysics.MultithreadedProcessingStage.AllowMultithreading">
      <summary>
             Gets or sets whether or not the processing stage should allow multithreading.
            </summary>
    </member>
    <member name="P:BEPUphysics.MultithreadedProcessingStage.ThreadManager">
      <summary>
             Gets or sets the thread manager used by the stage.
            </summary>
    </member>
    <member name="E:BEPUphysics.MultithreadedProcessingStage.Starting">
      <summary>
             Fires when the processing stage begins working.
            </summary>
    </member>
    <member name="E:BEPUphysics.MultithreadedProcessingStage.Finishing">
      <summary>
            Fires when the processing stage finishes working.
            </summary>
    </member>
    <member name="T:BEPUphysics.NarrowPhaseSystems.NarrowPhase">
      <summary>
             Manages and constructs pair handlers from broad phase overlaps.
            </summary>
    </member>
    <member name="F:BEPUphysics.NarrowPhaseSystems.NarrowPhase.MultithreadedRemovalCutoff">
      <summary>
             The required number of pairs in the narrow phase to use multithreading.
            </summary>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.NarrowPhase.#ctor(BEPUphysics.TimeStepSettings)">
      <summary>
             Constructs a new narrow phase.
            </summary>
      <param name="timeStepSettings">Time step settings used by the narrow phase.</param>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.NarrowPhase.#ctor(BEPUphysics.TimeStepSettings,BEPUphysics.DataStructures.RawList{BEPUphysics.BroadPhaseSystems.BroadPhaseOverlap})">
      <summary>
             Constructs a new narrow phase.
            </summary>
      <param name="timeStepSettings">Time step settings used by the narrow phase.</param>
      <param name="overlaps">Overlaps list used by the narrow phase to create pairs.</param>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.NarrowPhase.#ctor(BEPUphysics.TimeStepSettings,BEPUphysics.DataStructures.RawList{BEPUphysics.BroadPhaseSystems.BroadPhaseOverlap},BEPUphysics.Threading.IThreadManager)">
      <summary>
             Constructs a new narrow phase.
            </summary>
      <param name="timeStepSettings">Time step settings used by the narrow phase.</param>
      <param name="overlaps">Overlaps list used by the narrow phase to create pairs.</param>
      <param name="threadManager">Thread manager used by the narrow phase.</param>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.NarrowPhase.GetPair(BEPUphysics.BroadPhaseSystems.BroadPhaseEntry,BEPUphysics.BroadPhaseSystems.BroadPhaseEntry)">
      <summary>
             Gets the pair between two broad phase entries, if any.
            </summary>
      <param name="entryA">First entry in the pair.</param>
      <param name="entryB">Second entry in the pair.</param>
      <returns>The pair if it exists, null otherwise.</returns>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.NarrowPhase.EnqueueGeneratedSolverUpdateable(BEPUphysics.Constraints.EntitySolverUpdateable)">
      <summary>
             Enqueues a solver updateable created by some pair for flushing into the solver later.
            </summary>
      <param name="addedItem">Solver updateable to add.</param>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.NarrowPhase.EnqueueRemovedSolverUpdateable(BEPUphysics.Constraints.EntitySolverUpdateable)">
      <summary>
             Enqueues a solver updateable removed by some pair for flushing into the solver later.
            </summary>
      <param name="removedItem">Solver updateable to add.</param>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.NarrowPhase.FlushGeneratedSolverUpdateables(BEPUphysics.SolverSystems.Solver)">
      <summary>
            Flushes the solver updateable changes.
            </summary>
      <param name="solver">Solver to flush the changes into.</param>
    </member>
    <member name="P:BEPUphysics.NarrowPhaseSystems.NarrowPhase.BroadPhaseOverlaps">
      <summary>
             Gets or sets the list of broad phase overlaps used by the narrow phase to manage pairs.
            </summary>
    </member>
    <member name="P:BEPUphysics.NarrowPhaseSystems.NarrowPhase.Pairs">
      <summary>
             Gets the list of Pairs managed by the narrow phase.
            </summary>
    </member>
    <member name="P:BEPUphysics.NarrowPhaseSystems.NarrowPhase.TimeStepSettings">
      <summary>
             Gets or sets the time step settings used by the narrow phase.
            </summary>
    </member>
    <member name="E:BEPUphysics.NarrowPhaseSystems.NarrowPhase.CreatingPair">
      <summary>
             Fires when the narrow phase creates a pair.
            </summary>
    </member>
    <member name="E:BEPUphysics.NarrowPhaseSystems.NarrowPhase.RemovingPair">
      <summary>
             Fires when the narrow phase removes a pair.
            </summary>
    </member>
    <member name="T:BEPUphysics.Collidables.Events.PairCreatedEventHandler`1">
      <summary>
            Handles any special logic when two objects' bounding boxes overlap as determined by the broadphase system.
            </summary>
      <param name="sender">Entry sending the event.</param>
      <param name="other">Other entry within the pair opposing the monitored entry.</param>
      <param name="pair">Pair presiding over the interaction of the two involved bodies.
            This reference cannot be safely kept outside of the scope of the handler; pairs can quickly return to the resource pool.</param>
    </member>
    <member name="T:BEPUphysics.Collidables.Events.CreatingPairEventHandler`1">
      <summary>
            Handles any special logic when two objects' bounding boxes overlap as determined by the broadphase system.
            Unlike PairCreatedEventHandler, this will be called as soon as a pair is created instead of at the end of the frame.
            This allows the pair's data to be adjusted prior to any usage, but some actions are not supported due to the execution stage.
            </summary>
      <param name="sender">Entry sending the event.</param>
      <param name="other">Other entry within the pair opposing the monitored entry.</param>
      <param name="pair">Pair presiding over the interaction of the two involved bodies.
            This reference cannot be safely kept outside of the scope of the handler; pairs can quickly return to the resource pool.</param>
    </member>
    <member name="T:BEPUphysics.Collidables.Events.PairRemovedEventHandler`1">
      <summary>
            Handles any special logic when two objects' bounding boxes cease to overlap as determined by the broadphase system.
            </summary>
      <param name="sender">Entry sending the event.</param>
      <param name="other">The entry formerly interacting with the sender via the deleted pair.</param>
    </member>
    <member name="T:BEPUphysics.Collidables.Events.RemovingPairEventHandler`1">
      <summary>
            Handles any special logic when two objects' bounding boxes cease to overlap as determined by the broadphase system.
            Unlike PairRemovedEventHandler, this will trigger at the time of pair removal instead of at the end of the space's update.
            </summary>
      <param name="sender">Entry sending the event.</param>
      <param name="other">The entry formerly interacting with the sender via the deleted pair.</param>
    </member>
    <member name="T:BEPUphysics.Collidables.Events.ContactCreatedEventHandler`1">
      <summary>
            Handles any special logic when two bodies are touching and generate a contact point.
            </summary>
      <param name="sender">Entry sending the event.</param>
      <param name="other">Other entry within the pair opposing the monitored entry.</param>
      <param name="pair">Pair presiding over the interaction of the two involved bodies.
            This reference cannot be safely kept outside of the scope of the handler; pairs can quickly return to the resource pool.</param>
      <param name="contact">Created contact data.</param>
    </member>
    <member name="T:BEPUphysics.Collidables.Events.CreatingContactEventHandler`1">
      <summary>
            Handles any special logic when two bodies are touching and generate a contact point.
            Unlike ContactCreatedEventHandler, this will trigger at the time of contact generation instead of at the end of the space's update.
            This allows the contact's data to be adjusted prior to usage in the velocity solver, 
            but other actions such as altering the owning space's pair or entry listings are unsafe.
            </summary>
      <param name="sender">Entry sending the event.</param>
      <param name="other">Other entry within the pair opposing the monitored entry.</param>
      <param name="pair">Pair presiding over the interaction of the two involved bodies.
            This reference cannot be safely kept outside of the scope of the handler; pairs can quickly return to the resource pool.</param>
      <param name="contact">Newly generated contact point between the pair's two bodies.
            This reference cannot be safely kept outside of the scope of the handler; contacts can quickly return to the resource pool.</param>
    </member>
    <member name="T:BEPUphysics.Collidables.Events.InitialCollisionDetectedEventHandler`1">
      <summary>
            Handles any special logic when two bodies initally collide and generate a contact point.
            </summary>
      <param name="sender">Entry sending the event.</param>
      <param name="other">Other entry within the pair opposing the monitored entry.</param>
      <param name="pair">Pair presiding over the interaction of the two involved bodies.
            This reference cannot be safely kept outside of the scope of the handler; pairs can quickly return to the resource pool.</param>
    </member>
    <member name="T:BEPUphysics.Collidables.Events.DetectingInitialCollisionEventHandler`1">
      <summary>
            Handles any special logic when two bodies initally collide and generate a contact point.
            Unlike InitialCollisionDetectedEventHandler, this will trigger at the time of contact creation instead of at the end of the space's update.
            Performing operations outside of the scope of the pair is unsafe.
            </summary>
      <param name="sender">Entry sending the event.</param>
      <param name="other">Other entry within the pair opposing the monitored entry.</param>
      <param name="pair">Pair presiding over the interaction of the two involved bodies.
            This reference cannot be safely kept outside of the scope of the handler; pairs can quickly return to the resource pool.</param>
    </member>
    <member name="T:BEPUphysics.Collidables.Events.ContactRemovedEventHandler`1">
      <summary>
            Handles any special logic when a contact point between two bodies is removed.
            </summary>
      <param name="sender">Entry sending the event.</param>
      <param name="other">Other entry within the pair opposing the monitored entry.</param>
      <param name="pair">Pair presiding over the interaction of the two involved bodies and data about the removed contact.
            This reference cannot be safely kept outside of the scope of the handler; pairs can quickly return to the resource pool.</param>
      <param name="contact">Removed contact data.</param>
    </member>
    <member name="T:BEPUphysics.Collidables.Events.RemovingContactEventHandler`1">
      <summary>
            Handles any special logic when a contact point between two bodies is removed.
            Unlike ContactRemovedEventHandler, this will trigger at the time of contact removal instead of at the end of the space's update.
            Performing operations outside of the scope of the controller is unsafe.
            </summary>
      <param name="sender">Entry sending the event.</param>
      <param name="other">Other entry within the pair opposing the monitored entry.</param>
      <param name="pair">Pair presiding over the interaction of the two involved bodies and data about the removed contact.
            This reference cannot be safely kept outside of the scope of the handler; pairs can quickly return to the resource pool.</param>
      <param name="contact">Contact between the two entries.  This reference cannot be safely kept outside of the scope of the handler;
            it will be immediately returned to the resource pool after the event handler completes.</param>
    </member>
    <member name="T:BEPUphysics.Collidables.Events.CollisionEndedEventHandler`1">
      <summary>
            Handles any special logic when two bodies go from a touching state to a separated state.
            </summary>
      <param name="sender">Entry sending the event.</param>
      <param name="other">Other entry within the pair opposing the monitored entry.</param>
      <param name="pair">Pair overseeing the collision.  Note that this instance may be invalid if the entries' bounding boxes no longer overlap.</param>
    </member>
    <member name="T:BEPUphysics.Collidables.Events.CollisionEndingEventHandler`1">
      <summary>
            Handles any special logic when two bodies go from a touching state to a separated state.
            Unlike CollisionEndedEventHandler, this will trigger at the time of contact removal instead of at the end of the space's update.
            Performing operations outside of the scope of the controller is unsafe.
            </summary>
      <param name="sender">Entry sending the event.</param>
      <param name="other">Other entry within the pair opposing the monitored entry.</param>
      <param name="pair">Pair presiding over the interaction of the two involved bodies.
            This reference cannot be safely kept outside of the scope of the handler; pairs can quickly return to the resource pool.</param>
    </member>
    <member name="T:BEPUphysics.Collidables.Events.PairUpdatedEventHandler`1">
      <summary>
            Handles any special logic to perform at the end of a pair's UpdateContactManifold method.
            This is called every single update regardless if the process was quit early or did not complete due to interaction rules.
            </summary>
      <param name="sender">Entry involved in the pair monitored for events.</param>
      <param name="other">Other entry within the pair opposing the monitored entry.</param>
      <param name="pair">Pair that was updated.</param>
    </member>
    <member name="T:BEPUphysics.Collidables.Events.PairUpdatingEventHandler`1">
      <summary>
            Handles any special logic to perform at the end of a pair's UpdateContactManifold method.
            This is called every single update regardless if the process was quit early or did not complete due to interaction rules.
            Unlike PairUpdatedEventHandler, this is called at the time of the collision detection update rather than at the end of the space's update.
            Other entries' information may not be up to date, and operations acting on data outside of the character controller may be unsafe.
            </summary>
      <param name="sender">Entry involved in the pair monitored for events.</param>
      <param name="other">Other entry within the pair opposing the monitored entry.</param>
      <param name="pair">Pair that was updated.</param>
    </member>
    <member name="T:BEPUphysics.Collidables.Events.PairTouchedEventHandler`1">
      <summary>
            Handles any special logic to perform at the end of a pair's UpdateContactManifold method if the two objects are colliding.
            This is called every single update regardless if the process was quit early or did not complete due to interaction rules.
            </summary>
      <param name="sender">Entry involved in the pair monitored for events.</param>
      <param name="other">Other entry within the pair opposing the monitored entry.</param>
      <param name="pair">Pair that was updated.</param>
    </member>
    <member name="T:BEPUphysics.Collidables.Events.PairTouchingEventHandler`1">
      <summary>
            Handles any special logic to perform at the end of a pair's UpdateContactManifold method if the two objects are colliding.
            This is called every single update regardless if the process was quit early or did not complete due to interaction rules.
            Unlike PairTouchedEventHandler, this is called at the time of the collision detection update rather than at the end of the space's update.
            Other entries' information may not be up to date, and operations acting on data outside of the character controller may be unsafe.
            </summary>
      <param name="sender">Entry involved in the pair monitored for events.</param>
      <param name="other">Other entry within the pair opposing the monitored entry.</param>
      <param name="pair">Pair that was updated.</param>
    </member>
    <member name="T:BEPUphysics.Materials.InteractionProperties">
      <summary>
             Contains the blended friction and bounciness of a pair of objects.
            </summary>
    </member>
    <member name="F:BEPUphysics.Materials.InteractionProperties.KineticFriction">
      <summary>
             Kinetic friction between the pair of objects.
            </summary>
    </member>
    <member name="F:BEPUphysics.Materials.InteractionProperties.StaticFriction">
      <summary>
             Static friction between the pair of objects.
            </summary>
    </member>
    <member name="F:BEPUphysics.Materials.InteractionProperties.Bounciness">
      <summary>
             Bounciness between the pair of objects.
            </summary>
    </member>
    <member name="T:BEPUphysics.OtherSpaceStages.IDeferredEventCreatorOwner">
      <summary>
             Defines an object that owns a deferred event creator.
            </summary>
    </member>
    <member name="P:BEPUphysics.OtherSpaceStages.IDeferredEventCreatorOwner.EventCreator">
      <summary>
             Gets the event creator owned by the object.
            </summary>
    </member>
    <member name="T:BEPUphysics.DataStructures.TinyStructList`1">
      <summary>
            Special datatype used for heapless lists without unsafe/stackalloc.
            Since reference types would require heap-side allocation and
            do not match well with this structure's ref-parameter based access,
            only structs are allowed.
            Stores a maximum of 8 entries.
            </summary>
      <typeparam name="T">Struct type to use.</typeparam>
    </member>
    <member name="M:BEPUphysics.DataStructures.TinyStructList`1.ToString">
      <summary>
            Creates a string representation of the list.
            </summary>
      <returns>String representation of the list.</returns>
    </member>
    <member name="M:BEPUphysics.DataStructures.TinyStructList`1.Add(`0@)">
      <summary>
            Tries to add an element to the list.
            </summary>
      <param name="item">Item to add.</param>
      <returns>Whether or not the item could be added.
            Will return false when the list is full.</returns>
    </member>
    <member name="M:BEPUphysics.DataStructures.TinyStructList`1.Clear">
      <summary>
            Clears the list.
            </summary>
    </member>
    <member name="M:BEPUphysics.DataStructures.TinyStructList`1.Get(System.Int32,`0@)">
      <summary>
            Gets the item at the specified index.
            </summary>
      <param name="index">Index to retrieve.</param>
      <param name="item">Retrieved item.</param>
      <returns>Whether or not the index was valid.</returns>
    </member>
    <member name="M:BEPUphysics.DataStructures.TinyStructList`1.IndexOf(`0@)">
      <summary>
            Gets the index of the item in the list, if it is present.
            </summary>
      <param name="item">Item to look for.</param>
      <returns>Index of the item, if present.  -1 otherwise.</returns>
    </member>
    <member name="M:BEPUphysics.DataStructures.TinyStructList`1.Remove(`0@)">
      <summary>
            Tries to remove an element from the list.
            </summary>
      <param name="item">Item to remove.</param>
      <returns>Whether or not the item existed in the list.</returns>
    </member>
    <member name="M:BEPUphysics.DataStructures.TinyStructList`1.RemoveAt(System.Int32)">
      <summary>
            Removes the item at the specified index.
            </summary>
      <param name="index">Index of the element to remove.</param>
      <returns>Whether or not the item could be removed.
            Returns false if the index is out of bounds.</returns>
    </member>
    <member name="M:BEPUphysics.DataStructures.TinyStructList`1.Replace(System.Int32,`0@)">
      <summary>
            Tries to add an element to the list.
            </summary>
      <param name="index">Index to replace.</param>
      <param name="item">Item to add.</param>
      <returns>Whether or not the item could be replaced.
            Returns false if the index is invalid.</returns>
    </member>
    <member name="P:BEPUphysics.DataStructures.TinyStructList`1.Count">
      <summary>
            Gets the current number of elements in the list.
            </summary>
    </member>
    <member name="T:BEPUphysics.NarrowPhaseSystems.Pairs.INarrowPhasePair">
      <summary>
             Defines an object which handles a collision between two broad phase entries.
            </summary>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.Pairs.INarrowPhasePair.UpdateCollision(System.Single)">
      <summary>
             Updates the collision between the broad phase entries.
            </summary>
      <param name="dt">Timestep duration.</param>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.Pairs.INarrowPhasePair.Initialize(BEPUphysics.BroadPhaseSystems.BroadPhaseEntry,BEPUphysics.BroadPhaseSystems.BroadPhaseEntry)">
      <summary>
             Initializes the pair.
            </summary>
      <param name="entryA">First entry in the pair.</param>
      <param name="entryB">Second entry in the pair.</param>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.Pairs.INarrowPhasePair.OnAddedToNarrowPhase">
      <summary>
            Called when the pair is added to the narrow phase.
            </summary>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.Pairs.INarrowPhasePair.CleanUp">
      <summary>
            Cleans up the pair, preparing it to go inactive.
            </summary>
    </member>
    <member name="P:BEPUphysics.NarrowPhaseSystems.Pairs.INarrowPhasePair.NeedsUpdate">
      <summary>
             Gets or sets whether or not the pair needs to be updated.
             Used by the NarrowPhase to manage pairs.
            </summary>
    </member>
    <member name="P:BEPUphysics.NarrowPhaseSystems.Pairs.INarrowPhasePair.BroadPhaseOverlap">
      <summary>
             Gets or sets the overlap used to create the pair.
            </summary>
    </member>
    <member name="P:BEPUphysics.NarrowPhaseSystems.Pairs.INarrowPhasePair.Factory">
      <summary>
             Gets or sets the factory that created the pair.
            </summary>
    </member>
    <member name="P:BEPUphysics.NarrowPhaseSystems.Pairs.INarrowPhasePair.NarrowPhase">
      <summary>
            Gets or sets the narrow phase that owns this pair.
            </summary>
    </member>
    <member name="T:BEPUphysics.NarrowPhaseSystems.Pairs.CollidablePairHandler">
      <summary>
             Superclass of pairs between collidables that generate contact points.
            </summary>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.Pairs.CollidablePairHandler.UpdateCollision(System.Single)">
      <summary>
             Updates the pair handler.
            </summary>
      <param name="dt">Timestep duration.</param>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.Pairs.CollidablePairHandler.UpdateTimeOfImpact(BEPUphysics.Collidables.Collidable,System.Single)">
      <summary>
             Updates the time of impact for the pair.
            </summary>
      <param name="requester">Collidable requesting the update.</param>
      <param name="dt">Timestep duration.</param>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.Pairs.CollidablePairHandler.Initialize(BEPUphysics.BroadPhaseSystems.BroadPhaseEntry,BEPUphysics.BroadPhaseSystems.BroadPhaseEntry)">
      <summary>
             Initializes the pair handler.
            </summary>
      <param name="entryA">First entry in the pair.</param>
      <param name="entryB">Second entry in the pair.</param>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.Pairs.CollidablePairHandler.OnAddedToNarrowPhase">
      <summary>
             Called when the pair handler is added to the narrow phase.
            </summary>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.Pairs.CollidablePairHandler.CleanUp">
      <summary>
             Cleans up the pair handler.
            </summary>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.Pairs.CollidablePairHandler.UpdateMaterialProperties">
      <summary>
             Forces an update of the pair's material properties.
            </summary>
    </member>
    <member name="P:BEPUphysics.NarrowPhaseSystems.Pairs.CollidablePairHandler.TimeOfImpact">
      <summary>
             Gets the last computed time of impact of the pair handler.
             This is only computed when one of the members is a continuously
             updated object.
            </summary>
    </member>
    <member name="P:BEPUphysics.NarrowPhaseSystems.Pairs.CollidablePairHandler.BroadPhaseOverlap">
      <summary>
             Gets the broad phase overlap associated with this pair handler.
            </summary>
    </member>
    <member name="P:BEPUphysics.NarrowPhaseSystems.Pairs.CollidablePairHandler.CollisionRule">
      <summary>
             Gets or sets the collision rule governing this pair handler.
            </summary>
    </member>
    <member name="P:BEPUphysics.NarrowPhaseSystems.Pairs.CollidablePairHandler.NarrowPhase">
      <summary>
             Gets the narrow phase that owns this pair handler.
            </summary>
    </member>
    <member name="P:BEPUphysics.NarrowPhaseSystems.Pairs.CollidablePairHandler.SuppressEvents">
      <summary>
             Gets or sets whether or not to suppress events from this pair handler.
            </summary>
    </member>
    <member name="P:BEPUphysics.NarrowPhaseSystems.Pairs.CollidablePairHandler.Parent">
      <summary>
             Gets or sets the parent of this pair handler.
             Pairs with parents report to their parents various
             changes in state.  This is mainly used to support
             hierarchies of pairs for compound collisions.
            </summary>
    </member>
    <member name="P:BEPUphysics.NarrowPhaseSystems.Pairs.CollidablePairHandler.Contacts">
      <summary>
             Gets a list of the contacts in the pair and their associated constraint information.
            </summary>
    </member>
    <member name="T:BEPUphysics.NarrowPhaseSystems.Pairs.TriangleConvexPairHandler">
      <summary>
             Handles a triangle-convex collision pair.
            </summary>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.Pairs.TriangleConvexPairHandler.#ctor">
      <summary>
             Constructs a new pair handler.
            </summary>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.Pairs.TriangleConvexPairHandler.Initialize(BEPUphysics.BroadPhaseSystems.BroadPhaseEntry,BEPUphysics.BroadPhaseSystems.BroadPhaseEntry)">
      <summary>
             Initializes the pair handler.
            </summary>
      <param name="entryA">First entry in the pair.</param>
      <param name="entryB">Second entry in the pair.</param>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.Pairs.TriangleConvexPairHandler.UpdateMaterialProperties">
      <summary>
             Forces an update of the pair's material properties.
            </summary>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.Pairs.TriangleConvexPairHandler.OnAddedToNarrowPhase">
      <summary>
             Called when the pair handler is added to the narrow phase.
            </summary>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.Pairs.TriangleConvexPairHandler.CleanUp">
      <summary>
             Cleans up the pair handler.
            </summary>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.Pairs.TriangleConvexPairHandler.UpdateCollision(System.Single)">
      <summary>
             Updates the pair handler.
            </summary>
      <param name="dt">Timestep duration.</param>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.Pairs.TriangleConvexPairHandler.UpdateTimeOfImpact(BEPUphysics.Collidables.Collidable,System.Single)">
      <summary>
             Updates the time of impact for the pair.
            </summary>
      <param name="requester">Collidable requesting the update.</param>
      <param name="dt">Timestep duration.</param>
    </member>
    <member name="T:BEPUphysics.NarrowPhaseSystems.Factories.NarrowPhasePairFactory">
      <summary>
             Superclass of all factories which manufacture narrow phase pairs.
            </summary>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.Factories.NarrowPhasePairFactory.GetNarrowPhasePair(BEPUphysics.BroadPhaseSystems.BroadPhaseOverlap)">
      <summary>
             Manufactures and returns a narrow phase pair for the given overlap.
            </summary>
      <param name="overlap">Overlap used to create a pair.</param>
      <returns>Narrow phase pair.</returns>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.Factories.NarrowPhasePairFactory.GiveBack(BEPUphysics.NarrowPhaseSystems.Pairs.INarrowPhasePair)">
      <summary>
            Returns a pair to the factory for re-use.
            </summary>
      <param name="pair">Pair to return.</param>
    </member>
    <member name="T:BEPUphysics.NarrowPhaseSystems.Factories.BoxSpherePairFactory">
      <summary>
             Manufactures box-sphere pairs.
            </summary>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.Factories.BoxSpherePairFactory.GetNarrowPhasePair(BEPUphysics.BroadPhaseSystems.BroadPhaseOverlap)">
      <summary>
             Manufactures and returns a narrow phase pair for the given overlap.
            </summary>
      <param name="overlap">Overlap used to create a pair.</param>
      <returns>Narrow phase pair.</returns>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.Factories.BoxSpherePairFactory.GiveBack(BEPUphysics.NarrowPhaseSystems.Pairs.INarrowPhasePair)">
      <summary>
            Returns a pair to the factory for re-use.
            </summary>
      <param name="pair">Pair to return.</param>
    </member>
    <member name="T:BEPUphysics.BroadPhaseSystems.IBroadPhaseEntryOwner">
      <summary>
             Requires that a class own a BroadPhaseEntry.
            </summary>
    </member>
    <member name="P:BEPUphysics.BroadPhaseSystems.IBroadPhaseEntryOwner.Entry">
      <summary>
             Gets the broad phase entry associated with this object.
            </summary>
    </member>
    <member name="T:BEPUphysics.DeactivationManagement.ISimulationIslandMember">
      <summary>
             Defines an object which can belong to a simulation island.
            </summary>
    </member>
    <member name="M:BEPUphysics.DeactivationManagement.ISimulationIslandMember.UpdateDeactivationCandidacy(System.Single)">
      <summary>
             Updates the member's deactivation state.
            </summary>
      <param name="dt">Timestep duration.</param>
    </member>
    <member name="M:BEPUphysics.DeactivationManagement.ISimulationIslandMember.RemoveConnectionReference(BEPUphysics.DeactivationManagement.ISimulationIslandConnection)">
      <summary>
             Removes a connection reference from the member.
            </summary>
      <param name="connection">Reference to remove.</param>
    </member>
    <member name="M:BEPUphysics.DeactivationManagement.ISimulationIslandMember.AddConnectionReference(BEPUphysics.DeactivationManagement.ISimulationIslandConnection)">
      <summary>
             Adds a connection reference to the member.
            </summary>
      <param name="connection">Reference to add.</param>
    </member>
    <member name="P:BEPUphysics.DeactivationManagement.ISimulationIslandMember.Connections">
      <summary>
             Gets the connections associated with this member.
            </summary>
    </member>
    <member name="P:BEPUphysics.DeactivationManagement.ISimulationIslandMember.IsDeactivationCandidate">
      <summary>
             Gets whether or not the object is a deactivation candidate.
            </summary>
    </member>
    <member name="P:BEPUphysics.DeactivationManagement.ISimulationIslandMember.IsActive">
      <summary>
             Gets whether or not the member is active.
            </summary>
    </member>
    <member name="P:BEPUphysics.DeactivationManagement.ISimulationIslandMember.SimulationIsland">
      <summary>
             Gets or sets the simulation island that owns this member.
            </summary>
    </member>
    <member name="P:BEPUphysics.DeactivationManagement.ISimulationIslandMember.IsDynamic">
      <summary>
             Gets whether or not the object is dynamic.
             Non-dynamic members act as dead-ends in connection graphs.
            </summary>
    </member>
    <member name="P:BEPUphysics.DeactivationManagement.ISimulationIslandMember.SearchState">
      <summary>
             Gets or sets the current search state of the simulation island member.  This is used by the simulation island system
             to efficiently split islands.
            </summary>
    </member>
    <member name="P:BEPUphysics.DeactivationManagement.ISimulationIslandMember.DeactivationManager">
      <summary>
            Gets or sets the deactivation manager that is managing this member.
            </summary>
    </member>
    <member name="E:BEPUphysics.DeactivationManagement.ISimulationIslandMember.Activated">
      <summary>
             Fired when the object activates.
            </summary>
    </member>
    <member name="E:BEPUphysics.DeactivationManagement.ISimulationIslandMember.BecameDeactivationCandidate">
      <summary>
             Fired when the object becomes a deactivation candidate.
            </summary>
    </member>
    <member name="E:BEPUphysics.DeactivationManagement.ISimulationIslandMember.BecameNonDeactivationCandidate">
      <summary>
             Fired when the object is no longer a deactivation candidate.
            </summary>
    </member>
    <member name="E:BEPUphysics.DeactivationManagement.ISimulationIslandMember.Deactivated">
      <summary>
             Fired when the object deactivates.
            </summary>
    </member>
    <member name="T:BEPUphysics.PositionUpdating.IPositionUpdateable">
      <summary>
             Defines an object capable of a position update.
            </summary>
    </member>
    <member name="M:BEPUphysics.PositionUpdating.IPositionUpdateable.PreUpdatePosition(System.Single)">
      <summary>
             Updates the position state of the object.
            </summary>
      <param name="dt">Time step duration.</param>
    </member>
    <member name="P:BEPUphysics.PositionUpdating.IPositionUpdateable.IsActive">
      <summary>
             Gets whether or not the object is active.
             Only active objects will be updated.
            </summary>
    </member>
    <member name="P:BEPUphysics.PositionUpdating.IPositionUpdateable.PositionUpdater">
      <summary>
             Gets or sets the position updater that owns this updateable.
            </summary>
    </member>
    <member name="T:BEPUphysics.PositionUpdating.ICCDPositionUpdateable">
      <summary>
             A position updateable that can be updated continuously.
            </summary>
    </member>
    <member name="M:BEPUphysics.PositionUpdating.ICCDPositionUpdateable.UpdateTimeOfImpacts(System.Single)">
      <summary>
             Updates the time of impacts associated with the updateable.
            </summary>
      <param name="dt">Time step duration.</param>
    </member>
    <member name="M:BEPUphysics.PositionUpdating.ICCDPositionUpdateable.UpdatePositionContinuously(System.Single)">
      <summary>
            Updates the updateable using its continuous nature.
            </summary>
      <param name="dt">Time step duration.</param>
    </member>
    <member name="P:BEPUphysics.PositionUpdating.ICCDPositionUpdateable.PositionUpdateMode">
      <summary>
            Gets or sets the position update mode of the object.
            The position update mode defines the way the object
            interacts with continuous collision detection.
            </summary>
    </member>
    <member name="T:BEPUphysics.OtherSpaceStages.IForceUpdateable">
      <summary>
             Defines an object which can be updated using forces by the ForceUpdater.
            </summary>
    </member>
    <member name="M:BEPUphysics.OtherSpaceStages.IForceUpdateable.UpdateForForces(System.Single)">
      <summary>
             Applies forces to the object.
            </summary>
      <param name="dt">Time step duration.</param>
    </member>
    <member name="P:BEPUphysics.OtherSpaceStages.IForceUpdateable.ForceUpdater">
      <summary>
             Force updater that owns this object.
            </summary>
    </member>
    <member name="P:BEPUphysics.OtherSpaceStages.IForceUpdateable.IsDynamic">
      <summary>
             Gets whether or not this object is dynamic.
             Only dynamic objects are updated by the force updater.
            </summary>
    </member>
    <member name="P:BEPUphysics.OtherSpaceStages.IForceUpdateable.IsActive">
      <summary>
             Gets whether or not this object is active.  Only active objects are updated by the force updater.
            </summary>
    </member>
    <member name="T:BEPUphysics.Materials.IMaterialOwner">
      <summary>
             Defines an object that has a material.
            </summary>
    </member>
    <member name="P:BEPUphysics.Materials.IMaterialOwner.Material">
      <summary>
             Gets or sets the material of the object.
            </summary>
    </member>
    <member name="T:BEPUphysics.CollisionRuleManagement.ICollisionRulesOwner">
      <summary>
             Defines a class which must own CollisionRules.
            </summary>
    </member>
    <member name="P:BEPUphysics.CollisionRuleManagement.ICollisionRulesOwner.CollisionRules">
      <summary>
             Collision rules owned by the object.
            </summary>
    </member>
    <member name="T:BEPUphysics.Entities.Entity">
      <summary>
             Superclass of movable rigid bodies.  Contains information for
             both dynamic and kinematic simulation.
            </summary>
    </member>
    <member name="M:BEPUphysics.Entities.Entity.ApplyImpulse(Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3)">
      <summary>
             Applies an impulse to the entity.
            </summary>
      <param name="location">Location to apply the impulse.</param>
      <param name="impulse">Impulse to apply.</param>
    </member>
    <member name="M:BEPUphysics.Entities.Entity.ApplyImpulse(Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Vector3@)">
      <summary>
             Applies an impulse to the entity.
            </summary>
      <param name="location">Location to apply the impulse.</param>
      <param name="impulse">Impulse to apply.</param>
    </member>
    <member name="M:BEPUphysics.Entities.Entity.BecomeKinematic">
      <summary>
             Forces the entity to become kinematic.  Kinematic entities have infinite mass and inertia.
            </summary>
    </member>
    <member name="M:BEPUphysics.Entities.Entity.BecomeDynamic(System.Single)">
      <summary>
             Forces the entity to become dynamic.  Dynamic entities respond to collisions and have finite mass and inertia.
            </summary>
      <param name="mass">Mass to use for the entity.</param>
    </member>
    <member name="M:BEPUphysics.Entities.Entity.BecomeDynamic(System.Single,BEPUphysics.MathExtensions.Matrix3X3)">
      <summary>
             Forces the entity to become dynamic.  Dynamic entities respond to collisions and have finite mass and inertia.
            </summary>
      <param name="mass">Mass to use for the entity.</param>
      <param name="localInertiaTensor">Inertia tensor to use for the entity.</param>
    </member>
    <member name="M:BEPUphysics.Entities.Entity.ModifyLinearDamping(System.Single)">
      <summary>
            Temporarily adjusts the linear damping by an amount.  After the value is used, the
            damping returns to the base value.
            </summary>
      <param name="damping">Damping to add.</param>
    </member>
    <member name="M:BEPUphysics.Entities.Entity.ModifyAngularDamping(System.Single)">
      <summary>
            Temporarily adjusts the angular damping by an amount.  After the value is used, the
            damping returns to the base value.
            </summary>
      <param name="damping">Damping to add.</param>
    </member>
    <member name="P:BEPUphysics.Entities.Entity.Position">
      <summary>
             Gets or sets the position of the Entity.  This Position acts
             as the center of mass for dynamic entities.
            </summary>
    </member>
    <member name="P:BEPUphysics.Entities.Entity.Orientation">
      <summary>
             Gets or sets the orientation quaternion of the entity.
            </summary>
    </member>
    <member name="P:BEPUphysics.Entities.Entity.OrientationMatrix">
      <summary>
            Gets or sets the orientation matrix of the entity.
            </summary>
    </member>
    <member name="P:BEPUphysics.Entities.Entity.WorldTransform">
      <summary>
             Gets or sets the world transform of the entity.
             The upper left 3x3 part is the Orientation, and the translation is the Position.
             When setting this property, ensure that the rotation matrix component does not include
             any scaling or shearing.
            </summary>
    </member>
    <member name="P:BEPUphysics.Entities.Entity.AngularVelocity">
      <summary>
            Gets or sets the angular velocity of the entity.
            </summary>
    </member>
    <member name="P:BEPUphysics.Entities.Entity.AngularMomentum">
      <summary>
            Gets or sets the angular momentum of the entity.
            </summary>
    </member>
    <member name="P:BEPUphysics.Entities.Entity.LinearVelocity">
      <summary>
            Gets or sets the linear velocity of the entity.
            </summary>
    </member>
    <member name="P:BEPUphysics.Entities.Entity.LinearMomentum">
      <summary>
            Gets or sets the linear momentum of the entity.
            </summary>
    </member>
    <member name="P:BEPUphysics.Entities.Entity.MotionState">
      <summary>
            Gets or sets the position, orientation, linear velocity, and angular velocity of the entity.
            </summary>
    </member>
    <member name="P:BEPUphysics.Entities.Entity.IsDynamic">
      <summary>
            Gets whether or not the entity is dynamic.
            Dynamic entities have finite mass and respond
            to collisions.  Kinematic (non-dynamic) entities
            have infinite mass and inertia and will plow through anything.
            </summary>
    </member>
    <member name="P:BEPUphysics.Entities.Entity.IsActive">
      <summary>
             Gets whether or not the member is active.
            </summary>
    </member>
    <member name="P:BEPUphysics.Entities.Entity.IsAlwaysActive">
      <summary>
             Gets or sets whether or not the entity is always active.
             If set to true, the object cannot deactivate.
            </summary>
    </member>
    <member name="P:BEPUphysics.Entities.Entity.IsAffectedByGravity">
      <summary>
             Gets or sets whether or not the entity can be affected by gravity applied by the ForceUpdater.
            </summary>
    </member>
    <member name="P:BEPUphysics.Entities.Entity.BufferedStates">
      <summary>
             Gets the buffered states of the entity.  If the Space.BufferedStates manager is enabled,
             this property provides access to the buffered and interpolated states of the entity.
             Buffered states are the most recent completed update values, while interpolated states are the previous values blended
             with the current frame's values.  Interpolated states are helpful when updating the engine with internal time stepping, 
             giving entity motion a smooth appearance even when updates aren't occurring consistently every frame.  
             Both are buffered for asynchronous access.
            </summary>
    </member>
    <member name="P:BEPUphysics.Entities.Entity.InertiaTensorInverse">
      <summary>
             Gets the world space inertia tensor inverse of the entity.
            </summary>
    </member>
    <member name="P:BEPUphysics.Entities.Entity.InertiaTensor">
      <summary>
             Gets the world space inertia tensor of the entity.
            </summary>
    </member>
    <member name="P:BEPUphysics.Entities.Entity.LocalInertiaTensor">
      <summary>
             Gets or sets the local inertia tensor of the entity.
            </summary>
    </member>
    <member name="P:BEPUphysics.Entities.Entity.LocalInertiaTensorInverse">
      <summary>
            Gets or sets the local inertia tensor inverse of the entity.
            </summary>
    </member>
    <member name="P:BEPUphysics.Entities.Entity.Mass">
      <summary>
             Gets or sets the mass of the entity.
            </summary>
    </member>
    <member name="P:BEPUphysics.Entities.Entity.Volume">
      <summary>
            Gets or sets the volume of the entity.
            This is computed along with other physical properties at initialization,
            but it's only used for auxiliary systems like the FluidVolume.
            Changing this can tune behavior of those systems.
            </summary>
    </member>
    <member name="P:BEPUphysics.Entities.Entity.CollisionInformation">
      <summary>
             Gets the collidable used by the entity.
            </summary>
    </member>
    <member name="P:BEPUphysics.Entities.Entity.Locker">
      <summary>
             Gets the synchronization object used by systems that need
             exclusive access to the entity's properties.
            </summary>
    </member>
    <member name="P:BEPUphysics.Entities.Entity.Material">
      <summary>
             Gets or sets the material used by the entity.
            </summary>
    </member>
    <member name="P:BEPUphysics.Entities.Entity.SolverUpdateables">
      <summary>
             Gets all the EntitySolverUpdateables associated with this entity.
            </summary>
    </member>
    <member name="P:BEPUphysics.Entities.Entity.Constraints">
      <summary>
             Gets the two-entity constraints associated with this entity (a subset of the solver updateables).
            </summary>
    </member>
    <member name="P:BEPUphysics.Entities.Entity.Connections">
      <summary>
             Gets the connections associated with this member.
            </summary>
    </member>
    <member name="P:BEPUphysics.Entities.Entity.IsDeactivationCandidate">
      <summary>
             Gets whether or not the object is a deactivation candidate.
            </summary>
    </member>
    <member name="P:BEPUphysics.Entities.Entity.SimulationIsland">
      <summary>
             Gets the simulation island that owns this entity.
            </summary>
    </member>
    <member name="P:BEPUphysics.Entities.Entity.IgnoreShapeChanges">
      <summary>
            Gets or sets whether or not to ignore shape changes.  When true, changing the entity's collision shape will not update the maximum radius, volume, density, or inertia tensor. 
            </summary>
    </member>
    <member name="P:BEPUphysics.Entities.Entity.Space">
      <summary>
             Gets the space that owns the entity.
            </summary>
    </member>
    <member name="P:BEPUphysics.Entities.Entity.PositionUpdateMode">
      <summary>
             Gets the position update mode of the entity.
            </summary>
    </member>
    <member name="P:BEPUphysics.Entities.Entity.AngularDamping">
      <summary>
             Gets or sets the angular damping of the entity.
             Values range from 0 to 1, correspondong to a fraction of angular momentum removed
             from the entity over a unit of time.
            </summary>
    </member>
    <member name="P:BEPUphysics.Entities.Entity.LinearDamping">
      <summary>
             Gets or sets the linear damping of the entity.
             Values range from 0 to 1, correspondong to a fraction of linear momentum removed
             from the entity over a unit of time.
            </summary>
    </member>
    <member name="P:BEPUphysics.Entities.Entity.Tag">
      <summary>
            Gets or sets the user data associated with the entity.
            This is separate from the entity's collidable's tag.
            If a tag needs to be accessed from within the collision
            detection pipeline, consider using the entity.CollisionInformation.Tag.
            </summary>
    </member>
    <member name="E:BEPUphysics.Entities.Entity.PositionUpdated">
      <summary>
             Fires when the entity's position is updated.
            </summary>
    </member>
    <member name="E:BEPUphysics.Entities.Entity.Activated">
      <summary>
             Fires when the entity activates.
            </summary>
    </member>
    <member name="E:BEPUphysics.Entities.Entity.BecameDeactivationCandidate">
      <summary>
             Fires when the entity becomes a deactivation candidate.
            </summary>
    </member>
    <member name="E:BEPUphysics.Entities.Entity.BecameNonDeactivationCandidate">
      <summary>
            Fires when the entity is no longer a deactivation candidate.
            </summary>
    </member>
    <member name="E:BEPUphysics.Entities.Entity.Deactivated">
      <summary>
             Fires when the entity deactivates.
            </summary>
    </member>
    <member name="T:BEPUphysics.Entities.Entity`1">
      <summary>
             Superclass of all entities which have a defined collidable type.
             After construction, the collidable on this sort of Entity cannot be changed.
             It can be constructed directly, or one of its prefab children (Box, Sphere, etc.) can be used.
            </summary>
      <remarks>If the collidable needs to be changed after construction, consider using the MorphableEntity.</remarks>
      <typeparam name="T">Type of EntityCollidable to use for the entity.</typeparam>
    </member>
    <member name="M:BEPUphysics.Entities.Entity`1.#ctor(`0)">
      <summary>
             Constructs an Entity.
            </summary>
      <param name="collisionInformation">Collidable for the entity.</param>
    </member>
    <member name="M:BEPUphysics.Entities.Entity`1.#ctor(`0,System.Single)">
      <summary>
             Constructs an Entity.
            </summary>
      <param name="collisionInformation">Collidable for the entity.</param>
      <param name="mass">Mass of the entity.</param>
    </member>
    <member name="M:BEPUphysics.Entities.Entity`1.#ctor(`0,System.Single,BEPUphysics.MathExtensions.Matrix3X3)">
      <summary>
             Constructs an Entity.
            </summary>
      <param name="collisionInformation">Collidable for the entity.</param>
      <param name="mass">Mass of the entity.</param>
      <param name="inertiaTensor">Inertia of the entity.</param>
    </member>
    <member name="M:BEPUphysics.Entities.Entity`1.#ctor(`0,System.Single,BEPUphysics.MathExtensions.Matrix3X3,System.Single)">
      <summary>
             Constructs an Entity.
            </summary>
      <param name="collisionInformation">Collidable for the entity.</param>
      <param name="mass">Mass of the entity.</param>
      <param name="inertiaTensor">Inertia of the entity.</param>
      <param name="volume">Volume of the entity.</param>
    </member>
    <member name="P:BEPUphysics.Entities.Entity`1.CollisionInformation">
      <summary>
             Gets the collidable used by the entity.
            </summary>
    </member>
    <member name="T:BEPUphysics.Entities.Prefabs.ConvexHull">
      <summary>
            Shape that can collide and move based on the convex 'outer layer' of a list of points.  After making an entity, add it to a Space so that the engine can manage it.
            </summary>
    </member>
    <member name="M:BEPUphysics.Entities.Prefabs.ConvexHull.#ctor(System.Collections.Generic.IList{Microsoft.Xna.Framework.Vector3})">
      <summary>
            Constructs a nondynamic convex hull of points.
            </summary>
      <param name="points">List of points in the object.</param>
    </member>
    <member name="M:BEPUphysics.Entities.Prefabs.ConvexHull.#ctor(System.Collections.Generic.IList{Microsoft.Xna.Framework.Vector3},System.Single)">
      <summary>
            Constructs a physically simulated convex hull of points.
            </summary>
      <param name="points">List of points in the object.</param>
      <param name="mass">Mass of the object.</param>
    </member>
    <member name="M:BEPUphysics.Entities.Prefabs.ConvexHull.#ctor(Microsoft.Xna.Framework.Vector3,System.Collections.Generic.IList{Microsoft.Xna.Framework.Vector3},System.Single)">
      <summary>
            Constructs a physically simulated convex hull of points.
            </summary>
      <param name="position">Position to place the convex hull.</param>
      <param name="points">List of points in the object.</param>
      <param name="mass">Mass of the object.</param>
    </member>
    <member name="M:BEPUphysics.Entities.Prefabs.ConvexHull.#ctor(Microsoft.Xna.Framework.Vector3,System.Collections.Generic.IList{Microsoft.Xna.Framework.Vector3})">
      <summary>
            Constructs a nondynamic convex hull of points.
            </summary>
      <param name="position">Position to place the convex hull.</param>
      <param name="points">List of points in the object.</param>
    </member>
    <member name="M:BEPUphysics.Entities.Prefabs.ConvexHull.#ctor(BEPUphysics.EntityStateManagement.MotionState,System.Collections.Generic.IList{Microsoft.Xna.Framework.Vector3},System.Single)">
      <summary>
            Constructs a physically simulated convex hull of points.
            </summary>
      <param name="motionState">Motion state specifying the entity's initial state.</param>
      <param name="points">List of points in the object.</param>
      <param name="mass">Mass of the object.</param>
    </member>
    <member name="M:BEPUphysics.Entities.Prefabs.ConvexHull.#ctor(BEPUphysics.EntityStateManagement.MotionState,System.Collections.Generic.IList{Microsoft.Xna.Framework.Vector3})">
      <summary>
            Constructs a nondynamic convex hull of points.
            </summary>
      <param name="motionState">Motion state specifying the entity's initial state.</param>
      <param name="points">List of points in the object.</param>
    </member>
    <member name="P:BEPUphysics.Entities.Prefabs.ConvexHull.Vertices">
      <summary>
            List of the points composing the surface of the convex hull in local space.
            </summary>
    </member>
    <member name="T:BEPUphysics.CollisionShapes.CollisionShape">
      <summary>
             Superclass of all collision shapes.
             Collision shapes are composed entirely of local space information.
             Collidables provide the world space information needed to use the shapes to do collision detection.
            </summary>
    </member>
    <member name="E:BEPUphysics.CollisionShapes.CollisionShape.ShapeChanged">
      <summary>
             Fires when some of the local space information in the shape changes.
            </summary>
    </member>
    <member name="T:BEPUphysics.CollisionShapes.EntityShape">
      <summary>
             Superclass of all collision shapes that are used by Entities.
            </summary>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.EntityShape.ComputeMinimumRadius">
      <summary>
             Computes the minimum radius of the shape.
             This is often smaller than the actual minimum radius;
             it is simply an approximation that avoids overestimating.
            </summary>
      <returns>Minimum radius of the shape.</returns>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.EntityShape.ComputeMaximumRadius">
      <summary>
            Computes the maximum radius of the shape.
            This is often larger than the actual maximum radius;
            it is simply an approximation that avoids underestimating.
            </summary>
      <returns>Maximum radius of the shape.</returns>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.EntityShape.ComputeVolume">
      <summary>
            Computes the volume of the shape.
            </summary>
      <returns>Volume of the shape.</returns>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.EntityShape.ComputeVolumeDistribution(System.Single@)">
      <summary>
            Computes the volume distribution of the shape as well as its volume.
            The volume distribution can be used to compute inertia tensors when
            paired with mass and other tuning factors.
            </summary>
      <param name="volume">Volume of the shape.</param>
      <returns>Volume distribution of the shape.</returns>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.EntityShape.ComputeVolumeDistribution">
      <summary>
            Computes the volume distribution of the shape.
            The volume distribution can be used to compute inertia tensors when
            paired with mass and other tuning factors.
            </summary>
      <returns>Volume distribution of the shape.</returns>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.EntityShape.ComputeCenter">
      <summary>
            Computes the center of the shape.  This can be considered its 
            center of mass.
            </summary>
      <returns>Center of the shape.</returns>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.EntityShape.ComputeCenter(System.Single@)">
      <summary>
            Computes the center of the shape.  This can be considered its 
            center of mass.  This calculation is often associated with the 
            volume calculation, which is given by this method as well.
            </summary>
      <param name="volume">Volume of the shape.</param>
      <returns>Center of the shape.</returns>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.EntityShape.ComputeDistributionInformation(BEPUphysics.CollisionShapes.ShapeDistributionInformation@)">
      <summary>
            Computes a variety of shape information all at once.
            </summary>
      <param name="shapeInfo">Properties of the shape.</param>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.EntityShape.GetMobileInstance">
      <summary>
            Retrieves an instance of an EntityCollidable that uses this EntityShape.  Mainly used by compound bodies.
            </summary>
      <returns>EntityCollidable that uses this shape.</returns>
    </member>
    <member name="T:BEPUphysics.CollisionShapes.ConvexShapes.ConvexShape">
      <summary>
             Superclass of convex collision shapes.
            </summary>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.ConvexShapes.ConvexShape.GetLocalExtremePointWithoutMargin(Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Vector3@)">
      <summary>
             Gets the extreme point of the shape in local space in a given direction.
            </summary>
      <param name="direction">Direction to find the extreme point in.</param>
      <param name="extremePoint">Extreme point on the shape.</param>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.ConvexShapes.ConvexShape.GetExtremePointWithoutMargin(Microsoft.Xna.Framework.Vector3,BEPUphysics.MathExtensions.RigidTransform@,Microsoft.Xna.Framework.Vector3@)">
      <summary>
             Gets the extreme point of the shape in world space in a given direction.
            </summary>
      <param name="direction">Direction to find the extreme point in.</param>
      <param name="shapeTransform">Transform to use for the shape.</param>
      <param name="extremePoint">Extreme point on the shape.</param>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.ConvexShapes.ConvexShape.GetExtremePoint(Microsoft.Xna.Framework.Vector3,BEPUphysics.MathExtensions.RigidTransform@,Microsoft.Xna.Framework.Vector3@)">
      <summary>
             Gets the extreme point of the shape in world space in a given direction with margin expansion.
            </summary>
      <param name="direction">Direction to find the extreme point in.</param>
      <param name="shapeTransform">Transform to use for the shape.</param>
      <param name="extremePoint">Extreme point on the shape.</param>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.ConvexShapes.ConvexShape.GetLocalExtremePoint(Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3@)">
      <summary>
             Gets the extreme point of the shape in local space in a given direction with margin expansion.
            </summary>
      <param name="direction">Direction to find the extreme point in.</param>
      <param name="extremePoint">Extreme point on the shape.</param>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.ConvexShapes.ConvexShape.GetBoundingBox(BEPUphysics.MathExtensions.RigidTransform@,Microsoft.Xna.Framework.BoundingBox@)">
      <summary>
            Gets the bounding box of the shape given a transform.
            </summary>
      <param name="shapeTransform">Transform to use.</param>
      <param name="boundingBox">Bounding box of the transformed shape.</param>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.ConvexShapes.ConvexShape.RayTest(Microsoft.Xna.Framework.Ray@,BEPUphysics.MathExtensions.RigidTransform@,System.Single,BEPUphysics.RayHit@)">
      <summary>
            Gets the intersection between the convex shape and the ray.
            </summary>
      <param name="ray">Ray to test.</param>
      <param name="transform">Transform of the convex shape.</param>
      <param name="maximumLength">Maximum distance to travel in units of the ray direction's length.</param>
      <param name="hit">Ray hit data, if any.</param>
      <returns>Whether or not the ray hit the target.</returns>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.ConvexShapes.ConvexShape.ComputeCenter">
      <summary>
            Computes the center of the shape.  This can be considered its 
            center of mass.
            </summary>
      <returns>Center of the shape.</returns>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.ConvexShapes.ConvexShape.ComputeCenter(System.Single@)">
      <summary>
            Computes the center of the shape.  This can be considered its 
            center of mass.  This calculation is often associated with the 
            volume calculation, which is given by this method as well.
            </summary>
      <param name="volume">Volume of the shape.</param>
      <returns>Center of the shape.</returns>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.ConvexShapes.ConvexShape.ComputeVolume">
      <summary>
            Computes the volume of the shape.
            </summary>
      <returns>Volume of the shape.</returns>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.ConvexShapes.ConvexShape.ComputeVolumeDistribution(System.Single@)">
      <summary>
            Computes the volume distribution of the shape as well as its volume.
            The volume distribution can be used to compute inertia tensors when
            paired with mass and other tuning factors.
            </summary>
      <param name="volume">Volume of the shape.</param>
      <returns>Volume distribution of the shape.</returns>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.ConvexShapes.ConvexShape.ComputeVolumeDistribution">
      <summary>
            Computes the volume distribution of the shape.
            The volume distribution can be used to compute inertia tensors when
            paired with mass and other tuning factors.
            </summary>
      <returns>Volume distribution of the shape.</returns>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.ConvexShapes.ConvexShape.GetLocalBoundingBox(BEPUphysics.MathExtensions.RigidTransform@,BEPUphysics.MathExtensions.AffineTransform@,Microsoft.Xna.Framework.BoundingBox@)">
      <summary>
            Gets the bounding box of the convex shape transformed first into world space, and then into the local space of another affine transform.
            </summary>
      <param name="shapeTransform">Transform to use to put the shape into world space.</param>
      <param name="spaceTransform">Used as the frame of reference to compute the bounding box.
            In effect, the shape is transformed by the inverse of the space transform to compute its bounding box in local space.</param>
      <param name="boundingBox">Bounding box in the local space.</param>
    </member>
    <member name="P:BEPUphysics.CollisionShapes.ConvexShapes.ConvexShape.CollisionMargin">
      <summary>
             Collision margin of the convex shape.  The margin is a small spherical expansion around
             entities which allows specialized collision detection algorithms to be used.
             It's recommended that this be left unchanged.
            </summary>
    </member>
    <member name="P:BEPUphysics.CollisionShapes.ConvexShapes.ConvexShape.MinimumRadius">
      <summary>
            Gets or sets the minimum radius of the collidable's shape.  This is initialized to a value that is
            guaranteed to be equal to or smaller than the actual minimum radius.  When setting this property,
            ensure that the inner sphere formed by the new minimum radius is fully contained within the shape.
            </summary>
    </member>
    <member name="P:BEPUphysics.CollisionShapes.ConvexShapes.ConvexShape.MaximumRadius">
      <summary>
            Gets the maximum radius of the collidable's shape.  This is initialized to a value that is
            guaranteed to be equal to or larger than the actual maximum radius.
            </summary>
    </member>
    <member name="T:BEPUphysics.CollisionShapes.MobileMeshShape">
      <summary>
             Local space data associated with an instanced mesh.
             This contains a hierarchy and all the other heavy data needed
             by an InstancedMesh.
            </summary>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.MobileMeshShape.#ctor(Microsoft.Xna.Framework.Vector3[],System.Int32[])">
      <summary>
             Constructs a new instanced mesh shape.
            </summary>
      <param name="vertices">Vertices of the mesh.</param>
      <param name="indices">Indices of the mesh.</param>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.MobileMeshShape.GetBoundingBox(BEPUphysics.MathExtensions.RigidTransform@,Microsoft.Xna.Framework.BoundingBox@)">
      <summary>
             Computes the bounding box of the transformed mesh shape.
            </summary>
      <param name="transform">Transform to apply to the shape during the bounding box calculation.</param>
      <param name="boundingBox">Bounding box containing the transformed mesh shape.</param>
    </member>
    <member name="P:BEPUphysics.CollisionShapes.MobileMeshShape.TriangleMesh">
      <summary>
             Gets or sets the TriangleMesh data structure used by this shape.
            </summary>
    </member>
    <member name="T:BEPUphysics.Constraints.ISpringSettings">
      <summary>
            Implemented by constraints that support springlike behavior.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.ISpringSettings.SpringSettings">
      <summary>
            Gets the spring settings used by the constraint.
            </summary>
    </member>
    <member name="T:BEPUphysics.Constraints.ISolverSettings">
      <summary>
            Implemented by classes which have solver settings.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.ISolverSettings.SolverSettings">
      <summary>
            Gets the solver settings for this constraint.
            </summary>
    </member>
    <member name="T:BEPUphysics.Vehicle.WheelSuspension">
      <summary>
            Allows the connected wheel and vehicle to smoothly absorb bumps.
            </summary>
    </member>
    <member name="M:BEPUphysics.Vehicle.WheelSuspension.#ctor(System.Single,System.Single,Microsoft.Xna.Framework.Vector3,System.Single,Microsoft.Xna.Framework.Vector3)">
      <summary>
            Constructs a new suspension for a wheel.
            </summary>
      <param name="stiffnessConstant">Strength of the spring.  Higher values resist compression more.</param>
      <param name="dampingConstant">Damping constant of the spring.  Higher values remove more momentum.</param>
      <param name="localDirection">Direction of the suspension in the vehicle's local space.  For a normal, straight down suspension, this would be (0, -1, 0).</param>
      <param name="restLength">Length of the suspension when uncompressed.</param>
      <param name="localAttachmentPoint">Place where the suspension hooks up to the body of the vehicle.</param>
    </member>
    <member name="P:BEPUphysics.Vehicle.WheelSuspension.AllowedCompression">
      <summary>
            Gets or sets the allowed compression of the suspension before suspension forces take effect.
            Usually a very small number.  Used to prevent 'jitter' where the wheel leaves the ground due to spring forces repeatedly.
            </summary>
    </member>
    <member name="P:BEPUphysics.Vehicle.WheelSuspension.CurrentLength">
      <summary>
            Gets the the current length of the suspension.
            This will be less than the restLength if the suspension is compressed.
            </summary>
    </member>
    <member name="P:BEPUphysics.Vehicle.WheelSuspension.LocalAttachmentPoint">
      <summary>
            Gets or sets the attachment point of the suspension to the vehicle body in the body's local space.
            </summary>
    </member>
    <member name="P:BEPUphysics.Vehicle.WheelSuspension.LocalDirection">
      <summary>
            Gets or sets the direction of the wheel suspension in the local space of the vehicle body.
            A normal, straight suspension would be (0,-1,0).
            </summary>
    </member>
    <member name="P:BEPUphysics.Vehicle.WheelSuspension.MaximumSpringCorrectionSpeed">
      <summary>
            Gets or sets the maximum speed at which the suspension will try to return the suspension to rest length.
            </summary>
    </member>
    <member name="P:BEPUphysics.Vehicle.WheelSuspension.MaximumSpringForce">
      <summary>
            Gets or sets the maximum force that can be applied by this suspension.
            </summary>
    </member>
    <member name="P:BEPUphysics.Vehicle.WheelSuspension.RestLength">
      <summary>
            Gets or sets the length of the uncompressed suspension.
            </summary>
    </member>
    <member name="P:BEPUphysics.Vehicle.WheelSuspension.TotalImpulse">
      <summary>
            Gets the force that the suspension is applying to support the vehicle.
            </summary>
    </member>
    <member name="P:BEPUphysics.Vehicle.WheelSuspension.Wheel">
      <summary>
            Gets the wheel that this suspension applies to.
            </summary>
    </member>
    <member name="P:BEPUphysics.Vehicle.WheelSuspension.WorldAttachmentPoint">
      <summary>
            Gets or sets the attachment point of the suspension to the vehicle body in world space.
            </summary>
    </member>
    <member name="P:BEPUphysics.Vehicle.WheelSuspension.WorldDirection">
      <summary>
            Gets or sets the direction of the wheel suspension in the world space of the vehicle body.
            </summary>
    </member>
    <member name="P:BEPUphysics.Vehicle.WheelSuspension.SolverSettings">
      <summary>
            Gets the solver settings used by this wheel constraint.
            </summary>
    </member>
    <member name="P:BEPUphysics.Vehicle.WheelSuspension.SpringSettings">
      <summary>
            Gets the spring settings that define the behavior of the suspension.
            </summary>
    </member>
    <member name="P:BEPUphysics.Vehicle.WheelSuspension.RelativeVelocity">
      <summary>
             Gets the relative velocity along the support normal at the contact point.
            </summary>
    </member>
    <member name="T:BEPUphysics.Vehicle.WheelDrivingMotor">
      <summary>
            Handles a wheel's driving force for a vehicle.
            </summary>
    </member>
    <member name="F:BEPUphysics.Vehicle.WheelDrivingMotor.DefaultGripFrictionBlender">
      <summary>
            Default blender used by WheelSlidingFriction constraints.
            </summary>
    </member>
    <member name="M:BEPUphysics.Vehicle.WheelDrivingMotor.BlendFriction(System.Single,System.Single,System.Object)">
      <summary>
            Computes the friction to use between the vehicle and support for a wheel.
            </summary>
      <param name="wheelFriction">Friction coefficient of the wheel.</param>
      <param name="supportFriction">Friction coefficient of the supporting entity.</param>
      <param name="extraInfo">Any extra information to be considered.</param>
      <returns>Blended friction coefficient.</returns>
    </member>
    <member name="M:BEPUphysics.Vehicle.WheelDrivingMotor.#ctor(System.Single,System.Single,System.Single)">
      <summary>
            Constructs a new wheel motor.
            </summary>
      <param name="gripFriction">Friction coefficient of the wheel.  Blended with the ground's friction coefficient and normal force to determine a maximum force.</param>
      <param name="maximumForwardForce">Maximum force that the wheel motor can apply when driving forward (a target speed greater than zero).</param>
      <param name="maximumBackwardForce">Maximum force that the wheel motor can apply when driving backward (a target speed less than zero).</param>
    </member>
    <member name="P:BEPUphysics.Vehicle.WheelDrivingMotor.BlendedCoefficient">
      <summary>
            Gets the coefficient of grip friction between the wheel and support.
            This coefficient is the blended result of the supporting entity's friction and the wheel's friction.
            </summary>
    </member>
    <member name="P:BEPUphysics.Vehicle.WheelDrivingMotor.ForceAxis">
      <summary>
            Gets the axis along which the driving forces are applied.
            </summary>
    </member>
    <member name="P:BEPUphysics.Vehicle.WheelDrivingMotor.GripFriction">
      <summary>
            Gets or sets the coefficient of forward-backward gripping friction for this wheel.
            This coefficient and the supporting entity's coefficient of friction will be 
            taken into account to determine the used coefficient at any given time.
            </summary>
    </member>
    <member name="P:BEPUphysics.Vehicle.WheelDrivingMotor.GripFrictionBlender">
      <summary>
            Gets or sets the function used to blend the supporting entity's friction and the wheel's friction.
            </summary>
    </member>
    <member name="P:BEPUphysics.Vehicle.WheelDrivingMotor.MaximumBackwardForce">
      <summary>
            Gets or sets the maximum force that the wheel motor can apply when driving backward (a target speed less than zero).
            </summary>
    </member>
    <member name="P:BEPUphysics.Vehicle.WheelDrivingMotor.MaximumForwardForce">
      <summary>
            Gets or sets the maximum force that the wheel motor can apply when driving forward (a target speed greater than zero).
            </summary>
    </member>
    <member name="P:BEPUphysics.Vehicle.WheelDrivingMotor.TargetSpeed">
      <summary>
            Gets or sets the target speed of this wheel.
            </summary>
    </member>
    <member name="P:BEPUphysics.Vehicle.WheelDrivingMotor.TotalImpulse">
      <summary>
            Gets the force this wheel's motor is applying.
            </summary>
    </member>
    <member name="P:BEPUphysics.Vehicle.WheelDrivingMotor.Wheel">
      <summary>
            Gets the wheel that this motor applies to.
            </summary>
    </member>
    <member name="P:BEPUphysics.Vehicle.WheelDrivingMotor.SolverSettings">
      <summary>
            Gets the solver settings used by this wheel constraint.
            </summary>
    </member>
    <member name="P:BEPUphysics.Vehicle.WheelDrivingMotor.RelativeVelocity">
      <summary>
            Gets the relative velocity between the ground and wheel.
            </summary>
      <returns>Relative velocity between the ground and wheel.</returns>
    </member>
    <member name="T:BEPUphysics.Paths.Path`1">
      <summary>
            Superclass of a variety of classes that can be evaluated at a time to retrieve a value associated with that time.
            </summary>
      <typeparam name="TValue">Type of the value of the path.</typeparam>
    </member>
    <member name="M:BEPUphysics.Paths.Path`1.Evaluate(System.Double,`0@)">
      <summary>
            Computes the value of the path at a given time.
            </summary>
      <param name="time">Time at which to evaluate the path.</param>
      <param name="value">Path value at the given time.</param>
    </member>
    <member name="M:BEPUphysics.Paths.Path`1.GetPathBoundsInformation(System.Single@,System.Single@)">
      <summary>
            Gets the starting and ending times of the path.
            </summary>
      <param name="startingTime">Beginning time of the path.</param>
      <param name="endingTime">Ending time of the path.</param>
    </member>
    <member name="M:BEPUphysics.Paths.Path`1.Evaluate(System.Double)">
      <summary>
            Computes the value of the path at a given time.
            </summary>
      <param name="time">Time at which to evaluate the path.</param>
      <returns>Path value at the given time.</returns>
    </member>
    <member name="T:BEPUphysics.Paths.SpeedControlledCurve`1">
      <summary>
            Wrapper that controls the speed at which a curve is traversed.
            </summary>
      <remarks>
        <para>
            Even if a curve is evaluated at linearly increasing positions,
            the distance between consecutive values can be different.  This
            has the effect of a curve-following object having variable velocity.
            </para>
        <para>
            To counteract the variable velocity, this wrapper samples the curve
            and produces a reparameterized, distance-based curve.  Changing the
            evaluated curve position will linearly change the value.
            </para>
      </remarks>
    </member>
    <member name="M:BEPUphysics.Paths.SpeedControlledCurve`1.#ctor">
      <summary>
            Constructs a new speed controlled curve.
            </summary>
    </member>
    <member name="M:BEPUphysics.Paths.SpeedControlledCurve`1.#ctor(BEPUphysics.Paths.Curve{`0})">
      <summary>
            Constructs a new speed-controlled curve.
            </summary>
      <param name="curve">Curve to wrap.</param>
    </member>
    <member name="M:BEPUphysics.Paths.SpeedControlledCurve`1.#ctor(BEPUphysics.Paths.Curve{`0},System.Int32)">
      <summary>
            Constructs a new speed-controlled curve.
            </summary>
      <param name="curve">Curve to wrap.</param>
      <param name="samplesPerInterval">Number of samples to use when constructing the wrapper curve.
            More samples increases the accuracy of the speed requirement at the cost of performance.</param>
    </member>
    <member name="M:BEPUphysics.Paths.SpeedControlledCurve`1.GetSpeedAtCurveTime(System.Single)">
      <summary>
            Gets the desired speed at a given time.
            </summary>
      <param name="time">Time to check for speed.</param>
      <returns>Speed at the given time.</returns>
    </member>
    <member name="M:BEPUphysics.Paths.SpeedControlledCurve`1.Evaluate(System.Double,`0@)">
      <summary>
            Computes the value of the curve at a given time.
            </summary>
      <param name="time">Time to evaluate the curve at.</param>
      <param name="value">Value of the curve at the given time.</param>
    </member>
    <member name="M:BEPUphysics.Paths.SpeedControlledCurve`1.GetPathBoundsInformation(System.Single@,System.Single@)">
      <summary>
            Gets the starting and ending times of the path.
            </summary>
      <param name="startingTime">Beginning time of the path.</param>
      <param name="endingTime">Ending time of the path.</param>
    </member>
    <member name="M:BEPUphysics.Paths.SpeedControlledCurve`1.ResampleCurve">
      <summary>
            Forces a recalculation of curve samples.
            This needs to be called if the wrapped curve
            is changed.
            </summary>
    </member>
    <member name="M:BEPUphysics.Paths.SpeedControlledCurve`1.GetDistance(`0,`0)">
      <summary>
            Computes the distance between the two values.
            </summary>
      <param name="start">Starting value.</param>
      <param name="end">Ending value.</param>
      <returns>Distance between the values.</returns>
    </member>
    <member name="P:BEPUphysics.Paths.SpeedControlledCurve`1.Curve">
      <summary>
            Gets or sets the curve wrapped by this instance.
            </summary>
    </member>
    <member name="P:BEPUphysics.Paths.SpeedControlledCurve`1.PostLoop">
      <summary>
            Defines how the curve is sampled when the evaluation time exceeds the final control point.
            </summary>
    </member>
    <member name="P:BEPUphysics.Paths.SpeedControlledCurve`1.PreLoop">
      <summary>
            Defines how the curve is sampled when the evaluation time exceeds the beginning control point.
            </summary>
    </member>
    <member name="P:BEPUphysics.Paths.SpeedControlledCurve`1.SamplesPerInterval">
      <summary>
            Gets or sets the number of samples to use per interval in the curve.
            </summary>
    </member>
    <member name="T:BEPUphysics.Paths.VariableSpeedCurve`1">
      <summary>
            Curve that wraps another curve and travels along it with specified speeds.
            </summary>
      <typeparam name="TValue">Type of the value of the wrapped curve.</typeparam>
    </member>
    <member name="M:BEPUphysics.Paths.VariableSpeedCurve`1.#ctor(BEPUphysics.Paths.Path{System.Single},BEPUphysics.Paths.Curve{`0})">
      <summary>
            Constructs a new constant speed curve.
            </summary>
      <param name="speedCurve">Curve defining speeds to use.</param>
      <param name="curve">Curve to wrap.</param>
    </member>
    <member name="M:BEPUphysics.Paths.VariableSpeedCurve`1.#ctor(BEPUphysics.Paths.Path{System.Single},BEPUphysics.Paths.Curve{`0},System.Int32)">
      <summary>
            Constructs a new constant speed curve.
            </summary>
      <param name="speedCurve">Curve defining speeds to use.</param>
      <param name="curve">Curve to wrap.</param>
      <param name="sampleCount">Number of samples to use when constructing the wrapper curve.
            More samples increases the accuracy of the speed requirement at the cost of performance.</param>
    </member>
    <member name="M:BEPUphysics.Paths.VariableSpeedCurve`1.GetSpeedAtCurveTime(System.Single)">
      <summary>
            Gets the speed at a given time on the wrapped curve.
            </summary>
      <param name="time">Time to evaluate.</param>
      <returns>Speed at the given time.</returns>
    </member>
    <member name="P:BEPUphysics.Paths.VariableSpeedCurve`1.SpeedCurve">
      <summary>
            Gets or sets the path that defines the speeds at given locations.
            The speed curve will be sampled at times associated with the wrapped curve.
            </summary>
    </member>
    <member name="T:BEPUphysics.Paths.VariableLinearSpeedCurve">
      <summary>
            Wraps a curve that is traveled along with arbitrary defined linear speed.
            </summary>
      <remarks>
            The speed curve should be designed with the wrapped curve's times in mind.
            Speeds will be sampled based on the wrapped curve's interval.</remarks>
    </member>
    <member name="M:BEPUphysics.Paths.VariableLinearSpeedCurve.#ctor(BEPUphysics.Paths.Path{System.Single},BEPUphysics.Paths.Curve{Microsoft.Xna.Framework.Vector3})">
      <summary>
            Constructs a new variable speed curve.
            </summary>
      <param name="speedCurve">Curve defining speeds to use.</param>
      <param name="curve">Curve to wrap.</param>
    </member>
    <member name="M:BEPUphysics.Paths.VariableLinearSpeedCurve.#ctor(BEPUphysics.Paths.Path{System.Single},BEPUphysics.Paths.Curve{Microsoft.Xna.Framework.Vector3},System.Int32)">
      <summary>
            Constructs a new variable speed curve.
            </summary>
      <param name="speedCurve">Curve defining speeds to use.</param>
      <param name="curve">Curve to wrap.</param>
      <param name="sampleCount">Number of samples to use when constructing the wrapper curve.
            More samples increases the accuracy of the speed requirement at the cost of performance.</param>
    </member>
    <member name="T:BEPUphysics.Paths.VariableAngularSpeedCurve">
      <summary>
            Wraps a curve that is traveled along with arbitrary defined angular speed.
            </summary>
      <remarks>
            The speed curve should be designed with the wrapped curve's times in mind.
            Speeds will be sampled based on the wrapped curve's interval.</remarks>
    </member>
    <member name="M:BEPUphysics.Paths.VariableAngularSpeedCurve.#ctor(BEPUphysics.Paths.Path{System.Single},BEPUphysics.Paths.Curve{Microsoft.Xna.Framework.Quaternion})">
      <summary>
            Constructs a new variable speed curve.
            </summary>
      <param name="speedCurve">Curve defining speeds to use.</param>
      <param name="curve">Curve to wrap.</param>
    </member>
    <member name="M:BEPUphysics.Paths.VariableAngularSpeedCurve.#ctor(BEPUphysics.Paths.Path{System.Single},BEPUphysics.Paths.Curve{Microsoft.Xna.Framework.Quaternion},System.Int32)">
      <summary>
            Constructs a new variable speed curve.
            </summary>
      <param name="speedCurve">Curve defining speeds to use.</param>
      <param name="curve">Curve to wrap.</param>
      <param name="sampleCount">Number of samples to use when constructing the wrapper curve.
            More samples increases the accuracy of the speed requirement at the cost of performance.</param>
    </member>
    <member name="T:BEPUphysics.Paths.CurveControlPoint`1">
      <summary>
            Point defining the shape of a 3D curve.
            </summary>
      <typeparam name="TValue">Type of values in the curve.</typeparam>
    </member>
    <member name="M:BEPUphysics.Paths.CurveControlPoint`1.#ctor(System.Single,`0,BEPUphysics.Paths.Curve{`0})">
      <summary>
            Constructs a new 3D curve control point.
            </summary>
      <param name="time">Time at which the point is positioned.</param>
      <param name="value">Value of the control point.</param>
      <param name="curve">Curve associated with the control point.</param>
    </member>
    <member name="M:BEPUphysics.Paths.CurveControlPoint`1.CompareTo(BEPUphysics.Paths.CurveControlPoint{`0})">
      <summary>
            Compares the two control points based on their time.
            </summary>
      <param name="other">Control point to compare.</param>
      <returns>-1 if the current instance has a smaller time, 0 if equal, and 1 if the current instance has a larger time.</returns>
    </member>
    <member name="P:BEPUphysics.Paths.CurveControlPoint`1.Curve">
      <summary>
            Gets the curve associated with this control point.
            </summary>
    </member>
    <member name="P:BEPUphysics.Paths.CurveControlPoint`1.Time">
      <summary>
            Gets or sets the time at which this control point is positioned.
            </summary>
    </member>
    <member name="P:BEPUphysics.Paths.CurveControlPoint`1.Value">
      <summary>
            Gets or sets the value of this control point.
            </summary>
    </member>
    <member name="T:BEPUphysics.BroadPhaseSystems.IBoundingBoxOwner">
      <summary>
             Requires that a class have a BoundingBox.
            </summary>
    </member>
    <member name="P:BEPUphysics.BroadPhaseSystems.IBoundingBoxOwner.BoundingBox">
      <summary>
             Gets the bounding box of the object.
            </summary>
    </member>
    <member name="T:BEPUphysics.BroadPhaseSystems.BroadPhaseEntry">
      <summary>
            Superclass of all objects which live inside the broad phase.
            The BroadPhase will generate pairs between BroadPhaseEntries.
            </summary>
    </member>
    <member name="M:BEPUphysics.BroadPhaseSystems.BroadPhaseEntry.GetHashCode">
      <summary>
            Gets the object's hash code.
            </summary>
      <returns>Hash code for the object.</returns>
    </member>
    <member name="M:BEPUphysics.BroadPhaseSystems.BroadPhaseEntry.RayCast(Microsoft.Xna.Framework.Ray,System.Single,BEPUphysics.RayHit@)">
      <summary>
            Tests a ray against the entry.
            </summary>
      <param name="ray">Ray to test.</param>
      <param name="maximumLength">Maximum length, in units of the ray's direction's length, to test.</param>
      <param name="rayHit">Hit location of the ray on the entry, if any.</param>
      <returns>Whether or not the ray hit the entry.</returns>
    </member>
    <member name="P:BEPUphysics.BroadPhaseSystems.BroadPhaseEntry.BoundingBox">
      <summary>
            Gets the bounding box of the entry.
            </summary>
    </member>
    <member name="P:BEPUphysics.BroadPhaseSystems.BroadPhaseEntry.CollisionRules">
      <summary>
            Gets the entry's collision rules.
            </summary>
    </member>
    <member name="P:BEPUphysics.BroadPhaseSystems.BroadPhaseEntry.Tag">
      <summary>
            Gets or sets the user data associated with this entry.
            </summary>
    </member>
    <member name="T:BEPUphysics.Collidables.Collidable">
      <summary>
             Superclass of objects living in the collision detection pipeline
             that can result in contacts.
            </summary>
    </member>
    <member name="P:BEPUphysics.Collidables.Collidable.Shape">
      <summary>
             Gets the shape used by the collidable.
            </summary>
    </member>
    <member name="P:BEPUphysics.Collidables.Collidable.IgnoreShapeChanges">
      <summary>
            Gets or sets whether or not to ignore shape changes.  When true, changing the collision shape will not force an update of maximum or minimum radii.
            </summary>
    </member>
    <member name="P:BEPUphysics.Collidables.Collidable.Pairs">
      <summary>
             Gets the list of pairs associated with the collidable.
             These pairs are found by the broad phase and are managed by the narrow phase;
             they can contain other collidables, entities, and contacts.
            </summary>
    </member>
    <member name="P:BEPUphysics.Collidables.Collidable.OverlappedCollidables">
      <summary>
             Gets a list of all other collidables that this collidable overlaps.
            </summary>
    </member>
    <member name="T:BEPUphysics.UpdateableSystems.ForceFields.ForceFieldShape">
      <summary>
            Superclass of force field shapes that test whether or not entities are affected by a forcefield.
            </summary>
    </member>
    <member name="M:BEPUphysics.UpdateableSystems.ForceFields.ForceFieldShape.GetPossiblyAffectedEntities">
      <summary>
            Uses an efficient query to see what entities may be affected.
            Usually uses a broadphase bounding box query.
            </summary>
      <returns>Possibly affected entities.</returns>
    </member>
    <member name="M:BEPUphysics.UpdateableSystems.ForceFields.ForceFieldShape.IsEntityAffected(BEPUphysics.Entities.Entity)">
      <summary>
            Performs a narrow-phase test to see if an entity is affected by the force field.
            </summary>
      <param name="entity">Entity to test.</param>
      <returns>Whether or not the entity is affected.</returns>
    </member>
    <member name="P:BEPUphysics.UpdateableSystems.ForceFields.ForceFieldShape.ForceField">
      <summary>
            Force field associated with this shape.
            </summary>
    </member>
    <member name="T:BEPUphysics.UpdateableSystems.ForceFields.InfiniteForceFieldShape">
      <summary>
            Defines the area in which a force field works using an entity's shape.
            </summary>
    </member>
    <member name="M:BEPUphysics.UpdateableSystems.ForceFields.InfiniteForceFieldShape.GetPossiblyAffectedEntities">
      <summary>
            Determines the possibly involved entities.
            </summary>
      <returns>Possibly involved entities.</returns>
    </member>
    <member name="M:BEPUphysics.UpdateableSystems.ForceFields.InfiniteForceFieldShape.IsEntityAffected(BEPUphysics.Entities.Entity)">
      <summary>
            Determines if the entity is affected by the force field.
            </summary>
      <param name="testEntity">Entity to test.</param>
      <returns>Whether the entity is affected.</returns>
    </member>
    <member name="T:BEPUphysics.DataStructures.ReadOnlyEnumerable`1">
      <summary>
             WRaps an enumerable in a temporary enumeration struct.
            </summary>
      <typeparam name="T">Type of the enumerable being iterated.</typeparam>
    </member>
    <member name="M:BEPUphysics.DataStructures.ReadOnlyEnumerable`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
      <summary>
             Constructs a new read only enumerable.
            </summary>
      <param name="enumerable">Enumerable to wrap.</param>
    </member>
    <member name="M:BEPUphysics.DataStructures.ReadOnlyEnumerable`1.GetEnumerator">
      <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
      <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1" /> that can be used to iterate through the collection.
            </returns>
      <filterpriority>1</filterpriority>
    </member>
    <member name="T:BEPUphysics.DataStructures.ReadOnlyDictionary`2">
      <summary>
             Wraps a dictionary in a read only collection.
            </summary>
      <typeparam name="TKey">Type of keys in the dictionary.</typeparam>
      <typeparam name="TValue">Type of values in the dictionary.</typeparam>
    </member>
    <member name="M:BEPUphysics.DataStructures.ReadOnlyDictionary`2.#ctor(System.Collections.Generic.IDictionary{`0,`1})">
      <summary>
            Constructs a new read-only wrapper dictionary.
            </summary>
      <param name="dictionary">Internal dictionary to use.</param>
    </member>
    <member name="M:BEPUphysics.DataStructures.ReadOnlyDictionary`2.Contains(System.Collections.Generic.KeyValuePair{`0,`1})">
      <summary>
            Determines if the dictionary contains a key-value pair.
            </summary>
      <param name="item">Key-value pair to look for.</param>
      <returns>Whether or not the key-value pair is present.</returns>
    </member>
    <member name="M:BEPUphysics.DataStructures.ReadOnlyDictionary`2.ContainsKey(`0)">
      <summary>
            Determines if the dictionary contains a given key.
            </summary>
      <param name="key">Key to check for.</param>
      <returns>Whether or not the key is contained.</returns>
    </member>
    <member name="M:BEPUphysics.DataStructures.ReadOnlyDictionary`2.CopyTo(System.Collections.Generic.KeyValuePair{`0,`1}[],System.Int32)">
      <summary>
            Copies the key-value pairs of the dictionary into an array.
            </summary>
      <param name="array">Target array.</param>
      <param name="arrayIndex">The zero-based index at which copying begins.</param>
    </member>
    <member name="M:BEPUphysics.DataStructures.ReadOnlyDictionary`2.TryGetValue(`0,`1@)">
      <summary>
            Tries to retrieve a value from the dictionary using a key.
            </summary>
      <param name="key">Key to look for.</param>
      <param name="value">Value associated with the key.</param>
      <returns>Whether or not the key exists.</returns>
    </member>
    <member name="P:BEPUphysics.DataStructures.ReadOnlyDictionary`2.Count">
      <summary>
            Gets the number of elements in the dictionary.
            </summary>
    </member>
    <member name="P:BEPUphysics.DataStructures.ReadOnlyDictionary`2.IsReadOnly">
      <summary>
            Gets whether or not this dictionary is read-only.
            </summary>
    </member>
    <member name="P:BEPUphysics.DataStructures.ReadOnlyDictionary`2.Item(`0)">
      <summary>
            Gets the value associated with the key in the dictionary.
            </summary>
      <param name="key">Key to look for in the dictionary.</param>
      <returns>Value associated with the key.</returns>
    </member>
    <member name="P:BEPUphysics.DataStructures.ReadOnlyDictionary`2.Keys">
      <summary>
            Gets an enumerable set of keys in the dictionary.
            </summary>
    </member>
    <member name="P:BEPUphysics.DataStructures.ReadOnlyDictionary`2.Values">
      <summary>
            Gets an enumerable set of values in the dictionary.
            </summary>
    </member>
    <member name="T:BEPUphysics.DataStructures.RawList`1">
      <summary>
             No-frills list that wraps an accessible array.
            </summary>
      <typeparam name="T">Type of elements contained by the list.</typeparam>
    </member>
    <member name="T:BEPUphysics.DataStructures.RawList`1.Enumerator">
      <summary>
             Enumerator for the RawList.
            </summary>
    </member>
    <member name="F:BEPUphysics.DataStructures.RawList`1.Elements">
      <summary>
             Direct access to the elements owned by the raw list.
             Be careful about the operations performed on this list;
             use the normal access methods if in doubt.
            </summary>
    </member>
    <member name="M:BEPUphysics.DataStructures.RawList`1.#ctor">
      <summary>
             Constructs an empty list.
            </summary>
    </member>
    <member name="M:BEPUphysics.DataStructures.RawList`1.#ctor(System.Int32)">
      <summary>
             Constructs an empty list.
            </summary>
      <param name="initialCapacity">Initial capacity to allocate for the list.</param>
      <exception cref="T:System.ArgumentException">Thrown when the initial capacity is zero or negative.</exception>
    </member>
    <member name="M:BEPUphysics.DataStructures.RawList`1.#ctor(System.Collections.Generic.IList{`0})">
      <summary>
             Constructs a raw list from another list.
            </summary>
      <param name="elements">List to copy.</param>
    </member>
    <member name="M:BEPUphysics.DataStructures.RawList`1.Add(`0)">
      <summary>
            Adds an item to the <see cref="T:System.Collections.Generic.ICollection`1" />.
            </summary>
      <param name="item">The object to add to the <see cref="T:System.Collections.Generic.ICollection`1" />.</param>
      <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.Generic.ICollection`1" /> is read-only.</exception>
    </member>
    <member name="M:BEPUphysics.DataStructures.RawList`1.AddRange(BEPUphysics.DataStructures.RawList{`0})">
      <summary>
             Adds a range of elements to the list from another list.
            </summary>
      <param name="items">Elements to add.</param>
    </member>
    <member name="M:BEPUphysics.DataStructures.RawList`1.AddRange(System.Collections.Generic.List{`0})">
      <summary>
             Adds a range of elements to the list from another list.
            </summary>
      <param name="items">Elements to add.</param>
    </member>
    <member name="M:BEPUphysics.DataStructures.RawList`1.Clear">
      <summary>
            Removes all items from the <see cref="T:System.Collections.Generic.ICollection`1" />.
            </summary>
      <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.Generic.ICollection`1" /> is read-only. </exception>
    </member>
    <member name="M:BEPUphysics.DataStructures.RawList`1.Remove(`0)">
      <summary>
            Removes the first occurrence of a specific object from the <see cref="T:System.Collections.Generic.ICollection`1" />.
            </summary>
      <returns>
            true if <paramref name="item" /> was successfully removed from the <see cref="T:System.Collections.Generic.ICollection`1" />; otherwise, false. This method also returns false if <paramref name="item" /> is not found in the original <see cref="T:System.Collections.Generic.ICollection`1" />.
            </returns>
      <param name="item">The object to remove from the <see cref="T:System.Collections.Generic.ICollection`1" />.</param>
      <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.Generic.ICollection`1" /> is read-only.</exception>
    </member>
    <member name="M:BEPUphysics.DataStructures.RawList`1.IndexOf(`0)">
      <summary>
            Determines the index of a specific item in the <see cref="T:System.Collections.Generic.IList`1" />.
            </summary>
      <returns>
            The index of <paramref name="item" /> if found in the list; otherwise, -1.
            </returns>
      <param name="item">The object to locate in the <see cref="T:System.Collections.Generic.IList`1" />.</param>
    </member>
    <member name="M:BEPUphysics.DataStructures.RawList`1.GetEnumerator">
      <summary>
             Gets an enumerator for the list.
            </summary>
      <returns>Enumerator for the list.</returns>
    </member>
    <member name="M:BEPUphysics.DataStructures.RawList`1.Sort(System.Collections.Generic.IComparer{`0})">
      <summary>
             Sorts the list.
            </summary>
      <param name="comparer">Comparer to use to sort the list.</param>
    </member>
    <member name="P:BEPUphysics.DataStructures.RawList`1.Count">
      <summary>
            Gets the number of elements contained in the <see cref="T:System.Collections.Generic.ICollection`1" />.
            </summary>
      <returns>
            The number of elements contained in the <see cref="T:System.Collections.Generic.ICollection`1" />.
            </returns>
    </member>
    <member name="P:BEPUphysics.DataStructures.RawList`1.Capacity">
      <summary>
             Gets or sets the current size allocated for the list.
            </summary>
    </member>
    <member name="T:BEPUphysics.NarrowPhaseSystems.Factories.TerrainConvexPairFactory">
      <summary>
             Manufactures terrain-convex pairs.
            </summary>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.Factories.TerrainConvexPairFactory.GetNarrowPhasePair(BEPUphysics.BroadPhaseSystems.BroadPhaseOverlap)">
      <summary>
             Manufactures and returns a narrow phase pair for the given overlap.
            </summary>
      <param name="overlap">Overlap used to create a pair.</param>
      <returns>Narrow phase pair.</returns>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.Factories.TerrainConvexPairFactory.GiveBack(BEPUphysics.NarrowPhaseSystems.Pairs.INarrowPhasePair)">
      <summary>
            Returns a pair to the factory for re-use.
            </summary>
      <param name="pair">Pair to return.</param>
    </member>
    <member name="T:BEPUphysics.Entities.EntityConstraintCollection">
      <summary>
             Convenience collection for easily scanning the two entity constraints connected to an entity.
            </summary>
    </member>
    <member name="T:BEPUphysics.Entities.EntityConstraintCollection.Enumerator">
      <summary>
             Enumerator for the EntityConstraintCollection.
            </summary>
    </member>
    <member name="M:BEPUphysics.Entities.EntityConstraintCollection.Enumerator.#ctor(System.Collections.Generic.List{BEPUphysics.DeactivationManagement.ISimulationIslandConnection})">
      <summary>
            Constructs an enumerator for the solver updateables list.
            </summary>
      <param name="connections">List of solver updateables to enumerate.</param>
    </member>
    <member name="M:BEPUphysics.Entities.EntityConstraintCollection.Enumerator.Dispose">
      <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
      <filterpriority>2</filterpriority>
    </member>
    <member name="M:BEPUphysics.Entities.EntityConstraintCollection.Enumerator.MoveNext">
      <summary>
            Advances the enumerator to the next element of the collection.
            </summary>
      <returns>
            true if the enumerator was successfully advanced to the next element; false if the enumerator has passed the end of the collection.
            </returns>
      <exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created. </exception>
      <filterpriority>2</filterpriority>
    </member>
    <member name="M:BEPUphysics.Entities.EntityConstraintCollection.Enumerator.Reset">
      <summary>
            Sets the enumerator to its initial position, which is before the first element in the collection.
            </summary>
      <exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created. </exception>
      <filterpriority>2</filterpriority>
    </member>
    <member name="P:BEPUphysics.Entities.EntityConstraintCollection.Enumerator.Current">
      <summary>
            Gets the element in the collection at the current position of the enumerator.
            </summary>
      <returns>
            The element in the collection at the current position of the enumerator.
            </returns>
    </member>
    <member name="M:BEPUphysics.Entities.EntityConstraintCollection.#ctor(System.Collections.Generic.List{BEPUphysics.DeactivationManagement.ISimulationIslandConnection})">
      <summary>
            Constructs a new constraint collection.
            </summary>
      <param name="connections">Solver updateables to enumerate over.</param>
    </member>
    <member name="M:BEPUphysics.Entities.EntityConstraintCollection.GetEnumerator">
      <summary>
            Gets an enumerator for the collection.
            </summary>
      <returns>Enumerator for the collection.</returns>
    </member>
    <member name="T:BEPUphysics.Constraints.TwoEntity.TwoEntityConstraint">
      <summary>
            Abstract superclass of constraints involving two bodies.
            </summary>
    </member>
    <member name="F:BEPUphysics.Constraints.TwoEntity.TwoEntityConstraint.WorldEntity">
      <summary>
            Entity that constraints connect to when they are given a null connection.
            </summary>
    </member>
    <member name="F:BEPUphysics.Constraints.TwoEntity.TwoEntityConstraint.connectionA">
      <summary>
            First connection to the constraint.
            </summary>
    </member>
    <member name="F:BEPUphysics.Constraints.TwoEntity.TwoEntityConstraint.connectionB">
      <summary>
            Second connection to the constraint.
            </summary>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.TwoEntityConstraint.CollectInvolvedEntities(BEPUphysics.DataStructures.RawList{BEPUphysics.Entities.Entity})">
      <summary>
            Adds entities associated with the solver item to the involved entities list.
            Ensure that sortInvolvedEntities() is called at the end of the function.
            This allows the non-batched multithreading system to lock properly.
            </summary>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.TwoEntityConstraint.UpdateSolverActivity">
      <summary>
            Sets the activity state of the constraint based on the activity state of its connections.
            Called automatically by the space owning a constaint.  If a constraint is a sub-constraint that hasn't been directly added to the space,
            this may need to be called alongside the preStep from within the parent constraint.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.TwoEntityConstraint.ConnectionA">
      <summary>
            Gets or sets the first connection to the constraint.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.TwoEntityConstraint.ConnectionB">
      <summary>
            Gets or sets the second connection to the constraint.
            </summary>
    </member>
    <member name="T:BEPUphysics.Constraints.TwoEntity.Joints.Joint">
      <summary>
            Superclass of position-based constraints.
            </summary>
    </member>
    <member name="F:BEPUphysics.Constraints.TwoEntity.Joints.Joint.maxCorrectiveVelocity">
      <summary>
            Maximum extra velocity that the constraint will apply in an effort to correct constraint error.
            </summary>
    </member>
    <member name="F:BEPUphysics.Constraints.TwoEntity.Joints.Joint.maxCorrectiveVelocitySquared">
      <summary>
            Squared maximum extra velocity that the constraint will apply in an effort to correct constraint error.
            </summary>
    </member>
    <member name="F:BEPUphysics.Constraints.TwoEntity.Joints.Joint.springSettings">
      <summary>
            Spring settings define how a constraint responds to velocity and position error.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.Joints.Joint.MaxCorrectiveVelocity">
      <summary>
            Gets or sets the maximum extra velocity that the constraint will apply in an effort to correct any constraint error.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.Joints.Joint.SpringSettings">
      <summary>
            Gets the spring settings used by the constraint.
            Spring settings define how a constraint responds to velocity and position error.
            </summary>
    </member>
    <member name="T:BEPUphysics.Constraints.TwoEntity.JointLimits.JointLimit">
      <summary>
            Superclass of constraints which have a limited area of free movement.
            </summary>
    </member>
    <member name="F:BEPUphysics.Constraints.TwoEntity.JointLimits.JointLimit.bounceVelocityThreshold">
      <summary>
            Minimum velocity necessary for a bounce to occur at a joint limit.
            </summary>
    </member>
    <member name="F:BEPUphysics.Constraints.TwoEntity.JointLimits.JointLimit.bounciness">
      <summary>
            Bounciness of this joint limit.  0 is completely inelastic; 1 is completely elastic.
            </summary>
    </member>
    <member name="F:BEPUphysics.Constraints.TwoEntity.JointLimits.JointLimit.margin">
      <summary>
            Small area that the constraint can be violated without applying position correction.  Helps avoid jitter.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.JointLimits.JointLimit.BounceVelocityThreshold">
      <summary>
            Gets or sets the minimum velocity necessary for a bounce to occur at a joint limit.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.JointLimits.JointLimit.Bounciness">
      <summary>
            Gets or sets the bounciness of this joint limit.  0 is completely inelastic; 1 is completely elastic.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.JointLimits.JointLimit.IsLimitActive">
      <summary>
            Gets whether or not the limit is currently working.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.JointLimits.JointLimit.Margin">
      <summary>
            Gets or sets the small area that the constraint can be violated without applying position correction.  Helps avoid jitter.
            </summary>
    </member>
    <member name="T:BEPUphysics.Constraints.I1DImpulseConstraint">
      <summary>
            Implemented by solver updateables which have a one dimensional impulse.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.I1DImpulseConstraint.RelativeVelocity">
      <summary>
            Gets the current relative velocity of the constraint.
            Computed based on the current connection velocities and jacobians.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.I1DImpulseConstraint.TotalImpulse">
      <summary>
            Gets the total impulse a constraint has applied.
            </summary>
    </member>
    <member name="T:BEPUphysics.Constraints.I1DImpulseConstraintWithError">
      <summary>
            Implemented by solver updateables which have a one dimensional impulse.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.I1DImpulseConstraintWithError.Error">
      <summary>
            Gets the current constraint error.
            </summary>
    </member>
    <member name="T:BEPUphysics.Constraints.I1DJacobianConstraint">
      <summary>
            Denotes a class that uses a single linear jacobian axis.
            </summary>
    </member>
    <member name="M:BEPUphysics.Constraints.I1DJacobianConstraint.GetAngularJacobianA(Microsoft.Xna.Framework.Vector3@)">
      <summary>
            Gets the angular jacobian entry for the first connected entity.
            </summary>
      <param name="jacobian">Angular jacobian entry for the first connected entity.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.I1DJacobianConstraint.GetAngularJacobianB(Microsoft.Xna.Framework.Vector3@)">
      <summary>
            Gets the angular jacobian entry for the second connected entity.
            </summary>
      <param name="jacobian">Angular jacobian entry for the second connected entity.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.I1DJacobianConstraint.GetLinearJacobianA(Microsoft.Xna.Framework.Vector3@)">
      <summary>
            Gets the linear jacobian entry for the first connected entity.
            </summary>
      <param name="jacobian">Linear jacobian entry for the first connected entity.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.I1DJacobianConstraint.GetLinearJacobianB(Microsoft.Xna.Framework.Vector3@)">
      <summary>
            Gets the linear jacobian entry for the second connected entity.
            </summary>
      <param name="jacobian">Linear jacobian entry for the second connected entity.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.I1DJacobianConstraint.GetMassMatrix(System.Single@)">
      <summary>
            Gets the mass matrix of the constraint.
            </summary>
      <param name="outputMassMatrix">Constraint's mass matrix.</param>
    </member>
    <member name="T:BEPUphysics.Constraints.TwoEntity.JointLimits.LinearAxisLimit">
      <summary>
            Constrains the distance along an axis between anchor points attached to two entities.
            </summary>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.JointLimits.LinearAxisLimit.#ctor">
      <summary>
            Constructs a constraint which tries to keep anchors on two entities within a certain distance of each other along an axis.
            To finish the initialization, specify the connections (ConnectionA and ConnectionB) 
            as well as the AnchorA, AnchorB, and Axis (or their entity-local versions),
            and the Minimum and Maximum.
            This constructor sets the constraint's IsActive property to false by default.
            </summary>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.JointLimits.LinearAxisLimit.#ctor(BEPUphysics.Entities.Entity,BEPUphysics.Entities.Entity,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,System.Single,System.Single)">
      <summary>
            Constructs a constraint which tries to keep anchors on two entities within a certain distance of each other along an axis.
            </summary>
      <param name="connectionA">First connection of the pair.</param>
      <param name="connectionB">Second connection of the pair.</param>
      <param name="anchorA">World space point to attach to connection A that will be constrained.</param>
      <param name="anchorB">World space point to attach to connection B that will be constrained.</param>
      <param name="axis">Limited axis in world space to attach to connection A.</param>
      <param name="minimum">Minimum allowed position along the axis.</param>
      <param name="maximum">Maximum allowed position along the axis.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.JointLimits.LinearAxisLimit.GetLinearJacobianA(Microsoft.Xna.Framework.Vector3@)">
      <summary>
            Gets the linear jacobian entry for the first connected entity.
            </summary>
      <param name="jacobian">Linear jacobian entry for the first connected entity.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.JointLimits.LinearAxisLimit.GetLinearJacobianB(Microsoft.Xna.Framework.Vector3@)">
      <summary>
            Gets the linear jacobian entry for the second connected entity.
            </summary>
      <param name="jacobian">Linear jacobian entry for the second connected entity.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.JointLimits.LinearAxisLimit.GetAngularJacobianA(Microsoft.Xna.Framework.Vector3@)">
      <summary>
            Gets the angular jacobian entry for the first connected entity.
            </summary>
      <param name="jacobian">Angular jacobian entry for the first connected entity.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.JointLimits.LinearAxisLimit.GetAngularJacobianB(Microsoft.Xna.Framework.Vector3@)">
      <summary>
            Gets the angular jacobian entry for the second connected entity.
            </summary>
      <param name="jacobian">Angular jacobian entry for the second connected entity.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.JointLimits.LinearAxisLimit.GetMassMatrix(System.Single@)">
      <summary>
            Gets the mass matrix of the constraint.
            </summary>
      <param name="outputMassMatrix">Constraint's mass matrix.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.JointLimits.LinearAxisLimit.SolveIteration">
      <summary>
            Computes one iteration of the constraint to meet the solver updateable's goal.
            </summary>
      <returns>The rough applied impulse magnitude.</returns>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.JointLimits.LinearAxisLimit.Update(System.Single)">
      <summary>
             Performs the frame's configuration step.
            </summary>
      <param name="dt">Timestep duration.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.JointLimits.LinearAxisLimit.ExclusiveUpdate">
      <summary>
            Performs any pre-solve iteration work that needs exclusive
            access to the members of the solver updateable.
            Usually, this is used for applying warmstarting impulses.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.JointLimits.LinearAxisLimit.AnchorA">
      <summary>
            Gets or sets the anchor point attached to entity A in world space.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.JointLimits.LinearAxisLimit.AnchorB">
      <summary>
            Gets or sets the anchor point attached to entity A in world space.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.JointLimits.LinearAxisLimit.Axis">
      <summary>
            Gets or sets the limited axis in world space.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.JointLimits.LinearAxisLimit.LocalAxis">
      <summary>
            Gets or sets the limited axis in the local space of connection A.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.JointLimits.LinearAxisLimit.LocalOffsetA">
      <summary>
            Gets or sets the offset from the first entity's center of mass to the anchor point in its local space.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.JointLimits.LinearAxisLimit.LocalOffsetB">
      <summary>
            Gets or sets the offset from the second entity's center of mass to the anchor point in its local space.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.JointLimits.LinearAxisLimit.Maximum">
      <summary>
            Gets or sets the maximum allowed distance along the axis.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.JointLimits.LinearAxisLimit.Minimum">
      <summary>
            Gets or sets the minimum allowed distance along the axis.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.JointLimits.LinearAxisLimit.OffsetA">
      <summary>
            Gets or sets the offset from the first entity's center of mass to the anchor point in world space.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.JointLimits.LinearAxisLimit.OffsetB">
      <summary>
            Gets or sets the offset from the second entity's center of mass to the anchor point in world space.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.JointLimits.LinearAxisLimit.RelativeVelocity">
      <summary>
            Gets the current relative velocity between the connected entities with respect to the constraint.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.JointLimits.LinearAxisLimit.TotalImpulse">
      <summary>
            Gets the total impulse applied by this constraint.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.JointLimits.LinearAxisLimit.Error">
      <summary>
            Gets the current constraint error.
            </summary>
    </member>
    <member name="T:BEPUphysics.Constraints.TwoEntity.JointLimits.EllipseSwingLimit">
      <summary>
            Constrains the relative orientation of two entities to within an ellipse.
            </summary>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.JointLimits.EllipseSwingLimit.#ctor">
      <summary>
            Constructs a new swing limit.
            To finish the initialization, specify the connections (ConnectionA and ConnectionB) 
            as well as the TwistAxis (or its entity-local version),
            the MaximumAngleX and MaximumAngleY,
            and the Basis.
            This constructor sets the constraint's IsActive property to false by default.
            </summary>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.JointLimits.EllipseSwingLimit.#ctor(BEPUphysics.Entities.Entity,BEPUphysics.Entities.Entity,Microsoft.Xna.Framework.Vector3,System.Single,System.Single)">
      <summary>
            Constructs a new swing limit.
            </summary>
      <param name="connectionA">First entity connected by the constraint.</param>
      <param name="connectionB">Second entity connected by the constraint.</param>
      <param name="twistAxis">Axis in world space to use as the initial unrestricted twist direction.
            This direction will be transformed to entity A's local space to form the basis's primary axis
            and to entity B's local space to form its twist axis.
            The basis's x and y axis are automatically created from the twist axis.</param>
      <param name="maximumAngleX">Maximum angle of rotation around the basis X axis.</param>
      <param name="maximumAngleY">Maximum angle of rotation around the basis Y axis.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.JointLimits.EllipseSwingLimit.#ctor(BEPUphysics.Entities.Entity,BEPUphysics.Entities.Entity)">
      <summary>
            Constructs a new swing limit.
            Using this constructor will leave the limit uninitialized.  Before using the limit in a simulation, be sure to set the basis axes using
            limit.basis.setLocalAxes or limit.basis.setWorldAxes and b's twist axis using the localTwistAxisB or twistAxisB properties.
            </summary>
      <param name="connectionA">First entity connected by the constraint.</param>
      <param name="connectionB">Second entity connected by the constraint.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.JointLimits.EllipseSwingLimit.GetLinearJacobianA(Microsoft.Xna.Framework.Vector3@)">
      <summary>
            Gets the linear jacobian entry for the first connected entity.
            </summary>
      <param name="jacobian">Linear jacobian entry for the first connected entity.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.JointLimits.EllipseSwingLimit.GetLinearJacobianB(Microsoft.Xna.Framework.Vector3@)">
      <summary>
            Gets the linear jacobian entry for the second connected entity.
            </summary>
      <param name="jacobian">Linear jacobian entry for the second connected entity.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.JointLimits.EllipseSwingLimit.GetAngularJacobianA(Microsoft.Xna.Framework.Vector3@)">
      <summary>
            Gets the angular jacobian entry for the first connected entity.
            </summary>
      <param name="jacobian">Angular jacobian entry for the first connected entity.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.JointLimits.EllipseSwingLimit.GetAngularJacobianB(Microsoft.Xna.Framework.Vector3@)">
      <summary>
            Gets the angular jacobian entry for the second connected entity.
            </summary>
      <param name="jacobian">Angular jacobian entry for the second connected entity.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.JointLimits.EllipseSwingLimit.GetMassMatrix(System.Single@)">
      <summary>
            Gets the mass matrix of the constraint.
            </summary>
      <param name="outputMassMatrix">Constraint's mass matrix.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.JointLimits.EllipseSwingLimit.SetupJointTransforms(Microsoft.Xna.Framework.Vector3)">
      <summary>
            Sets up the joint transforms by automatically creating perpendicular vectors to complete the bases.
            </summary>
      <param name="twistAxis">Axis around which rotation is allowed.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.JointLimits.EllipseSwingLimit.SolveIteration">
      <summary>
            Computes one iteration of the constraint to meet the solver updateable's goal.
            </summary>
      <returns>The rough applied impulse magnitude.</returns>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.JointLimits.EllipseSwingLimit.Update(System.Single)">
      <summary>
             Performs the frame's configuration step.
            </summary>
      <param name="dt">Timestep duration.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.JointLimits.EllipseSwingLimit.ExclusiveUpdate">
      <summary>
            Performs any pre-solve iteration work that needs exclusive
            access to the members of the solver updateable.
            Usually, this is used for applying warmstarting impulses.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.JointLimits.EllipseSwingLimit.Basis">
      <summary>
            Gets the basis attached to entity A.
            The primary axis is the "twist" axis attached to entity A.
            The xAxis is the axis around which the angle will be limited by maximumAngleX.
            Similarly, the yAxis is the axis around which the angle will be limited by maximumAngleY.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.JointLimits.EllipseSwingLimit.LocalTwistAxisB">
      <summary>
            Gets or sets the twist axis attached to entity B in its local space.
            The transformed twist axis will be used to determine the angles around entity A's basis axes.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.JointLimits.EllipseSwingLimit.MaximumAngleX">
      <summary>
            Gets or sets the maximum angle of rotation around the x axis.
            This can be thought of as the major radius of the swing limit's ellipse.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.JointLimits.EllipseSwingLimit.MaximumAngleY">
      <summary>
            Gets or sets the maximum angle of rotation around the y axis.
            This can be thought of as the minor radius of the swing limit's ellipse.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.JointLimits.EllipseSwingLimit.TwistAxisB">
      <summary>
            Gets or sets the twist axis attached to entity B in world space.
            The transformed twist axis will be used to determine the angles around entity A's basis axes.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.JointLimits.EllipseSwingLimit.RelativeVelocity">
      <summary>
            Gets the current relative velocity between the connected entities with respect to the constraint.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.JointLimits.EllipseSwingLimit.TotalImpulse">
      <summary>
            Gets the total impulse applied by this constraint.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.JointLimits.EllipseSwingLimit.Error">
      <summary>
            Gets the current constraint error.
            </summary>
    </member>
    <member name="T:BEPUphysics.Constraints.TwoEntity.JointLimits.DistanceLimit">
      <summary>
            A modified distance constraint allowing a range of lengths between two anchor points.
            </summary>
    </member>
    <member name="F:BEPUphysics.Constraints.TwoEntity.JointLimits.DistanceLimit.maximumLength">
      <summary>
            Maximum distance allowed between the anchors.
            </summary>
    </member>
    <member name="F:BEPUphysics.Constraints.TwoEntity.JointLimits.DistanceLimit.minimumLength">
      <summary>
            Minimum distance maintained between the anchors.
            </summary>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.JointLimits.DistanceLimit.#ctor">
      <summary>
            Constructs a distance limit joint.
            To finish the initialization, specify the connections (ConnectionA and ConnectionB) 
            as well as the WorldAnchorA and WorldAnchorB (or their entity-local versions)
            and the MinimumLength and MaximumLength.
            This constructor sets the constraint's IsActive property to false by default.
            </summary>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.JointLimits.DistanceLimit.#ctor(BEPUphysics.Entities.Entity,BEPUphysics.Entities.Entity,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,System.Single,System.Single)">
      <summary>
            Constructs a distance limit joint.
            </summary>
      <param name="connectionA">First body connected to the distance limit.</param>
      <param name="connectionB">Second body connected to the distance limit.</param>
      <param name="anchorA">Connection to the spring from the first connected body in world space.</param>
      <param name="anchorB"> Connection to the spring from the second connected body in world space.</param>
      <param name="minimumLength">Minimum distance maintained between the anchors.</param>
      <param name="maximumLength">Maximum distance allowed between the anchors.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.JointLimits.DistanceLimit.GetLinearJacobianA(Microsoft.Xna.Framework.Vector3@)">
      <summary>
            Gets the linear jacobian entry for the first connected entity.
            </summary>
      <param name="jacobian">Linear jacobian entry for the first connected entity.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.JointLimits.DistanceLimit.GetLinearJacobianB(Microsoft.Xna.Framework.Vector3@)">
      <summary>
            Gets the linear jacobian entry for the second connected entity.
            </summary>
      <param name="jacobian">Linear jacobian entry for the second connected entity.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.JointLimits.DistanceLimit.GetAngularJacobianA(Microsoft.Xna.Framework.Vector3@)">
      <summary>
            Gets the angular jacobian entry for the first connected entity.
            </summary>
      <param name="jacobian">Angular jacobian entry for the first connected entity.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.JointLimits.DistanceLimit.GetAngularJacobianB(Microsoft.Xna.Framework.Vector3@)">
      <summary>
            Gets the angular jacobian entry for the second connected entity.
            </summary>
      <param name="jacobian">Angular jacobian entry for the second connected entity.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.JointLimits.DistanceLimit.GetMassMatrix(System.Single@)">
      <summary>
            Gets the mass matrix of the constraint.
            </summary>
      <param name="outputMassMatrix">Constraint's mass matrix.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.JointLimits.DistanceLimit.SolveIteration">
      <summary>
            Calculates and applies corrective impulses.
            Called automatically by space.
            </summary>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.JointLimits.DistanceLimit.Update(System.Single)">
      <summary>
            Calculates necessary information for velocity solving.
            </summary>
      <param name="dt">Time in seconds since the last update.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.JointLimits.DistanceLimit.ExclusiveUpdate">
      <summary>
            Performs any pre-solve iteration work that needs exclusive
            access to the members of the solver updateable.
            Usually, this is used for applying warmstarting impulses.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.JointLimits.DistanceLimit.LocalAnchorA">
      <summary>
            Gets or sets the first entity's connection point in local space.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.JointLimits.DistanceLimit.LocalAnchorB">
      <summary>
            Gets or sets the first entity's connection point in local space.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.JointLimits.DistanceLimit.MaximumLength">
      <summary>
            Gets or sets the maximum distance allowed between the anchors.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.JointLimits.DistanceLimit.MinimumLength">
      <summary>
            Gets or sets the minimum distance maintained between the anchors.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.JointLimits.DistanceLimit.WorldAnchorA">
      <summary>
            Gets or sets the connection to the distance constraint from the first connected body in world space.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.JointLimits.DistanceLimit.WorldAnchorB">
      <summary>
            Gets or sets the connection to the distance constraint from the second connected body in world space.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.JointLimits.DistanceLimit.RelativeVelocity">
      <summary>
            Gets the current relative velocity between the connected entities with respect to the constraint.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.JointLimits.DistanceLimit.TotalImpulse">
      <summary>
            Gets the total impulse applied by this constraint.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.JointLimits.DistanceLimit.Error">
      <summary>
            Gets the current constraint error.
            </summary>
    </member>
    <member name="T:BEPUphysics.Constraints.Collision.SlidingFrictionTwoAxis">
      <summary>
            Computes the forces to slow down and stop sliding motion between two entities when centralized friction is active.
            </summary>
    </member>
    <member name="M:BEPUphysics.Constraints.Collision.SlidingFrictionTwoAxis.#ctor">
      <summary>
             Constructs a new sliding friction constraint.
            </summary>
    </member>
    <member name="M:BEPUphysics.Constraints.Collision.SlidingFrictionTwoAxis.SolveIteration">
      <summary>
            Computes one iteration of the constraint to meet the solver updateable's goal.
            </summary>
      <returns>The rough applied impulse magnitude.</returns>
    </member>
    <member name="M:BEPUphysics.Constraints.Collision.SlidingFrictionTwoAxis.Update(System.Single)">
      <summary>
             Performs the frame's configuration step.
            </summary>
      <param name="dt">Timestep duration.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.Collision.SlidingFrictionTwoAxis.ExclusiveUpdate">
      <summary>
            Performs any pre-solve iteration work that needs exclusive
            access to the members of the solver updateable.
            Usually, this is used for applying warmstarting impulses.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.Collision.SlidingFrictionTwoAxis.ContactManifoldConstraint">
      <summary>
             Gets the contact manifold constraint that owns this constraint.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.Collision.SlidingFrictionTwoAxis.FrictionDirectionX">
      <summary>
            Gets the first direction in which the friction force acts.
            This is one of two directions that are perpendicular to each other and the normal of a collision between two entities.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.Collision.SlidingFrictionTwoAxis.FrictionDirectionY">
      <summary>
            Gets the second direction in which the friction force acts.
            This is one of two directions that are perpendicular to each other and the normal of a collision between two entities.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.Collision.SlidingFrictionTwoAxis.TotalForce">
      <summary>
            Gets the total force applied by sliding friction.
            The X component of this vector is the force applied along the frictionDirectionX,
            while the Y component is the force applied along the frictionDirectionY.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.Collision.SlidingFrictionTwoAxis.RelativeVelocity">
      <summary>
             Gets the tangential relative velocity between the associated entities at the contact point.
            </summary>
    </member>
    <member name="T:BEPUphysics.CollisionTests.Manifolds.ContactManifold">
      <summary>
             Superclass of manifolds which manage persistent contacts over multiple frames.
            </summary>
    </member>
    <member name="M:BEPUphysics.CollisionTests.Manifolds.ContactManifold.Initialize(BEPUphysics.Collidables.Collidable,BEPUphysics.Collidables.Collidable)">
      <summary>
             Initializes the manifold.
            </summary>
      <param name="newCollidableA">First collidable.</param>
      <param name="newCollidableB">Second collidable.</param>
    </member>
    <member name="M:BEPUphysics.CollisionTests.Manifolds.ContactManifold.CleanUp">
      <summary>
             Cleans up the manifold.
            </summary>
    </member>
    <member name="M:BEPUphysics.CollisionTests.Manifolds.ContactManifold.Update(System.Single)">
      <summary>
             Updates the manifold.
            </summary>
      <param name="dt">Timestep duration.</param>
    </member>
    <member name="P:BEPUphysics.CollisionTests.Manifolds.ContactManifold.Contacts">
      <summary>
             Gets the contacts in the manifold.
            </summary>
    </member>
    <member name="E:BEPUphysics.CollisionTests.Manifolds.ContactManifold.ContactAdded">
      <summary>
             Fires when a contact is added.
            </summary>
    </member>
    <member name="E:BEPUphysics.CollisionTests.Manifolds.ContactManifold.ContactRemoved">
      <summary>
             Fires when a contact is removed.
            </summary>
    </member>
    <member name="T:BEPUphysics.CollisionTests.Manifolds.TriangleMeshConvexContactManifold">
      <summary>
             Manages persistent contact data between a triangle mesh and a convex.
            </summary>
    </member>
    <member name="T:BEPUphysics.CollisionTests.Manifolds.TriangleMeshConvexContactManifold.TriangleIndices">
      <summary>
             Stores indices of a triangle.
            </summary>
    </member>
    <member name="M:BEPUphysics.CollisionTests.Manifolds.TriangleMeshConvexContactManifold.TriangleIndices.GetHashCode">
      <summary>
            Returns the hash code for this instance.
            </summary>
      <returns>
            A 32-bit signed integer that is the hash code for this instance.
            </returns>
      <filterpriority>2</filterpriority>
    </member>
    <member name="M:BEPUphysics.CollisionTests.Manifolds.TriangleMeshConvexContactManifold.TriangleIndices.Equals(BEPUphysics.CollisionTests.Manifolds.TriangleMeshConvexContactManifold.TriangleIndices)">
      <summary>
            Indicates whether the current object is equal to another object of the same type.
            </summary>
      <returns>
            true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false.
            </returns>
      <param name="other">An object to compare with this object.</param>
    </member>
    <member name="M:BEPUphysics.CollisionTests.Manifolds.TriangleMeshConvexContactManifold.#ctor">
      <summary>
             Constructs a new contact manifold.
            </summary>
    </member>
    <member name="M:BEPUphysics.CollisionTests.Manifolds.TriangleMeshConvexContactManifold.Update(System.Single)">
      <summary>
             Updates the manifold.
            </summary>
      <param name="dt">Timestep duration.</param>
    </member>
    <member name="M:BEPUphysics.CollisionTests.Manifolds.TriangleMeshConvexContactManifold.CleanUp">
      <summary>
             Cleans up the manifold.
            </summary>
    </member>
    <member name="P:BEPUphysics.CollisionTests.Manifolds.TriangleMeshConvexContactManifold.ConvexCollidable">
      <summary>
             Gets the convex collidable associated with this pair.
            </summary>
    </member>
    <member name="T:BEPUphysics.CollisionTests.Manifolds.TerrainConvexContactManifold">
      <summary>
             Manages persistent contacts between a Terrain and a convex.
            </summary>
    </member>
    <member name="M:BEPUphysics.CollisionTests.Manifolds.TerrainConvexContactManifold.CleanUp">
      <summary>
             Cleans up the manifold.
            </summary>
    </member>
    <member name="M:BEPUphysics.CollisionTests.Manifolds.TerrainConvexContactManifold.Initialize(BEPUphysics.Collidables.Collidable,BEPUphysics.Collidables.Collidable)">
      <summary>
             Initializes the manifold.
            </summary>
      <param name="newCollidableA">First collidable.</param>
      <param name="newCollidableB">Second collidable.</param>
    </member>
    <member name="P:BEPUphysics.CollisionTests.Manifolds.TerrainConvexContactManifold.Terrain">
      <summary>
             Gets the terrain associated with this pair.
            </summary>
    </member>
    <member name="T:BEPUphysics.CollisionShapes.ConvexShapes.TransformableShape">
      <summary>
             Shape which can take any convex shape and use a linear transform to shear, scale, and rotate it.
            </summary>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.ConvexShapes.TransformableShape.#ctor(BEPUphysics.CollisionShapes.ConvexShapes.ConvexShape,BEPUphysics.MathExtensions.Matrix3X3)">
      <summary>
             Constructs a new transformable shape.
            </summary>
      <param name="shape">Base shape to transform.</param>
      <param name="transform">Transform to use.</param>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.ConvexShapes.TransformableShape.GetLocalExtremePointWithoutMargin(Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Vector3@)">
      <summary>
             Gets the extreme point of the shape in local space in a given direction.
            </summary>
      <param name="direction">Direction to find the extreme point in.</param>
      <param name="extremePoint">Extreme point on the shape.</param>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.ConvexShapes.TransformableShape.ComputeMaximumRadius">
      <summary>
            Computes the maximum radius of the shape.
            This is often larger than the actual maximum radius;
            it is simply an approximation that avoids underestimating.
            </summary>
      <returns>Maximum radius of the shape.</returns>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.ConvexShapes.TransformableShape.ComputeMinimumRadius">
      <summary>
             Computes the minimum radius of the shape.
             This is often smaller than the actual minimum radius;
             it is simply an approximation that avoids overestimating.
            </summary>
      <returns>Minimum radius of the shape.</returns>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.ConvexShapes.TransformableShape.ComputeCenter">
      <summary>
            Computes the center of the shape.  This can be considered its 
            center of mass.
            </summary>
      <returns>Center of the shape.</returns>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.ConvexShapes.TransformableShape.ComputeCenter(System.Single@)">
      <summary>
            Computes the center of the shape.  This can be considered its 
            center of mass.  This calculation is often associated with the 
            volume calculation, which is given by this method as well.
            </summary>
      <param name="volume">Volume of the shape.</param>
      <returns>Center of the shape.</returns>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.ConvexShapes.TransformableShape.GetMobileInstance">
      <summary>
            Retrieves an instance of an EntityCollidable that uses this EntityShape.  Mainly used by compound bodies.
            </summary>
      <returns>EntityCollidable that uses this shape.</returns>
    </member>
    <member name="P:BEPUphysics.CollisionShapes.ConvexShapes.TransformableShape.Shape">
      <summary>
             Gets or sets the convex shape to be transformed.
            </summary>
    </member>
    <member name="P:BEPUphysics.CollisionShapes.ConvexShapes.TransformableShape.Transform">
      <summary>
             Gets or sets the linear transform used to transform the convex shape.
            </summary>
    </member>
    <member name="T:BEPUphysics.Collidables.MobileCollidables.MobileCollidable">
      <summary>
             Superclass of all collidables which are capable of movement, and thus need bounding box updates every frame.
            </summary>
    </member>
    <member name="M:BEPUphysics.Collidables.MobileCollidables.MobileCollidable.UpdateBoundingBox(System.Single)">
      <summary>
             Updates the bounding box of the mobile collidable.
            </summary>
      <param name="dt">Timestep with which to update the bounding box.</param>
    </member>
    <member name="T:BEPUphysics.Collidables.MobileCollidables.EntityCollidable">
      <summary>
             Mobile collidable acting as a collision proxy for an entity.
            </summary>
    </member>
    <member name="M:BEPUphysics.Collidables.MobileCollidables.EntityCollidable.UpdateBoundingBox(System.Single)">
      <summary>
             Updates the bounding box of the mobile collidable.
            </summary>
      <param name="dt">Timestep with which to update the bounding box.</param>
    </member>
    <member name="M:BEPUphysics.Collidables.MobileCollidables.EntityCollidable.UpdateWorldTransform(Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Quaternion@)">
      <summary>
             Updates the world transform of the collidable.
            </summary>
      <param name="position">Position to use for the calculation.</param>
      <param name="orientation">Orientation to use for the calculation.</param>
    </member>
    <member name="P:BEPUphysics.Collidables.MobileCollidables.EntityCollidable.Shape">
      <summary>
            Gets the shape of the collidable.
            </summary>
    </member>
    <member name="P:BEPUphysics.Collidables.MobileCollidables.EntityCollidable.Entity">
      <summary>
             Gets the entity owning the collidable.
            </summary>
    </member>
    <member name="P:BEPUphysics.Collidables.MobileCollidables.EntityCollidable.WorldTransform">
      <summary>
             Gets the world transform of the collidable.
            </summary>
    </member>
    <member name="P:BEPUphysics.Collidables.MobileCollidables.EntityCollidable.LocalPosition">
      <summary>
             Gets or sets the local position of the collidable.
             The local position can be used to offset the collision geometry
             from an entity's center of mass.
            </summary>
    </member>
    <member name="P:BEPUphysics.Collidables.MobileCollidables.EntityCollidable.Events">
      <summary>
             Gets or sets the event manager of the collidable.
            </summary>
    </member>
    <member name="P:BEPUphysics.Collidables.MobileCollidables.EntityCollidable.OverlappedEntities">
      <summary>
             Gets an enumerable collection of all entities overlapping this collidable.
            </summary>
    </member>
    <member name="T:BEPUphysics.Collidables.MobileCollidables.ConvexCollidable">
      <summary>
             Collidable with a convex shape.
            </summary>
    </member>
    <member name="P:BEPUphysics.Collidables.MobileCollidables.ConvexCollidable.Shape">
      <summary>
             Gets the shape of the collidable.
            </summary>
    </member>
    <member name="T:BEPUphysics.Collidables.MobileCollidables.ConvexCollidable`1">
      <summary>
             Collidable with a convex shape of a particular type.
            </summary>
      <typeparam name="T">ConvexShape type.</typeparam>
    </member>
    <member name="M:BEPUphysics.Collidables.MobileCollidables.ConvexCollidable`1.#ctor(`0)">
      <summary>
             Constructs a new convex collidable.
            </summary>
      <param name="shape">Shape to use in the collidable.</param>
    </member>
    <member name="M:BEPUphysics.Collidables.MobileCollidables.ConvexCollidable`1.RayCast(Microsoft.Xna.Framework.Ray,System.Single,BEPUphysics.RayHit@)">
      <summary>
            Tests a ray against the entry.
            </summary>
      <param name="ray">Ray to test.</param>
      <param name="maximumLength">Maximum length, in units of the ray's direction's length, to test.</param>
      <param name="rayHit">Hit location of the ray on the entry, if any.</param>
      <returns>Whether or not the ray hit the entry.</returns>
    </member>
    <member name="P:BEPUphysics.Collidables.MobileCollidables.ConvexCollidable`1.Shape">
      <summary>
             Gets the shape of the collidable.
            </summary>
    </member>
    <member name="T:BEPUphysics.Collidables.MobileCollidables.TriangleCollidable">
      <summary>
             Special case collidable for reuseable triangles.
            </summary>
    </member>
    <member name="M:BEPUphysics.Collidables.MobileCollidables.TriangleCollidable.#ctor">
      <summary>
             Constructs a new shapeless collidable.
            </summary>
    </member>
    <member name="M:BEPUphysics.Collidables.MobileCollidables.TriangleCollidable.#ctor(BEPUphysics.CollisionShapes.ConvexShapes.TriangleShape)">
      <summary>
             Constructs the triangle collidable using the given shape.
            </summary>
      <param name="shape">TriangleShape to use in the collidable.</param>
    </member>
    <member name="M:BEPUphysics.Collidables.MobileCollidables.TriangleCollidable.Initialize(BEPUphysics.CollisionShapes.ConvexShapes.TriangleShape)">
      <summary>
             Initializes the collidable using the new triangle shape, but does NOT
             fire any shape-changed events.
            </summary>
      <param name="triangleShape">New triangle shape to use.</param>
    </member>
    <member name="M:BEPUphysics.Collidables.MobileCollidables.TriangleCollidable.CleanUp">
      <summary>
             Cleans up the collidable by removing all events and setting the shape to null.
            </summary>
    </member>
    <member name="T:BEPUphysics.Paths.Curve`1">
      <summary>
            Manages a curve in 3D space that supports interpolation.
            </summary>
      <typeparam name="TValue">Type of values in the curve.</typeparam>
    </member>
    <member name="M:BEPUphysics.Paths.Curve`1.#ctor">
      <summary>
            Constructs a new 3D curve.
            </summary>
    </member>
    <member name="M:BEPUphysics.Paths.Curve`1.ModifyTime(System.Double,System.Single,System.Single,BEPUphysics.Paths.CurveEndpointBehavior,BEPUphysics.Paths.CurveEndpointBehavior)">
      <summary>
            Converts an unbounded time to a time within the curve's interval using the 
            endpoint behavior.
            </summary>
      <param name="time">Time to convert.</param>
      <param name="intervalBegin">Beginning of the curve's interval.</param>
      <param name="intervalEnd">End of the curve's interval.</param>
      <param name="preLoop">Looping behavior of the curve before the first endpoint's time.</param>
      <param name="postLoop">Looping behavior of the curve after the last endpoint's time.</param>
      <returns>Time within the curve's interval.</returns>
    </member>
    <member name="M:BEPUphysics.Paths.Curve`1.Evaluate(System.Int32,System.Single,`0@)">
      <summary>
            Evaluates the curve section starting at the control point index using
            the weight value.
            </summary>
      <param name="controlPointIndex">Index of the starting control point of the subinterval.</param>
      <param name="weight">Location to evaluate on the subinterval from 0 to 1.</param>
      <param name="value">Value at the given location.</param>
    </member>
    <member name="M:BEPUphysics.Paths.Curve`1.GetCurveIndexBoundsInformation(System.Int32@,System.Int32@)">
      <summary>
            Gets the curve's bounding index information.
            </summary>
      <param name="minIndex">Index of the minimum control point in the active curve segment.</param>
      <param name="maxIndex">Index of the maximum control point in the active curve segment.</param>
    </member>
    <member name="M:BEPUphysics.Paths.Curve`1.Evaluate(System.Double,`0@)">
      <summary>
            Computes the value of the curve at a given time.
            </summary>
      <param name="time">Time at which to evaluate the curve.</param>
      <param name="value">Curve value at the given time.</param>
    </member>
    <member name="M:BEPUphysics.Paths.Curve`1.GetPathBoundsInformation(System.Single@,System.Single@)">
      <summary>
            Gets the starting and ending times of the path.
            </summary>
      <param name="startingTime">Beginning time of the path.</param>
      <param name="endingTime">Ending time of the path.</param>
    </member>
    <member name="M:BEPUphysics.Paths.Curve`1.GetCurveBoundsInformation(System.Single@,System.Single@,System.Int32@,System.Int32@)">
      <summary>
            Gets information about the curve's total active interval.
            These are not always the first and last endpoints in a curve.
            </summary>
      <param name="firstIndexTime">Time of the first index.</param>
      <param name="lastIndexTime">Time of the last index.</param>
      <param name="minIndex">First index in the reachable curve.</param>
      <param name="maxIndex">Last index in the reachable curve.</param>
    </member>
    <member name="M:BEPUphysics.Paths.Curve`1.GetPreviousIndex(System.Double)">
      <summary>
            Computes the indices of control points surrounding the time.
            If the time is equal to a control point's time, indexA will
            be that control point's index.
            </summary>
      <param name="time">Time to index.</param>
      <returns>Index prior to or equal to the given time.</returns>
    </member>
    <member name="M:BEPUphysics.Paths.Curve`1.ControlPointAdded(BEPUphysics.Paths.CurveControlPoint{`0},System.Int32)">
      <summary>
            Called when a control point is added.
            </summary>
      <param name="curveControlPoint">New control point.</param>
      <param name="index">Index of the control point.</param>
    </member>
    <member name="M:BEPUphysics.Paths.Curve`1.ControlPointRemoved(BEPUphysics.Paths.CurveControlPoint{`0},System.Int32)">
      <summary>
            Called when a control point is removed.
            </summary>
      <param name="curveControlPoint">Removed control point.</param>
      <param name="oldIndex">Index of the control point before it was removed.</param>
    </member>
    <member name="M:BEPUphysics.Paths.Curve`1.ControlPointTimeChanged(BEPUphysics.Paths.CurveControlPoint{`0},System.Int32,System.Int32)">
      <summary>
            Called when a control point belonging to the curve has its time changed.
            </summary>
      <param name="curveControlPoint">Changed control point.</param>
      <param name="oldIndex">Old index of the control point.</param>
      <param name="newIndex">New index of the control point.</param>
    </member>
    <member name="M:BEPUphysics.Paths.Curve`1.ControlPointValueChanged(BEPUphysics.Paths.CurveControlPoint{`0})">
      <summary>
            Called when a control point belonging to the curve has its value changed.
            </summary>
      <param name="curveControlPoint">Changed control point.</param>
    </member>
    <member name="P:BEPUphysics.Paths.Curve`1.ControlPoints">
      <summary>
            Gets the list of control points in the curve.
            </summary>
    </member>
    <member name="P:BEPUphysics.Paths.Curve`1.PostLoop">
      <summary>
            Defines how the curve is sampled when the evaluation time exceeds the final control point.
            </summary>
    </member>
    <member name="P:BEPUphysics.Paths.Curve`1.PreLoop">
      <summary>
            Defines how the curve is sampled when the evaluation time exceeds the beginning control point.
            </summary>
    </member>
    <member name="T:BEPUphysics.Paths.HermiteCurve3D">
      <summary>
            Defines a 3D curve using hermite interpolation.
            </summary>
    </member>
    <member name="F:BEPUphysics.Paths.HermiteCurve3D.tangents">
      <summary>
            Internal list of curve tangents.
            </summary>
    </member>
    <member name="M:BEPUphysics.Paths.HermiteCurve3D.Evaluate(System.Int32,System.Single,Microsoft.Xna.Framework.Vector3@)">
      <summary>
            Evaluates the curve section starting at the control point index using
            the weight value.
            </summary>
      <param name="controlPointIndex">Index of the starting control point of the subinterval.</param>
      <param name="weight">Location to evaluate on the subinterval from 0 to 1.</param>
      <param name="value">Value at the given location.</param>
    </member>
    <member name="M:BEPUphysics.Paths.HermiteCurve3D.ControlPointAdded(BEPUphysics.Paths.CurveControlPoint{Microsoft.Xna.Framework.Vector3},System.Int32)">
      <summary>
            Called when a control point is added.
            </summary>
      <param name="curveControlPoint">New control point.</param>
      <param name="index">Index of the control point.</param>
    </member>
    <member name="M:BEPUphysics.Paths.HermiteCurve3D.ControlPointRemoved(BEPUphysics.Paths.CurveControlPoint{Microsoft.Xna.Framework.Vector3},System.Int32)">
      <summary>
            Called when a control point is removed.
            </summary>
      <param name="curveControlPoint">Removed control point.</param>
      <param name="oldIndex">Index of the control point before it was removed.</param>
    </member>
    <member name="M:BEPUphysics.Paths.HermiteCurve3D.ControlPointTimeChanged(BEPUphysics.Paths.CurveControlPoint{Microsoft.Xna.Framework.Vector3},System.Int32,System.Int32)">
      <summary>
            Called when a control point belonging to the curve has its time changed.
            </summary>
      <param name="curveControlPoint">Changed control point.</param>
      <param name="oldIndex">Old index of the control point.</param>
      <param name="newIndex">New index of the control point.</param>
    </member>
    <member name="M:BEPUphysics.Paths.HermiteCurve3D.ControlPointValueChanged(BEPUphysics.Paths.CurveControlPoint{Microsoft.Xna.Framework.Vector3})">
      <summary>
            Called when a control point belonging to the curve has its value changed.
            </summary>
      <param name="curveControlPoint">Changed control point.</param>
    </member>
    <member name="M:BEPUphysics.Paths.HermiteCurve3D.ComputeTangents">
      <summary>
            Computes the tangent entries in the curve according to some type of hermite curve.
            </summary>
    </member>
    <member name="P:BEPUphysics.Paths.HermiteCurve3D.Tangents">
      <summary>
            Gets the tangents used by the curve per control point.
            </summary>
    </member>
    <member name="T:BEPUphysics.Paths.FiniteDifferenceSpline3D">
      <summary>
            3D hermite curve that uses the finite difference method to compute tangents.
            </summary>
    </member>
    <member name="M:BEPUphysics.Paths.FiniteDifferenceSpline3D.GetCurveIndexBoundsInformation(System.Int32@,System.Int32@)">
      <summary>
            Gets the curve's bounding index information.
            </summary>
      <param name="minIndex">Index of the minimum control point in the active curve segment.</param>
      <param name="maxIndex">Index of the maximum control point in the active curve segment.</param>
    </member>
    <member name="T:BEPUphysics.CollisionTests.Contact">
      <summary>
            Handles information about a contact point during a collision between two bodies.
            </summary>
    </member>
    <member name="F:BEPUphysics.CollisionTests.Contact.PenetrationDepth">
      <summary>
            Amount of penetration between the two objects.
            </summary>
    </member>
    <member name="F:BEPUphysics.CollisionTests.Contact.Id">
      <summary>
            Feature-based id used to match contacts from the previous frame to their current versions.
            </summary>
    </member>
    <member name="F:BEPUphysics.CollisionTests.Contact.Normal">
      <summary>
            Normal direction of the surface at the contact point.
            </summary>
    </member>
    <member name="F:BEPUphysics.CollisionTests.Contact.Position">
      <summary>
            Position of the contact point.
            </summary>
    </member>
    <member name="M:BEPUphysics.CollisionTests.Contact.Setup(BEPUphysics.CollisionTests.ContactData@)">
      <summary>
             Sets upt he contact with new information.
            </summary>
      <param name="candidate">Contact data to initialize the contact with.</param>
    </member>
    <member name="M:BEPUphysics.CollisionTests.Contact.Equals(BEPUphysics.CollisionTests.Contact)">
      <summary>
            Determines if two contacts are equal using their id and position.
            </summary>
      <param name="other">Other contact to compare.</param>
      <returns>Whether or not the contacts are equivalent.</returns>
    </member>
    <member name="M:BEPUphysics.CollisionTests.Contact.ToString">
      <summary>
            Outputs the position, normal, and depth information of the contact into a string.
            </summary>
      <returns>Position, normal, and depth information of the contact in a string.</returns>
    </member>
    <member name="T:BEPUphysics.RayHit">
      <summary>
             Contains ray hit data.
            </summary>
    </member>
    <member name="F:BEPUphysics.RayHit.Location">
      <summary>
             Location of the ray hit.
            </summary>
    </member>
    <member name="F:BEPUphysics.RayHit.Normal">
      <summary>
             Normal of the ray hit.
            </summary>
    </member>
    <member name="F:BEPUphysics.RayHit.T">
      <summary>
             T parameter of the ray hit.  
             The ray hit location is equal to the ray origin added to the ray direction multiplied by T.
            </summary>
    </member>
    <member name="T:BEPUphysics.Entities.Prefabs.MinkowskiSum">
      <summary>
            Shape representing the sweeping of one entity through another.  Can collide and move.  After making an entity, add it to a Space so that the engine can manage it.
            </summary>
    </member>
    <member name="F:BEPUphysics.Entities.Prefabs.MinkowskiSum.EntityA">
      <summary>
            First entity in the sum.
            </summary>
    </member>
    <member name="F:BEPUphysics.Entities.Prefabs.MinkowskiSum.EntityB">
      <summary>
            Second entity in the sum.
            </summary>
    </member>
    <member name="M:BEPUphysics.Entities.Prefabs.MinkowskiSum.#ctor(Microsoft.Xna.Framework.Vector3,BEPUphysics.CollisionShapes.ConvexShapes.OrientedConvexShapeEntry,BEPUphysics.CollisionShapes.ConvexShapes.OrientedConvexShapeEntry,System.Single)">
      <summary>
            Constructs a dynamic minkowski sum.
            </summary>
      <param name="position">Position of the resulting shape.</param>
      <param name="a">First entity in the sum.</param>
      <param name="b">Second entity in the sum.</param>
      <param name="mass">Mass of the object.</param>
    </member>
    <member name="M:BEPUphysics.Entities.Prefabs.MinkowskiSum.#ctor(Microsoft.Xna.Framework.Vector3,BEPUphysics.CollisionShapes.ConvexShapes.OrientedConvexShapeEntry,BEPUphysics.CollisionShapes.ConvexShapes.OrientedConvexShapeEntry)">
      <summary>
            Constructs a nondynamic minkowski sum of two entities.
            </summary>
      <param name="position">Position of the resulting shape.</param>
      <param name="a">First entity in the sum.</param>
      <param name="b">Second entity in the sum.</param>
    </member>
    <member name="M:BEPUphysics.Entities.Prefabs.MinkowskiSum.#ctor(BEPUphysics.EntityStateManagement.MotionState,BEPUphysics.CollisionShapes.ConvexShapes.OrientedConvexShapeEntry,BEPUphysics.CollisionShapes.ConvexShapes.OrientedConvexShapeEntry,System.Single)">
      <summary>
            Constructs a dynamic minkowski sum of two entities.
            </summary>
      <param name="motionState">Motion state specifying the entity's initial state.</param>
      <param name="a">First entity in the sum.</param>
      <param name="b">Second entity in the sum.</param>
      <param name="mass">Mass of the object.</param>
    </member>
    <member name="M:BEPUphysics.Entities.Prefabs.MinkowskiSum.#ctor(BEPUphysics.EntityStateManagement.MotionState,BEPUphysics.CollisionShapes.ConvexShapes.OrientedConvexShapeEntry,BEPUphysics.CollisionShapes.ConvexShapes.OrientedConvexShapeEntry)">
      <summary>
            Constructs a nondynamic minkowski sum of two entities.
            </summary>
      <param name="motionState">Motion state specifying the entity's initial state.</param>
      <param name="a">First entity in the sum.</param>
      <param name="b">Second entity in the sum.</param>
    </member>
    <member name="M:BEPUphysics.Entities.Prefabs.MinkowskiSum.#ctor(BEPUphysics.EntityStateManagement.MotionState,System.Collections.Generic.IList{BEPUphysics.CollisionShapes.ConvexShapes.OrientedConvexShapeEntry},System.Single)">
      <summary>
            Constructs a dynamic minkowski sum entity.
            </summary>
      <param name="motionState">Motion state specifying the entity's initial state.</param>
      <param name="shapes">List of shapes to make the sum frmo.</param>
      <param name="mass">Mass of the object.</param>
    </member>
    <member name="M:BEPUphysics.Entities.Prefabs.MinkowskiSum.#ctor(BEPUphysics.EntityStateManagement.MotionState,System.Collections.Generic.IList{BEPUphysics.CollisionShapes.ConvexShapes.OrientedConvexShapeEntry})">
      <summary>
            Constructs a nondynamic minkowski sum.
            </summary>
      <param name="motionState">Motion state specifying the entity's initial state.</param>
      <param name="shapes">List of shapes to make the sum frmo.</param>
    </member>
    <member name="T:BEPUphysics.Entities.Prefabs.Box">
      <summary>
            Box-shaped object that can collide and move.  After making an entity, add it to a Space so that the engine can manage it.
            </summary>
    </member>
    <member name="M:BEPUphysics.Entities.Prefabs.Box.#ctor(Microsoft.Xna.Framework.Vector3,System.Single,System.Single,System.Single,System.Single)">
      <summary>
            Constructs a physically simulated box.
            </summary>
      <param name="pos">Position of the box.</param>
      <param name="width">Height of the box.</param>
      <param name="length">Length of the box.</param>
      <param name="height">Height of the box.</param>
      <param name="mass">Mass of the object.</param>
    </member>
    <member name="M:BEPUphysics.Entities.Prefabs.Box.#ctor(Microsoft.Xna.Framework.Vector3,System.Single,System.Single,System.Single)">
      <summary>
            Constructs a nondynamic box.
            </summary>
      <param name="pos">Position of the box.</param>
      <param name="width">Height of the box.</param>
      <param name="length">Length of the box.</param>
      <param name="height">Height of the box.</param>
    </member>
    <member name="M:BEPUphysics.Entities.Prefabs.Box.#ctor(BEPUphysics.EntityStateManagement.MotionState,System.Single,System.Single,System.Single,System.Single)">
      <summary>
            Constructs a physically simulated box.
            </summary>
      <param name="motionState">Motion state specifying the entity's initial state.</param>
      <param name="width">Width of the box.</param>
      <param name="length">Length of the box.</param>
      <param name="height">Height of the box.</param>
      <param name="mass">Mass of the object.</param>
    </member>
    <member name="M:BEPUphysics.Entities.Prefabs.Box.#ctor(BEPUphysics.EntityStateManagement.MotionState,System.Single,System.Single,System.Single)">
      <summary>
            Constructs a nondynamic box.
            </summary>
      <param name="motionState">Motion state specifying the entity's initial state.</param>
      <param name="width">Height of the box.</param>
      <param name="length">Length of the box.</param>
      <param name="height">Height of the box.</param>
    </member>
    <member name="P:BEPUphysics.Entities.Prefabs.Box.HalfWidth">
      <summary>
            Width of the box divided by two.
            </summary>
    </member>
    <member name="P:BEPUphysics.Entities.Prefabs.Box.HalfHeight">
      <summary>
            Height of the box divided by two.
            </summary>
    </member>
    <member name="P:BEPUphysics.Entities.Prefabs.Box.HalfLength">
      <summary>
            Length of the box divided by two.
            </summary>
    </member>
    <member name="P:BEPUphysics.Entities.Prefabs.Box.Width">
      <summary>
            Width of the box.
            </summary>
    </member>
    <member name="P:BEPUphysics.Entities.Prefabs.Box.Height">
      <summary>
            Height of the box.
            </summary>
    </member>
    <member name="P:BEPUphysics.Entities.Prefabs.Box.Length">
      <summary>
            Length of the box.
            </summary>
    </member>
    <member name="T:BEPUphysics.Collidables.InstancedMesh">
      <summary>
             Collidable mesh which can be created from a reusable InstancedMeshShape.
             Very little data is needed for each individual InstancedMesh object, allowing
             a complicated mesh to be repeated many times.  Since the hierarchy used to accelerate
             collisions is purely local, it may be marginally slower than an individual StaticMesh.
            </summary>
    </member>
    <member name="M:BEPUphysics.Collidables.InstancedMesh.#ctor(BEPUphysics.CollisionShapes.InstancedMeshShape)">
      <summary>
             Constructs a new InstancedMesh.
            </summary>
      <param name="meshShape">Shape to use for the instance.</param>
    </member>
    <member name="M:BEPUphysics.Collidables.InstancedMesh.#ctor(BEPUphysics.CollisionShapes.InstancedMeshShape,BEPUphysics.MathExtensions.AffineTransform)">
      <summary>
             Constructs a new InstancedMesh.
            </summary>
      <param name="meshShape">Shape to use for the instance.</param>
      <param name="worldTransform">Transform to use for the instance.</param>
    </member>
    <member name="M:BEPUphysics.Collidables.InstancedMesh.RayCast(Microsoft.Xna.Framework.Ray,System.Single,BEPUphysics.RayHit@)">
      <summary>
            Tests a ray against the entry.
            </summary>
      <param name="ray">Ray to test.</param>
      <param name="maximumLength">Maximum length, in units of the ray's direction's length, to test.</param>
      <param name="rayHit">Hit location of the ray on the entry, if any.</param>
      <returns>Whether or not the ray hit the entry.</returns>
    </member>
    <member name="M:BEPUphysics.Collidables.InstancedMesh.RayCast(Microsoft.Xna.Framework.Ray,System.Single,BEPUphysics.CollisionShapes.ConvexShapes.TriangleSidedness,BEPUphysics.RayHit@)">
      <summary>
             Tests a ray against the instance.
            </summary>
      <param name="ray">Ray to test.</param>
      <param name="maximumLength">Maximum length of the ray to test; in units of the ray's direction's length.</param>
      <param name="sidedness">Sidedness to use during the ray cast.  This does not have to be the same as the mesh's sidedness.</param>
      <param name="rayHit">The hit location of the ray on the mesh, if any.</param>
      <returns>Whether or not the ray hit the mesh.</returns>
    </member>
    <member name="P:BEPUphysics.Collidables.InstancedMesh.WorldTransform">
      <summary>
             Gets or sets the world transform of the mesh.
            </summary>
    </member>
    <member name="P:BEPUphysics.Collidables.InstancedMesh.Shape">
      <summary>
             Gets the shape used by the instanced mesh.
            </summary>
    </member>
    <member name="P:BEPUphysics.Collidables.InstancedMesh.Sidedness">
      <summary>
             Gets or sets the sidedness of the mesh.  This can be used to ignore collisions and rays coming from a direction relative to the winding of the triangle.
            </summary>
    </member>
    <member name="P:BEPUphysics.Collidables.InstancedMesh.ImproveBoundaryBehavior">
      <summary>
            Gets or sets whether or not the collision system should attempt to improve contact behavior at the boundaries between triangles.
            This has a slight performance cost, but prevents objects sliding across a triangle boundary from 'bumping,' and otherwise improves
            the robustness of contacts at edges and vertices.
            </summary>
    </member>
    <member name="P:BEPUphysics.Collidables.InstancedMesh.Events">
      <summary>
             Gets the event manager of the mesh.
            </summary>
    </member>
    <member name="P:BEPUphysics.Collidables.InstancedMesh.Material">
      <summary>
             Gets or sets the material of the mesh.
            </summary>
    </member>
    <member name="P:BEPUphysics.Collidables.InstancedMesh.Space">
      <summary>
             Gets the Space to which the instance belongs.
            </summary>
    </member>
    <member name="T:BEPUphysics.DataStructures.BoundingBoxTree`1">
      <summary>
             Acceleration structure of objects surrounded by axis aligned bounding boxes, supporting various speedy queries.
            </summary>
    </member>
    <member name="F:BEPUphysics.DataStructures.BoundingBoxTree`1.LeafMargin">
      <summary>
            The tiny extra margin added to leaf bounding boxes that allow the volume cost metric to function properly even in degenerate cases.
            </summary>
    </member>
    <member name="M:BEPUphysics.DataStructures.BoundingBoxTree`1.#ctor(System.Collections.Generic.IList{`0})">
      <summary>
            Constructs a new tree.
            </summary>
      <param name="elements">Data to use to construct the tree.</param>
    </member>
    <member name="M:BEPUphysics.DataStructures.BoundingBoxTree`1.Reconstruct(System.Collections.Generic.IList{`0})">
      <summary>
            Reconstructs the tree based on the current data.
            </summary>
    </member>
    <member name="M:BEPUphysics.DataStructures.BoundingBoxTree`1.Refit">
      <summary>
            Refits the tree based on the current data.
            This process is cheaper to perform than a reconstruction when the topology of the mesh
            does not change.
            </summary>
    </member>
    <member name="M:BEPUphysics.DataStructures.BoundingBoxTree`1.Add(`0)">
      <summary>
            Adds an element to the tree.
            If a list of objects is available, using the Reconstruct method is recommended.
            </summary>
      <param name="element">Element to add.</param>
    </member>
    <member name="M:BEPUphysics.DataStructures.BoundingBoxTree`1.GetOverlaps(Microsoft.Xna.Framework.BoundingBox,System.Collections.Generic.IList{`0})">
      <summary>
            Gets the triangles whose bounding boxes are overlapped by the query.
            </summary>
      <param name="boundingBox">Shape to query against the tree.</param>
      <param name="outputOverlappedElements">Indices of triangles in the index buffer with bounding boxes which are overlapped by the query.</param>
      <returns>Whether or not any elements were overlapped.</returns>
    </member>
    <member name="M:BEPUphysics.DataStructures.BoundingBoxTree`1.GetOverlaps(Microsoft.Xna.Framework.BoundingSphere,System.Collections.Generic.IList{`0})">
      <summary>
            Gets the triangles whose bounding boxes are overlapped by the query.
            </summary>
      <param name="boundingSphere">Shape to query against the tree.</param>
      <param name="outputOverlappedElements">Indices of triangles in the index buffer with bounding boxes which are overlapped by the query.</param>
      <returns>Whether or not any elements were overlapped.</returns>
    </member>
    <member name="M:BEPUphysics.DataStructures.BoundingBoxTree`1.GetOverlaps(Microsoft.Xna.Framework.BoundingFrustum,System.Collections.Generic.IList{`0})">
      <summary>
            Gets the triangles whose bounding boxes are overlapped by the query.
            </summary>
      <param name="boundingFrustum">Shape to query against the tree.</param>
      <param name="outputOverlappedElements">Indices of triangles in the index buffer with bounding boxes which are overlapped by the query.</param>
      <returns>Whether or not any elements were overlapped.</returns>
    </member>
    <member name="M:BEPUphysics.DataStructures.BoundingBoxTree`1.GetOverlaps(Microsoft.Xna.Framework.Ray,System.Collections.Generic.IList{`0})">
      <summary>
            Gets the triangles whose bounding boxes are overlapped by the query.
            </summary>
      <param name="ray">Shape to query against the tree.</param>
      <param name="outputOverlappedElements">Indices of triangles in the index buffer with bounding boxes which are overlapped by the query.</param>
      <returns>Whether or not any elements were overlapped.</returns>
    </member>
    <member name="M:BEPUphysics.DataStructures.BoundingBoxTree`1.GetOverlaps(Microsoft.Xna.Framework.Ray,System.Single,System.Collections.Generic.IList{`0})">
      <summary>
            Gets the triangles whose bounding boxes are overlapped by the query.
            </summary>
      <param name="ray">Shape to query against the tree.</param>
      <param name="maximumLength">Maximum length of the ray in units of the ray's length.</param>
      <param name="outputOverlappedElements">Indices of triangles in the index buffer with bounding boxes which are overlapped by the query.</param>
      <returns>Whether or not any elements were overlapped.</returns>
    </member>
    <member name="M:BEPUphysics.DataStructures.BoundingBoxTree`1.GetOverlaps``1(BEPUphysics.DataStructures.BoundingBoxTree{``0},System.Collections.Generic.IList{BEPUphysics.DataStructures.TreeOverlapPair{`0,``0}})">
      <summary>
            Gets the pairs of elements in each tree with overlapping bounding boxes.
            </summary>
      <typeparam name="TElement">Type of the elements in the opposing tree.</typeparam>
      <param name="tree">Other tree to test.</param>
      <param name="outputOverlappedElements">List of overlaps found by the query.</param>
      <returns>Whether or not any overlaps were found.</returns>
    </member>
    <member name="P:BEPUphysics.DataStructures.BoundingBoxTree`1.BoundingBox">
      <summary>
            Gets the bounding box surrounding the tree.
            </summary>
    </member>
    <member name="T:BEPUphysics.MathExtensions.Matrix3X3">
      <summary>
            3 row, 3 column matrix.
            </summary>
    </member>
    <member name="F:BEPUphysics.MathExtensions.Matrix3X3.M11">
      <summary>
            Value at row 1, column 1 of the matrix.
            </summary>
    </member>
    <member name="F:BEPUphysics.MathExtensions.Matrix3X3.M12">
      <summary>
            Value at row 1, column 2 of the matrix.
            </summary>
    </member>
    <member name="F:BEPUphysics.MathExtensions.Matrix3X3.M13">
      <summary>
            Value at row 1, column 3 of the matrix.
            </summary>
    </member>
    <member name="F:BEPUphysics.MathExtensions.Matrix3X3.M21">
      <summary>
            Value at row 2, column 1 of the matrix.
            </summary>
    </member>
    <member name="F:BEPUphysics.MathExtensions.Matrix3X3.M22">
      <summary>
            Value at row 2, column 2 of the matrix.
            </summary>
    </member>
    <member name="F:BEPUphysics.MathExtensions.Matrix3X3.M23">
      <summary>
            Value at row 2, column 3 of the matrix.
            </summary>
    </member>
    <member name="F:BEPUphysics.MathExtensions.Matrix3X3.M31">
      <summary>
            Value at row 3, column 1 of the matrix.
            </summary>
    </member>
    <member name="F:BEPUphysics.MathExtensions.Matrix3X3.M32">
      <summary>
            Value at row 3, column 2 of the matrix.
            </summary>
    </member>
    <member name="F:BEPUphysics.MathExtensions.Matrix3X3.M33">
      <summary>
            Value at row 3, column 3 of the matrix.
            </summary>
    </member>
    <member name="M:BEPUphysics.MathExtensions.Matrix3X3.#ctor(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
      <summary>
            Constructs a new 3 row, 3 column matrix.
            </summary>
      <param name="m11">Value at row 1, column 1 of the matrix.</param>
      <param name="m12">Value at row 1, column 2 of the matrix.</param>
      <param name="m13">Value at row 1, column 3 of the matrix.</param>
      <param name="m21">Value at row 2, column 1 of the matrix.</param>
      <param name="m22">Value at row 2, column 2 of the matrix.</param>
      <param name="m23">Value at row 2, column 3 of the matrix.</param>
      <param name="m31">Value at row 3, column 1 of the matrix.</param>
      <param name="m32">Value at row 3, column 2 of the matrix.</param>
      <param name="m33">Value at row 3, column 3 of the matrix.</param>
    </member>
    <member name="M:BEPUphysics.MathExtensions.Matrix3X3.Add(BEPUphysics.MathExtensions.Matrix3X3@,BEPUphysics.MathExtensions.Matrix3X3@,BEPUphysics.MathExtensions.Matrix3X3@)">
      <summary>
            Adds the two matrices together on a per-element basis.
            </summary>
      <param name="a">First matrix to add.</param>
      <param name="b">Second matrix to add.</param>
      <param name="result">Sum of the two matrices.</param>
    </member>
    <member name="M:BEPUphysics.MathExtensions.Matrix3X3.Add(Microsoft.Xna.Framework.Matrix@,BEPUphysics.MathExtensions.Matrix3X3@,BEPUphysics.MathExtensions.Matrix3X3@)">
      <summary>
            Adds the two matrices together on a per-element basis.
            </summary>
      <param name="a">First matrix to add.</param>
      <param name="b">Second matrix to add.</param>
      <param name="result">Sum of the two matrices.</param>
    </member>
    <member name="M:BEPUphysics.MathExtensions.Matrix3X3.Add(BEPUphysics.MathExtensions.Matrix3X3@,Microsoft.Xna.Framework.Matrix@,BEPUphysics.MathExtensions.Matrix3X3@)">
      <summary>
            Adds the two matrices together on a per-element basis.
            </summary>
      <param name="a">First matrix to add.</param>
      <param name="b">Second matrix to add.</param>
      <param name="result">Sum of the two matrices.</param>
    </member>
    <member name="M:BEPUphysics.MathExtensions.Matrix3X3.Add(Microsoft.Xna.Framework.Matrix@,Microsoft.Xna.Framework.Matrix@,BEPUphysics.MathExtensions.Matrix3X3@)">
      <summary>
            Adds the two matrices together on a per-element basis.
            </summary>
      <param name="a">First matrix to add.</param>
      <param name="b">Second matrix to add.</param>
      <param name="result">Sum of the two matrices.</param>
    </member>
    <member name="M:BEPUphysics.MathExtensions.Matrix3X3.CreateCrossProduct(Microsoft.Xna.Framework.Vector3@,BEPUphysics.MathExtensions.Matrix3X3@)">
      <summary>
            Creates a skew symmetric matrix M from vector A such that M * B for some other vector B is equivalent to the cross product of A and B.
            </summary>
      <param name="v">Vector to base the matrix on.</param>
      <param name="result">Skew-symmetric matrix result.</param>
    </member>
    <member name="M:BEPUphysics.MathExtensions.Matrix3X3.CreateFromMatrix(Microsoft.Xna.Framework.Matrix@,BEPUphysics.MathExtensions.Matrix3X3@)">
      <summary>
            Creates a 3x3 matrix from an XNA 4x4 matrix.
            </summary>
      <param name="matrix4X4">Matrix to extract a 3x3 matrix from.</param>
      <param name="matrix3X3">Upper 3x3 matrix extracted from the XNA matrix.</param>
    </member>
    <member name="M:BEPUphysics.MathExtensions.Matrix3X3.CreateScale(System.Single,BEPUphysics.MathExtensions.Matrix3X3@)">
      <summary>
            Constructs a uniform scaling matrix.
            </summary>
      <param name="scale">Value to use in the diagonal.</param>
      <param name="matrix">Scaling matrix.</param>
    </member>
    <member name="M:BEPUphysics.MathExtensions.Matrix3X3.CreateScale(System.Single)">
      <summary>
            Constructs a uniform scaling matrix.
            </summary>
      <param name="scale">Value to use in the diagonal.</param>
      <returns>Scaling matrix.</returns>
    </member>
    <member name="M:BEPUphysics.MathExtensions.Matrix3X3.CreateScale(Microsoft.Xna.Framework.Vector3@,BEPUphysics.MathExtensions.Matrix3X3@)">
      <summary>
            Constructs a non-uniform scaling matrix.
            </summary>
      <param name="scale">Values defining the axis scales.</param>
      <param name="matrix">Scaling matrix.</param>
    </member>
    <member name="M:BEPUphysics.MathExtensions.Matrix3X3.CreateScale(Microsoft.Xna.Framework.Vector3@)">
      <summary>
            Constructs a non-uniform scaling matrix.
            </summary>
      <param name="scale">Values defining the axis scales.</param>
      <returns>Scaling matrix.</returns>
    </member>
    <member name="M:BEPUphysics.MathExtensions.Matrix3X3.CreateScale(System.Single,System.Single,System.Single,BEPUphysics.MathExtensions.Matrix3X3@)">
      <summary>
            Constructs a non-uniform scaling matrix.
            </summary>
      <param name="x">Scaling along the x axis.</param>
      <param name="y">Scaling along the y axis.</param>
      <param name="z">Scaling along the z axis.</param>
      <param name="matrix">Scaling matrix.</param>
    </member>
    <member name="M:BEPUphysics.MathExtensions.Matrix3X3.CreateScale(System.Single,System.Single,System.Single)">
      <summary>
            Constructs a non-uniform scaling matrix.
            </summary>
      <param name="x">Scaling along the x axis.</param>
      <param name="y">Scaling along the y axis.</param>
      <param name="z">Scaling along the z axis.</param>
      <returns>Scaling matrix.</returns>
    </member>
    <member name="M:BEPUphysics.MathExtensions.Matrix3X3.Invert(BEPUphysics.MathExtensions.Matrix3X3@,BEPUphysics.MathExtensions.Matrix3X3@)">
      <summary>
            Inverts the given matix.
            </summary>
      <param name="matrix">Matrix to be inverted.</param>
      <param name="result">Inverted matrix.</param>
    </member>
    <member name="M:BEPUphysics.MathExtensions.Matrix3X3.op_Multiply(BEPUphysics.MathExtensions.Matrix3X3,BEPUphysics.MathExtensions.Matrix3X3)">
      <summary>
            Multiplies the two matrices.
            </summary>
      <param name="a">First matrix to multiply.</param>
      <param name="b">Second matrix to multiply.</param>
      <returns>Product of the multiplication.</returns>
    </member>
    <member name="M:BEPUphysics.MathExtensions.Matrix3X3.Multiply(BEPUphysics.MathExtensions.Matrix3X3@,BEPUphysics.MathExtensions.Matrix3X3@,BEPUphysics.MathExtensions.Matrix3X3@)">
      <summary>
            Multiplies the two matrices.
            </summary>
      <param name="a">First matrix to multiply.</param>
      <param name="b">Second matrix to multiply.</param>
      <param name="result">Product of the multiplication.</param>
    </member>
    <member name="M:BEPUphysics.MathExtensions.Matrix3X3.Multiply(BEPUphysics.MathExtensions.Matrix3X3@,Microsoft.Xna.Framework.Matrix@,BEPUphysics.MathExtensions.Matrix3X3@)">
      <summary>
            Multiplies the two matrices.
            </summary>
      <param name="a">First matrix to multiply.</param>
      <param name="b">Second matrix to multiply.</param>
      <param name="result">Product of the multiplication.</param>
    </member>
    <member name="M:BEPUphysics.MathExtensions.Matrix3X3.Multiply(Microsoft.Xna.Framework.Matrix@,BEPUphysics.MathExtensions.Matrix3X3@,BEPUphysics.MathExtensions.Matrix3X3@)">
      <summary>
            Multiplies the two matrices.
            </summary>
      <param name="a">First matrix to multiply.</param>
      <param name="b">Second matrix to multiply.</param>
      <param name="result">Product of the multiplication.</param>
    </member>
    <member name="M:BEPUphysics.MathExtensions.Matrix3X3.MultiplyTransposed(BEPUphysics.MathExtensions.Matrix3X3@,BEPUphysics.MathExtensions.Matrix3X3@,BEPUphysics.MathExtensions.Matrix3X3@)">
      <summary>
            Multiplies a transposed matrix with another matrix.
            </summary>
      <param name="matrix">Matrix to be multiplied.</param>
      <param name="transpose">Matrix to be transposed and multiplied.</param>
      <param name="result">Product of the multiplication.</param>
    </member>
    <member name="M:BEPUphysics.MathExtensions.Matrix3X3.MultiplyByTransposed(BEPUphysics.MathExtensions.Matrix3X3@,BEPUphysics.MathExtensions.Matrix3X3@,BEPUphysics.MathExtensions.Matrix3X3@)">
      <summary>
            Multiplies a matrix with a transposed matrix.
            </summary>
      <param name="matrix">Matrix to be multiplied.</param>
      <param name="transpose">Matrix to be transposed and multiplied.</param>
      <param name="result">Product of the multiplication.</param>
    </member>
    <member name="M:BEPUphysics.MathExtensions.Matrix3X3.Multiply(BEPUphysics.MathExtensions.Matrix3X3@,System.Single,BEPUphysics.MathExtensions.Matrix3X3@)">
      <summary>
            Scales the matrix.
            </summary>
      <param name="matrix">Matrix to scale.</param>
      <param name="scale">Amount to scale.</param>
      <param name="result">Scaled matrix.</param>
    </member>
    <member name="M:BEPUphysics.MathExtensions.Matrix3X3.Negate(BEPUphysics.MathExtensions.Matrix3X3@,BEPUphysics.MathExtensions.Matrix3X3@)">
      <summary>
            Negates every element in the matrix.
            </summary>
      <param name="matrix">Matrix to negate.</param>
      <param name="result">Negated matrix.</param>
    </member>
    <member name="M:BEPUphysics.MathExtensions.Matrix3X3.Subtract(BEPUphysics.MathExtensions.Matrix3X3@,BEPUphysics.MathExtensions.Matrix3X3@,BEPUphysics.MathExtensions.Matrix3X3@)">
      <summary>
            Subtracts the two matrices from each other on a per-element basis.
            </summary>
      <param name="a">First matrix to subtract.</param>
      <param name="b">Second matrix to subtract.</param>
      <param name="result">Difference of the two matrices.</param>
    </member>
    <member name="M:BEPUphysics.MathExtensions.Matrix3X3.ToMatrix4X4(BEPUphysics.MathExtensions.Matrix3X3@,Microsoft.Xna.Framework.Matrix@)">
      <summary>
            Creates a 4x4 matrix from a 3x3 matrix.
            </summary>
      <param name="a">3x3 matrix.</param>
      <param name="b">Created 4x4 matrix.</param>
    </member>
    <member name="M:BEPUphysics.MathExtensions.Matrix3X3.ToMatrix4X4(BEPUphysics.MathExtensions.Matrix3X3)">
      <summary>
            Creates a 4x4 matrix from a 3x3 matrix.
            </summary>
      <param name="a">3x3 matrix.</param>
      <returns>Created 4x4 matrix.</returns>
    </member>
    <member name="M:BEPUphysics.MathExtensions.Matrix3X3.Transform(Microsoft.Xna.Framework.Vector3,BEPUphysics.MathExtensions.Matrix3X3)">
      <summary>
            Transforms the vector by the matrix.
            </summary>
      <param name="v">Vector3 to transform.</param>
      <param name="matrix">Matrix to use as the transformation.</param>
      <returns>Product of the transformation.</returns>
    </member>
    <member name="M:BEPUphysics.MathExtensions.Matrix3X3.Transform(Microsoft.Xna.Framework.Vector3@,BEPUphysics.MathExtensions.Matrix3X3@,Microsoft.Xna.Framework.Vector3@)">
      <summary>
            Transforms the vector by the matrix.
            </summary>
      <param name="v">Vector3 to transform.</param>
      <param name="matrix">Matrix to use as the transformation.</param>
      <param name="result">Product of the transformation.</param>
    </member>
    <member name="M:BEPUphysics.MathExtensions.Matrix3X3.Transform(Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Matrix@,Microsoft.Xna.Framework.Vector3@)">
      <summary>
            Transforms the vector by the matrix.
            </summary>
      <param name="v">Vector3 to transform.</param>
      <param name="matrix">Matrix to use as the transformation.</param>
      <param name="result">Product of the transformation.</param>
    </member>
    <member name="M:BEPUphysics.MathExtensions.Matrix3X3.TransformTranspose(Microsoft.Xna.Framework.Vector3,BEPUphysics.MathExtensions.Matrix3X3)">
      <summary>
            Transforms the vector by the matrix's transpose.
            </summary>
      <param name="v">Vector3 to transform.</param>
      <param name="matrix">Matrix to use as the transformation transpose.</param>
      <returns>Product of the transformation.</returns>
    </member>
    <member name="M:BEPUphysics.MathExtensions.Matrix3X3.TransformTranspose(Microsoft.Xna.Framework.Vector3@,BEPUphysics.MathExtensions.Matrix3X3@,Microsoft.Xna.Framework.Vector3@)">
      <summary>
            Transforms the vector by the matrix's transpose.
            </summary>
      <param name="v">Vector3 to transform.</param>
      <param name="matrix">Matrix to use as the transformation transpose.</param>
      <param name="result">Product of the transformation.</param>
    </member>
    <member name="M:BEPUphysics.MathExtensions.Matrix3X3.TransformTranspose(Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Matrix@,Microsoft.Xna.Framework.Vector3@)">
      <summary>
            Transforms the vector by the matrix's transpose.
            </summary>
      <param name="v">Vector3 to transform.</param>
      <param name="matrix">Matrix to use as the transformation transpose.</param>
      <param name="result">Product of the transformation.</param>
    </member>
    <member name="M:BEPUphysics.MathExtensions.Matrix3X3.Transpose(BEPUphysics.MathExtensions.Matrix3X3@,BEPUphysics.MathExtensions.Matrix3X3@)">
      <summary>
            Computes the transposed matrix of a matrix.
            </summary>
      <param name="matrix">Matrix to transpose.</param>
      <param name="result">Transposed matrix.</param>
    </member>
    <member name="M:BEPUphysics.MathExtensions.Matrix3X3.Transpose(Microsoft.Xna.Framework.Matrix@,BEPUphysics.MathExtensions.Matrix3X3@)">
      <summary>
            Computes the transposed matrix of a matrix.
            </summary>
      <param name="matrix">Matrix to transpose.</param>
      <param name="result">Transposed matrix.</param>
    </member>
    <member name="M:BEPUphysics.MathExtensions.Matrix3X3.ToString">
      <summary>
            Creates a string representation of the matrix.
            </summary>
      <returns>A string representation of the matrix.</returns>
    </member>
    <member name="M:BEPUphysics.MathExtensions.Matrix3X3.Determinant">
      <summary>
            Calculates the determinant of the matrix.
            </summary>
      <returns>The matrix's determinant.</returns>
    </member>
    <member name="M:BEPUphysics.MathExtensions.Matrix3X3.CreateQuaternion(BEPUphysics.MathExtensions.Matrix3X3@,Microsoft.Xna.Framework.Quaternion@)">
      <summary>
            Constructs a quaternion from a 3x3 rotation matrix.
            </summary>
      <param name="r">Rotation matrix to create the quaternion from.</param>
      <param name="q">Quaternion based on the rotation matrix.</param>
    </member>
    <member name="M:BEPUphysics.MathExtensions.Matrix3X3.CreateFromQuaternion(Microsoft.Xna.Framework.Quaternion@,BEPUphysics.MathExtensions.Matrix3X3@)">
      <summary>
            Creates a 3x3 matrix representing the orientation stored in the quaternion.
            </summary>
      <param name="quaternion">Quaternion to use to create a matrix.</param>
      <param name="result">Matrix representing the quaternion's orientation.</param>
    </member>
    <member name="M:BEPUphysics.MathExtensions.Matrix3X3.CreateOuterProduct(Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Vector3@,BEPUphysics.MathExtensions.Matrix3X3@)">
      <summary>
            Computes the outer product of the given vectors.
            </summary>
      <param name="a">First vector.</param>
      <param name="b">Second vector.</param>
      <param name="result">Outer product result.</param>
    </member>
    <member name="M:BEPUphysics.MathExtensions.Matrix3X3.CreateFromAxisAngle(Microsoft.Xna.Framework.Vector3,System.Single)">
      <summary>
            Creates a matrix representing a rotation of a given angle around a given axis.
            </summary>
      <param name="axis">Axis around which to rotate.</param>
      <param name="angle">Amount to rotate.</param>
      <returns>Matrix representing the rotation.</returns>
    </member>
    <member name="M:BEPUphysics.MathExtensions.Matrix3X3.CreateFromAxisAngle(Microsoft.Xna.Framework.Vector3@,System.Single,BEPUphysics.MathExtensions.Matrix3X3@)">
      <summary>
            Creates a matrix representing a rotation of a given angle around a given axis.
            </summary>
      <param name="axis">Axis around which to rotate.</param>
      <param name="angle">Amount to rotate.</param>
      <param name="result">Matrix representing the rotation.</param>
    </member>
    <member name="P:BEPUphysics.MathExtensions.Matrix3X3.Identity">
      <summary>
            Gets the 3x3 identity matrix.
            </summary>
    </member>
    <member name="P:BEPUphysics.MathExtensions.Matrix3X3.Backward">
      <summary>
            Gets or sets the backward vector of the matrix.
            </summary>
    </member>
    <member name="P:BEPUphysics.MathExtensions.Matrix3X3.Down">
      <summary>
            Gets or sets the down vector of the matrix.
            </summary>
    </member>
    <member name="P:BEPUphysics.MathExtensions.Matrix3X3.Forward">
      <summary>
            Gets or sets the forward vector of the matrix.
            </summary>
    </member>
    <member name="P:BEPUphysics.MathExtensions.Matrix3X3.Left">
      <summary>
            Gets or sets the left vector of the matrix.
            </summary>
    </member>
    <member name="P:BEPUphysics.MathExtensions.Matrix3X3.Right">
      <summary>
            Gets or sets the right vector of the matrix.
            </summary>
    </member>
    <member name="P:BEPUphysics.MathExtensions.Matrix3X3.Up">
      <summary>
            Gets or sets the up vector of the matrix.
            </summary>
    </member>
    <member name="T:BEPUphysics.BroadPhaseSystems.IQueryAccelerator">
      <summary>
             Defines a system that accelerates bounding volume and ray cast queries.
            </summary>
    </member>
    <member name="M:BEPUphysics.BroadPhaseSystems.IQueryAccelerator.RayCast(Microsoft.Xna.Framework.Ray,System.Collections.Generic.IList{BEPUphysics.BroadPhaseSystems.BroadPhaseEntry})">
      <summary>
             Gets the broad phase entries overlapping the ray.
            </summary>
      <param name="ray">Ray to test.</param>
      <param name="outputIntersections">Overlapped entries.</param>
      <returns>Whether or not the ray hit anything.</returns>
    </member>
    <member name="M:BEPUphysics.BroadPhaseSystems.IQueryAccelerator.RayCast(Microsoft.Xna.Framework.Ray,System.Single,System.Collections.Generic.IList{BEPUphysics.BroadPhaseSystems.BroadPhaseEntry})">
      <summary>
             Gets the broad phase entries overlapping the ray.
            </summary>
      <param name="ray">Ray to test.</param>
      <param name="maximumLength">Maximum length of the ray in units of the ray's direction's length.</param>
      <param name="outputIntersections">Overlapped entries.</param>
      <returns>Whether or not the ray hit anything.</returns>
    </member>
    <member name="M:BEPUphysics.BroadPhaseSystems.IQueryAccelerator.GetEntries(Microsoft.Xna.Framework.BoundingBox,System.Collections.Generic.IList{BEPUphysics.BroadPhaseSystems.BroadPhaseEntry})">
      <summary>
            Gets the entries with bounding boxes which overlap the bounding shape.
            </summary>
      <param name="boundingShape">Bounding shape to test.</param>
      <param name="overlaps">Overlapped entries.</param>
    </member>
    <member name="M:BEPUphysics.BroadPhaseSystems.IQueryAccelerator.GetEntries(Microsoft.Xna.Framework.BoundingSphere,System.Collections.Generic.IList{BEPUphysics.BroadPhaseSystems.BroadPhaseEntry})">
      <summary>
            Gets the entries with bounding boxes which overlap the bounding shape.
            </summary>
      <param name="boundingShape">Bounding shape to test.</param>
      <param name="overlaps">Overlapped entries.</param>
    </member>
    <member name="M:BEPUphysics.BroadPhaseSystems.IQueryAccelerator.GetEntries(Microsoft.Xna.Framework.BoundingFrustum,System.Collections.Generic.IList{BEPUphysics.BroadPhaseSystems.BroadPhaseEntry})">
      <summary>
            Gets the entries with bounding boxes which overlap the bounding shape.
            </summary>
      <param name="boundingShape">Bounding shape to test.</param>
      <param name="overlaps">Overlapped entries.</param>
    </member>
    <member name="T:BEPUphysics.OtherSpaceStages.BoundingBoxUpdater">
      <summary>
             Updates the bounding box of managed objects.
            </summary>
    </member>
    <member name="M:BEPUphysics.OtherSpaceStages.BoundingBoxUpdater.#ctor(BEPUphysics.TimeStepSettings)">
      <summary>
             Constructs the bounding box updater.
            </summary>
      <param name="timeStepSettings">Time step setttings to be used by the updater.</param>
    </member>
    <member name="M:BEPUphysics.OtherSpaceStages.BoundingBoxUpdater.#ctor(BEPUphysics.TimeStepSettings,BEPUphysics.Threading.IThreadManager)">
      <summary>
             Constructs the bounding box updater.
            </summary>
      <param name="timeStepSettings">Time step setttings to be used by the updater.</param>
      <param name="threadManager">Thread manager to be used by the updater.</param>
    </member>
    <member name="M:BEPUphysics.OtherSpaceStages.BoundingBoxUpdater.Add(BEPUphysics.Collidables.MobileCollidables.MobileCollidable)">
      <summary>
             Adds an entry to the updater.
            </summary>
      <param name="entry">Entry to add.</param>
    </member>
    <member name="M:BEPUphysics.OtherSpaceStages.BoundingBoxUpdater.Remove(BEPUphysics.Collidables.MobileCollidables.MobileCollidable)">
      <summary>
             Removes an entry from the updater.
            </summary>
      <param name="entry">Entry to remove.</param>
    </member>
    <member name="P:BEPUphysics.OtherSpaceStages.BoundingBoxUpdater.TimeStepSettings">
      <summary>
             Gets or sets the time step settings used by the updater.
            </summary>
    </member>
    <member name="T:BEPUphysics.NarrowPhaseSystems.Factories.GeneralConvexFactory">
      <summary>
             Manufactures convex-convex pairs.
            </summary>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.Factories.GeneralConvexFactory.GetNarrowPhasePair(BEPUphysics.BroadPhaseSystems.BroadPhaseOverlap)">
      <summary>
             Manufactures and returns a narrow phase pair for the given overlap.
            </summary>
      <param name="overlap">Overlap used to create a pair.</param>
      <returns>Narrow phase pair.</returns>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.Factories.GeneralConvexFactory.GiveBack(BEPUphysics.NarrowPhaseSystems.Pairs.INarrowPhasePair)">
      <summary>
            Returns a pair to the factory for re-use.
            </summary>
      <param name="pair">Pair to return.</param>
    </member>
    <member name="T:BEPUphysics.NarrowPhaseSystems.Factories.CompoundConvexPairFactory">
      <summary>
             Manufactures compound-convex pairs.
            </summary>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.Factories.CompoundConvexPairFactory.GetNarrowPhasePair(BEPUphysics.BroadPhaseSystems.BroadPhaseOverlap)">
      <summary>
             Manufactures and returns a narrow phase pair for the given overlap.
            </summary>
      <param name="overlap">Overlap used to create a pair.</param>
      <returns>Narrow phase pair.</returns>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.Factories.CompoundConvexPairFactory.GiveBack(BEPUphysics.NarrowPhaseSystems.Pairs.INarrowPhasePair)">
      <summary>
            Returns a pair to the factory for re-use.
            </summary>
      <param name="pair">Pair to return.</param>
    </member>
    <member name="T:BEPUphysics.Constraints.I2DImpulseConstraint">
      <summary>
            Implemented by solver updateables which have a two dimensional impulse.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.I2DImpulseConstraint.RelativeVelocity">
      <summary>
            Gets the current relative velocity of the constraint.
            Computed based on the current connection velocities and jacobians.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.I2DImpulseConstraint.TotalImpulse">
      <summary>
            Gets the total impulse a constraint has applied.
            </summary>
    </member>
    <member name="T:BEPUphysics.Constraints.I2DImpulseConstraintWithError">
      <summary>
            Implemented by solver updateables which have a two dimensional impulse.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.I2DImpulseConstraintWithError.Error">
      <summary>
            Gets the current constraint error.
            </summary>
    </member>
    <member name="T:BEPUphysics.Constraints.I2DJacobianConstraint">
      <summary>
            Denotes a class that uses two linear jacobian axes.
            </summary>
    </member>
    <member name="M:BEPUphysics.Constraints.I2DJacobianConstraint.GetAngularJacobianA(Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Vector3@)">
      <summary>
            Gets the angular jacobian entry for the first connected entity.
            </summary>
      <param name="jacobianX">First angular jacobian entry for the first connected entity.</param>
      <param name="jacobianY">Second angular jacobian entry for the first connected entity.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.I2DJacobianConstraint.GetAngularJacobianB(Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Vector3@)">
      <summary>
            Gets the angular jacobian entry for the second connected entity.
            </summary>
      <param name="jacobianX">First angular jacobian entry for the second connected entity.</param>
      <param name="jacobianY">Second angular jacobian entry for the second connected entity.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.I2DJacobianConstraint.GetLinearJacobianA(Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Vector3@)">
      <summary>
            Gets the linear jacobian entry for the first connected entity.
            </summary>
      <param name="jacobianX">First linear jacobian entry for the first connected entity.</param>
      <param name="jacobianY">Second linear jacobian entry for the first connected entity.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.I2DJacobianConstraint.GetLinearJacobianB(Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Vector3@)">
      <summary>
            Gets the linear jacobian entry for the second connected entity.
            </summary>
      <param name="jacobianX">First linear jacobian entry for the second connected entity.</param>
      <param name="jacobianY">Second linear jacobian entry for the second connected entity.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.I2DJacobianConstraint.GetMassMatrix(BEPUphysics.MathExtensions.Matrix2X2@)">
      <summary>
            Gets the mass matrix of the constraint.
            </summary>
      <param name="massMatrix">Constraint's mass matrix.</param>
    </member>
    <member name="T:BEPUphysics.Constraints.TwoEntity.Joints.RevoluteAngularJoint">
      <summary>
            Constrains two entities to rotate only around a single axis.
            Acts like the angular portion of a hinge joint.
            </summary>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.Joints.RevoluteAngularJoint.#ctor">
      <summary>
            Constructs a new orientation joint.
            Orientation joints can be used to simulate the angular portion of a hinge.
            Orientation joints allow rotation around only a single axis.
            To finish the initialization, specify the connections (ConnectionA and ConnectionB) 
            as well as the WorldFreeAxisA and WorldFreeAxisB (or their entity-local versions).
            This constructor sets the constraint's IsActive property to false by default.
            </summary>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.Joints.RevoluteAngularJoint.#ctor(BEPUphysics.Entities.Entity,BEPUphysics.Entities.Entity,Microsoft.Xna.Framework.Vector3)">
      <summary>
            Constructs a new orientation joint.
            Orientation joints can be used to simulate the angular portion of a hinge.
            Orientation joints allow rotation around only a single axis.
            </summary>
      <param name="connectionA">First entity connected in the orientation joint.</param>
      <param name="connectionB">Second entity connected in the orientation joint.</param>
      <param name="freeAxis">Axis allowed to rotate freely in world space.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.Joints.RevoluteAngularJoint.GetLinearJacobianA(Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Vector3@)">
      <summary>
            Gets the linear jacobian entry for the first connected entity.
            </summary>
      <param name="jacobianX">First linear jacobian entry for the first connected entity.</param>
      <param name="jacobianY">Second linear jacobian entry for the first connected entity.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.Joints.RevoluteAngularJoint.GetLinearJacobianB(Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Vector3@)">
      <summary>
            Gets the linear jacobian entry for the second connected entity.
            </summary>
      <param name="jacobianX">First linear jacobian entry for the second connected entity.</param>
      <param name="jacobianY">Second linear jacobian entry for the second connected entity.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.Joints.RevoluteAngularJoint.GetAngularJacobianA(Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Vector3@)">
      <summary>
            Gets the angular jacobian entry for the first connected entity.
            </summary>
      <param name="jacobianX">First angular jacobian entry for the first connected entity.</param>
      <param name="jacobianY">Second angular jacobian entry for the first connected entity.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.Joints.RevoluteAngularJoint.GetAngularJacobianB(Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Vector3@)">
      <summary>
            Gets the angular jacobian entry for the second connected entity.
            </summary>
      <param name="jacobianX">First angular jacobian entry for the second connected entity.</param>
      <param name="jacobianY">Second angular jacobian entry for the second connected entity.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.Joints.RevoluteAngularJoint.GetMassMatrix(BEPUphysics.MathExtensions.Matrix2X2@)">
      <summary>
            Gets the mass matrix of the constraint.
            </summary>
      <param name="massMatrix">Constraint's mass matrix.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.Joints.RevoluteAngularJoint.SolveIteration">
      <summary>
            Computes one iteration of the constraint to meet the solver updateable's goal.
            </summary>
      <returns>The rough applied impulse magnitude.</returns>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.Joints.RevoluteAngularJoint.Update(System.Single)">
      <summary>
             Performs the frame's configuration step.
            </summary>
      <param name="dt">Timestep duration.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.Joints.RevoluteAngularJoint.ExclusiveUpdate">
      <summary>
            Performs any pre-solve iteration work that needs exclusive
            access to the members of the solver updateable.
            Usually, this is used for applying warmstarting impulses.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.Joints.RevoluteAngularJoint.LocalFreeAxisA">
      <summary>
            Gets or sets the free axis in connection A's local space.
            Updates the internal restricted axes.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.Joints.RevoluteAngularJoint.LocalFreeAxisB">
      <summary>
            Gets or sets the free axis in connection B's local space.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.Joints.RevoluteAngularJoint.WorldFreeAxisA">
      <summary>
            Gets or sets the free axis attached to connection A in world space.
            This does not change the other connection's free axis.
            Updates the internal restricted axes.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.Joints.RevoluteAngularJoint.WorldFreeAxisB">
      <summary>
            Gets or sets the free axis attached to connection A in world space.
            This does not change the other connection's free axis.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.Joints.RevoluteAngularJoint.RelativeVelocity">
      <summary>
            Gets the current relative velocity between the connected entities with respect to the constraint.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.Joints.RevoluteAngularJoint.TotalImpulse">
      <summary>
            Gets the total impulse applied by this constraint.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.Joints.RevoluteAngularJoint.Error">
      <summary>
            Gets the current constraint error.
            </summary>
    </member>
    <member name="T:BEPUphysics.Constraints.TwoEntity.Joints.DistanceJoint">
      <summary>
            Constraint which tries to maintain the distance between points on two entities.
            </summary>
    </member>
    <member name="F:BEPUphysics.Constraints.TwoEntity.Joints.DistanceJoint.distance">
      <summary>
            Distance maintained between the anchors.
            </summary>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.Joints.DistanceJoint.#ctor">
      <summary>
            Constructs a distance joint.
            To finish the initialization, specify the connections (ConnectionA and ConnectionB) 
            as well as the anchors (WorldAnchorA, WorldAnchorB or LocalAnchorA, LocalAnchorB)
            and the desired Distance.
            This constructor sets the constraint's IsActive property to false by default.
            </summary>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.Joints.DistanceJoint.#ctor(BEPUphysics.Entities.Entity,BEPUphysics.Entities.Entity,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3)">
      <summary>
            Constructs a distance joint.
            </summary>
      <param name="connectionA">First body connected to the distance joint.</param>
      <param name="connectionB">Second body connected to the distance joint.</param>
      <param name="anchorA">Connection to the distance joint from the first connected body in world space.</param>
      <param name="anchorB"> Connection to the distance joint from the second connected body in world space.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.Joints.DistanceJoint.GetLinearJacobianA(Microsoft.Xna.Framework.Vector3@)">
      <summary>
            Gets the linear jacobian entry for the first connected entity.
            </summary>
      <param name="jacobian">Linear jacobian entry for the first connected entity.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.Joints.DistanceJoint.GetLinearJacobianB(Microsoft.Xna.Framework.Vector3@)">
      <summary>
            Gets the linear jacobian entry for the second connected entity.
            </summary>
      <param name="jacobian">Linear jacobian entry for the second connected entity.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.Joints.DistanceJoint.GetAngularJacobianA(Microsoft.Xna.Framework.Vector3@)">
      <summary>
            Gets the angular jacobian entry for the first connected entity.
            </summary>
      <param name="jacobian">Angular jacobian entry for the first connected entity.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.Joints.DistanceJoint.GetAngularJacobianB(Microsoft.Xna.Framework.Vector3@)">
      <summary>
            Gets the angular jacobian entry for the second connected entity.
            </summary>
      <param name="jacobian">Angular jacobian entry for the second connected entity.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.Joints.DistanceJoint.GetMassMatrix(System.Single@)">
      <summary>
            Gets the mass matrix of the constraint.
            </summary>
      <param name="outputMassMatrix">Constraint's mass matrix.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.Joints.DistanceJoint.SolveIteration">
      <summary>
            Calculates and applies corrective impulses.
            Called automatically by space.
            </summary>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.Joints.DistanceJoint.Update(System.Single)">
      <summary>
            Calculates necessary information for velocity solving.
            </summary>
      <param name="dt">Time in seconds since the last update.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.Joints.DistanceJoint.ExclusiveUpdate">
      <summary>
            Performs any pre-solve iteration work that needs exclusive
            access to the members of the solver updateable.
            Usually, this is used for applying warmstarting impulses.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.Joints.DistanceJoint.Distance">
      <summary>
            Gets or sets the distance maintained between the anchors.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.Joints.DistanceJoint.LocalAnchorA">
      <summary>
            Gets or sets the first entity's connection point in local space.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.Joints.DistanceJoint.LocalAnchorB">
      <summary>
            Gets or sets the first entity's connection point in local space.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.Joints.DistanceJoint.WorldAnchorA">
      <summary>
            Gets or sets the connection to the distance constraint from the first connected body in world space.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.Joints.DistanceJoint.WorldAnchorB">
      <summary>
            Gets or sets the connection to the distance constraint from the second connected body in world space.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.Joints.DistanceJoint.RelativeVelocity">
      <summary>
            Gets the current relative velocity between the connected entities with respect to the constraint.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.Joints.DistanceJoint.TotalImpulse">
      <summary>
            Gets the total impulse applied by this constraint.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.Joints.DistanceJoint.Error">
      <summary>
            Gets the current constraint error.
            </summary>
    </member>
    <member name="T:BEPUphysics.Constraints.SolverGroups.SolverGroup">
      <summary>
            Superclass of constraints that are composed of multiple subconstraints.
            </summary>
    </member>
    <member name="M:BEPUphysics.Constraints.SolverGroups.SolverGroup.#ctor">
      <summary>
            Instantiates some internal values.
            </summary>
    </member>
    <member name="M:BEPUphysics.Constraints.SolverGroups.SolverGroup.CollectInvolvedEntities(BEPUphysics.DataStructures.RawList{BEPUphysics.Entities.Entity})">
      <summary>
            Collects the entities which are affected by the solver group and updates the internal listing.
            </summary>
    </member>
    <member name="M:BEPUphysics.Constraints.SolverGroups.SolverGroup.UpdateSolverActivity">
      <summary>
            Sets the activity state of the constraint based on the activity state of its connections.
            Called automatically by the space owning a constaint.  If a constraint is a sub-constraint that hasn't been directly added to the space,
            this may need to be called alongside the preStep from within the parent constraint.
            </summary>
    </member>
    <member name="M:BEPUphysics.Constraints.SolverGroups.SolverGroup.Update(System.Single)">
      <summary>
             Performs the frame's configuration step.
            </summary>
      <param name="dt">Timestep duration.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.SolverGroups.SolverGroup.ExclusiveUpdate">
      <summary>
            Performs any pre-solve iteration work that needs exclusive
            access to the members of the solver updateable.
            Usually, this is used for applying warmstarting impulses.
            </summary>
    </member>
    <member name="M:BEPUphysics.Constraints.SolverGroups.SolverGroup.SolveIteration">
      <summary>
            Computes one iteration of the constraint to meet the solver updateable's goal.
            </summary>
      <returns>The rough applied impulse magnitude.</returns>
    </member>
    <member name="M:BEPUphysics.Constraints.SolverGroups.SolverGroup.Add(BEPUphysics.Constraints.EntitySolverUpdateable)">
      <summary>
            Adds a solver updateable to the group.
            </summary>
      <param name="solverUpdateable">Solver updateable to add.</param>
      <exception cref="T:System.InvalidOperationException">Thrown when the SolverUpdateable to add to the SolverGroup already belongs to another SolverGroup or to a Space.</exception>
    </member>
    <member name="M:BEPUphysics.Constraints.SolverGroups.SolverGroup.Remove(BEPUphysics.Constraints.EntitySolverUpdateable)">
      <summary>
            Removes a solver updateable from the group.
            </summary>
      <param name="solverUpdateable">Solver updateable to remove.</param>
      <exception cref="T:System.InvalidOperationException">Thrown when the SolverUpdateable to remove from the SolverGroup doesn't actually belong to this SolverGroup.</exception>
    </member>
    <member name="M:BEPUphysics.Constraints.SolverGroups.SolverGroup.OnAdditionToSpace(BEPUphysics.ISpace)">
      <summary>
            Called after the object is added to a space.
            </summary>
      <param name="newSpace">
      </param>
    </member>
    <member name="M:BEPUphysics.Constraints.SolverGroups.SolverGroup.OnRemovalFromSpace(BEPUphysics.ISpace)">
      <summary>
            Called before an object is removed from its space.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.SolverGroups.SolverGroup.SolverUpdateables">
      <summary>
            Gets the solver updateables managed by this solver group.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.SolverGroups.SolverGroup.Solver">
      <summary>
             Gets the solver to which the solver updateable belongs.
            </summary>
    </member>
    <member name="T:BEPUphysics.Constraints.SolverGroups.RevoluteJoint">
      <summary>
            Restricts linear motion while allowing one degree of angular freedom.
            Acts like a normal door hinge.
            </summary>
    </member>
    <member name="M:BEPUphysics.Constraints.SolverGroups.RevoluteJoint.#ctor">
      <summary>
            Constructs a new constraint which restricts three degrees of linear freedom and two degrees of angular freedom between two entities.
            This constructs the internal constraints, but does not configure them.  Before using a constraint constructed in this manner,
            ensure that its active constituent constraints are properly configured.  The entire group as well as all internal constraints are initially inactive (IsActive = false).
            </summary>
    </member>
    <member name="M:BEPUphysics.Constraints.SolverGroups.RevoluteJoint.#ctor(BEPUphysics.Entities.Entity,BEPUphysics.Entities.Entity,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3)">
      <summary>
            Constructs a new constraint which restricts three degrees of linear freedom and two degrees of angular freedom between two entities.
            </summary>
      <param name="connectionA">First entity of the constraint pair.</param>
      <param name="connectionB">Second entity of the constraint pair.</param>
      <param name="anchor">Point around which both entities rotate.</param>
      <param name="freeAxis">Axis around which the hinge can rotate.</param>
    </member>
    <member name="P:BEPUphysics.Constraints.SolverGroups.RevoluteJoint.AngularJoint">
      <summary>
            Gets the angular joint which removes two degrees of freedom.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.SolverGroups.RevoluteJoint.BallSocketJoint">
      <summary>
            Gets the ball socket joint that restricts linear degrees of freedom.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.SolverGroups.RevoluteJoint.Limit">
      <summary>
            Gets the rotational limit of the hinge.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.SolverGroups.RevoluteJoint.Motor">
      <summary>
            Gets the motor of the hinge.
            </summary>
    </member>
    <member name="T:BEPUphysics.Constraints.SingleEntity.SingleEntityConstraint">
      <summary>
            Abstract superclass of constraints which control a single entity.
            </summary>
    </member>
    <member name="F:BEPUphysics.Constraints.SingleEntity.SingleEntityConstraint.iterationsAtZeroImpulse">
      <summary>
            Number of frames so far at effectively zero corrective impulse.
            Set to zero during every preStep(float dt) call and incremented by checkForEarlyOutIterations(Vector3 impulse).
            </summary>
    </member>
    <member name="F:BEPUphysics.Constraints.SingleEntity.SingleEntityConstraint.entity">
      <summary>
            Entity affected by the constraint.
            </summary>
    </member>
    <member name="M:BEPUphysics.Constraints.SingleEntity.SingleEntityConstraint.CollectInvolvedEntities(BEPUphysics.DataStructures.RawList{BEPUphysics.Entities.Entity})">
      <summary>
            Adds entities associated with the solver item to the involved entities list.
            Ensure that sortInvolvedEntities() is called at the end of the function.
            This allows the non-batched multithreading system to lock properly.
            </summary>
    </member>
    <member name="M:BEPUphysics.Constraints.SingleEntity.SingleEntityConstraint.UpdateSolverActivity">
      <summary>
            Updates the activity state of the constraint.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.SingleEntity.SingleEntityConstraint.Entity">
      <summary>
            Gets or sets the entity affected by the constraint.
            </summary>
    </member>
    <member name="T:BEPUphysics.Constraints.I3DImpulseConstraint">
      <summary>
            Implemented by solver updateables which have a three dimensional impulse.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.I3DImpulseConstraint.RelativeVelocity">
      <summary>
            Gets the current relative velocity of the constraint.
            Computed based on the current connection velocities and jacobians.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.I3DImpulseConstraint.TotalImpulse">
      <summary>
            Gets the total impulse a constraint has applied.
            </summary>
    </member>
    <member name="T:BEPUphysics.Constraints.SingleEntity.MaximumLinearSpeedConstraint">
      <summary>
            Prevents the target entity from moving faster than the specified speeds.
            </summary>
    </member>
    <member name="M:BEPUphysics.Constraints.SingleEntity.MaximumLinearSpeedConstraint.#ctor">
      <summary>
            Constructs a maximum speed constraint.
            Set its Entity and MaximumSpeed to complete the configuration.
            IsActive also starts as false with this constructor.
            </summary>
    </member>
    <member name="M:BEPUphysics.Constraints.SingleEntity.MaximumLinearSpeedConstraint.#ctor(BEPUphysics.Entities.Entity,System.Single)">
      <summary>
            Constructs a maximum speed constraint.
            </summary>
      <param name="e">Affected entity.</param>
      <param name="maxSpeed">Maximum linear speed allowed.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.SingleEntity.MaximumLinearSpeedConstraint.SolveIteration">
      <summary>
            Calculates and applies corrective impulses.
            Called automatically by space.
            </summary>
    </member>
    <member name="M:BEPUphysics.Constraints.SingleEntity.MaximumLinearSpeedConstraint.Update(System.Single)">
      <summary>
            Calculates necessary information for velocity solving.
            Called automatically by space.
            </summary>
      <param name="dt">Time in seconds since the last update.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.SingleEntity.MaximumLinearSpeedConstraint.ExclusiveUpdate">
      <summary>
            Performs any pre-solve iteration work that needs exclusive
            access to the members of the solver updateable.
            Usually, this is used for applying warmstarting impulses.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.SingleEntity.MaximumLinearSpeedConstraint.MaximumForce">
      <summary>
            Gets and sets the maximum impulse that the constraint will attempt to apply when satisfying its requirements.
            This field can be used to simulate friction in a constraint.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.SingleEntity.MaximumLinearSpeedConstraint.MaximumSpeed">
      <summary>
            Gets or sets the maximum linear speed that this constraint allows.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.SingleEntity.MaximumLinearSpeedConstraint.Softness">
      <summary>
            Gets and sets the softness of this constraint.
            Higher values of softness allow the constraint to be violated more.
            Must be greater than zero.
            Sometimes, if a joint system is unstable, increasing the softness of the involved constraints will make it settle down.
            For motors, softness can be used to implement damping.  For a damping constant k, the appropriate softness is 1/k.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.SingleEntity.MaximumLinearSpeedConstraint.TotalImpulse">
      <summary>
            Gets the total impulse applied by the constraint.
            </summary>
    </member>
    <member name="T:BEPUphysics.Constraints.I3DJacobianConstraint">
      <summary>
            Denotes a class that uses three linear jacobian axes.
            </summary>
    </member>
    <member name="M:BEPUphysics.Constraints.I3DJacobianConstraint.GetAngularJacobianA(Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Vector3@)">
      <summary>
            Gets the angular jacobian entry for the first connected entity.
            </summary>
      <param name="jacobianX">First angular jacobian entry for the first connected entity.</param>
      <param name="jacobianY">Second angular jacobian entry for the first connected entity.</param>
      <param name="jacobianZ">Third angular jacobian entry for the first connected entity.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.I3DJacobianConstraint.GetAngularJacobianB(Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Vector3@)">
      <summary>
            Gets the angular jacobian entry for the second connected entity.
            </summary>
      <param name="jacobianX">First angular jacobian entry for the second connected entity.</param>
      <param name="jacobianY">Second angular jacobian entry for the second connected entity.</param>
      <param name="jacobianZ">Third angular jacobian entry for the second connected entity.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.I3DJacobianConstraint.GetLinearJacobianA(Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Vector3@)">
      <summary>
            Gets the linear jacobian entry for the first connected entity.
            </summary>
      <param name="jacobianX">First linear jacobian entry for the first connected entity.</param>
      <param name="jacobianY">Second linear jacobian entry for the first connected entity.</param>
      <param name="jacobianZ">Third linear jacobian entry for the first connected entity.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.I3DJacobianConstraint.GetLinearJacobianB(Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Vector3@)">
      <summary>
            Gets the linear jacobian entry for the second connected entity.
            </summary>
      <param name="jacobianX">First linear jacobian entry for the second connected entity.</param>
      <param name="jacobianY">Second linear jacobian entry for the second connected entity.</param>
      <param name="jacobianZ">Third linear jacobian entry for the second connected entity.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.I3DJacobianConstraint.GetMassMatrix(BEPUphysics.MathExtensions.Matrix3X3@)">
      <summary>
            Gets the mass matrix of the constraint.
            </summary>
      <param name="outputMassMatrix">Constraint's mass matrix.</param>
    </member>
    <member name="T:BEPUphysics.DataStructures.TreeOverlapPair`2">
      <summary>
             Result of an overlap test between two trees of specified type.
            </summary>
      <typeparam name="T1">Type of elements in the first tree.</typeparam>
      <typeparam name="T2">Type of elements in the second tree.</typeparam>
    </member>
    <member name="F:BEPUphysics.DataStructures.TreeOverlapPair`2.OverlapA">
      <summary>
            Overlap owned by the first tree.
            </summary>
    </member>
    <member name="F:BEPUphysics.DataStructures.TreeOverlapPair`2.OverlapB">
      <summary>
            Overlap owned by the second tree.
            </summary>
    </member>
    <member name="M:BEPUphysics.DataStructures.TreeOverlapPair`2.#ctor(`0,`1)">
      <summary>
            Constructs a new overlap pair.
            </summary>
      <param name="overlapA">Overlap owned by the first tree.</param>
      <param name="overlapB">Overlap owned by the second tree.</param>
    </member>
    <member name="T:BEPUphysics.Threading.IThreadManager">
      <summary>
            Manages the engine's threads.
            </summary>
      <remarks>
            The thread manager is constructed with certain access assumptions in mind.
            When implementing custom thread managers, ensure that the requirements are met
            or exceeded with regard to concurrent access.
            </remarks>
    </member>
    <member name="M:BEPUphysics.Threading.IThreadManager.AddThread">
      <summary>
            Adds a new worker thread to the engine.
            </summary>
    </member>
    <member name="M:BEPUphysics.Threading.IThreadManager.AddThread(System.Action{System.Object},System.Object)">
      <summary>
            Adds a new worker thread to the engine.
            </summary>
      <param name="initialization">Function that the new thread will call before entering its work loop.</param>
      <param name="initializationInformation">Data to give the initializer.</param>
    </member>
    <member name="M:BEPUphysics.Threading.IThreadManager.EnqueueTask(System.Action{System.Object},System.Object)">
      <summary>
            Enqueues a task to the thread manager.
            This should be safe to call from multiple threads and from other tasks.
            </summary>
      <param name="taskBody">Method to run.</param>
      <param name="taskInformation">Data to give to the task.</param>
    </member>
    <member name="M:BEPUphysics.Threading.IThreadManager.ForLoop(System.Int32,System.Int32,System.Action{System.Int32})">
      <summary>
            Loops from the starting index (inclusive) to the ending index (exclusive), calling the loopBody at each iteration.
            The forLoop function will not return until all iterations are complete.
            This is meant to be used in a 'fork-join' model; only a single thread should be running a forLoop
            at any time.
            </summary>
      <param name="startIndex">Inclusive starting index.</param>
      <param name="endIndex">Exclusive ending index.</param>
      <param name="loopBody">Function that handles an individual iteration of the loop.</param>
    </member>
    <member name="M:BEPUphysics.Threading.IThreadManager.RemoveThread">
      <summary>
            Removes a worker thread from the engine.
            </summary>
    </member>
    <member name="M:BEPUphysics.Threading.IThreadManager.WaitForTaskCompletion">
      <summary>
            Waits until all tasks enqueued using enqueueTask are complete.
            </summary>
    </member>
    <member name="P:BEPUphysics.Threading.IThreadManager.ThreadCount">
      <summary>
            Gets the number of threads currently managed by the thread manager.
            </summary>
    </member>
    <member name="T:BEPUphysics.Threading.ThreadManagerTPL">
      <summary>
            Uses the .NET Task Parallel library to manage the engine's threads.
            </summary>
    </member>
    <member name="M:BEPUphysics.Threading.ThreadManagerTPL.#ctor">
      <summary>
            Constructs the TPL thread manager.
            </summary>
    </member>
    <member name="M:BEPUphysics.Threading.ThreadManagerTPL.AddThread">
      <summary>
            Notifies the thread manager that it should use another thread.
            </summary>
    </member>
    <member name="M:BEPUphysics.Threading.ThreadManagerTPL.AddThread(System.Action{System.Object},System.Object)">
      <summary>
            Notifies the thread manager that it should use another thread.
            </summary>
      <param name="initialization">Function to use to initialize the thread.</param>
      <param name="initializationInformation">Information to provide to the initializer.</param>
    </member>
    <member name="M:BEPUphysics.Threading.ThreadManagerTPL.RemoveThread">
      <summary>
            Notifies the thread manager that it should decrease the number of threads used.
            </summary>
    </member>
    <member name="M:BEPUphysics.Threading.ThreadManagerTPL.EnqueueTask(System.Action{System.Object},System.Object)">
      <summary>
            Enqueues a task to the thread manager.
            This should be safe to call from multiple threads and from other tasks.
            </summary>
      <param name="taskBody">Method to run.</param>
      <param name="taskInformation">Data to give to the task.</param>
    </member>
    <member name="M:BEPUphysics.Threading.ThreadManagerTPL.ForLoop(System.Int32,System.Int32,System.Action{System.Int32})">
      <summary>
            Loops from the starting index (inclusive) to the ending index (exclusive), calling the loopBody at each iteration.
            The forLoop function will not return until all iterations are complete.
            This is meant to be used in a 'fork-join' model; only a single thread should be running a forLoop
            at any time.
            </summary>
      <param name="startIndex">Inclusive starting index.</param>
      <param name="endIndex">Exclusive ending index.</param>
      <param name="loopBody">Function that handles an individual iteration of the loop.</param>
    </member>
    <member name="M:BEPUphysics.Threading.ThreadManagerTPL.WaitForTaskCompletion">
      <summary>
            Waits until all tasks enqueued using enqueueTask are complete.
            </summary>
    </member>
    <member name="M:BEPUphysics.Threading.ThreadManagerTPL.Dispose">
      <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
      <filterpriority>2</filterpriority>
    </member>
    <member name="P:BEPUphysics.Threading.ThreadManagerTPL.TaskManager">
      <summary>
            Gets or sets the task manager used to supplement the TPL.
            </summary>
    </member>
    <member name="P:BEPUphysics.Threading.ThreadManagerTPL.ThreadCount">
      <summary>
            Gets the number of threads that the threadpool is targeting.
            </summary>
    </member>
    <member name="T:BEPUphysics.SolverSystems.Solver">
      <summary>
             Iteratively solves solver updateables, converging to a solution for simulated joints and collision pair contact constraints.
            </summary>
    </member>
    <member name="M:BEPUphysics.SolverSystems.Solver.#ctor(BEPUphysics.TimeStepSettings,BEPUphysics.DeactivationManagement.DeactivationManager)">
      <summary>
             Constructs a Solver.
            </summary>
      <param name="timeStepSettings">Time step settings used by the solver.</param>
      <param name="deactivationManager">Deactivation manager used by the solver.</param>
    </member>
    <member name="M:BEPUphysics.SolverSystems.Solver.#ctor(BEPUphysics.TimeStepSettings,BEPUphysics.DeactivationManagement.DeactivationManager,BEPUphysics.Threading.IThreadManager)">
      <summary>
             Constructs a Solver.
            </summary>
      <param name="timeStepSettings">Time step settings used by the solver.</param>
      <param name="deactivationManager">Deactivation manager used by the solver.</param>
      <param name="threadManager">Thread manager used by the solver.</param>
    </member>
    <member name="M:BEPUphysics.SolverSystems.Solver.Add(BEPUphysics.SolverSystems.SolverUpdateable)">
      <summary>
             Adds a solver updateable to the solver.
            </summary>
      <param name="item">Updateable to add.</param>
      <exception cref="T:System.ArgumentException">Thrown when the item already belongs to a solver.</exception>
    </member>
    <member name="M:BEPUphysics.SolverSystems.Solver.Remove(BEPUphysics.SolverSystems.SolverUpdateable)">
      <summary>
             Removes a solver updateable from the solver.
            </summary>
      <param name="item">Updateable to remove.</param>
      <exception cref="T:System.ArgumentException">Thrown when the item does not belong to the solver.</exception>
    </member>
    <member name="P:BEPUphysics.SolverSystems.Solver.IterationLimit">
      <summary>
             Gets or sets the maximum number of iterations the solver will attempt to use to solve the simulation's constraints.
            </summary>
    </member>
    <member name="P:BEPUphysics.SolverSystems.Solver.SolverUpdateables">
      <summary>
             Gets the list of solver updateables in the solver.
            </summary>
    </member>
    <member name="P:BEPUphysics.SolverSystems.Solver.TimeStepSettings">
      <summary>
             Gets or sets the time step settings used by the solver.
            </summary>
    </member>
    <member name="P:BEPUphysics.SolverSystems.Solver.DeactivationManager">
      <summary>
             Gets or sets the deactivation manager used by the solver.
             When constraints are added and removed, the deactivation manager
             gains and loses simulation island connections that affect simulation islands
             and activity states.
            </summary>
    </member>
    <member name="T:BEPUphysics.Paths.ConstantSpeedCurve`1">
      <summary>
            Superclass of speed-controlled curves that have a constant speed.
            </summary>
      <typeparam name="TValue">Type of the values in the curve.</typeparam>
    </member>
    <member name="M:BEPUphysics.Paths.ConstantSpeedCurve`1.#ctor(System.Single,BEPUphysics.Paths.Curve{`0})">
      <summary>
            Constructs a new constant speed curve.
            </summary>
      <param name="speed">Speed to maintain while traveling around a curve.</param>
      <param name="curve">Curve to wrap.</param>
    </member>
    <member name="M:BEPUphysics.Paths.ConstantSpeedCurve`1.#ctor(System.Single,BEPUphysics.Paths.Curve{`0},System.Int32)">
      <summary>
            Constructs a new constant speed curve.
            </summary>
      <param name="speed">Speed to maintain while traveling around a curve.</param>
      <param name="curve">Curve to wrap.</param>
      <param name="sampleCount">Number of samples to use when constructing the wrapper curve.
            More samples increases the accuracy of the speed requirement at the cost of performance.</param>
    </member>
    <member name="M:BEPUphysics.Paths.ConstantSpeedCurve`1.GetSpeedAtCurveTime(System.Single)">
      <summary>
            Gets the desired speed at a given time.
            </summary>
      <param name="time">Time to check for speed.</param>
      <returns>Speed at the given time.</returns>
    </member>
    <member name="P:BEPUphysics.Paths.ConstantSpeedCurve`1.Speed">
      <summary>
            Gets or sets the speed of the curve.
            </summary>
    </member>
    <member name="T:BEPUphysics.Paths.ConstantLinearSpeedCurve">
      <summary>
            Wrapper around a 3d position curve that specifies a specific velocity at which to travel.
            </summary>
    </member>
    <member name="M:BEPUphysics.Paths.ConstantLinearSpeedCurve.#ctor(System.Single,BEPUphysics.Paths.Curve{Microsoft.Xna.Framework.Vector3})">
      <summary>
            Constructs a new constant speed curve.
            </summary>
      <param name="speed">Speed to maintain while traveling around a curve.</param>
      <param name="curve">Curve to wrap.</param>
    </member>
    <member name="M:BEPUphysics.Paths.ConstantLinearSpeedCurve.#ctor(System.Single,BEPUphysics.Paths.Curve{Microsoft.Xna.Framework.Vector3},System.Int32)">
      <summary>
            Constructs a new constant speed curve.
            </summary>
      <param name="speed">Speed to maintain while traveling around a curve.</param>
      <param name="curve">Curve to wrap.</param>
      <param name="sampleCount">Number of samples to use when constructing the wrapper curve.
            More samples increases the accuracy of the speed requirement at the cost of performance.</param>
    </member>
    <member name="T:BEPUphysics.MathExtensions.Matrix3X2">
      <summary>
            3 row, 2 column matrix.
            </summary>
    </member>
    <member name="F:BEPUphysics.MathExtensions.Matrix3X2.M11">
      <summary>
            Value at row 1, column 1 of the matrix.
            </summary>
    </member>
    <member name="F:BEPUphysics.MathExtensions.Matrix3X2.M12">
      <summary>
            Value at row 1, column 2 of the matrix.
            </summary>
    </member>
    <member name="F:BEPUphysics.MathExtensions.Matrix3X2.M21">
      <summary>
            Value at row 2, column 1 of the matrix.
            </summary>
    </member>
    <member name="F:BEPUphysics.MathExtensions.Matrix3X2.M22">
      <summary>
            Value at row 2, column 2 of the matrix.
            </summary>
    </member>
    <member name="F:BEPUphysics.MathExtensions.Matrix3X2.M31">
      <summary>
            Value at row 3, column 1 of the matrix.
            </summary>
    </member>
    <member name="F:BEPUphysics.MathExtensions.Matrix3X2.M32">
      <summary>
            Value at row 3, column 2 of the matrix.
            </summary>
    </member>
    <member name="M:BEPUphysics.MathExtensions.Matrix3X2.#ctor(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
      <summary>
            Constructs a new 3 row, 2 column matrix.
            </summary>
      <param name="m11">Value at row 1, column 1 of the matrix.</param>
      <param name="m12">Value at row 1, column 2 of the matrix.</param>
      <param name="m21">Value at row 2, column 1 of the matrix.</param>
      <param name="m22">Value at row 2, column 2 of the matrix.</param>
      <param name="m31">Value at row 2, column 1 of the matrix.</param>
      <param name="m32">Value at row 2, column 2 of the matrix.</param>
    </member>
    <member name="M:BEPUphysics.MathExtensions.Matrix3X2.Add(BEPUphysics.MathExtensions.Matrix3X2@,BEPUphysics.MathExtensions.Matrix3X2@,BEPUphysics.MathExtensions.Matrix3X2@)">
      <summary>
            Adds the two matrices together on a per-element basis.
            </summary>
      <param name="a">First matrix to add.</param>
      <param name="b">Second matrix to add.</param>
      <param name="result">Sum of the two matrices.</param>
    </member>
    <member name="M:BEPUphysics.MathExtensions.Matrix3X2.Multiply(BEPUphysics.MathExtensions.Matrix3X3@,BEPUphysics.MathExtensions.Matrix3X2@,BEPUphysics.MathExtensions.Matrix3X2@)">
      <summary>
            Multiplies the two matrices.
            </summary>
      <param name="a">First matrix to multiply.</param>
      <param name="b">Second matrix to multiply.</param>
      <param name="result">Product of the multiplication.</param>
    </member>
    <member name="M:BEPUphysics.MathExtensions.Matrix3X2.Multiply(Microsoft.Xna.Framework.Matrix@,BEPUphysics.MathExtensions.Matrix3X2@,BEPUphysics.MathExtensions.Matrix3X2@)">
      <summary>
            Multiplies the two matrices.
            </summary>
      <param name="a">First matrix to multiply.</param>
      <param name="b">Second matrix to multiply.</param>
      <param name="result">Product of the multiplication.</param>
    </member>
    <member name="M:BEPUphysics.MathExtensions.Matrix3X2.Negate(BEPUphysics.MathExtensions.Matrix3X2@,BEPUphysics.MathExtensions.Matrix3X2@)">
      <summary>
            Negates every element in the matrix.
            </summary>
      <param name="matrix">Matrix to negate.</param>
      <param name="result">Negated matrix.</param>
    </member>
    <member name="M:BEPUphysics.MathExtensions.Matrix3X2.Subtract(BEPUphysics.MathExtensions.Matrix3X2@,BEPUphysics.MathExtensions.Matrix3X2@,BEPUphysics.MathExtensions.Matrix3X2@)">
      <summary>
            Subtracts the two matrices from each other on a per-element basis.
            </summary>
      <param name="a">First matrix to subtract.</param>
      <param name="b">Second matrix to subtract.</param>
      <param name="result">Difference of the two matrices.</param>
    </member>
    <member name="M:BEPUphysics.MathExtensions.Matrix3X2.Transform(Microsoft.Xna.Framework.Vector2@,BEPUphysics.MathExtensions.Matrix3X2@,Microsoft.Xna.Framework.Vector3@)">
      <summary>
            Transforms the vector by the matrix.
            </summary>
      <param name="v">Vector2 to transform.  Considered to be a column vector for purposes of multiplication.</param>
      <param name="matrix">Matrix to use as the transformation.</param>
      <param name="result">Column vector product of the transformation.</param>
    </member>
    <member name="M:BEPUphysics.MathExtensions.Matrix3X2.Transform(Microsoft.Xna.Framework.Vector3@,BEPUphysics.MathExtensions.Matrix3X2@,Microsoft.Xna.Framework.Vector2@)">
      <summary>
            Transforms the vector by the matrix.
            </summary>
      <param name="v">Vector2 to transform.  Considered to be a row vector for purposes of multiplication.</param>
      <param name="matrix">Matrix to use as the transformation.</param>
      <param name="result">Row vector product of the transformation.</param>
    </member>
    <member name="M:BEPUphysics.MathExtensions.Matrix3X2.Transpose(BEPUphysics.MathExtensions.Matrix3X2@,BEPUphysics.MathExtensions.Matrix2X3@)">
      <summary>
            Computes the transposed matrix of a matrix.
            </summary>
      <param name="matrix">Matrix to transpose.</param>
      <param name="result">Transposed matrix.</param>
    </member>
    <member name="M:BEPUphysics.MathExtensions.Matrix3X2.ToString">
      <summary>
            Creates a string representation of the matrix.
            </summary>
      <returns>A string representation of the matrix.</returns>
    </member>
    <member name="T:BEPUphysics.MathExtensions.Matrix2X3">
      <summary>
            2 row, 3 column matrix.
            </summary>
    </member>
    <member name="F:BEPUphysics.MathExtensions.Matrix2X3.M11">
      <summary>
            Value at row 1, column 1 of the matrix.
            </summary>
    </member>
    <member name="F:BEPUphysics.MathExtensions.Matrix2X3.M12">
      <summary>
            Value at row 1, column 2 of the matrix.
            </summary>
    </member>
    <member name="F:BEPUphysics.MathExtensions.Matrix2X3.M13">
      <summary>
            Value at row 1, column 2 of the matrix.
            </summary>
    </member>
    <member name="F:BEPUphysics.MathExtensions.Matrix2X3.M21">
      <summary>
            Value at row 2, column 1 of the matrix.
            </summary>
    </member>
    <member name="F:BEPUphysics.MathExtensions.Matrix2X3.M22">
      <summary>
            Value at row 2, column 2 of the matrix.
            </summary>
    </member>
    <member name="F:BEPUphysics.MathExtensions.Matrix2X3.M23">
      <summary>
            Value at row 2, column 3 of the matrix.
            </summary>
    </member>
    <member name="M:BEPUphysics.MathExtensions.Matrix2X3.#ctor(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
      <summary>
            Constructs a new 2 row, 2 column matrix.
            </summary>
      <param name="m11">Value at row 1, column 1 of the matrix.</param>
      <param name="m12">Value at row 1, column 2 of the matrix.</param>
      <param name="m13">Value at row 1, column 3 of the matrix.</param>
      <param name="m21">Value at row 2, column 1 of the matrix.</param>
      <param name="m22">Value at row 2, column 2 of the matrix.</param>
      <param name="m23">Value at row 2, column 3 of the matrix.</param>
    </member>
    <member name="M:BEPUphysics.MathExtensions.Matrix2X3.Add(BEPUphysics.MathExtensions.Matrix2X3@,BEPUphysics.MathExtensions.Matrix2X3@,BEPUphysics.MathExtensions.Matrix2X3@)">
      <summary>
            Adds the two matrices together on a per-element basis.
            </summary>
      <param name="a">First matrix to add.</param>
      <param name="b">Second matrix to add.</param>
      <param name="result">Sum of the two matrices.</param>
    </member>
    <member name="M:BEPUphysics.MathExtensions.Matrix2X3.Multiply(BEPUphysics.MathExtensions.Matrix2X3@,BEPUphysics.MathExtensions.Matrix3X3@,BEPUphysics.MathExtensions.Matrix2X3@)">
      <summary>
            Multiplies the two matrices.
            </summary>
      <param name="a">First matrix to multiply.</param>
      <param name="b">Second matrix to multiply.</param>
      <param name="result">Product of the multiplication.</param>
    </member>
    <member name="M:BEPUphysics.MathExtensions.Matrix2X3.Multiply(BEPUphysics.MathExtensions.Matrix2X3@,Microsoft.Xna.Framework.Matrix@,BEPUphysics.MathExtensions.Matrix2X3@)">
      <summary>
            Multiplies the two matrices.
            </summary>
      <param name="a">First matrix to multiply.</param>
      <param name="b">Second matrix to multiply.</param>
      <param name="result">Product of the multiplication.</param>
    </member>
    <member name="M:BEPUphysics.MathExtensions.Matrix2X3.Negate(BEPUphysics.MathExtensions.Matrix2X3@,BEPUphysics.MathExtensions.Matrix2X3@)">
      <summary>
            Negates every element in the matrix.
            </summary>
      <param name="matrix">Matrix to negate.</param>
      <param name="result">Negated matrix.</param>
    </member>
    <member name="M:BEPUphysics.MathExtensions.Matrix2X3.Subtract(BEPUphysics.MathExtensions.Matrix2X3@,BEPUphysics.MathExtensions.Matrix2X3@,BEPUphysics.MathExtensions.Matrix2X3@)">
      <summary>
            Subtracts the two matrices from each other on a per-element basis.
            </summary>
      <param name="a">First matrix to subtract.</param>
      <param name="b">Second matrix to subtract.</param>
      <param name="result">Difference of the two matrices.</param>
    </member>
    <member name="M:BEPUphysics.MathExtensions.Matrix2X3.Transform(Microsoft.Xna.Framework.Vector2@,BEPUphysics.MathExtensions.Matrix2X3@,Microsoft.Xna.Framework.Vector3@)">
      <summary>
            Transforms the vector by the matrix.
            </summary>
      <param name="v">Vector2 to transform.  Considered to be a row vector for purposes of multiplication.</param>
      <param name="matrix">Matrix to use as the transformation.</param>
      <param name="result">Row vector product of the transformation.</param>
    </member>
    <member name="M:BEPUphysics.MathExtensions.Matrix2X3.Transform(Microsoft.Xna.Framework.Vector3@,BEPUphysics.MathExtensions.Matrix2X3@,Microsoft.Xna.Framework.Vector2@)">
      <summary>
            Transforms the vector by the matrix.
            </summary>
      <param name="v">Vector2 to transform.  Considered to be a column vector for purposes of multiplication.</param>
      <param name="matrix">Matrix to use as the transformation.</param>
      <param name="result">Column vector product of the transformation.</param>
    </member>
    <member name="M:BEPUphysics.MathExtensions.Matrix2X3.Transpose(BEPUphysics.MathExtensions.Matrix2X3@,BEPUphysics.MathExtensions.Matrix3X2@)">
      <summary>
            Computes the transposed matrix of a matrix.
            </summary>
      <param name="matrix">Matrix to transpose.</param>
      <param name="result">Transposed matrix.</param>
    </member>
    <member name="M:BEPUphysics.MathExtensions.Matrix2X3.ToString">
      <summary>
            Creates a string representation of the matrix.
            </summary>
      <returns>A string representation of the matrix.</returns>
    </member>
    <member name="T:BEPUphysics.PositionUpdating.PositionUpdater">
      <summary>
             Superclass of updaters which manage the position of objects.
            </summary>
    </member>
    <member name="M:BEPUphysics.PositionUpdating.PositionUpdater.Add(BEPUphysics.PositionUpdating.IPositionUpdateable)">
      <summary>
             Adds an object to the position updater.
            </summary>
      <param name="updateable">Updateable to add.</param>
      <exception cref="T:System.Exception">Thrown if the updateable already belongs to a position updater.</exception>
    </member>
    <member name="M:BEPUphysics.PositionUpdating.PositionUpdater.Remove(BEPUphysics.PositionUpdating.IPositionUpdateable)">
      <summary>
             Removes an updateable from the updater.
            </summary>
      <param name="updateable">Item to remove.</param>
      <exception cref="T:System.Exception">Thrown if the updater does not own the updateable.</exception>
    </member>
    <member name="P:BEPUphysics.PositionUpdating.PositionUpdater.TimeStepSettings">
      <summary>
             Gets or sets the time step settings used by the updater.
            </summary>
    </member>
    <member name="T:BEPUphysics.NarrowPhaseSystems.Pairs.IPairHandlerParent">
      <summary>
             Defines a pair handler which can have children.
            </summary>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.Pairs.IPairHandlerParent.OnContactAdded(BEPUphysics.CollisionTests.Contact)">
      <summary>
             Called when a child adds a contact.
            </summary>
      <param name="contact">Contact added.</param>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.Pairs.IPairHandlerParent.OnContactRemoved(BEPUphysics.CollisionTests.Contact)">
      <summary>
            Called when a child removes a contact.
            </summary>
      <param name="contact">Contact removed.</param>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.Pairs.IPairHandlerParent.AddSolverUpdateable(BEPUphysics.Constraints.EntitySolverUpdateable)">
      <summary>
             Called when a child attempts to add a solver updateable to the solver.
            </summary>
      <param name="addedItem">Item to add.</param>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.Pairs.IPairHandlerParent.RemoveSolverUpdateable(BEPUphysics.Constraints.EntitySolverUpdateable)">
      <summary>
             Called when a child attempts to remove a solver updateable from the solver.
            </summary>
      <param name="removedItem">Item to remove.</param>
    </member>
    <member name="T:BEPUphysics.NarrowPhaseSystems.Pairs.CompoundTerrainPairHandler">
      <summary>
             Handles a compound-terrain collision pair.
            </summary>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.Pairs.CompoundTerrainPairHandler.#ctor">
      <summary>
             Constructs a new pair handler.
            </summary>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.Pairs.CompoundTerrainPairHandler.Initialize(BEPUphysics.BroadPhaseSystems.BroadPhaseEntry,BEPUphysics.BroadPhaseSystems.BroadPhaseEntry)">
      <summary>
             Initializes the pair handler.
            </summary>
      <param name="entryA">First entry in the pair.</param>
      <param name="entryB">Second entry in the pair.</param>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.Pairs.CompoundTerrainPairHandler.UpdateMaterialProperties">
      <summary>
             Forces an update of the pair's material properties.
            </summary>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.Pairs.CompoundTerrainPairHandler.OnAddedToNarrowPhase">
      <summary>
             Called when the pair handler is added to the narrow phase.
            </summary>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.Pairs.CompoundTerrainPairHandler.CleanUp">
      <summary>
             Cleans up the pair handler.
            </summary>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.Pairs.CompoundTerrainPairHandler.UpdateCollision(System.Single)">
      <summary>
             Updates the pair handler.
            </summary>
      <param name="dt">Timestep duration.</param>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.Pairs.CompoundTerrainPairHandler.UpdateTimeOfImpact(BEPUphysics.Collidables.Collidable,System.Single)">
      <summary>
             Updates the time of impact for the pair.
            </summary>
      <param name="requester">Collidable requesting the update.</param>
      <param name="dt">Timestep duration.</param>
    </member>
    <member name="P:BEPUphysics.NarrowPhaseSystems.Pairs.CompoundTerrainPairHandler.ChildPairs">
      <summary>
             Gets the pair handlers associated with children of the compound.
            </summary>
    </member>
    <member name="T:BEPUphysics.NarrowPhaseSystems.Pairs.ContactCollection">
      <summary>
             Convenience collection of contacts and their associated data.
            </summary>
    </member>
    <member name="T:BEPUphysics.NarrowPhaseSystems.Pairs.ContactCollection.Enumerator">
      <summary>
             Enumerator for the contact collection.
            </summary>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.Pairs.ContactCollection.Enumerator.Dispose">
      <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
      <filterpriority>2</filterpriority>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.Pairs.ContactCollection.Enumerator.MoveNext">
      <summary>
            Advances the enumerator to the next element of the collection.
            </summary>
      <returns>
            true if the enumerator was successfully advanced to the next element; false if the enumerator has passed the end of the collection.
            </returns>
      <exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created. </exception>
      <filterpriority>2</filterpriority>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.Pairs.ContactCollection.Enumerator.Reset">
      <summary>
            Sets the enumerator to its initial position, which is before the first element in the collection.
            </summary>
      <exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created. </exception>
      <filterpriority>2</filterpriority>
    </member>
    <member name="P:BEPUphysics.NarrowPhaseSystems.Pairs.ContactCollection.Enumerator.Current">
      <summary>
            Gets the element in the collection at the current position of the enumerator.
            </summary>
      <returns>
            The element in the collection at the current position of the enumerator.
            </returns>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.Pairs.ContactCollection.GetEnumerator">
      <summary>
             Gets an enumerator for the collection.
            </summary>
      <returns>Enumerator for the contact collection.</returns>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.Pairs.ContactCollection.Contains(BEPUphysics.NarrowPhaseSystems.Pairs.ContactInformation)">
      <summary>
            Determines whether the <see cref="T:System.Collections.Generic.ICollection`1" /> contains a specific value.
            </summary>
      <returns>
            true if <paramref name="item" /> is found in the <see cref="T:System.Collections.Generic.ICollection`1" />; otherwise, false.
            </returns>
      <param name="item">The object to locate in the <see cref="T:System.Collections.Generic.ICollection`1" />.</param>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.Pairs.ContactCollection.CopyTo(BEPUphysics.NarrowPhaseSystems.Pairs.ContactInformation[],System.Int32)">
      <summary>
            Copies the elements of the <see cref="T:System.Collections.Generic.ICollection`1" /> to an <see cref="T:System.Array" />, starting at a particular <see cref="T:System.Array" /> index.
            </summary>
      <param name="array">The one-dimensional <see cref="T:System.Array" /> that is the destination of the elements copied from <see cref="T:System.Collections.Generic.ICollection`1" />. The <see cref="T:System.Array" /> must have zero-based indexing.</param>
      <param name="arrayIndex">The zero-based index in <paramref name="array" /> at which copying begins.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="array" /> is null.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="arrayIndex" /> is less than 0.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="array" /> is multidimensional.-or-The number of elements in the source <see cref="T:System.Collections.Generic.ICollection`1" /> is greater than the available space from <paramref name="arrayIndex" /> to the end of the destination <paramref name="array" />.-or-Type cannot be cast automatically to the type of the destination <paramref name="array" />.</exception>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.Pairs.ContactCollection.IndexOf(BEPUphysics.NarrowPhaseSystems.Pairs.ContactInformation)">
      <summary>
            Determines the index of a specific item in the <see cref="T:System.Collections.Generic.IList`1" />.
            </summary>
      <returns>
            The index of <paramref name="item" /> if found in the list; otherwise, -1.
            </returns>
      <param name="item">The object to locate in the <see cref="T:System.Collections.Generic.IList`1" />.</param>
    </member>
    <member name="P:BEPUphysics.NarrowPhaseSystems.Pairs.ContactCollection.Count">
      <summary>
            Gets the number of elements contained in the <see cref="T:System.Collections.Generic.ICollection`1" />.
            </summary>
      <returns>
            The number of elements contained in the <see cref="T:System.Collections.Generic.ICollection`1" />.
            </returns>
    </member>
    <member name="P:BEPUphysics.NarrowPhaseSystems.Pairs.ContactCollection.Item(System.Int32)">
      <summary>
            Gets or sets the element at the specified index.
            </summary>
      <returns>
            The element at the specified index.
            </returns>
      <param name="index">The zero-based index of the element to get or set.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> is not a valid index in the <see cref="T:System.Collections.Generic.IList`1" />.</exception>
      <exception cref="T:System.NotSupportedException">The property is set and the <see cref="T:System.Collections.Generic.IList`1" /> is read-only.</exception>
    </member>
    <member name="T:BEPUphysics.Constraints.I3DImpulseConstraintWithError">
      <summary>
            Implemented by solver updateables which have a three dimensional impulse.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.I3DImpulseConstraintWithError.Error">
      <summary>
            Gets the current constraint error.
            </summary>
    </member>
    <member name="T:BEPUphysics.Constraints.TwoEntity.Joints.BallSocketJoint">
      <summary>
            Connects two entities with a spherical joint.  Acts like an unrestricted shoulder joint.
            </summary>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.Joints.BallSocketJoint.#ctor">
      <summary>
            Constructs a spherical joint.
            To finish the initialization, specify the connections (ConnectionA and ConnectionB) 
            as well as the offsets (OffsetA, OffsetB or LocalOffsetA, LocalOffsetB).
            This constructor sets the constraint's IsActive property to false by default.
            </summary>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.Joints.BallSocketJoint.#ctor(BEPUphysics.Entities.Entity,BEPUphysics.Entities.Entity,Microsoft.Xna.Framework.Vector3)">
      <summary>
            Constructs a spherical joint.
            </summary>
      <param name="connectionA">First connected entity.</param>
      <param name="connectionB">Second connected entity.</param>
      <param name="anchorLocation">Location of the socket.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.Joints.BallSocketJoint.GetLinearJacobianA(Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Vector3@)">
      <summary>
            Gets the linear jacobian entry for the first connected entity.
            </summary>
      <param name="jacobianX">First linear jacobian entry for the first connected entity.</param>
      <param name="jacobianY">Second linear jacobian entry for the first connected entity.</param>
      <param name="jacobianZ">Third linear jacobian entry for the first connected entity.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.Joints.BallSocketJoint.GetLinearJacobianB(Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Vector3@)">
      <summary>
            Gets the linear jacobian entry for the second connected entity.
            </summary>
      <param name="jacobianX">First linear jacobian entry for the second connected entity.</param>
      <param name="jacobianY">Second linear jacobian entry for the second connected entity.</param>
      <param name="jacobianZ">Third linear jacobian entry for the second connected entity.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.Joints.BallSocketJoint.GetAngularJacobianA(Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Vector3@)">
      <summary>
            Gets the angular jacobian entry for the first connected entity.
            </summary>
      <param name="jacobianX">First angular jacobian entry for the first connected entity.</param>
      <param name="jacobianY">Second angular jacobian entry for the first connected entity.</param>
      <param name="jacobianZ">Third angular jacobian entry for the first connected entity.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.Joints.BallSocketJoint.GetAngularJacobianB(Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Vector3@)">
      <summary>
            Gets the angular jacobian entry for the second connected entity.
            </summary>
      <param name="jacobianX">First angular jacobian entry for the second connected entity.</param>
      <param name="jacobianY">Second angular jacobian entry for the second connected entity.</param>
      <param name="jacobianZ">Third angular jacobian entry for the second connected entity.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.Joints.BallSocketJoint.GetMassMatrix(BEPUphysics.MathExtensions.Matrix3X3@)">
      <summary>
            Gets the mass matrix of the constraint.
            </summary>
      <param name="outputMassMatrix">Constraint's mass matrix.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.Joints.BallSocketJoint.SolveIteration">
      <summary>
            Calculates and applies corrective impulses.
            Called automatically by space.
            </summary>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.Joints.BallSocketJoint.Update(System.Single)">
      <summary>
            Calculates necessary information for velocity solving.
            Called by preStep(float dt)
            </summary>
      <param name="dt">Time in seconds since the last update.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.Joints.BallSocketJoint.ExclusiveUpdate">
      <summary>
            Performs any pre-solve iteration work that needs exclusive
            access to the members of the solver updateable.
            Usually, this is used for applying warmstarting impulses.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.Joints.BallSocketJoint.LocalOffsetA">
      <summary>
            Gets or sets the offset from the first entity's center of mass to the anchor point in its local space.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.Joints.BallSocketJoint.LocalOffsetB">
      <summary>
            Gets or sets the offset from the second entity's center of mass to the anchor point in its local space.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.Joints.BallSocketJoint.OffsetA">
      <summary>
            Gets or sets the offset from the first entity's center of mass to the anchor point in world space.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.Joints.BallSocketJoint.OffsetB">
      <summary>
            Gets or sets the offset from the second entity's center of mass to the anchor point in world space.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.Joints.BallSocketJoint.RelativeVelocity">
      <summary>
            Gets the current relative velocity between the connected entities with respect to the constraint.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.Joints.BallSocketJoint.TotalImpulse">
      <summary>
            Gets the total impulse applied by this constraint.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.Joints.BallSocketJoint.Error">
      <summary>
            Gets the current constraint error.
            </summary>
    </member>
    <member name="T:BEPUphysics.Constraints.SolverGroups.LineSliderJoint">
      <summary>
            Restricts two degrees of linear motion while allowing one degree of angular freedom.
            </summary>
    </member>
    <member name="M:BEPUphysics.Constraints.SolverGroups.LineSliderJoint.#ctor">
      <summary>
            Constructs a new constraint which restricts two degrees of linear freedom and two degrees of angular freedom between two entities.
            This constructs the internal constraints, but does not configure them.  Before using a constraint constructed in this manner,
            ensure that its active constituent constraints are properly configured.  The entire group as well as all internal constraints are initially inactive (IsActive = false).
            </summary>
    </member>
    <member name="M:BEPUphysics.Constraints.SolverGroups.LineSliderJoint.#ctor(BEPUphysics.Entities.Entity,BEPUphysics.Entities.Entity,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3)">
      <summary>
            Constructs a new constraint which restricts two degrees of linear freedom and two degrees of angular freedom between two entities.
            </summary>
      <param name="connectionA">First entity of the constraint pair.</param>
      <param name="connectionB">Second entity of the constraint pair.</param>
      <param name="lineAnchor">Location of the anchor for the line to be attached to connectionA in world space.</param>
      <param name="lineDirection">Axis in world space to be attached to connectionA along which connectionB can move and rotate.</param>
      <param name="pointAnchor">Location of the anchor for the point to be attached to connectionB in world space.</param>
    </member>
    <member name="P:BEPUphysics.Constraints.SolverGroups.LineSliderJoint.AngularJoint">
      <summary>
            Gets the angular joint which removes two degrees of freedom.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.SolverGroups.LineSliderJoint.Limit">
      <summary>
            Gets the distance limits for the slider.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.SolverGroups.LineSliderJoint.Motor">
      <summary>
            Gets the slider motor.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.SolverGroups.LineSliderJoint.PointOnLineJoint">
      <summary>
            Gets the line joint that restricts two linear degrees of freedom.
            </summary>
    </member>
    <member name="T:BEPUphysics.Constraints.Collision.ContactManifoldConstraintGroup">
      <summary>
             Constraint group containing multiple contact manifold constraints.
             Used by some pairs which manage multiple sub-pairs.
            </summary>
    </member>
    <member name="M:BEPUphysics.Constraints.Collision.ContactManifoldConstraintGroup.Add(BEPUphysics.Constraints.EntitySolverUpdateable)">
      <summary>
             Adds a constraint to the group.
            </summary>
      <param name="manifoldConstraint">Constraint to add.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.Collision.ContactManifoldConstraintGroup.Remove(BEPUphysics.Constraints.EntitySolverUpdateable)">
      <summary>
             Removes a constraint from the group.
            </summary>
      <param name="manifoldConstraint">Constraint to remove.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.Collision.ContactManifoldConstraintGroup.Initialize(BEPUphysics.Entities.Entity,BEPUphysics.Entities.Entity)">
      <summary>
             Initializes the constraint group.
            </summary>
      <param name="a">First entity of the pair.</param>
      <param name="b">Second entity of the pair.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.Collision.ContactManifoldConstraintGroup.CleanUp">
      <summary>
             Cleans up the constraint group.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.Collision.ContactManifoldConstraintGroup.EntityA">
      <summary>
             Gets the first entity in the pair.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.Collision.ContactManifoldConstraintGroup.EntityB">
      <summary>
             Gets the second entity in the pair.
            </summary>
    </member>
    <member name="T:BEPUphysics.Paths.StepCurve1D">
      <summary>
            One dimensional-valued curve that does not interpolate values.
            Instead, it just picks the value from the previous control point.
            </summary>
    </member>
    <member name="M:BEPUphysics.Paths.StepCurve1D.Evaluate(System.Int32,System.Single,System.Single@)">
      <summary>
            Evaluates the curve at a given time using linear interpolation.
            </summary>
      <param name="controlPointIndex">Index of the control point at the beginning of the evaluation interval.</param>
      <param name="weight">Value of 0 to 1 representing how far along the interval to sample.</param>
      <param name="value">Value of the curve at the given location.</param>
    </member>
    <member name="M:BEPUphysics.Paths.StepCurve1D.GetCurveIndexBoundsInformation(System.Int32@,System.Int32@)">
      <summary>
            Computes the bounds of the curve.
            </summary>
      <param name="minIndex">Minimum index of the curve.</param>
      <param name="maxIndex">Maximum index of the curve.</param>
    </member>
    <member name="T:BEPUphysics.MathExtensions.Matrix2X2">
      <summary>
            2 row, 2 column matrix.
            </summary>
    </member>
    <member name="F:BEPUphysics.MathExtensions.Matrix2X2.M11">
      <summary>
            Value at row 1, column 1 of the matrix.
            </summary>
    </member>
    <member name="F:BEPUphysics.MathExtensions.Matrix2X2.M12">
      <summary>
            Value at row 1, column 2 of the matrix.
            </summary>
    </member>
    <member name="F:BEPUphysics.MathExtensions.Matrix2X2.M21">
      <summary>
            Value at row 2, column 1 of the matrix.
            </summary>
    </member>
    <member name="F:BEPUphysics.MathExtensions.Matrix2X2.M22">
      <summary>
            Value at row 2, column 2 of the matrix.
            </summary>
    </member>
    <member name="M:BEPUphysics.MathExtensions.Matrix2X2.#ctor(System.Single,System.Single,System.Single,System.Single)">
      <summary>
            Constructs a new 2 row, 2 column matrix.
            </summary>
      <param name="m11">Value at row 1, column 1 of the matrix.</param>
      <param name="m12">Value at row 1, column 2 of the matrix.</param>
      <param name="m21">Value at row 2, column 1 of the matrix.</param>
      <param name="m22">Value at row 2, column 2 of the matrix.</param>
    </member>
    <member name="M:BEPUphysics.MathExtensions.Matrix2X2.Add(BEPUphysics.MathExtensions.Matrix2X2@,BEPUphysics.MathExtensions.Matrix2X2@,BEPUphysics.MathExtensions.Matrix2X2@)">
      <summary>
            Adds the two matrices together on a per-element basis.
            </summary>
      <param name="a">First matrix to add.</param>
      <param name="b">Second matrix to add.</param>
      <param name="result">Sum of the two matrices.</param>
    </member>
    <member name="M:BEPUphysics.MathExtensions.Matrix2X2.Add(Microsoft.Xna.Framework.Matrix@,BEPUphysics.MathExtensions.Matrix2X2@,BEPUphysics.MathExtensions.Matrix2X2@)">
      <summary>
            Adds the two matrices together on a per-element basis.
            </summary>
      <param name="a">First matrix to add.</param>
      <param name="b">Second matrix to add.</param>
      <param name="result">Sum of the two matrices.</param>
    </member>
    <member name="M:BEPUphysics.MathExtensions.Matrix2X2.Add(BEPUphysics.MathExtensions.Matrix2X2@,Microsoft.Xna.Framework.Matrix@,BEPUphysics.MathExtensions.Matrix2X2@)">
      <summary>
            Adds the two matrices together on a per-element basis.
            </summary>
      <param name="a">First matrix to add.</param>
      <param name="b">Second matrix to add.</param>
      <param name="result">Sum of the two matrices.</param>
    </member>
    <member name="M:BEPUphysics.MathExtensions.Matrix2X2.Add(Microsoft.Xna.Framework.Matrix@,Microsoft.Xna.Framework.Matrix@,BEPUphysics.MathExtensions.Matrix2X2@)">
      <summary>
            Adds the two matrices together on a per-element basis.
            </summary>
      <param name="a">First matrix to add.</param>
      <param name="b">Second matrix to add.</param>
      <param name="result">Sum of the two matrices.</param>
    </member>
    <member name="M:BEPUphysics.MathExtensions.Matrix2X2.CreateScale(System.Single,BEPUphysics.MathExtensions.Matrix2X2@)">
      <summary>
            Constructs a uniform scaling matrix.
            </summary>
      <param name="scale">Value to use in the diagonal.</param>
      <param name="matrix">Scaling matrix.</param>
    </member>
    <member name="M:BEPUphysics.MathExtensions.Matrix2X2.Invert(BEPUphysics.MathExtensions.Matrix2X2@,BEPUphysics.MathExtensions.Matrix2X2@)">
      <summary>
            Inverts the given matix.
            </summary>
      <param name="matrix">Matrix to be inverted.</param>
      <param name="result">Inverted matrix.</param>
    </member>
    <member name="M:BEPUphysics.MathExtensions.Matrix2X2.Multiply(BEPUphysics.MathExtensions.Matrix2X2@,BEPUphysics.MathExtensions.Matrix2X2@,BEPUphysics.MathExtensions.Matrix2X2@)">
      <summary>
            Multiplies the two matrices.
            </summary>
      <param name="a">First matrix to multiply.</param>
      <param name="b">Second matrix to multiply.</param>
      <param name="result">Product of the multiplication.</param>
    </member>
    <member name="M:BEPUphysics.MathExtensions.Matrix2X2.Multiply(BEPUphysics.MathExtensions.Matrix2X2@,Microsoft.Xna.Framework.Matrix@,BEPUphysics.MathExtensions.Matrix2X2@)">
      <summary>
            Multiplies the two matrices.
            </summary>
      <param name="a">First matrix to multiply.</param>
      <param name="b">Second matrix to multiply.</param>
      <param name="result">Product of the multiplication.</param>
    </member>
    <member name="M:BEPUphysics.MathExtensions.Matrix2X2.Multiply(Microsoft.Xna.Framework.Matrix@,BEPUphysics.MathExtensions.Matrix2X2@,BEPUphysics.MathExtensions.Matrix2X2@)">
      <summary>
            Multiplies the two matrices.
            </summary>
      <param name="a">First matrix to multiply.</param>
      <param name="b">Second matrix to multiply.</param>
      <param name="result">Product of the multiplication.</param>
    </member>
    <member name="M:BEPUphysics.MathExtensions.Matrix2X2.Multiply(BEPUphysics.MathExtensions.Matrix2X3@,BEPUphysics.MathExtensions.Matrix3X2@,BEPUphysics.MathExtensions.Matrix2X2@)">
      <summary>
            Multiplies the two matrices.
            </summary>
      <param name="a">First matrix to multiply.</param>
      <param name="b">Second matrix to multiply.</param>
      <param name="result">Product of the multiplication.</param>
    </member>
    <member name="M:BEPUphysics.MathExtensions.Matrix2X2.Negate(BEPUphysics.MathExtensions.Matrix2X2@,BEPUphysics.MathExtensions.Matrix2X2@)">
      <summary>
            Negates every element in the matrix.
            </summary>
      <param name="matrix">Matrix to negate.</param>
      <param name="result">Negated matrix.</param>
    </member>
    <member name="M:BEPUphysics.MathExtensions.Matrix2X2.Subtract(BEPUphysics.MathExtensions.Matrix2X2@,BEPUphysics.MathExtensions.Matrix2X2@,BEPUphysics.MathExtensions.Matrix2X2@)">
      <summary>
            Subtracts the two matrices from each other on a per-element basis.
            </summary>
      <param name="a">First matrix to subtract.</param>
      <param name="b">Second matrix to subtract.</param>
      <param name="result">Difference of the two matrices.</param>
    </member>
    <member name="M:BEPUphysics.MathExtensions.Matrix2X2.Transform(Microsoft.Xna.Framework.Vector2@,BEPUphysics.MathExtensions.Matrix2X2@,Microsoft.Xna.Framework.Vector2@)">
      <summary>
            Transforms the vector by the matrix.
            </summary>
      <param name="v">Vector2 to transform.</param>
      <param name="matrix">Matrix to use as the transformation.</param>
      <param name="result">Product of the transformation.</param>
    </member>
    <member name="M:BEPUphysics.MathExtensions.Matrix2X2.Transpose(BEPUphysics.MathExtensions.Matrix2X2@,BEPUphysics.MathExtensions.Matrix2X2@)">
      <summary>
            Computes the transposed matrix of a matrix.
            </summary>
      <param name="matrix">Matrix to transpose.</param>
      <param name="result">Transposed matrix.</param>
    </member>
    <member name="M:BEPUphysics.MathExtensions.Matrix2X2.ToString">
      <summary>
            Creates a string representation of the matrix.
            </summary>
      <returns>A string representation of the matrix.</returns>
    </member>
    <member name="M:BEPUphysics.MathExtensions.Matrix2X2.Determinant">
      <summary>
            Calculates the determinant of the matrix.
            </summary>
      <returns>The matrix's determinant.</returns>
    </member>
    <member name="P:BEPUphysics.MathExtensions.Matrix2X2.Identity">
      <summary>
            Gets the 2x2 identity matrix.
            </summary>
    </member>
    <member name="T:BEPUphysics.MathExtensions.RigidTransform">
      <summary>
             Transform composed of a rotation and translation.
            </summary>
    </member>
    <member name="F:BEPUphysics.MathExtensions.RigidTransform.Position">
      <summary>
             Translation component of the transform.
            </summary>
    </member>
    <member name="F:BEPUphysics.MathExtensions.RigidTransform.Orientation">
      <summary>
             Rotation component of the transform.
            </summary>
    </member>
    <member name="M:BEPUphysics.MathExtensions.RigidTransform.#ctor(Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Quaternion)">
      <summary>
             Constructs a new rigid transform.
            </summary>
      <param name="position">Translation component of the transform.</param>
      <param name="orienation">Rotation component of the transform.</param>
    </member>
    <member name="M:BEPUphysics.MathExtensions.RigidTransform.#ctor(Microsoft.Xna.Framework.Vector3)">
      <summary>
             Constructs a new rigid transform.
            </summary>
      <param name="position">Translation component of the transform.</param>
    </member>
    <member name="M:BEPUphysics.MathExtensions.RigidTransform.#ctor(Microsoft.Xna.Framework.Quaternion)">
      <summary>
             Constructs a new rigid transform.
            </summary>
      <param name="orienation">Rotation component of the transform.</param>
    </member>
    <member name="M:BEPUphysics.MathExtensions.RigidTransform.Transform(BEPUphysics.MathExtensions.RigidTransform@,BEPUphysics.MathExtensions.RigidTransform@,BEPUphysics.MathExtensions.RigidTransform@)">
      <summary>
             Transforms a rigid transform by another rigid transform.
            </summary>
      <param name="local">The first, "local" rigid transform.</param>
      <param name="world">The second, "world" rigid transform.</param>
      <param name="combined">Combined rigid transform.</param>
    </member>
    <member name="M:BEPUphysics.MathExtensions.RigidTransform.Transform(Microsoft.Xna.Framework.Vector3@,BEPUphysics.MathExtensions.RigidTransform@,Microsoft.Xna.Framework.Vector3@)">
      <summary>
             Transforms a position by a rigid transform.
            </summary>
      <param name="position">Position to transform.</param>
      <param name="transform">Transform to apply.</param>
      <param name="result">Transformed position.</param>
    </member>
    <member name="M:BEPUphysics.MathExtensions.RigidTransform.TransformByInverse(Microsoft.Xna.Framework.Vector3@,BEPUphysics.MathExtensions.RigidTransform@,Microsoft.Xna.Framework.Vector3@)">
      <summary>
             Transforms a position by a rigid transform's inverse.
            </summary>
      <param name="position">Position to transform.</param>
      <param name="transform">Transform to invert and apply.</param>
      <param name="result">Transformed position.</param>
    </member>
    <member name="P:BEPUphysics.MathExtensions.RigidTransform.OrientationMatrix">
      <summary>
            Gets the orientation matrix created from the orientation of the rigid transform.
            </summary>
    </member>
    <member name="P:BEPUphysics.MathExtensions.RigidTransform.Matrix">
      <summary>
             Gets the 4x4 matrix created from the rigid transform.
            </summary>
    </member>
    <member name="P:BEPUphysics.MathExtensions.RigidTransform.Identity">
      <summary>
             Gets the identity rigid transform.
            </summary>
    </member>
    <member name="T:BEPUphysics.CollisionTests.Manifolds.GeneralConvexContactManifold">
      <summary>
             Manages persistent contacts for two convex collidables.
            </summary>
    </member>
    <member name="M:BEPUphysics.CollisionTests.Manifolds.GeneralConvexContactManifold.#ctor">
      <summary>
             Constructs a new convex-convex manifold.
            </summary>
    </member>
    <member name="M:BEPUphysics.CollisionTests.Manifolds.GeneralConvexContactManifold.Update(System.Single)">
      <summary>
             Updates the manifold.
            </summary>
      <param name="dt">Timestep duration.</param>
    </member>
    <member name="M:BEPUphysics.CollisionTests.Manifolds.GeneralConvexContactManifold.Initialize(BEPUphysics.Collidables.Collidable,BEPUphysics.Collidables.Collidable)">
      <summary>
             Initializes the manifold.
            </summary>
      <param name="newCollidableA">First collidable.</param>
      <param name="newCollidableB">Second collidable.</param>
    </member>
    <member name="M:BEPUphysics.CollisionTests.Manifolds.GeneralConvexContactManifold.CleanUp">
      <summary>
             Cleans up the manifold.
            </summary>
    </member>
    <member name="P:BEPUphysics.CollisionTests.Manifolds.GeneralConvexContactManifold.PairTester">
      <summary>
             Gets the pair tester used by the manifold to do testing.
            </summary>
    </member>
    <member name="P:BEPUphysics.CollisionTests.Manifolds.GeneralConvexContactManifold.CollidableA">
      <summary>
             Gets the first collidable in the pair.
            </summary>
    </member>
    <member name="P:BEPUphysics.CollisionTests.Manifolds.GeneralConvexContactManifold.CollidableB">
      <summary>
            Gets the second collidable in the pair.
            </summary>
    </member>
    <member name="T:BEPUphysics.CollisionShapes.ConvexShapes.TriangleSidedness">
      <summary>
             Sidedness of a triangle or mesh.
             A triangle can be double sided, or allow one of its sides to let interacting objects through.
            </summary>
    </member>
    <member name="F:BEPUphysics.CollisionShapes.ConvexShapes.TriangleSidedness.DoubleSided">
      <summary>
            The triangle will interact with objects coming from both directions.
            </summary>
    </member>
    <member name="F:BEPUphysics.CollisionShapes.ConvexShapes.TriangleSidedness.Clockwise">
      <summary>
            The triangle will interact with objects from which the winding of the triangle appears to be clockwise.
            </summary>
    </member>
    <member name="F:BEPUphysics.CollisionShapes.ConvexShapes.TriangleSidedness.Counterclockwise">
      <summary>
            The triangle will interact with objects from which the winding of the triangle appears to be counterclockwise..
            </summary>
    </member>
    <member name="T:BEPUphysics.CollisionShapes.ConvexShapes.TriangleShape">
      <summary>
             Triangle collision shape.
            </summary>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.ConvexShapes.TriangleShape.#ctor">
      <summary>
             Constructs a triangle shape without initializing it.
             This is useful for systems that re-use a triangle shape repeatedly.
            </summary>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.ConvexShapes.TriangleShape.#ctor(Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3@)">
      <summary>
             Constructs a triangle shape.
             The vertices will be recentered.
            </summary>
      <param name="vA">First vertex in the triangle.</param>
      <param name="vB">Second vertex in the triangle.</param>
      <param name="vC">Third vertex in the triangle.</param>
      <param name="center">Computed center of the triangle.</param>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.ConvexShapes.TriangleShape.#ctor(Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3)">
      <summary>
             Constructs a triangle shape.
             The vertices will be recentered.  If the center is needed, use the other constructor.
            </summary>
      <param name="vA">First vertex in the triangle.</param>
      <param name="vB">Second vertex in the triangle.</param>
      <param name="vC">Third vertex in the triangle.</param>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.ConvexShapes.TriangleShape.GetBoundingBox(BEPUphysics.MathExtensions.RigidTransform@,Microsoft.Xna.Framework.BoundingBox@)">
      <summary>
            Gets the bounding box of the shape given a transform.
            </summary>
      <param name="shapeTransform">Transform to use.</param>
      <param name="boundingBox">Bounding box of the transformed shape.</param>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.ConvexShapes.TriangleShape.GetLocalExtremePointWithoutMargin(Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Vector3@)">
      <summary>
             Gets the extreme point of the shape in local space in a given direction.
            </summary>
      <param name="direction">Direction to find the extreme point in.</param>
      <param name="extremePoint">Extreme point on the shape.</param>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.ConvexShapes.TriangleShape.ComputeMaximumRadius">
      <summary>
            Computes the maximum radius of the shape.
            This is often larger than the actual maximum radius;
            it is simply an approximation that avoids underestimating.
            </summary>
      <returns>Maximum radius of the shape.</returns>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.ConvexShapes.TriangleShape.ComputeMinimumRadius">
      <summary>
             Computes the minimum radius of the shape.
             This is often smaller than the actual minimum radius;
             it is simply an approximation that avoids overestimating.
            </summary>
      <returns>Minimum radius of the shape.</returns>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.ConvexShapes.TriangleShape.ComputeVolumeDistribution(System.Single@)">
      <summary>
            Computes the volume distribution of the shape as well as its volume.
            The volume distribution can be used to compute inertia tensors when
            paired with mass and other tuning factors.
            </summary>
      <param name="volume">Volume of the shape.</param>
      <returns>Volume distribution of the shape.</returns>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.ConvexShapes.TriangleShape.ComputeCenter">
      <summary>
            Computes the center of the shape.  This can be considered its 
            center of mass.
            </summary>
      <returns>Center of the shape.</returns>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.ConvexShapes.TriangleShape.ComputeCenter(System.Single@)">
      <summary>
            Computes the center of the shape.  This can be considered its 
            center of mass.  This calculation is often associated with the 
            volume calculation, which is given by this method as well.
            </summary>
      <param name="volume">Volume of the shape.</param>
      <returns>Center of the shape.</returns>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.ConvexShapes.TriangleShape.ComputeVolume">
      <summary>
            Computes the volume of the shape.
            </summary>
      <returns>Volume of the shape.</returns>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.ConvexShapes.TriangleShape.GetLocalNormal">
      <summary>
             Gets the normal of the triangle shape in its local space.
            </summary>
      <returns>The local normal.</returns>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.ConvexShapes.TriangleShape.GetNormal(BEPUphysics.MathExtensions.RigidTransform)">
      <summary>
            Gets the normal of the triangle in world space.
            </summary>
      <param name="transform">World transform.</param>
      <returns>Normal of the triangle in world space.</returns>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.ConvexShapes.TriangleShape.RayTest(Microsoft.Xna.Framework.Ray@,BEPUphysics.MathExtensions.RigidTransform@,System.Single,BEPUphysics.RayHit@)">
      <summary>
            Gets the intersection between the triangle and the ray.
            </summary>
      <param name="ray">Ray to test against the triangle.</param>
      <param name="transform">Transform to apply to the triangle shape for the test.</param>
      <param name="maximumLength">Maximum distance to travel in units of the direction vector's length.</param>
      <param name="hit">Hit data of the ray cast, if any.</param>
      <returns>Whether or not the ray hit the target.</returns>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.ConvexShapes.TriangleShape.ToString">
      <summary>
            Returns a <see cref="T:System.String" /> that represents the current <see cref="T:System.Object" />.
            </summary>
      <returns>
            A <see cref="T:System.String" /> that represents the current <see cref="T:System.Object" />.
            </returns>
      <filterpriority>2</filterpriority>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.ConvexShapes.TriangleShape.GetMobileInstance">
      <summary>
            Retrieves an instance of an EntityCollidable that uses this EntityShape.  Mainly used by compound bodies.
            </summary>
      <returns>EntityCollidable that uses this shape.</returns>
    </member>
    <member name="P:BEPUphysics.CollisionShapes.ConvexShapes.TriangleShape.VertexA">
      <summary>
             Gets or sets the first vertex of the triangle shape.
            </summary>
    </member>
    <member name="P:BEPUphysics.CollisionShapes.ConvexShapes.TriangleShape.VertexB">
      <summary>
             Gets or sets the second vertex of the triangle shape.
            </summary>
    </member>
    <member name="P:BEPUphysics.CollisionShapes.ConvexShapes.TriangleShape.VertexC">
      <summary>
             Gets or sets the third vertex of the triangle shape.
            </summary>
    </member>
    <member name="P:BEPUphysics.CollisionShapes.ConvexShapes.TriangleShape.Sidedness">
      <summary>
             Gets or sets the sidedness of the triangle.
            </summary>
    </member>
    <member name="T:BEPUphysics.NarrowPhaseSystems.Factories.TriangleConvexPairFactory">
      <summary>
             Manufactures triangle-convex pairs.
            </summary>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.Factories.TriangleConvexPairFactory.GetNarrowPhasePair(BEPUphysics.BroadPhaseSystems.BroadPhaseOverlap)">
      <summary>
             Manufactures and returns a narrow phase pair for the given overlap.
            </summary>
      <param name="overlap">Overlap used to create a pair.</param>
      <returns>Narrow phase pair.</returns>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.Factories.TriangleConvexPairFactory.GiveBack(BEPUphysics.NarrowPhaseSystems.Pairs.INarrowPhasePair)">
      <summary>
            Returns a pair to the factory for re-use.
            </summary>
      <param name="pair">Pair to return.</param>
    </member>
    <member name="T:BEPUphysics.NarrowPhaseSystems.Factories.CompoundStaticMeshPairFactory">
      <summary>
             Manufactures compound-static mesh pairs.
            </summary>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.Factories.CompoundStaticMeshPairFactory.GetNarrowPhasePair(BEPUphysics.BroadPhaseSystems.BroadPhaseOverlap)">
      <summary>
             Manufactures and returns a narrow phase pair for the given overlap.
            </summary>
      <param name="overlap">Overlap used to create a pair.</param>
      <returns>Narrow phase pair.</returns>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.Factories.CompoundStaticMeshPairFactory.GiveBack(BEPUphysics.NarrowPhaseSystems.Pairs.INarrowPhasePair)">
      <summary>
            Returns a pair to the factory for re-use.
            </summary>
      <param name="pair">Pair to return.</param>
    </member>
    <member name="T:BEPUphysics.Entities.Prefabs.Sphere">
      <summary>
            Ball-shaped object that can collide and move.  After making an entity, add it to a Space so that the engine can manage it.
            </summary>
    </member>
    <member name="M:BEPUphysics.Entities.Prefabs.Sphere.#ctor(Microsoft.Xna.Framework.Vector3,System.Single,System.Single)">
      <summary>
            Constructs a physically simulated sphere.
            </summary>
      <param name="position">Position of the sphere.</param>
      <param name="radius">Radius of the sphere.</param>
      <param name="mass">Mass of the object.</param>
    </member>
    <member name="M:BEPUphysics.Entities.Prefabs.Sphere.#ctor(Microsoft.Xna.Framework.Vector3,System.Single)">
      <summary>
            Constructs a nondynamic sphere.
            </summary>
      <param name="position">Position of the sphere.</param>
      <param name="radius">Radius of the sphere.</param>
    </member>
    <member name="M:BEPUphysics.Entities.Prefabs.Sphere.#ctor(BEPUphysics.EntityStateManagement.MotionState,System.Single,System.Single)">
      <summary>
            Constructs a physically simulated sphere.
            </summary>
      <param name="motionState">Motion state specifying the entity's initial state.</param>
      <param name="radius">Radius of the sphere.</param>
      <param name="mass">Mass of the object.</param>
    </member>
    <member name="M:BEPUphysics.Entities.Prefabs.Sphere.#ctor(BEPUphysics.EntityStateManagement.MotionState,System.Single)">
      <summary>
            Constructs a nondynamic sphere.
            </summary>
      <param name="motionState">Motion state specifying the entity's initial state.</param>
      <param name="radius">Radius of the sphere.</param>
    </member>
    <member name="P:BEPUphysics.Entities.Prefabs.Sphere.Radius">
      <summary>
            Radius of the sphere.
            </summary>
    </member>
    <member name="T:BEPUphysics.Constraints.TwoEntity.Motors.Motor">
      <summary>
            Superclass of constraints which do work and change the velocity of connected entities, but have no specific position target.
            </summary>
    </member>
    <member name="F:BEPUphysics.Constraints.TwoEntity.Motors.Motor.usedSoftness">
      <summary>
            Softness divided by the timestep to maintain timestep independence.
            </summary>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.Motors.Motor.ComputeMaxForces(System.Single,System.Single)">
      <summary>
            Computes the maxForceDt and maxForceDtSquared fields.
            </summary>
    </member>
    <member name="T:BEPUphysics.Constraints.TwoEntity.Motors.TwistMotor">
      <summary>
            Attempts to achieve some defined relative twist angle between the entities.
            </summary>
    </member>
    <member name="F:BEPUphysics.Constraints.TwoEntity.Motors.TwistMotor.biasVelocity">
      <summary>
            Velocity needed to get closer to the goal.
            </summary>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.Motors.TwistMotor.#ctor">
      <summary>
            Constructs a new constraint which prevents the connected entities from twisting relative to each other.
            To finish the initialization, specify the connections (ConnectionA and ConnectionB) 
            as well as the BasisA and BasisB.
            This constructor sets the constraint's IsActive property to false by default.
            </summary>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.Motors.TwistMotor.#ctor(BEPUphysics.Entities.Entity,BEPUphysics.Entities.Entity,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3)">
      <summary>
            Constructs a new constraint which prevents the connected entities from twisting relative to each other.
            </summary>
      <param name="connectionA">First connection of the pair.</param>
      <param name="connectionB">Second connection of the pair.</param>
      <param name="axisA">Twist axis attached to the first connected entity.</param>
      <param name="axisB">Twist axis attached to the second connected entity.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.Motors.TwistMotor.GetLinearJacobianA(Microsoft.Xna.Framework.Vector3@)">
      <summary>
            Gets the linear jacobian entry for the first connected entity.
            </summary>
      <param name="jacobian">Linear jacobian entry for the first connected entity.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.Motors.TwistMotor.GetLinearJacobianB(Microsoft.Xna.Framework.Vector3@)">
      <summary>
            Gets the linear jacobian entry for the second connected entity.
            </summary>
      <param name="jacobian">Linear jacobian entry for the second connected entity.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.Motors.TwistMotor.GetAngularJacobianA(Microsoft.Xna.Framework.Vector3@)">
      <summary>
            Gets the angular jacobian entry for the first connected entity.
            </summary>
      <param name="jacobian">Angular jacobian entry for the first connected entity.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.Motors.TwistMotor.GetAngularJacobianB(Microsoft.Xna.Framework.Vector3@)">
      <summary>
            Gets the angular jacobian entry for the second connected entity.
            </summary>
      <param name="jacobian">Angular jacobian entry for the second connected entity.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.Motors.TwistMotor.GetMassMatrix(System.Single@)">
      <summary>
            Gets the mass matrix of the constraint.
            </summary>
      <param name="outputMassMatrix">Constraint's mass matrix.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.Motors.TwistMotor.SetupJointTransforms(Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3)">
      <summary>
            Sets up the joint transforms by automatically creating perpendicular vectors to complete the bases.
            </summary>
      <param name="worldTwistAxisA">Twist axis in world space to attach to entity A.</param>
      <param name="worldTwistAxisB">Twist axis in world space to attach to entity B.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.Motors.TwistMotor.SolveIteration">
      <summary>
            Solves for velocity.
            </summary>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.Motors.TwistMotor.Update(System.Single)">
      <summary>
            Do any necessary computations to prepare the constraint for this frame.
            </summary>
      <param name="dt">Simulation step length.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.Motors.TwistMotor.ExclusiveUpdate">
      <summary>
            Performs any pre-solve iteration work that needs exclusive
            access to the members of the solver updateable.
            Usually, this is used for applying warmstarting impulses.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.Motors.TwistMotor.BasisA">
      <summary>
            Gets the basis attached to entity A.
            The primary axis represents the twist axis attached to entity A.
            The x axis and y axis represent a plane against which entity B's attached x axis is projected to determine the twist angle.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.Motors.TwistMotor.BasisB">
      <summary>
            Gets the basis attached to entity B.
            The primary axis represents the twist axis attached to entity A.
            The x axis is projected onto the plane defined by localTransformA's x and y axes
            to get the twist angle.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.Motors.TwistMotor.Settings">
      <summary>
            Gets the motor's velocity and servo settings.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.Motors.TwistMotor.RelativeVelocity">
      <summary>
            Gets the current relative velocity between the connected entities with respect to the constraint.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.Motors.TwistMotor.TotalImpulse">
      <summary>
            Gets the total impulse applied by this constraint.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.Motors.TwistMotor.Error">
      <summary>
            Gets the current constraint error.
            If the motor is in velocity only mode, the error will be zero.
            </summary>
    </member>
    <member name="T:BEPUphysics.Constraints.SingleEntity.SingleEntityAngularMotor">
      <summary>
            Constraint which attempts to restrict the relative angular velocity of two entities to some value.
            Can use a target relative orientation to apply additional force.
            </summary>
    </member>
    <member name="M:BEPUphysics.Constraints.SingleEntity.SingleEntityAngularMotor.#ctor(BEPUphysics.Entities.Entity)">
      <summary>
            Constructs a new constraint which attempts to restrict the relative angular velocity of two entities to some value.
            </summary>
      <param name="entity">Affected entity.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.SingleEntity.SingleEntityAngularMotor.#ctor">
      <summary>
            Constructs a new constraint which attempts to restrict the relative angular velocity of two entities to some value.
            This constructor will make the angular motor start with isActive set to false.
            </summary>
    </member>
    <member name="M:BEPUphysics.Constraints.SingleEntity.SingleEntityAngularMotor.SolveIteration">
      <summary>
            Applies the corrective impulses required by the constraint.
            </summary>
    </member>
    <member name="M:BEPUphysics.Constraints.SingleEntity.SingleEntityAngularMotor.Update(System.Single)">
      <summary>
            Initializes the constraint for the current frame.
            </summary>
      <param name="dt">Time between frames.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.SingleEntity.SingleEntityAngularMotor.ExclusiveUpdate">
      <summary>
            Performs any pre-solve iteration work that needs exclusive
            access to the members of the solver updateable.
            Usually, this is used for applying warmstarting impulses.
            </summary>
    </member>
    <member name="M:BEPUphysics.Constraints.SingleEntity.SingleEntityAngularMotor.ComputeMaxForces(System.Single,System.Single)">
      <summary>
            Computes the maxForceDt and maxForceDtSquared fields.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.SingleEntity.SingleEntityAngularMotor.Basis">
      <summary>
            Gets the basis attached to the entity.
            The target velocity/orientation of this motor is transformed by the basis.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.SingleEntity.SingleEntityAngularMotor.Settings">
      <summary>
            Gets the motor's velocity and servo settings.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.SingleEntity.SingleEntityAngularMotor.RelativeVelocity">
      <summary>
            Gets the current relative velocity with respect to the constraint.
            For single entity constraints, this is pretty straightforward.  It is taken directly from the 
            entity.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.SingleEntity.SingleEntityAngularMotor.TotalImpulse">
      <summary>
            Gets the total impulse applied by this constraint.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.SingleEntity.SingleEntityAngularMotor.Error">
      <summary>
            Gets the current constraint error.
            If the motor is in velocity only mode, error is zero.
            </summary>
    </member>
    <member name="T:BEPUphysics.CollisionTests.Manifolds.TriangleConvexContactManifold">
      <summary>
             Manages persistent contacts between a triangle and convex.
            </summary>
    </member>
    <member name="M:BEPUphysics.CollisionTests.Manifolds.TriangleConvexContactManifold.#ctor">
      <summary>
             Constructs a new manifold.
            </summary>
    </member>
    <member name="P:BEPUphysics.CollisionTests.Manifolds.TriangleConvexContactManifold.PairTester">
      <summary>
             Gets the pair tester used by the manifold.
            </summary>
    </member>
    <member name="P:BEPUphysics.CollisionTests.Manifolds.TriangleConvexContactManifold.Convex">
      <summary>
             Gets the convex associated with the pair.
            </summary>
    </member>
    <member name="P:BEPUphysics.CollisionTests.Manifolds.TriangleConvexContactManifold.Triangle">
      <summary>
             Gets the triangle associated with the pair.
            </summary>
    </member>
    <member name="T:BEPUphysics.CollisionTests.CollisionAlgorithms.GJK.RaySimplex">
      <summary>
             GJK simplex supporting ray-based tests.
            </summary>
    </member>
    <member name="F:BEPUphysics.CollisionTests.CollisionAlgorithms.GJK.RaySimplex.A">
      <summary>
             First vertex in the simplex.
            </summary>
    </member>
    <member name="F:BEPUphysics.CollisionTests.CollisionAlgorithms.GJK.RaySimplex.B">
      <summary>
            Second vertex in the simplex.
            </summary>
    </member>
    <member name="F:BEPUphysics.CollisionTests.CollisionAlgorithms.GJK.RaySimplex.C">
      <summary>
            Third vertex in the simplex.
            </summary>
    </member>
    <member name="F:BEPUphysics.CollisionTests.CollisionAlgorithms.GJK.RaySimplex.D">
      <summary>
            Fourth vertex in the simplex.
            </summary>
    </member>
    <member name="F:BEPUphysics.CollisionTests.CollisionAlgorithms.GJK.RaySimplex.State">
      <summary>
            Current state of the simplex.
            </summary>
    </member>
    <member name="M:BEPUphysics.CollisionTests.CollisionAlgorithms.GJK.RaySimplex.GetPointClosestToOrigin(BEPUphysics.CollisionTests.CollisionAlgorithms.GJK.RaySimplex@,Microsoft.Xna.Framework.Vector3@)">
      <summary>
             Gets the point on the simplex that is closest to the origin.
            </summary>
      <param name="simplex">Simplex to test.</param>
      <param name="point">Closest point on the simplex.</param>
      <returns>Whether or not the simplex contains the origin.</returns>
    </member>
    <member name="M:BEPUphysics.CollisionTests.CollisionAlgorithms.GJK.RaySimplex.GetPointOnSegmentClosestToOrigin(BEPUphysics.CollisionTests.CollisionAlgorithms.GJK.RaySimplex@,Microsoft.Xna.Framework.Vector3@)">
      <summary>
             Finds the point on the segment to the origin.
            </summary>
      <param name="simplex">Simplex to test.</param>
      <param name="point">Closest point.</param>
    </member>
    <member name="M:BEPUphysics.CollisionTests.CollisionAlgorithms.GJK.RaySimplex.GetPointOnTriangleClosestToOrigin(BEPUphysics.CollisionTests.CollisionAlgorithms.GJK.RaySimplex@,Microsoft.Xna.Framework.Vector3@)">
      <summary>
             Gets the point on the triangle that is closest to the origin.
            </summary>
      <param name="simplex">Simplex to test.</param>
      <param name="point">Closest point to origin.</param>
    </member>
    <member name="M:BEPUphysics.CollisionTests.CollisionAlgorithms.GJK.RaySimplex.GetPointOnTetrahedronClosestToOrigin(BEPUphysics.CollisionTests.CollisionAlgorithms.GJK.RaySimplex@,Microsoft.Xna.Framework.Vector3@)">
      <summary>
             Gets the point closest to the origin on the tetrahedron.
            </summary>
      <param name="simplex">Simplex to test.</param>
      <param name="point">Closest point.</param>
      <returns>Whether or not the tetrahedron encloses the origin.</returns>
    </member>
    <member name="M:BEPUphysics.CollisionTests.CollisionAlgorithms.GJK.RaySimplex.AddNewSimplexPoint(Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Vector3@,BEPUphysics.CollisionTests.CollisionAlgorithms.GJK.RaySimplex@)">
      <summary>
             Adds a new point to the simplex.
            </summary>
      <param name="point">Point to add.</param>
      <param name="hitLocation">Current ray hit location.</param>
      <param name="shiftedSimplex">Simplex shifted with the hit location.</param>
    </member>
    <member name="M:BEPUphysics.CollisionTests.CollisionAlgorithms.GJK.RaySimplex.GetErrorTolerance(Microsoft.Xna.Framework.Vector3@)">
      <summary>
            Gets the error tolerance for the simplex.
            </summary>
      <param name="rayOrigin">Origin of the ray.</param>
      <returns>Error tolerance of the simplex.</returns>
    </member>
    <member name="T:BEPUphysics.Collidables.CollidablePair">
      <summary>
             Pair of collidables.
            </summary>
    </member>
    <member name="M:BEPUphysics.Collidables.CollidablePair.#ctor(BEPUphysics.Collidables.Collidable,BEPUphysics.Collidables.Collidable)">
      <summary>
             Constructs a new collidable pair.
            </summary>
      <param name="collidableA">First collidable in the pair.</param>
      <param name="collidableB">Second collidable in the pair.</param>
    </member>
    <member name="M:BEPUphysics.Collidables.CollidablePair.GetHashCode">
      <summary>
            Returns the hash code for this instance.
            </summary>
      <returns>
            A 32-bit signed integer that is the hash code for this instance.
            </returns>
      <filterpriority>2</filterpriority>
    </member>
    <member name="M:BEPUphysics.Collidables.CollidablePair.Equals(BEPUphysics.Collidables.CollidablePair)">
      <summary>
            Indicates whether the current object is equal to another object of the same type.
            </summary>
      <returns>
            true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false.
            </returns>
      <param name="other">An object to compare with this object.</param>
    </member>
    <member name="P:BEPUphysics.Collidables.CollidablePair.CollidableA">
      <summary>
             First collidable in the pair.
            </summary>
    </member>
    <member name="P:BEPUphysics.Collidables.CollidablePair.CollidableB">
      <summary>
            Second collidable in the pair.
            </summary>
    </member>
    <member name="T:BEPUphysics.DataStructures.MeshBoundingBoxTreeData">
      <summary>
             Superclass of the data used to create triangle mesh bounding box trees.
            </summary>
    </member>
    <member name="M:BEPUphysics.DataStructures.MeshBoundingBoxTreeData.GetBoundingBox(System.Int32,Microsoft.Xna.Framework.BoundingBox@)">
      <summary>
            Gets the bounding box of an element in the data.
            </summary>
      <param name="triangleIndex">Index of the triangle in the data.</param>
      <param name="boundingBox">Bounding box of the triangle.</param>
    </member>
    <member name="M:BEPUphysics.DataStructures.MeshBoundingBoxTreeData.GetTriangle(System.Int32,Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Vector3@)">
      <summary>
             Gets the triangle vertex positions at a given index.
            </summary>
      <param name="triangleIndex">First index of a triangle's vertices in the index buffer.</param>
      <param name="v1">First vertex of the triangle.</param>
      <param name="v2">Second vertex of the triangle.</param>
      <param name="v3">Third vertex of the triangle.</param>
    </member>
    <member name="M:BEPUphysics.DataStructures.MeshBoundingBoxTreeData.GetVertexPosition(System.Int32,Microsoft.Xna.Framework.Vector3@)">
      <summary>
             Gets the position of a vertex in the data.
            </summary>
      <param name="i">Index of the vertex.</param>
      <param name="vertex">Position of the vertex.</param>
    </member>
    <member name="P:BEPUphysics.DataStructures.MeshBoundingBoxTreeData.Indices">
      <summary>
             Gets or sets the indices of the triangle mesh.
            </summary>
    </member>
    <member name="P:BEPUphysics.DataStructures.MeshBoundingBoxTreeData.Vertices">
      <summary>
             Gets or sets the vertices of the triangle mesh.
            </summary>
    </member>
    <member name="T:BEPUphysics.DataStructures.TransformableMeshData">
      <summary>
             Collection of mesh data which transforms its vertices before returning them.
            </summary>
    </member>
    <member name="M:BEPUphysics.DataStructures.TransformableMeshData.#ctor(Microsoft.Xna.Framework.Vector3[],System.Int32[])">
      <summary>
             Constructs the mesh data.
            </summary>
      <param name="vertices">Vertices to use in the mesh data.</param>
      <param name="indices">Indices to use in the mesh data.</param>
    </member>
    <member name="M:BEPUphysics.DataStructures.TransformableMeshData.#ctor(Microsoft.Xna.Framework.Vector3[],System.Int32[],BEPUphysics.MathExtensions.AffineTransform)">
      <summary>
             Constructs the mesh data.
            </summary>
      <param name="vertices">Vertice sto use in the mesh data.</param>
      <param name="indices">Indices to use in the mesh data.</param>
      <param name="worldTransform">Transform to apply to vertices before returning their positions.</param>
    </member>
    <member name="M:BEPUphysics.DataStructures.TransformableMeshData.GetTriangle(System.Int32,Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Vector3@)">
      <summary>
             Gets the triangle vertex positions at a given index.
            </summary>
      <param name="triangleIndex">First index of a triangle's vertices in the index buffer.</param>
      <param name="v1">First vertex of the triangle.</param>
      <param name="v2">Second vertex of the triangle.</param>
      <param name="v3">Third vertex of the triangle.</param>
    </member>
    <member name="M:BEPUphysics.DataStructures.TransformableMeshData.GetVertexPosition(System.Int32,Microsoft.Xna.Framework.Vector3@)">
      <summary>
             Gets the position of a vertex in the data.
            </summary>
      <param name="i">Index of the vertex.</param>
      <param name="vertex">Position of the vertex.</param>
    </member>
    <member name="P:BEPUphysics.DataStructures.TransformableMeshData.WorldTransform">
      <summary>
             Gets or sets the transform to apply to the vertices before returning their position.
            </summary>
    </member>
    <member name="T:BEPUphysics.UpdateableSystems.UpdateableManager">
      <summary>
             Superclass of updateable managers.
            </summary>
    </member>
    <member name="M:BEPUphysics.UpdateableSystems.UpdateableManager.SequentialUpdatingStateChanged(BEPUphysics.UpdateableSystems.ISpaceUpdateable)">
      <summary>
             Notifies the manager that the updateable has changed sequential updating state.
            </summary>
      <param name="updateable">Updateable with changed state.</param>
    </member>
    <member name="P:BEPUphysics.UpdateableSystems.UpdateableManager.TimeStepSettings">
      <summary>
             Gets the time step settings used by the updateable manager.
            </summary>
    </member>
    <member name="P:BEPUphysics.UpdateableSystems.UpdateableManager.Space">
      <summary>
             Gets or sets the owning space.
            </summary>
    </member>
    <member name="T:BEPUphysics.UpdateableSystems.UpdateableManager`1">
      <summary>
             Superclass of updateable managers with a specific type.
            </summary>
      <typeparam name="T">Type of Updateable being managed.</typeparam>
    </member>
    <member name="M:BEPUphysics.UpdateableSystems.UpdateableManager`1.Add(`0)">
      <summary>
             Adds an updateable to the manager.
            </summary>
      <param name="updateable">Updateable to add.</param>
      <exception cref="T:System.Exception">Thrown if the manager already contains the updateable.</exception>
    </member>
    <member name="M:BEPUphysics.UpdateableSystems.UpdateableManager`1.Remove(`0)">
      <summary>
             Removes an updateable from the manager.
            </summary>
      <param name="updateable">Updateable to remove.</param>
      <exception cref="T:System.Exception">Thrown if the manager does not contain the updateable.</exception>
    </member>
    <member name="T:BEPUphysics.UpdateableSystems.IDuringForcesUpdateable">
      <summary>
             Defines an object which is updated by a space during force application.
            </summary>
    </member>
    <member name="M:BEPUphysics.UpdateableSystems.IDuringForcesUpdateable.Update(System.Single)">
      <summary>
             Updates the object during force application.
            </summary>
      <param name="dt">Time step duration.</param>
    </member>
    <member name="M:BEPUphysics.Threading.ParallelLoopWorker.Finalize">
      <summary>
            Releases resources used by the object.
            </summary>
    </member>
    <member name="M:BEPUphysics.Threading.ParallelLoopWorker.Dispose">
      <summary>
            Disposes the worker.
            </summary>
    </member>
    <member name="T:BEPUphysics.Threading.ParallelLoopManager">
      <summary>
            Manages parallel for loops.
            Cannot handle general task-based parallelism.
            </summary>
    </member>
    <member name="M:BEPUphysics.Threading.ParallelLoopManager.#ctor">
      <summary>
            Constructs a new parallel loop manager.
            </summary>
    </member>
    <member name="M:BEPUphysics.Threading.ParallelLoopManager.ForLoop(System.Int32,System.Int32,System.Action{System.Int32})">
      <summary>
            Iterates over the interval.
            </summary>
      <param name="beginIndex">Starting index of the iteration.</param>
      <param name="endIndex">Ending index of the iteration.</param>
      <param name="loopBody">Function to call on each iteration.</param>
    </member>
    <member name="M:BEPUphysics.Threading.ParallelLoopManager.Dispose">
      <summary>
            Releases resources used by the object.
            </summary>
    </member>
    <member name="M:BEPUphysics.Threading.ParallelLoopManager.Finalize">
      <summary>
            Releases resources used by the object.
            </summary>
    </member>
    <member name="P:BEPUphysics.Threading.ParallelLoopManager.MinimumTasksPerThread">
      <summary>
            Gets or sets the minimum number of tasks to be allocated to each thread
            per loop.
            </summary>
    </member>
    <member name="P:BEPUphysics.Threading.ParallelLoopManager.MaximumIterationsPerTask">
      <summary>
            Gets or sets the maximum number of loop iterations
            per individual task.
            </summary>
    </member>
    <member name="T:BEPUphysics.ResourceManagement.ResourcePool`1">
      <summary>
            Manages a cache of a type of resource.
            </summary>
      <typeparam name="T">Type of object to pool.</typeparam>
    </member>
    <member name="M:BEPUphysics.ResourceManagement.ResourcePool`1.GiveBack(`0)">
      <summary>
            Gives an item back to the resource pool.
            </summary>
      <param name="item">Item to return.</param>
    </member>
    <member name="M:BEPUphysics.ResourceManagement.ResourcePool`1.Initialize(System.Int32)">
      <summary>
            Initializes the pool with some resources.
            Throws away excess resources.
            </summary>
      <param name="initialResourceCount">Number of resources to include.</param>
    </member>
    <member name="M:BEPUphysics.ResourceManagement.ResourcePool`1.Take">
      <summary>
            Takes an item from the resource pool.
            </summary>
      <returns>Item to take.</returns>
    </member>
    <member name="M:BEPUphysics.ResourceManagement.ResourcePool`1.CreateNewResource">
      <summary>
            Creates and returns a new resource.
            </summary>
      <returns>New resource.</returns>
    </member>
    <member name="P:BEPUphysics.ResourceManagement.ResourcePool`1.Count">
      <summary>
            Gets the number of resources in the pool.
            Even if the resource count hits 0, resources
            can still be requested; they will be allocated
            dynamically.
            </summary>
    </member>
    <member name="P:BEPUphysics.ResourceManagement.ResourcePool`1.InstanceInitializer">
      <summary>
            Gets or sets the function that configures new instances.
            This is only called once per object created for the resource pool.
            </summary>
    </member>
    <member name="T:BEPUphysics.UpdateableSystems.Updateable">
      <summary>
             Convenience superclass of Updateables.
             Updateables are updated by the Space at various
             points during the execution of the engine
             to support easy extensions.
            </summary>
    </member>
    <member name="M:BEPUphysics.UpdateableSystems.Updateable.OnAdditionToSpace(BEPUphysics.ISpace)">
      <summary>
            Called after the object is added to a space.
            </summary>
      <param name="newSpace">
      </param>
    </member>
    <member name="M:BEPUphysics.UpdateableSystems.Updateable.OnRemovalFromSpace(BEPUphysics.ISpace)">
      <summary>
            Called before an object is removed from its space.
            </summary>
    </member>
    <member name="P:BEPUphysics.UpdateableSystems.Updateable.IsUpdatedSequentially">
      <summary>
            Gets and sets whether or not the updateable should be updated sequentially even in a multithreaded space.
            If this is true, the updateable can make use of the space's ThreadManager for internal multithreading.
            </summary>
    </member>
    <member name="P:BEPUphysics.UpdateableSystems.Updateable.IsUpdating">
      <summary>
            Gets and sets whether or not the updateable should be updated by its manager.
            </summary>
    </member>
    <member name="P:BEPUphysics.UpdateableSystems.Updateable.Space">
      <summary>
             Space that owns the updateable.
            </summary>
    </member>
    <member name="P:BEPUphysics.UpdateableSystems.Updateable.Tag">
      <summary>
            Gets or sets the user data associated with this object.
            </summary>
    </member>
    <member name="T:BEPUphysics.Paths.PathFollowing.EntityRotator">
      <summary>
            Pushes an entity around according to goal positions and orientations.
            </summary>
    </member>
    <member name="M:BEPUphysics.Paths.PathFollowing.EntityRotator.#ctor(BEPUphysics.Entities.Entity)">
      <summary>
            Constructs a new EntityRotator.
            </summary>
      <param name="e">Entity to move.</param>
    </member>
    <member name="M:BEPUphysics.Paths.PathFollowing.EntityRotator.#ctor(BEPUphysics.Entities.Entity,BEPUphysics.Constraints.SingleEntity.SingleEntityAngularMotor)">
      <summary>
            Constructs a new EntityRotator.
            </summary>
      <param name="e">Entity to move.</param>
      <param name="angularMotor">Motor to use for angular motion if the entity is dynamic.</param>
    </member>
    <member name="M:BEPUphysics.Paths.PathFollowing.EntityRotator.GetAngularVelocity(Microsoft.Xna.Framework.Quaternion,Microsoft.Xna.Framework.Quaternion,System.Single)">
      <summary>
            Gets the angular velocity necessary to change an entity's orientation from
            the starting quaternion to the ending quaternion over time dt.
            </summary>
      <param name="start">Initial orientation.</param>
      <param name="end">Final orientation.</param>
      <param name="dt">Time over which the angular velocity is to be applied.</param>
      <returns>Angular velocity to reach the goal in time.</returns>
    </member>
    <member name="M:BEPUphysics.Paths.PathFollowing.EntityRotator.OnAdditionToSpace(BEPUphysics.ISpace)">
      <summary>
            Adds the motors to the solver.  Called automatically.
            </summary>
    </member>
    <member name="M:BEPUphysics.Paths.PathFollowing.EntityRotator.OnRemovalFromSpace(BEPUphysics.ISpace)">
      <summary>
            Removes the motors from the solver.  Called automatically.
            </summary>
    </member>
    <member name="P:BEPUphysics.Paths.PathFollowing.EntityRotator.AngularMotor">
      <summary>
            Gets the angular motor used by the entity rotator.
            When the affected entity is dynamic, it is pushed by motors.
            This ensures that its interactions and collisions with
            other entities remain stable.
            </summary>
    </member>
    <member name="P:BEPUphysics.Paths.PathFollowing.EntityRotator.Entity">
      <summary>
            Gets or sets the entity being pushed by the entity rotator.
            </summary>
    </member>
    <member name="P:BEPUphysics.Paths.PathFollowing.EntityRotator.TargetOrientation">
      <summary>
            Gets or sets the target orientation of the entity rotator.
            </summary>
    </member>
    <member name="T:BEPUphysics.UpdateableSystems.ContainmentState">
      <summary>
            Stores flags regarding an object's degree of inclusion in a volume.
            </summary>
    </member>
    <member name="F:BEPUphysics.UpdateableSystems.ContainmentState.IsContained">
      <summary>
            Whether or not the object is fully contained.
            </summary>
    </member>
    <member name="F:BEPUphysics.UpdateableSystems.ContainmentState.IsTouching">
      <summary>
            Whether or not the object is partially or fully contained.
            </summary>
    </member>
    <member name="M:BEPUphysics.UpdateableSystems.ContainmentState.#ctor(System.Boolean,System.Boolean)">
      <summary>
            Constructs a new ContainmentState.
            </summary>
      <param name="touching">Whether or not the object is partially or fully contained.</param>
      <param name="contained">Whether or not the object is fully contained.</param>
    </member>
    <member name="T:BEPUphysics.UpdateableSystems.IEndOfTimeStepUpdateable">
      <summary>
             Defines an object which is updated by the space at the end of a time step.
            </summary>
    </member>
    <member name="M:BEPUphysics.UpdateableSystems.IEndOfTimeStepUpdateable.Update(System.Single)">
      <summary>
             Updates the object at the end of a time step.
            </summary>
      <param name="dt">Time step duration.</param>
    </member>
    <member name="T:BEPUphysics.UpdateableSystems.DetectorVolume">
      <summary>
            Manages the detection of entities within an arbitrary closed triangle mesh.
            </summary>
    </member>
    <member name="M:BEPUphysics.UpdateableSystems.DetectorVolume.#ctor(BEPUphysics.DataStructures.MeshBoundingBoxTreeData,BEPUphysics.BroadPhaseSystems.IQueryAccelerator)">
      <summary>
            Creates a detector volume.
            </summary>
      <param name="triangleMesh">Arbitrary closed triangle mesh representing the volume.</param>
      <param name="queryAccelerator">System used to find nearby objects.</param>
    </member>
    <member name="M:BEPUphysics.UpdateableSystems.DetectorVolume.IsEntityIntersectingVolume(BEPUphysics.Entities.Entity)">
      <summary>
            Determines whether or not an entity is partially or fully contained within the volume.
            </summary>
      <param name="entity">Entity to check for intersection.</param>
      <returns>Whether or not the entity is partially or fully contained with the volume.</returns>
    </member>
    <member name="M:BEPUphysics.UpdateableSystems.DetectorVolume.IsEntityIntersectingVolume(BEPUphysics.Entities.Entity,System.Boolean@)">
      <summary>
            Determines whether or not an entity is partially or fully contained within the volume.
            </summary>
      <param name="entity">Entity to check for intersection.</param>
      <param name="isContained">Whether or not the entity is fully contained within the volume.</param>
      <returns>Whether or not the entity is partially or fully contained with the volume.</returns>
    </member>
    <member name="M:BEPUphysics.UpdateableSystems.DetectorVolume.IsEntityIntersectingVolume(BEPUphysics.Entities.Entity,System.Collections.Generic.List{System.Int32})">
      <summary>
            Determines whether or not an entity is partially or fully contained within the volume.
            Any surface triangles intersected by the entity are collected.
            </summary>
      <param name="entity">Entity to check for intersection.</param>
      <param name="intersectedTriangleIndices">First indices of intersected triangles in the index buffer.</param>
      <returns>Whether or not the entity is partially or fully contained with the volume.</returns>
    </member>
    <member name="M:BEPUphysics.UpdateableSystems.DetectorVolume.IsEntityWithinVolume(BEPUphysics.Entities.Entity)">
      <summary>
            Determines whether or not an entity is fully contained within the volume.
            </summary>
      <param name="entity">Entity to check for containment.</param>
      <returns>Whether or not the entity is fully contained with the volume.</returns>
    </member>
    <member name="M:BEPUphysics.UpdateableSystems.DetectorVolume.IsEntityIntersectingShell(BEPUphysics.Entities.Entity)">
      <summary>
             Determines whether or not an entity is intersecting the triangle shell of a detector volume.
            </summary>
      <param name="entity">Entity to test.</param>
      <returns>Whether or not the entity is intersecting the shell.</returns>
    </member>
    <member name="M:BEPUphysics.UpdateableSystems.DetectorVolume.IsEntityIntersectingShell(BEPUphysics.Entities.Entity,System.Collections.Generic.IList{System.Int32})">
      <summary>
             Determines whether or not an entity is intersecting the triangle shell of a detector volume.
            </summary>
      <param name="entity">Entity to test.</param>
      <param name="intersectedTriangleIndices">First indices of intersected triangles in the index buffer.</param>
      <returns>Whether or not the entity is intersecting the shell.</returns>
    </member>
    <member name="M:BEPUphysics.UpdateableSystems.DetectorVolume.IsPointInVolume(Microsoft.Xna.Framework.Vector3)">
      <summary>
            Determines whether the given point is within the triangle mesh.
            </summary>
      <param name="point">Point to check.</param>
      <returns>Whether or not the point is in the triangle mesh volume.</returns>
    </member>
    <member name="P:BEPUphysics.UpdateableSystems.DetectorVolume.CollisionRules">
      <summary>
             Gets or sets the collision rules of the detector volume.
            </summary>
    </member>
    <member name="P:BEPUphysics.UpdateableSystems.DetectorVolume.QueryAccelerator">
      <summary>
             Gets or sets the query accelerator used to find nearby objects.
            </summary>
    </member>
    <member name="P:BEPUphysics.UpdateableSystems.DetectorVolume.NearbyEntities">
      <summary>
            Gets a mapping of nearby entities to their containment states as determined by the DetectorVolume update method.
            </summary>
    </member>
    <member name="P:BEPUphysics.UpdateableSystems.DetectorVolume.TriangleMesh">
      <summary>
            Gets or sets the acceleration structure associated with the triangle mesh data.
            </summary>
    </member>
    <member name="E:BEPUphysics.UpdateableSystems.DetectorVolume.EntityBeginsTouching">
      <summary>
            Fires when an entity comes into contact with the volume.
            </summary>
    </member>
    <member name="E:BEPUphysics.UpdateableSystems.DetectorVolume.EntityStopsTouching">
      <summary>
            Fires when an entity ceases to intersect the volume.
            </summary>
    </member>
    <member name="E:BEPUphysics.UpdateableSystems.DetectorVolume.VolumeBeginsContainingEntity">
      <summary>
            Fires when an entity becomes fully engulfed by a volume.
            </summary>
    </member>
    <member name="E:BEPUphysics.UpdateableSystems.DetectorVolume.VolumeStopsContainingEntity">
      <summary>
            Fires when an entity ceases to be fully engulfed by a volume.
            </summary>
    </member>
    <member name="T:BEPUphysics.UpdateableSystems.EntityBeginsTouchingVolumeEventHandler">
      <summary>
            Handles any special logic to perform when an entry begins touching a detector volume.
            Runs within an update loop for updateables; modifying the updateable listing during the event is disallowed.
            </summary>
      <param name="toucher">Entry touching the volume.</param>
      <param name="volume">DetectorVolume being touched.</param>
    </member>
    <member name="T:BEPUphysics.UpdateableSystems.EntityStopsTouchingVolumeEventHandler">
      <summary>
            Handles any special logic to perform when an entry stops touching a detector volume.
            Runs within an update loop for updateables; modifying the updateable listing during the event is disallowed.
            </summary>
      <param name="toucher">Entry no longer touching the volume.</param>
      <param name="volume">DetectorVolume no longer being touched.</param>
    </member>
    <member name="T:BEPUphysics.UpdateableSystems.VolumeBeginsContainingEntityEventHandler">
      <summary>
            Handles any special logic to perform when an entry begins being contained by a detector volume.
            Runs within an update loop for updateables; modifying the updateable listing during the event is disallowed.
            </summary>
      <param name="volume">DetectorVolume containing the entry.</param>
      <param name="entry">Entry contained by the volume.</param>
    </member>
    <member name="T:BEPUphysics.UpdateableSystems.VolumeStopsContainingEntityEventHandler">
      <summary>
            Handles any special logic to perform when an entry stops being contained by a detector volume.
            Runs within an update loop for updateables; modifying the updateable listing during the event is disallowed.
            </summary>
      <param name="volume">DetectorVolume no longer containing the entry.</param>
      <param name="entry">Entry no longer contained by the volume.</param>
    </member>
    <member name="T:BEPUphysics.CollisionTests.CollisionAlgorithms.GJK.SimplexState">
      <summary>
             Defines the state of a simplex.
            </summary>
    </member>
    <member name="T:BEPUphysics.CollisionTests.CollisionAlgorithms.GJK.CachedSimplex">
      <summary>
             Stored simplex used to warmstart closest point GJK runs.
            </summary>
    </member>
    <member name="F:BEPUphysics.CollisionTests.CollisionAlgorithms.GJK.CachedSimplex.LocalSimplexA">
      <summary>
             Simplex in the local space of shape A.
            </summary>
    </member>
    <member name="F:BEPUphysics.CollisionTests.CollisionAlgorithms.GJK.CachedSimplex.LocalSimplexB">
      <summary>
             Simplex in the local space of shape B.
            </summary>
    </member>
    <member name="F:BEPUphysics.CollisionTests.CollisionAlgorithms.GJK.CachedSimplex.State">
      <summary>
            State of the simplex at the termination of the last GJK run.
            </summary>
    </member>
    <member name="T:BEPUphysics.CollisionTests.CollisionAlgorithms.GJK.ContributingShapeSimplex">
      <summary>
             List of points composing a shape's contributions to a simplex.
            </summary>
    </member>
    <member name="T:BEPUphysics.CollisionTests.CollisionAlgorithms.GJK.PairSimplex">
      <summary>
             GJK simplex used to support closest point tests with warmstarting.
            </summary>
    </member>
    <member name="F:BEPUphysics.CollisionTests.CollisionAlgorithms.GJK.PairSimplex.ProgressionEpsilon">
      <summary>
             The baseline amount that a GJK iteration must progress through to avoid exiting.
            </summary>
    </member>
    <member name="F:BEPUphysics.CollisionTests.CollisionAlgorithms.GJK.PairSimplex.DistanceConvergenceEpsilon">
      <summary>
            The baseline amount that an iteration must converge with its distance to avoid exiting.
            </summary>
    </member>
    <member name="F:BEPUphysics.CollisionTests.CollisionAlgorithms.GJK.PairSimplex.SimplexA">
      <summary>
             Simplex as viewed from the local space of A.
            </summary>
    </member>
    <member name="F:BEPUphysics.CollisionTests.CollisionAlgorithms.GJK.PairSimplex.SimplexB">
      <summary>
             Simplex as viewed from the local space of B.
            </summary>
    </member>
    <member name="F:BEPUphysics.CollisionTests.CollisionAlgorithms.GJK.PairSimplex.U">
      <summary>
            Weight of vertex A.
            </summary>
    </member>
    <member name="F:BEPUphysics.CollisionTests.CollisionAlgorithms.GJK.PairSimplex.V">
      <summary>
            Weight of vertex B.
            </summary>
    </member>
    <member name="F:BEPUphysics.CollisionTests.CollisionAlgorithms.GJK.PairSimplex.W">
      <summary>
            Weight of vertex C.
            </summary>
    </member>
    <member name="F:BEPUphysics.CollisionTests.CollisionAlgorithms.GJK.PairSimplex.LocalTransformB">
      <summary>
            Transform of the second shape in the first shape's local space.
            </summary>
    </member>
    <member name="M:BEPUphysics.CollisionTests.CollisionAlgorithms.GJK.PairSimplex.#ctor(BEPUphysics.CollisionTests.CollisionAlgorithms.GJK.CachedSimplex@,BEPUphysics.MathExtensions.RigidTransform@)">
      <summary>
             Constructs a new pair simplex.
            </summary>
      <param name="cachedSimplex">Cached simplex to use to warmstart the simplex.</param>
      <param name="localTransformB">Transform of shape B in the local space of A.</param>
    </member>
    <member name="M:BEPUphysics.CollisionTests.CollisionAlgorithms.GJK.PairSimplex.UpdateCachedSimplex(BEPUphysics.CollisionTests.CollisionAlgorithms.GJK.CachedSimplex@)">
      <summary>
             Updates the cached simplex with the latest run's results.
            </summary>
      <param name="simplex">Simplex to update.</param>
    </member>
    <member name="M:BEPUphysics.CollisionTests.CollisionAlgorithms.GJK.PairSimplex.GetPointClosestToOrigin(Microsoft.Xna.Framework.Vector3@)">
      <summary>
             Gets the point on the simplex closest to the origin.
            </summary>
      <param name="point">Point closest to the origin.</param>
      <returns>Whether or not the simplex encloses the origin.</returns>
    </member>
    <member name="M:BEPUphysics.CollisionTests.CollisionAlgorithms.GJK.PairSimplex.GetPointOnSegmentClosestToOrigin(Microsoft.Xna.Framework.Vector3@)">
      <summary>
             Gets the point on the segment closest to the origin.
            </summary>
      <param name="point">Point closest to origin.</param>
    </member>
    <member name="M:BEPUphysics.CollisionTests.CollisionAlgorithms.GJK.PairSimplex.GetPointOnTriangleClosestToOrigin(Microsoft.Xna.Framework.Vector3@)">
      <summary>
             Gets the point on the triangle closest to the origin.
            </summary>
      <param name="point">Point closest to origin.</param>
    </member>
    <member name="M:BEPUphysics.CollisionTests.CollisionAlgorithms.GJK.PairSimplex.GetPointOnTetrahedronClosestToOrigin(Microsoft.Xna.Framework.Vector3@)">
      <summary>
             Gets the point on the tetrahedron closest to the origin.
            </summary>
      <param name="point">Closest point to the origin.</param>
      <returns>Whether or not the tetrahedron encloses the origin.</returns>
    </member>
    <member name="M:BEPUphysics.CollisionTests.CollisionAlgorithms.GJK.PairSimplex.GetNewSimplexPoint(BEPUphysics.CollisionShapes.ConvexShapes.ConvexShape,BEPUphysics.CollisionShapes.ConvexShapes.ConvexShape,System.Int32,Microsoft.Xna.Framework.Vector3@)">
      <summary>
             Adds a new point to the simplex.
            </summary>
      <param name="shapeA">First shape in the pair.</param>
      <param name="shapeB">Second shape in the pair.</param>
      <param name="iterationCount">Current iteration count.</param>
      <param name="closestPoint">Current point on simplex closest to origin.</param>
      <returns>Whether or not GJK should exit due to a lack of progression.</returns>
    </member>
    <member name="M:BEPUphysics.CollisionTests.CollisionAlgorithms.GJK.PairSimplex.GetClosestPoints(Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Vector3@)">
      <summary>
             Gets the closest points by using the barycentric coordinates and shape simplex contributions.
            </summary>
      <param name="closestPointA">Closest point on shape A.</param>
      <param name="closestPointB">Closest point on shape B.</param>
    </member>
    <member name="P:BEPUphysics.CollisionTests.CollisionAlgorithms.GJK.PairSimplex.ErrorTolerance">
      <summary>
             Gets the error tolerance of the simplex.
            </summary>
    </member>
    <member name="T:BEPUphysics.CollisionShapes.TerrainShape">
      <summary>
             The local space data needed by a Terrain collidable.
             Contains the Heightmap and other information.
            </summary>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.TerrainShape.GetBoundingBox(BEPUphysics.MathExtensions.AffineTransform@,Microsoft.Xna.Framework.BoundingBox@)">
      <summary>
             Constructs the bounding box of the terrain given a transform.
            </summary>
      <param name="transform">Transform to apply to the terrain during the bounding box calculation.</param>
      <param name="boundingBox">Bounding box of the terrain shape when transformed.</param>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.TerrainShape.RayCast(Microsoft.Xna.Framework.Ray@,System.Single,BEPUphysics.MathExtensions.AffineTransform@,BEPUphysics.RayHit@)">
      <summary>
             Tests a ray against the terrain shape.
            </summary>
      <param name="ray">Ray to test against the shape.</param>
      <param name="maximumLength">Maximum length of the ray in units of the ray direction's length.</param>
      <param name="transform">Transform to apply to the terrain shape during the test.</param>
      <param name="hit">Hit data of the ray cast, if any.</param>
      <returns>Whether or not the ray hit the transformed terrain shape.</returns>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.TerrainShape.GetLocalPosition(System.Int32,System.Int32,Microsoft.Xna.Framework.Vector3@)">
      <summary>
             Gets the position of a vertex at the given indices in local space.
            </summary>
      <param name="i">Index in the first dimension.</param>
      <param name="j">Index in the second dimension.</param>
      <param name="v">Local space position at the given vertice.s</param>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.TerrainShape.GetPosition(System.Int32,System.Int32,BEPUphysics.MathExtensions.AffineTransform@,Microsoft.Xna.Framework.Vector3@)">
      <summary>
             Gets the world space position of a vertex in the terrain at the given indices.
             </summary>
      <param name="i">Index in the first dimension.</param>
      <param name="j">Index in the second dimension.</param>
      <param name="transform">Transform to apply to the vertex.</param>
      <param name="position">Transformed position of the vertex at the given indices.</param>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.TerrainShape.GetNormal(System.Int32,System.Int32,BEPUphysics.MathExtensions.AffineTransform@,Microsoft.Xna.Framework.Vector3@)">
      <summary>
             Gets the world space normal at the given indices.
             </summary>
      <param name="i">Index in the first dimension.</param>
      <param name="j">Index in the second dimension.</param>
      <param name="transform">Transform to apply to the terrain while computing the normal.</param>
      <param name="normal">World space normal at the given indices.</param>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.TerrainShape.GetOverlaps(Microsoft.Xna.Framework.BoundingBox,BEPUphysics.DataStructures.RawList{BEPUphysics.CollisionTests.Manifolds.TriangleMeshConvexContactManifold.TriangleIndices})">
      <summary>
             Gets overlapped triangles with the terrain shape with a bounding box in the local space of the shape.
            </summary>
      <param name="localSpaceBoundingBox">Bounding box in the local space of the terrain shape.</param>
      <param name="overlappedTriangles">Triangles whose bounding boxes overlap the input bounding box.</param>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.TerrainShape.GetTriangle(BEPUphysics.CollisionTests.Manifolds.TriangleMeshConvexContactManifold.TriangleIndices@,BEPUphysics.MathExtensions.AffineTransform@,Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Vector3@)">
      <summary>
             Gets a world space triangle in the terrain at the given indices (as if it were a mesh).
            </summary>
      <param name="indices">Indices of the triangle.</param>
      <param name="transform">Transform to apply to the triangle vertices.</param>
      <param name="a">First vertex of the triangle.</param>
      <param name="b">Second vertex of the triangle.</param>
      <param name="c">Third vertex of the triangle.</param>
    </member>
    <member name="P:BEPUphysics.CollisionShapes.TerrainShape.Heights">
      <summary>
             Gets or sets the height field of the terrain shape.
            </summary>
    </member>
    <member name="P:BEPUphysics.CollisionShapes.TerrainShape.QuadTriangleOrganization">
      <summary>
             Gets or sets the quad triangle organization.
            </summary>
    </member>
    <member name="T:BEPUphysics.CollisionShapes.QuadTriangleOrganization">
      <summary>
            Defines how a Terrain organizes triangles in its quads.
            </summary>
    </member>
    <member name="F:BEPUphysics.CollisionShapes.QuadTriangleOrganization.BottomLeftUpperRight">
      <summary>
            Triangle with a right angle at the (-i,-j) position and another at the (+i,+j) position.
            </summary>
    </member>
    <member name="F:BEPUphysics.CollisionShapes.QuadTriangleOrganization.BottomRightUpperLeft">
      <summary>
            Triangle with a right angle at the (+i,-j) position and another at the high (-i,+j) position.
            </summary>
    </member>
    <member name="T:BEPUphysics.NarrowPhaseSystems.Pairs.CompoundInstancedMeshPairHandler">
      <summary>
             Handles a compound-instanced mesh collision pair.
            </summary>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.Pairs.CompoundInstancedMeshPairHandler.#ctor">
      <summary>
             Constructs a new pair handler.
            </summary>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.Pairs.CompoundInstancedMeshPairHandler.Initialize(BEPUphysics.BroadPhaseSystems.BroadPhaseEntry,BEPUphysics.BroadPhaseSystems.BroadPhaseEntry)">
      <summary>
             Initializes the pair handler.
            </summary>
      <param name="entryA">First entry in the pair.</param>
      <param name="entryB">Second entry in the pair.</param>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.Pairs.CompoundInstancedMeshPairHandler.UpdateMaterialProperties">
      <summary>
             Forces an update of the pair's material properties.
            </summary>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.Pairs.CompoundInstancedMeshPairHandler.OnAddedToNarrowPhase">
      <summary>
             Called when the pair handler is added to the narrow phase.
            </summary>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.Pairs.CompoundInstancedMeshPairHandler.CleanUp">
      <summary>
             Cleans up the pair handler.
            </summary>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.Pairs.CompoundInstancedMeshPairHandler.UpdateCollision(System.Single)">
      <summary>
             Updates the pair handler.
            </summary>
      <param name="dt">Timestep duration.</param>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.Pairs.CompoundInstancedMeshPairHandler.UpdateTimeOfImpact(BEPUphysics.Collidables.Collidable,System.Single)">
      <summary>
             Updates the time of impact for the pair.
            </summary>
      <param name="requester">Collidable requesting the update.</param>
      <param name="dt">Timestep duration.</param>
    </member>
    <member name="P:BEPUphysics.NarrowPhaseSystems.Pairs.CompoundInstancedMeshPairHandler.ChildPairs">
      <summary>
             Gets a list of the pair handlers associated with children of the compound.
            </summary>
    </member>
    <member name="T:BEPUphysics.NarrowPhaseSystems.Factories.StaticMeshConvexPairFactory">
      <summary>
             Manufactures static mesh-convex pairs.
            </summary>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.Factories.StaticMeshConvexPairFactory.GetNarrowPhasePair(BEPUphysics.BroadPhaseSystems.BroadPhaseOverlap)">
      <summary>
             Manufactures and returns a narrow phase pair for the given overlap.
            </summary>
      <param name="overlap">Overlap used to create a pair.</param>
      <returns>Narrow phase pair.</returns>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.Factories.StaticMeshConvexPairFactory.GiveBack(BEPUphysics.NarrowPhaseSystems.Pairs.INarrowPhasePair)">
      <summary>
            Returns a pair to the factory for re-use.
            </summary>
      <param name="pair">Pair to return.</param>
    </member>
    <member name="T:BEPUphysics.NarrowPhaseSystems.Factories.CompoundPairFactory">
      <summary>
             Manufactures compound-compound pairs.
            </summary>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.Factories.CompoundPairFactory.GetNarrowPhasePair(BEPUphysics.BroadPhaseSystems.BroadPhaseOverlap)">
      <summary>
             Manufactures and returns a narrow phase pair for the given overlap.
            </summary>
      <param name="overlap">Overlap used to create a pair.</param>
      <returns>Narrow phase pair.</returns>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.Factories.CompoundPairFactory.GiveBack(BEPUphysics.NarrowPhaseSystems.Pairs.INarrowPhasePair)">
      <summary>
            Returns a pair to the factory for re-use.
            </summary>
      <param name="pair">Pair to return.</param>
    </member>
    <member name="T:BEPUphysics.MathExtensions.AffineTransform">
      <summary>
             A transformation composed of a linear transformation and a translation.
            </summary>
    </member>
    <member name="F:BEPUphysics.MathExtensions.AffineTransform.Translation">
      <summary>
             Translation in the affine transform.
            </summary>
    </member>
    <member name="F:BEPUphysics.MathExtensions.AffineTransform.LinearTransform">
      <summary>
            Linear transform in the affine transform.
            </summary>
    </member>
    <member name="M:BEPUphysics.MathExtensions.AffineTransform.#ctor(Microsoft.Xna.Framework.Vector3)">
      <summary>
             Constructs a new affine transform.
            </summary>
      <param name="translation">Translation to use in the transform.</param>
    </member>
    <member name="M:BEPUphysics.MathExtensions.AffineTransform.#ctor(Microsoft.Xna.Framework.Quaternion,Microsoft.Xna.Framework.Vector3)">
      <summary>
             Constructs a new affine tranform.
            </summary>
      <param name="orientation">Orientation to use as the linear transform.</param>
      <param name="translation">Translation to use in the transform.</param>
    </member>
    <member name="M:BEPUphysics.MathExtensions.AffineTransform.#ctor(Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Quaternion,Microsoft.Xna.Framework.Vector3)">
      <summary>
             Constructs a new affine transform.
            </summary>
      <param name="scaling">Scaling to apply in the linear transform.</param>
      <param name="orientation">Orientation to apply in the linear transform.</param>
      <param name="translation">Translation to apply.</param>
    </member>
    <member name="M:BEPUphysics.MathExtensions.AffineTransform.#ctor(BEPUphysics.MathExtensions.Matrix3X3,Microsoft.Xna.Framework.Vector3)">
      <summary>
             Constructs a new affine transform.
            </summary>
      <param name="linearTransform">The linear transform component.</param>
      <param name="translation">Translation component of the transform.</param>
    </member>
    <member name="M:BEPUphysics.MathExtensions.AffineTransform.Transform(Microsoft.Xna.Framework.Vector3@,BEPUphysics.MathExtensions.AffineTransform@,Microsoft.Xna.Framework.Vector3@)">
      <summary>
             Transforms a vector by an affine transform.
            </summary>
      <param name="position">Position to transform.</param>
      <param name="transform">Transform to apply.</param>
      <param name="transformed">Transformed position.</param>
    </member>
    <member name="M:BEPUphysics.MathExtensions.AffineTransform.TransformInverse(Microsoft.Xna.Framework.Vector3@,BEPUphysics.MathExtensions.AffineTransform@,Microsoft.Xna.Framework.Vector3@)">
      <summary>
             Transforms a vector by an affine transform's inverse.
            </summary>
      <param name="position">Position to transform.</param>
      <param name="transform">Transform to invert and apply.</param>
      <param name="transformed">Transformed position.</param>
    </member>
    <member name="M:BEPUphysics.MathExtensions.AffineTransform.Invert(BEPUphysics.MathExtensions.AffineTransform@,BEPUphysics.MathExtensions.AffineTransform@)">
      <summary>
             Inverts an affine transform.
            </summary>
      <param name="transform">Transform to invert.</param>
      <param name="inverse">Inverse of the transform.</param>
    </member>
    <member name="M:BEPUphysics.MathExtensions.AffineTransform.Multiply(BEPUphysics.MathExtensions.AffineTransform@,BEPUphysics.MathExtensions.AffineTransform@,BEPUphysics.MathExtensions.AffineTransform@)">
      <summary>
            Multiplies a transform by another transform.
            </summary>
      <param name="a">First transform.</param>
      <param name="b">Second transform.</param>
      <param name="transform">Combined transform.</param>
    </member>
    <member name="M:BEPUphysics.MathExtensions.AffineTransform.Multiply(BEPUphysics.MathExtensions.RigidTransform@,BEPUphysics.MathExtensions.AffineTransform@,BEPUphysics.MathExtensions.AffineTransform@)">
      <summary>
             Multiplies a rigid transform by an affine transform.
            </summary>
      <param name="a">Rigid transform.</param>
      <param name="b">Affine transform.</param>
      <param name="transform">Combined transform.</param>
    </member>
    <member name="M:BEPUphysics.MathExtensions.AffineTransform.Transform(Microsoft.Xna.Framework.Vector3,BEPUphysics.MathExtensions.AffineTransform)">
      <summary>
             Transforms a vector using an affine transform.
            </summary>
      <param name="position">Position to transform.</param>
      <param name="affineTransform">Transform to apply.</param>
      <returns>Transformed position.</returns>
    </member>
    <member name="M:BEPUphysics.MathExtensions.AffineTransform.CreateFromRigidTransform(BEPUphysics.MathExtensions.RigidTransform@,BEPUphysics.MathExtensions.AffineTransform@)">
      <summary>
            Creates an affine transform from a rigid transform.
            </summary>
      <param name="rigid">Rigid transform to base the affine transform on.</param>
      <param name="affine">Affine transform created from the rigid transform.</param>
    </member>
    <member name="M:BEPUphysics.MathExtensions.AffineTransform.CreateFromRigidTransform(BEPUphysics.MathExtensions.RigidTransform)">
      <summary>
            Creates an affine transform from a rigid transform.
            </summary>
      <param name="rigid">Rigid transform to base the affine transform on.</param>
      <returns>Affine transform created from the rigid transform.</returns>
    </member>
    <member name="P:BEPUphysics.MathExtensions.AffineTransform.Matrix">
      <summary>
             Gets or sets the 4x4 matrix representation of the affine transform.
             The linear transform is the upper left 3x3 part of the 4x4 matrix.
             The translation is included in the matrix's Translation property.
            </summary>
    </member>
    <member name="P:BEPUphysics.MathExtensions.AffineTransform.Identity">
      <summary>
             Gets the identity affine transform.
            </summary>
    </member>
    <member name="T:BEPUphysics.Constraints.SpringAdvancedSettings">
      <summary>
            Contains the error reduction factor and softness of a constraint.
            These can be used to make the same behaviors as the stiffness and damping constants,
            but may provide a more intuitive representation for rigid constraints.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.SpringAdvancedSettings.ErrorReductionFactor">
      <summary>
            Gets or sets the error reduction parameter of the spring.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.SpringAdvancedSettings.Softness">
      <summary>
            Gets or sets the softness of the joint.  Higher values allow the constraint to be violated more.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.SpringAdvancedSettings.UseAdvancedSettings">
      <summary>
            Gets or sets whether or not to use the advanced settings.
            If this is set to true, the errorReductionFactor and softness will be used instead
            of the stiffness constant and damping constant.
            </summary>
    </member>
    <member name="T:BEPUphysics.Constraints.SpringSettings">
      <summary>
            Specifies the way in which a constraint's spring component behaves.
            </summary>
    </member>
    <member name="M:BEPUphysics.Constraints.SpringSettings.ComputeErrorReductionAndSoftness(System.Single,System.Single@,System.Single@)">
      <summary>
            Computes the error reduction parameter and softness of a constraint based on its constants.
            Automatically called by constraint presteps to compute their per-frame values.
            </summary>
      <param name="dt">Simulation timestep.</param>
      <param name="errorReduction">Error reduction factor to use this frame.</param>
      <param name="softness">Adjusted softness of the constraint for this frame.</param>
    </member>
    <member name="P:BEPUphysics.Constraints.SpringSettings.Advanced">
      <summary>
            Gets an object containing the solver's direct view of the spring behavior.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.SpringSettings.DampingConstant">
      <summary>
            Gets or sets the damping constant of this spring.  Higher values reduce oscillation more.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.SpringSettings.StiffnessConstant">
      <summary>
            Gets or sets the spring constant of this spring.  Higher values make the spring stiffer.
            </summary>
    </member>
    <member name="T:BEPUphysics.Constraints.SolverGroups.UniversalJoint">
      <summary>
            Restricts three degrees of linear motion and one degree of angular motion.
            Acts like two hinges in immediate sequence.
            </summary>
    </member>
    <member name="M:BEPUphysics.Constraints.SolverGroups.UniversalJoint.#ctor">
      <summary>
            Constructs a new constraint which restricts three degrees of linear freedom and one degree of twisting angular freedom between two entities.
            This constructs the internal constraints, but does not configure them.  Before using a constraint constructed in this manner,
            ensure that its active constituent constraints are properly configured.  The entire group as well as all internal constraints are initially inactive (IsActive = false).
            </summary>
    </member>
    <member name="M:BEPUphysics.Constraints.SolverGroups.UniversalJoint.#ctor(BEPUphysics.Entities.Entity,BEPUphysics.Entities.Entity,Microsoft.Xna.Framework.Vector3)">
      <summary>
            Constructs a new constraint which restricts three degrees of linear freedom and one degree of twisting angular freedom between two entities.
            </summary>
      <param name="connectionA">First entity of the constraint pair.</param>
      <param name="connectionB">Second entity of the constraint pair.</param>
      <param name="anchor">Point around which both entities rotate in world space.</param>
    </member>
    <member name="P:BEPUphysics.Constraints.SolverGroups.UniversalJoint.BallSocketJoint">
      <summary>
            Gets the ball socket joint that restricts linear degrees of freedom.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.SolverGroups.UniversalJoint.Limit">
      <summary>
            Gets the rotational limit of the universal joint.
            This constraint overlaps with the twistJoint; if the limit is activated,
            the twistJoint should be generally deactivated and vice versa.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.SolverGroups.UniversalJoint.Motor">
      <summary>
            Gets the motor of the universal joint.
            This constraint overlaps with the twistJoint; if the motor is activated,
            the twistJoint should generally be deactivated and vice versa.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.SolverGroups.UniversalJoint.TwistJoint">
      <summary>
            Gets the angular joint which removes one twisting degree of freedom.
            </summary>
    </member>
    <member name="T:BEPUphysics.Constraints.SolverGroups.SwivelHingeJoint">
      <summary>
            Restricts linear motion while allowing one degree of angular freedom.
            Acts like a tablet pc monitor hinge.
            </summary>
    </member>
    <member name="M:BEPUphysics.Constraints.SolverGroups.SwivelHingeJoint.#ctor">
      <summary>
            Constructs a new constraint which restricts three degrees of linear freedom and one degree of angular freedom between two entities.
            This constructs the internal constraints, but does not configure them.  Before using a constraint constructed in this manner,
            ensure that its active constituent constraints are properly configured.  The entire group as well as all internal constraints are initially inactive (IsActive = false).
            </summary>
    </member>
    <member name="M:BEPUphysics.Constraints.SolverGroups.SwivelHingeJoint.#ctor(BEPUphysics.Entities.Entity,BEPUphysics.Entities.Entity,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3)">
      <summary>
            Constructs a new constraint which restricts three degrees of linear freedom and one degree of angular freedom between two entities.
            </summary>
      <param name="connectionA">First entity of the constraint pair.</param>
      <param name="connectionB">Second entity of the constraint pair.</param>
      <param name="anchor">Point around which both entities rotate.</param>
      <param name="hingeAxis">Axis of allowed rotation in world space to be attached to connectionA.  Will be kept perpendicular with the twist axis.</param>
    </member>
    <member name="P:BEPUphysics.Constraints.SolverGroups.SwivelHingeJoint.AngularJoint">
      <summary>
            Gets the angular joint which removes one degree of freedom.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.SolverGroups.SwivelHingeJoint.BallSocketJoint">
      <summary>
            Gets the ball socket joint that restricts linear degrees of freedom.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.SolverGroups.SwivelHingeJoint.HingeLimit">
      <summary>
            Gets the rotational limit of the hinge.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.SolverGroups.SwivelHingeJoint.HingeMotor">
      <summary>
            Gets the motor of the hinge.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.SolverGroups.SwivelHingeJoint.TwistLimit">
      <summary>
            Gets the rotational limit of the swivel hinge.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.SolverGroups.SwivelHingeJoint.TwistMotor">
      <summary>
            Gets the twist motor of the swivel hinge.
            </summary>
    </member>
    <member name="T:BEPUphysics.Constraints.SingleEntity.MaximumAngularSpeedConstraint">
      <summary>
            Prevents the target entity from moving faster than the specified speeds.
            </summary>
    </member>
    <member name="M:BEPUphysics.Constraints.SingleEntity.MaximumAngularSpeedConstraint.#ctor">
      <summary>
            Constructs a maximum speed constraint.
            Set its Entity and MaximumSpeed to complete the configuration.
            IsActive also starts as false with this constructor.
            </summary>
    </member>
    <member name="M:BEPUphysics.Constraints.SingleEntity.MaximumAngularSpeedConstraint.#ctor(BEPUphysics.Entities.Entity,System.Single)">
      <summary>
            Constructs a maximum speed constraint.
            </summary>
      <param name="e">Affected entity.</param>
      <param name="maxSpeed">Maximum angular speed allowed.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.SingleEntity.MaximumAngularSpeedConstraint.SolveIteration">
      <summary>
            Calculates and applies corrective impulses.
            Called automatically by space.
            </summary>
    </member>
    <member name="M:BEPUphysics.Constraints.SingleEntity.MaximumAngularSpeedConstraint.Update(System.Single)">
      <summary>
            Calculates necessary information for velocity solving.
            Called automatically by space.
            </summary>
      <param name="dt">Time in seconds since the last update.</param>
    </member>
    <member name="P:BEPUphysics.Constraints.SingleEntity.MaximumAngularSpeedConstraint.MaximumForce">
      <summary>
            Gets and sets the maximum impulse that the constraint will attempt to apply when satisfying its requirements.
            This field can be used to simulate friction in a constraint.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.SingleEntity.MaximumAngularSpeedConstraint.MaximumSpeed">
      <summary>
            Gets or sets the maximum angular speed that this constraint allows.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.SingleEntity.MaximumAngularSpeedConstraint.Softness">
      <summary>
            Gets and sets the softness of this constraint.
            Higher values of softness allow the constraint to be violated more.
            Must be greater than zero.
            Sometimes, if a joint system is unstable, increasing the softness of the involved constraints will make it settle down.
            For motors, softness can be used to implement damping.  For a damping constant k, the appropriate softness is 1/k.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.SingleEntity.MaximumAngularSpeedConstraint.TotalImpulse">
      <summary>
            Gets the total impulse applied by the constraint.
            </summary>
    </member>
    <member name="T:BEPUphysics.Constraints.JointBasis3D">
      <summary>
            Defines a three dimensional orthonormal basis used by a constraint.
            </summary>
    </member>
    <member name="M:BEPUphysics.Constraints.JointBasis3D.SetLocalAxes(Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,BEPUphysics.MathExtensions.Matrix3X3)">
      <summary>
            Sets up the axes of the transform and ensures that it is an orthonormal basis.
            </summary>
      <param name="primaryAxis">First axis in the transform.  Usually aligned along the main axis of a joint, like the twist axis of a TwistLimit.</param>
      <param name="xAxis">Second axis in the transform.</param>
      <param name="yAxis">Third axis in the transform.</param>
      <param name="rotationMatrix">Matrix to use to transform the local axes into world space.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.JointBasis3D.SetLocalAxes(Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3)">
      <summary>
            Sets up the axes of the transform and ensures that it is an orthonormal basis.
            </summary>
      <param name="primaryAxis">First axis in the transform.  Usually aligned along the main axis of a joint, like the twist axis of a TwistLimit.</param>
      <param name="xAxis">Second axis in the transform.</param>
      <param name="yAxis">Third axis in the transform.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.JointBasis3D.SetLocalAxes(BEPUphysics.MathExtensions.Matrix3X3)">
      <summary>
            Sets up the axes of the transform and ensures that it is an orthonormal basis.
            </summary>
      <param name="matrix">Rotation matrix representing the three axes.
            The matrix's backward vector is used as the primary axis.  
            The matrix's right vector is used as the x axis.
            The matrix's up vector is used as the y axis.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.JointBasis3D.SetWorldAxes(Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,BEPUphysics.MathExtensions.Matrix3X3)">
      <summary>
            Sets up the axes of the transform and ensures that it is an orthonormal basis.
            </summary>
      <param name="primaryAxis">First axis in the transform.  Usually aligned along the main axis of a joint, like the twist axis of a TwistLimit.</param>
      <param name="xAxis">Second axis in the transform.</param>
      <param name="yAxis">Third axis in the transform.</param>
      <param name="rotationMatrix">Matrix to use to transform the local axes into world space.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.JointBasis3D.SetWorldAxes(Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3)">
      <summary>
            Sets up the axes of the transform and ensures that it is an orthonormal basis.
            </summary>
      <param name="primaryAxis">First axis in the transform.  Usually aligned along the main axis of a joint, like the twist axis of a TwistLimit.</param>
      <param name="xAxis">Second axis in the transform.</param>
      <param name="yAxis">Third axis in the transform.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.JointBasis3D.SetWorldAxes(BEPUphysics.MathExtensions.Matrix3X3)">
      <summary>
            Sets up the axes of the transform and ensures that it is an orthonormal basis.
            </summary>
      <param name="matrix">Rotation matrix representing the three axes.
            The matrix's backward vector is used as the primary axis.  
            The matrix's right vector is used as the x axis.
            The matrix's up vector is used as the y axis.</param>
    </member>
    <member name="P:BEPUphysics.Constraints.JointBasis3D.LocalPrimaryAxis">
      <summary>
            Gets the primary axis of the transform in local space.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.JointBasis3D.LocalTransform">
      <summary>
            Gets or sets the local transform of the basis.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.JointBasis3D.LocalXAxis">
      <summary>
            Gets the X axis of the transform in local space.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.JointBasis3D.LocalYAxis">
      <summary>
            Gets the Y axis of the transform in local space.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.JointBasis3D.PrimaryAxis">
      <summary>
            Gets the primary axis of the transform.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.JointBasis3D.RotationMatrix">
      <summary>
            Gets or sets the rotation matrix used by the joint transform to convert local space axes to world space.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.JointBasis3D.WorldTransform">
      <summary>
            Gets or sets the world transform of the basis.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.JointBasis3D.XAxis">
      <summary>
            Gets the X axis of the transform.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.JointBasis3D.YAxis">
      <summary>
            Gets the Y axis of the transform.
            </summary>
    </member>
    <member name="T:BEPUphysics.Constraints.JointBasis2D">
      <summary>
            Defines a two axes which are perpendicular to each other used by a constraint.
            </summary>
    </member>
    <member name="M:BEPUphysics.Constraints.JointBasis2D.SetLocalAxes(Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,BEPUphysics.MathExtensions.Matrix3X3)">
      <summary>
            Sets up the axes of the transform and ensures that it is an orthonormal basis.
            </summary>
      <param name="primaryAxis">First axis in the transform.  Usually aligned along the main axis of a joint, like the twist axis of a TwistLimit.</param>
      <param name="xAxis">Second axis in the transform.</param>
      <param name="rotationMatrix">Matrix to use to transform the local axes into world space.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.JointBasis2D.SetLocalAxes(Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3)">
      <summary>
            Sets up the axes of the transform and ensures that it is an orthonormal basis.
            </summary>
      <param name="primaryAxis">First axis in the transform.  Usually aligned along the main axis of a joint, like the twist axis of a TwistLimit.</param>
      <param name="xAxis">Second axis in the transform.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.JointBasis2D.SetLocalAxes(BEPUphysics.MathExtensions.Matrix3X3)">
      <summary>
            Sets up the axes of the transform and ensures that it is an orthonormal basis.
            </summary>
      <param name="matrix">Rotation matrix representing the three axes.
            The matrix's backward vector is used as the primary axis.  
            The matrix's right vector is used as the x axis.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.JointBasis2D.SetWorldAxes(Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,BEPUphysics.MathExtensions.Matrix3X3)">
      <summary>
            Sets up the axes of the transform and ensures that it is an orthonormal basis.
            </summary>
      <param name="primaryAxis">First axis in the transform.  Usually aligned along the main axis of a joint, like the twist axis of a TwistLimit.</param>
      <param name="xAxis">Second axis in the transform.</param>
      <param name="rotationMatrix">Matrix to use to transform the local axes into world space.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.JointBasis2D.SetWorldAxes(Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3)">
      <summary>
            Sets up the axes of the transform and ensures that it is an orthonormal basis.
            </summary>
      <param name="primaryAxis">First axis in the transform.  Usually aligned along the main axis of a joint, like the twist axis of a TwistLimit.</param>
      <param name="xAxis">Second axis in the transform.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.JointBasis2D.SetWorldAxes(BEPUphysics.MathExtensions.Matrix3X3)">
      <summary>
            Sets up the axes of the transform and ensures that it is an orthonormal basis.
            </summary>
      <param name="matrix">Rotation matrix representing the three axes.
            The matrix's backward vector is used as the primary axis.  
            The matrix's right vector is used as the x axis.</param>
    </member>
    <member name="P:BEPUphysics.Constraints.JointBasis2D.LocalPrimaryAxis">
      <summary>
            Gets the primary axis of the transform in local space.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.JointBasis2D.LocalXAxis">
      <summary>
            Gets the X axis of the transform in local space.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.JointBasis2D.PrimaryAxis">
      <summary>
            Gets the primary axis of the transform.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.JointBasis2D.RotationMatrix">
      <summary>
            Gets or sets the rotation matrix used by the joint transform to convert local space axes to world space.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.JointBasis2D.XAxis">
      <summary>
            Gets the X axis of the transform.
            </summary>
    </member>
    <member name="T:BEPUphysics.Constraints.Collision.ContactManifoldConstraint">
      <summary>
             Superclass of collision constraints that include multiple contact subconstraints.
            </summary>
    </member>
    <member name="M:BEPUphysics.Constraints.Collision.ContactManifoldConstraint.AddContact(BEPUphysics.CollisionTests.Contact)">
      <summary>
             Adds a contact to be managed by the constraint.
            </summary>
      <param name="contact">Contact to add.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.Collision.ContactManifoldConstraint.RemoveContact(BEPUphysics.CollisionTests.Contact)">
      <summary>
             Removes a contact from the constraint.
            </summary>
      <param name="contact">Contact to remove.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.Collision.ContactManifoldConstraint.Initialize(BEPUphysics.Entities.Entity,BEPUphysics.Entities.Entity,BEPUphysics.NarrowPhaseSystems.Pairs.CollidablePairHandler)">
      <summary>
             Initializes the constraint.
            </summary>
      <param name="a">First entity of the pair.</param>
      <param name="b">Second entity of the pair.</param>
      <param name="newPair">Pair owning this constraint.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.Collision.ContactManifoldConstraint.CleanUp">
      <summary>
             Cleans up the constraint.
            </summary>
    </member>
    <member name="M:BEPUphysics.Constraints.Collision.ContactManifoldConstraint.OnRemovalFromSolver(BEPUphysics.SolverSystems.Solver)">
      <summary>
            Called when the updateable is removed from its solver.
            </summary>
      <param name="oldSolver">Solver from which the updateable was removed.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.Collision.ContactManifoldConstraint.UpdateSolverActivity">
      <summary>
            Sets the activity state of the constraint based on the activity state of its connections.
            Called automatically by the space owning a constaint.  If a constraint is a sub-constraint that hasn't been directly added to the space,
            this may need to be called alongside the preStep from within the parent constraint.
            </summary>
    </member>
    <member name="M:BEPUphysics.Constraints.Collision.ContactManifoldConstraint.UpdateMaterialProperties(BEPUphysics.Materials.Material,BEPUphysics.Materials.Material)">
      <summary>
             Updates the material properties associated with the constraint.
            </summary>
      <param name="materialA">Material associated with the first entity of the pair.</param>
      <param name="materialB">Material associated with the second entity of the pair.</param>
    </member>
    <member name="P:BEPUphysics.Constraints.Collision.ContactManifoldConstraint.MaterialInteraction">
      <summary>
             Gets or sets the material-blended properties used by this constraint.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.Collision.ContactManifoldConstraint.EntityA">
      <summary>
             Gets the first entity associated with the manifold.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.Collision.ContactManifoldConstraint.EntityB">
      <summary>
             Gets the second entity associated with the manifold.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.Collision.ContactManifoldConstraint.Pair">
      <summary>
             Gets the pair handler owning this constraint.
            </summary>
    </member>
    <member name="T:BEPUphysics.CollisionShapes.ConvexShapes.InertiaHelper">
      <summary>
             Helper class used to compute volume distribution information, which is in turn used to compute inertia tensor information.
            </summary>
    </member>
    <member name="F:BEPUphysics.CollisionShapes.ConvexShapes.InertiaHelper.InertiaTensorScale">
      <summary>
            Value to scale any created entities' inertia tensors by.
            Larger tensors (above 1) improve stiffness of constraints and contacts, while smaller values (towards 1) are closer to 'realistic' behavior.
            If MotionUpdateSettings.padInertiaTensors is enabled, this value can be reduced significantly or all the way to 1 while maintaining fairly good behavior.
            Defaults to 2.5.
            </summary>
    </member>
    <member name="F:BEPUphysics.CollisionShapes.ConvexShapes.InertiaHelper.NumberOfSamplesPerDimension">
      <summary>
             Number of samples the system takes along a side of an object's AABB when voxelizing it.
            </summary>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.ConvexShapes.InertiaHelper.ComputeCenter(BEPUphysics.CollisionShapes.ConvexShapes.ConvexShape)">
      <summary>
             Computes the center of a convex shape.
            </summary>
      <param name="shape">Shape to compute the center of.</param>
      <returns>Center of the shape.</returns>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.ConvexShapes.InertiaHelper.ComputeCenter(BEPUphysics.CollisionShapes.ConvexShapes.ConvexShape,System.Single@)">
      <summary>
             Computes the center and volume of a convex shape.
            </summary>
      <param name="shape">Shape to compute the center of.</param>
      <param name="volume">Volume of the shape.</param>
      <returns>Center of the shape.</returns>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.ConvexShapes.InertiaHelper.AveragePoints(System.Collections.Generic.List{Microsoft.Xna.Framework.Vector3})">
      <summary>
             Averages together all the points in the point list.
            </summary>
      <param name="pointContributions">Point list to average.</param>
      <returns>Averaged point.</returns>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.ConvexShapes.InertiaHelper.ComputeVolumeDistribution(BEPUphysics.CollisionShapes.ConvexShapes.ConvexShape,System.Single@)">
      <summary>
             Computes the volume and volume distribution of a shape.
            </summary>
      <param name="shape">Shape to compute the volume information of.</param>
      <param name="volume">Volume of the shape.</param>
      <returns>Volume distribution of the shape.</returns>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.ConvexShapes.InertiaHelper.ComputeVolumeDistribution(BEPUphysics.CollisionShapes.ConvexShapes.ConvexShape,Microsoft.Xna.Framework.Vector3@,System.Single@)">
      <summary>
             Computes the volume and volume distribution of a shape based on a given center.
            </summary>
      <param name="shape">Shape to compute the volume information of.</param>
      <param name="center">Location to use as the center of the shape when computing the volume distribution.</param>
      <param name="volume">Volume of the shape.</param>
      <returns>Volume distribution of the shape.</returns>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.ConvexShapes.InertiaHelper.ComputeVolumeDistribution(System.Collections.Generic.List{Microsoft.Xna.Framework.Vector3},Microsoft.Xna.Framework.Vector3@)">
      <summary>
             Computes a volume distribution based on a bunch of point contributions.
            </summary>
      <param name="pointContributions">Point contributions to the volume distribution.</param>
      <param name="center">Location to use as the center for purposes of computing point contributions.</param>
      <returns>Volume distribution of the point contributions.</returns>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.ConvexShapes.InertiaHelper.GetPoints(BEPUphysics.CollisionShapes.ConvexShapes.ConvexShape,System.Single@,System.Collections.Generic.List{Microsoft.Xna.Framework.Vector3})">
      <summary>
             Gets the point contributions within a convex shape.
            </summary>
      <param name="shape">Shape to compute the point contributions of.</param>
      <param name="volume">Volume of the shape.</param>
      <param name="outputPointContributions">Point contributions of the shape.</param>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.ConvexShapes.InertiaHelper.GetPointContribution(System.Single,Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Vector3,BEPUphysics.MathExtensions.Matrix3X3@)">
      <summary>
             Computes the volume contribution of a point.
            </summary>
      <param name="pointWeight">Weight of the point.</param>
      <param name="center">Location to use as the center for the purposes of computing the contribution.</param>
      <param name="p">Point to compute the contribution of.</param>
      <param name="contribution">Contribution of the point.</param>
    </member>
    <member name="T:BEPUphysics.CollisionShapes.ConvexShapes.BoxShape">
      <summary>
             Convex shape with width, length, and height.
            </summary>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.ConvexShapes.BoxShape.#ctor(System.Single,System.Single,System.Single)">
      <summary>
             Constructs a new box shape.
            </summary>
      <param name="width">Width of the box.</param>
      <param name="height">Height of the box.</param>
      <param name="length">Length of the box.</param>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.ConvexShapes.BoxShape.GetBoundingBox(BEPUphysics.MathExtensions.RigidTransform@,Microsoft.Xna.Framework.BoundingBox@)">
      <summary>
            Gets the bounding box of the shape given a transform.
            </summary>
      <param name="shapeTransform">Transform to use.</param>
      <param name="boundingBox">Bounding box of the transformed shape.</param>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.ConvexShapes.BoxShape.GetLocalExtremePointWithoutMargin(Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Vector3@)">
      <summary>
             Gets the extreme point of the shape in local space in a given direction.
            </summary>
      <param name="direction">Direction to find the extreme point in.</param>
      <param name="extremePoint">Extreme point on the shape.</param>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.ConvexShapes.BoxShape.ComputeMinimumRadius">
      <summary>
             Computes the minimum radius of the shape.
             This is often smaller than the actual minimum radius;
             it is simply an approximation that avoids overestimating.
            </summary>
      <returns>Minimum radius of the shape.</returns>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.ConvexShapes.BoxShape.ComputeMaximumRadius">
      <summary>
            Computes the maximum radius of the shape.
            This is often larger than the actual maximum radius;
            it is simply an approximation that avoids underestimating.
            </summary>
      <returns>Maximum radius of the shape.</returns>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.ConvexShapes.BoxShape.ComputeVolumeDistribution(System.Single@)">
      <summary>
            Computes the volume distribution of the shape as well as its volume.
            The volume distribution can be used to compute inertia tensors when
            paired with mass and other tuning factors.
            </summary>
      <param name="volume">Volume of the shape.</param>
      <returns>Volume distribution of the shape.</returns>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.ConvexShapes.BoxShape.RayTest(Microsoft.Xna.Framework.Ray@,BEPUphysics.MathExtensions.RigidTransform@,System.Single,BEPUphysics.RayHit@)">
      <summary>
            Gets the intersection between the box and the ray.
            </summary>
      <param name="ray">Ray to test against the box.</param>
      <param name="transform">Transform of the shape.</param>
      <param name="maximumLength">Maximum distance to travel in units of the direction vector's length.</param>
      <param name="hit">Hit data for the raycast, if any.</param>
      <returns>Whether or not the ray hit the target.</returns>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.ConvexShapes.BoxShape.ComputeCenter">
      <summary>
            Computes the center of the shape.  This can be considered its 
            center of mass.
            </summary>
      <returns>Center of the shape.</returns>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.ConvexShapes.BoxShape.ComputeCenter(System.Single@)">
      <summary>
            Computes the center of the shape.  This can be considered its 
            center of mass.  This calculation is often associated with the 
            volume calculation, which is given by this method as well.
            </summary>
      <param name="volume">Volume of the shape.</param>
      <returns>Center of the shape.</returns>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.ConvexShapes.BoxShape.ComputeVolume">
      <summary>
            Computes the volume of the shape.
            </summary>
      <returns>Volume of the shape.</returns>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.ConvexShapes.BoxShape.GetMobileInstance">
      <summary>
            Retrieves an instance of an EntityCollidable that uses this EntityShape.  Mainly used by compound bodies.
            </summary>
      <returns>EntityCollidable that uses this shape.</returns>
    </member>
    <member name="P:BEPUphysics.CollisionShapes.ConvexShapes.BoxShape.HalfWidth">
      <summary>
            Width of the box divided by two.
            </summary>
    </member>
    <member name="P:BEPUphysics.CollisionShapes.ConvexShapes.BoxShape.HalfHeight">
      <summary>
            Height of the box divided by two.
            </summary>
    </member>
    <member name="P:BEPUphysics.CollisionShapes.ConvexShapes.BoxShape.HalfLength">
      <summary>
            Length of the box divided by two.
            </summary>
    </member>
    <member name="P:BEPUphysics.CollisionShapes.ConvexShapes.BoxShape.Width">
      <summary>
            Width of the box.
            </summary>
    </member>
    <member name="P:BEPUphysics.CollisionShapes.ConvexShapes.BoxShape.Height">
      <summary>
            Height of the box.
            </summary>
    </member>
    <member name="P:BEPUphysics.CollisionShapes.ConvexShapes.BoxShape.Length">
      <summary>
            Length of the box.
            </summary>
    </member>
    <member name="T:BEPUphysics.Vehicle.WheelShape">
      <summary>
            Superclass for the shape of the tires of a vehicle.
            Responsible for figuring out where the wheel touches the ground and
            managing graphical properties.
            </summary>
    </member>
    <member name="F:BEPUphysics.Vehicle.WheelShape.detector">
      <summary>
            Collects collision pairs from the environment.
            </summary>
    </member>
    <member name="M:BEPUphysics.Vehicle.WheelShape.UpdateWorldTransform">
      <summary>
            Updates the wheel's world transform for graphics.
            Called automatically by the owning wheel at the end of each frame.
            If the engine is updating asynchronously, you can call this inside of a space read buffer lock
            and update the wheel transforms safely.
            </summary>
    </member>
    <member name="M:BEPUphysics.Vehicle.WheelShape.UpdateSpin(System.Single)">
      <summary>
            Updates the spin velocity and spin angle for the shape.
            </summary>
      <param name="dt">Simulation timestep.</param>
    </member>
    <member name="M:BEPUphysics.Vehicle.WheelShape.FindSupport(Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Vector3@,System.Single@,BEPUphysics.Entities.Entity@,BEPUphysics.Materials.Material@)">
      <summary>
            Finds a supporting entity, the contact location, and the contact normal.
            </summary>
      <param name="location">Contact point between the wheel and the support.</param>
      <param name="normal">Contact normal between the wheel and the support.</param>
      <param name="suspensionLength">Length of the suspension at the contact.</param>
      <param name="entity">Supporting object.</param>
      <param name="material">Material of the support.</param>
      <returns>Whether or not any support was found.</returns>
    </member>
    <member name="M:BEPUphysics.Vehicle.WheelShape.Initialize">
      <summary>
            Initializes the detector entity and any other necessary logic.
            </summary>
    </member>
    <member name="M:BEPUphysics.Vehicle.WheelShape.UpdateDetectorPosition">
      <summary>
            Updates the position of the detector before each step.
            </summary>
    </member>
    <member name="P:BEPUphysics.Vehicle.WheelShape.Radius">
      <summary>
            Gets or sets the graphical radius of the wheel.
            </summary>
    </member>
    <member name="P:BEPUphysics.Vehicle.WheelShape.AirborneWheelAcceleration">
      <summary>
            Gets or sets the rate at which the wheel's spinning velocity increases when accelerating and airborne.
            This is a purely graphical effect.
            </summary>
    </member>
    <member name="P:BEPUphysics.Vehicle.WheelShape.AirborneWheelDeceleration">
      <summary>
            Gets or sets the rate at which the wheel's spinning velocity decreases when the wheel is airborne and its motor is idle.
            This is a purely graphical effect.
            </summary>
    </member>
    <member name="P:BEPUphysics.Vehicle.WheelShape.BrakeFreezeWheelDeceleration">
      <summary>
            Gets or sets the rate at which the wheel's spinning velocity decreases when braking.
            This is a purely graphical effect.
            </summary>
    </member>
    <member name="P:BEPUphysics.Vehicle.WheelShape.CollisionRules">
      <summary>
            Gets or sets the collision rules used to filter wheel supports.
            </summary>
    </member>
    <member name="P:BEPUphysics.Vehicle.WheelShape.Detector">
      <summary>
            Gets the detector entity used by the wheelshape to collect collision pairs.
            </summary>
    </member>
    <member name="P:BEPUphysics.Vehicle.WheelShape.FreezeWheelsWhileBraking">
      <summary>
            Gets or sets whether or not to halt the wheel spin while the WheelBrake is active.
            </summary>
    </member>
    <member name="P:BEPUphysics.Vehicle.WheelShape.LocalGraphicTransform">
      <summary>
            Gets or sets the local graphic transform of the wheel shape.
            This transform is applied first when creating the shape's worldTransform.
            </summary>
    </member>
    <member name="P:BEPUphysics.Vehicle.WheelShape.SpinAngle">
      <summary>
            Gets or sets the current spin angle of this wheel.
            This changes each frame based on the relative velocity between the
            support and the wheel.
            </summary>
    </member>
    <member name="P:BEPUphysics.Vehicle.WheelShape.SpinVelocity">
      <summary>
            Gets or sets the graphical spin velocity of the wheel based on the relative velocity 
            between the support and the wheel.  Whenever the wheel is in contact with
            the ground, the spin velocity will be each frame.
            </summary>
    </member>
    <member name="P:BEPUphysics.Vehicle.WheelShape.SteeringAngle">
      <summary>
            Gets or sets the current steering angle of this wheel.
            </summary>
    </member>
    <member name="P:BEPUphysics.Vehicle.WheelShape.Wheel">
      <summary>
            Gets the wheel object associated with this shape.
            </summary>
    </member>
    <member name="P:BEPUphysics.Vehicle.WheelShape.WorldTransform">
      <summary>
            Gets the world matrix of the wheel for positioning a graphic.
            </summary>
    </member>
    <member name="T:BEPUphysics.Vehicle.RaycastWheelShape">
      <summary>
            Uses a raycast as the shape of a wheel.
            </summary>
    </member>
    <member name="M:BEPUphysics.Vehicle.RaycastWheelShape.#ctor(System.Single,Microsoft.Xna.Framework.Matrix)">
      <summary>
            Creates a new raycast based wheel shape.
            </summary>
      <param name="graphicalRadius">Graphical radius of the wheel.
            This is not used for simulation.  It is only used in
            determining aesthetic properties of a vehicle wheel,
            like position and orientation.</param>
      <param name="localGraphicTransform">Local graphic transform of the wheel shape.
            This transform is applied first when creating the shape's worldTransform.</param>
    </member>
    <member name="M:BEPUphysics.Vehicle.RaycastWheelShape.UpdateWorldTransform">
      <summary>
            Updates the wheel's world transform for graphics.
            Called automatically by the owning wheel at the end of each frame.
            If the engine is updating asynchronously, you can call this inside of a space read buffer lock
            and update the wheel transforms safely.
            </summary>
    </member>
    <member name="M:BEPUphysics.Vehicle.RaycastWheelShape.FindSupport(Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Vector3@,System.Single@,BEPUphysics.Entities.Entity@,BEPUphysics.Materials.Material@)">
      <summary>
            Finds a supporting entity, the contact location, and the contact normal.
            </summary>
      <param name="location">Contact point between the wheel and the support.</param>
      <param name="normal">Contact normal between the wheel and the support.</param>
      <param name="suspensionLength">Length of the suspension at the contact.</param>
      <param name="entity">Supporting object.</param>
      <param name="material">Material of the wheel.</param>
      <returns>Whether or not any support was found.</returns>
    </member>
    <member name="M:BEPUphysics.Vehicle.RaycastWheelShape.Initialize">
      <summary>
            Initializes the detector entity and any other necessary logic.
            </summary>
    </member>
    <member name="M:BEPUphysics.Vehicle.RaycastWheelShape.UpdateDetectorPosition">
      <summary>
            Updates the position of the detector before each step.
            </summary>
    </member>
    <member name="P:BEPUphysics.Vehicle.RaycastWheelShape.Radius">
      <summary>
            Gets or sets the graphical radius of the wheel.
            This is not used for simulation.  It is only used in
            determining aesthetic properties of a vehicle wheel,
            like position and orientation.
            </summary>
    </member>
    <member name="T:BEPUphysics.Paths.PathFollowing.EntityMover">
      <summary>
            Pushes an entity around according to goal positions and orientations.
            </summary>
    </member>
    <member name="M:BEPUphysics.Paths.PathFollowing.EntityMover.#ctor(BEPUphysics.Entities.Entity)">
      <summary>
            Constructs a new EntityMover.
            </summary>
      <param name="e">Entity to move.</param>
    </member>
    <member name="M:BEPUphysics.Paths.PathFollowing.EntityMover.#ctor(BEPUphysics.Entities.Entity,BEPUphysics.Constraints.SingleEntity.SingleEntityLinearMotor)">
      <summary>
            Constructs a new EntityMover.
            </summary>
      <param name="e">Entity to move.</param>
      <param name="linearMotor">Motor to use for linear motion if the entity is dynamic.</param>
    </member>
    <member name="M:BEPUphysics.Paths.PathFollowing.EntityMover.GetLinearVelocity(Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,System.Single)">
      <summary>
            Gets the angular velocity necessary to change an entity's orientation from
            the starting quaternion to the ending quaternion over time dt.
            </summary>
      <param name="start">Initial position.</param>
      <param name="end">Final position.</param>
      <param name="dt">Time over which the angular velocity is to be applied.</param>
      <returns>Angular velocity to reach the goal in time.</returns>
    </member>
    <member name="M:BEPUphysics.Paths.PathFollowing.EntityMover.OnAdditionToSpace(BEPUphysics.ISpace)">
      <summary>
            Adds the motors to the space.  Called automatically.
            </summary>
    </member>
    <member name="M:BEPUphysics.Paths.PathFollowing.EntityMover.OnRemovalFromSpace(BEPUphysics.ISpace)">
      <summary>
            Removes the motors from the space.  Called automatically.
            </summary>
    </member>
    <member name="P:BEPUphysics.Paths.PathFollowing.EntityMover.Entity">
      <summary>
            Gets or sets the entity being pushed by the entity mover.
            </summary>
    </member>
    <member name="P:BEPUphysics.Paths.PathFollowing.EntityMover.LinearMotor">
      <summary>
            Gets the linear motor used by the entity mover.
            When the affected entity is dynamic, it is pushed by motors.
            This ensures that its interactions and collisions with
            other entities remain stable.
            </summary>
    </member>
    <member name="P:BEPUphysics.Paths.PathFollowing.EntityMover.LocalOffset">
      <summary>
            Gets or sets the point in the entity's local space that will be moved towards the target position.
            </summary>
    </member>
    <member name="P:BEPUphysics.Paths.PathFollowing.EntityMover.Offset">
      <summary>
            Gets or sets the point attached to the entity in world space that will be moved towards the target position.
            </summary>
    </member>
    <member name="P:BEPUphysics.Paths.PathFollowing.EntityMover.TargetPosition">
      <summary>
            Gets or sets the target location of the entity mover.
            </summary>
    </member>
    <member name="T:BEPUphysics.Paths.LinearInterpolationCurve3D">
      <summary>
            Defines a 3D curve using linear interpolation.
            </summary>
    </member>
    <member name="M:BEPUphysics.Paths.LinearInterpolationCurve3D.Evaluate(System.Int32,System.Single,Microsoft.Xna.Framework.Vector3@)">
      <summary>
            Evaluates the curve section starting at the control point index using
            the weight value.
            </summary>
      <param name="controlPointIndex">Index of the starting control point of the subinterval.</param>
      <param name="weight">Location to evaluate on the subinterval from 0 to 1.</param>
      <param name="value">Value at the given location.</param>
    </member>
    <member name="M:BEPUphysics.Paths.LinearInterpolationCurve3D.GetCurveIndexBoundsInformation(System.Int32@,System.Int32@)">
      <summary>
            Gets the curve's bounding index information.
            </summary>
      <param name="minIndex">Index of the minimum control point in the active curve segment.</param>
      <param name="maxIndex">Index of the maximum control point in the active curve segment.</param>
    </member>
    <member name="M:BEPUphysics.Paths.LinearInterpolationCurve3D.ControlPointAdded(BEPUphysics.Paths.CurveControlPoint{Microsoft.Xna.Framework.Vector3},System.Int32)">
      <summary>
            Called when a control point is added.
            </summary>
      <param name="curveControlPoint">New control point.</param>
      <param name="index">Index of the control point.</param>
    </member>
    <member name="M:BEPUphysics.Paths.LinearInterpolationCurve3D.ControlPointRemoved(BEPUphysics.Paths.CurveControlPoint{Microsoft.Xna.Framework.Vector3},System.Int32)">
      <summary>
            Called when a control point is removed.
            </summary>
      <param name="curveControlPoint">Removed control point.</param>
      <param name="oldIndex">Index of the control point before it was removed.</param>
    </member>
    <member name="M:BEPUphysics.Paths.LinearInterpolationCurve3D.ControlPointTimeChanged(BEPUphysics.Paths.CurveControlPoint{Microsoft.Xna.Framework.Vector3},System.Int32,System.Int32)">
      <summary>
            Called when a control point belonging to the curve has its time changed.
            </summary>
      <param name="curveControlPoint">Changed control point.</param>
      <param name="oldIndex">Old index of the control point.</param>
      <param name="newIndex">New index of the control point.</param>
    </member>
    <member name="M:BEPUphysics.Paths.LinearInterpolationCurve3D.ControlPointValueChanged(BEPUphysics.Paths.CurveControlPoint{Microsoft.Xna.Framework.Vector3})">
      <summary>
            Called when a control point belonging to the curve has its value changed.
            </summary>
      <param name="curveControlPoint">Changed control point.</param>
    </member>
    <member name="T:BEPUphysics.UpdateableSystems.ForceFields.BoundingBoxForceFieldShape">
      <summary>
            Defines the area in which a force field works using an entity's shape.
            </summary>
    </member>
    <member name="M:BEPUphysics.UpdateableSystems.ForceFields.BoundingBoxForceFieldShape.#ctor(Microsoft.Xna.Framework.BoundingBox)">
      <summary>
            Constructs a new force field shape using a bounding box.
            </summary>
      <param name="box">Bounding box to use.</param>
    </member>
    <member name="M:BEPUphysics.UpdateableSystems.ForceFields.BoundingBoxForceFieldShape.GetPossiblyAffectedEntities">
      <summary>
            Determines the possibly involved entities.
            </summary>
      <returns>Possibly involved entities.</returns>
    </member>
    <member name="M:BEPUphysics.UpdateableSystems.ForceFields.BoundingBoxForceFieldShape.IsEntityAffected(BEPUphysics.Entities.Entity)">
      <summary>
            Determines if the entity is affected by the force field.
            </summary>
      <param name="testEntity">Entity to test.</param>
      <returns>Whether the entity is affected.</returns>
    </member>
    <member name="P:BEPUphysics.UpdateableSystems.ForceFields.BoundingBoxForceFieldShape.BoundingBox">
      <summary>
            Gets or sets the bounding box used by the shape.
            </summary>
    </member>
    <member name="T:BEPUphysics.CollisionTests.ContactReducer">
      <summary>
             Helper class that reduces contact manifolds to reasonable numbers of contacts.
            </summary>
    </member>
    <member name="M:BEPUphysics.CollisionTests.ContactReducer.ReduceContacts(BEPUphysics.DataStructures.RawList{BEPUphysics.CollisionTests.Contact},BEPUphysics.DataStructures.RawValueList{BEPUphysics.CollisionTests.ContactData},BEPUphysics.DataStructures.RawList{System.Int32},BEPUphysics.DataStructures.RawValueList{BEPUphysics.CollisionTests.ContactData})">
      <summary>
             Reduces the contact manifold to a good subset.
            </summary>
      <param name="contacts">Contacts to reduce.</param>
      <param name="contactCandidates">Contact candidates to include in the reduction process.</param>
      <param name="contactsToRemove">Contacts that need to removed to reach the reduced state.</param>
      <param name="toAdd">Contact candidates that should be added to reach the reduced state.</param>
      <exception cref="T:System.InvalidOperationException">Thrown when the set being reduced is empty.</exception>
    </member>
    <member name="M:BEPUphysics.CollisionTests.ContactReducer.ReduceContacts(BEPUphysics.DataStructures.RawList{BEPUphysics.CollisionTests.Contact},BEPUphysics.CollisionTests.ContactData@,BEPUphysics.DataStructures.RawList{System.Int32},System.Boolean@)">
      <summary>
             Reduces a 4-contact manifold and contact candidate to 4 total contacts.
            </summary>
      <param name="contacts">Contacts to reduce.</param>
      <param name="contactCandidate">Contact candidate to include in the reduction process.</param>
      <param name="toRemove">Contacts that need to be removed to reduce the manifold.</param>
      <param name="addCandidate">Whether or not to add the contact candidate to reach the reduced manifold.</param>
      <exception cref="T:System.ArgumentException">Thrown when the contact manifold being reduced doesn't have 4 contacts.</exception>
    </member>
    <member name="T:BEPUphysics.CollisionTests.ContactData">
      <summary>
             Contact data created by collision detection.
            </summary>
    </member>
    <member name="F:BEPUphysics.CollisionTests.ContactData.PenetrationDepth">
      <summary>
            Amount of penetration between the two objects.
            </summary>
    </member>
    <member name="F:BEPUphysics.CollisionTests.ContactData.Id">
      <summary>
            Feature-based id used to match contacts from the previous frame to their current versions.
            </summary>
    </member>
    <member name="F:BEPUphysics.CollisionTests.ContactData.Normal">
      <summary>
            Normal direction of the surface at the contact point.
            </summary>
    </member>
    <member name="F:BEPUphysics.CollisionTests.ContactData.Position">
      <summary>
            Position of the contact point.
            </summary>
    </member>
    <member name="M:BEPUphysics.CollisionTests.ContactData.ToString">
      <summary>
            Returns the fully qualified type name of this instance.
            </summary>
      <returns>
            A <see cref="T:System.String" /> containing a fully qualified type name.
            </returns>
      <filterpriority>2</filterpriority>
    </member>
    <member name="T:BEPUphysics.RayCastResult">
      <summary>
             Contains information about a ray cast hit.
            </summary>
    </member>
    <member name="F:BEPUphysics.RayCastResult.HitData">
      <summary>
             Position, normal, and t paramater of the hit.
            </summary>
    </member>
    <member name="F:BEPUphysics.RayCastResult.HitObject">
      <summary>
            Object hit by the ray.
            </summary>
    </member>
    <member name="M:BEPUphysics.RayCastResult.#ctor(BEPUphysics.RayHit,BEPUphysics.BroadPhaseSystems.BroadPhaseEntry)">
      <summary>
             Constructs a new ray cast result.
            </summary>
      <param name="hitData">Ray cast hit data.</param>
      <param name="hitObject">Object hit by the ray.</param>
    </member>
    <member name="T:BEPUphysics.EntityStateManagement.MotionState">
      <summary>
             State describing the position, orientation, and velocity of an entity.
            </summary>
    </member>
    <member name="F:BEPUphysics.EntityStateManagement.MotionState.Position">
      <summary>
             Position of an entity.
            </summary>
    </member>
    <member name="F:BEPUphysics.EntityStateManagement.MotionState.Orientation">
      <summary>
             Orientation of an entity.
            </summary>
    </member>
    <member name="F:BEPUphysics.EntityStateManagement.MotionState.LinearVelocity">
      <summary>
             Linear velocity of an entity.
            </summary>
    </member>
    <member name="F:BEPUphysics.EntityStateManagement.MotionState.AngularVelocity">
      <summary>
             Angular velocity of an entity.
            </summary>
    </member>
    <member name="P:BEPUphysics.EntityStateManagement.MotionState.OrientationMatrix">
      <summary>
             Orientation matrix of an entity.
            </summary>
    </member>
    <member name="P:BEPUphysics.EntityStateManagement.MotionState.WorldTransform">
      <summary>
             World transform of an entity.
            </summary>
    </member>
    <member name="T:BEPUphysics.NarrowPhaseSystems.Factories.CompoundTerrainPairFactory">
      <summary>
             Manufactures compound-terrain pairs.
            </summary>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.Factories.CompoundTerrainPairFactory.GetNarrowPhasePair(BEPUphysics.BroadPhaseSystems.BroadPhaseOverlap)">
      <summary>
             Manufactures and returns a narrow phase pair for the given overlap.
            </summary>
      <param name="overlap">Overlap used to create a pair.</param>
      <returns>Narrow phase pair.</returns>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.Factories.CompoundTerrainPairFactory.GiveBack(BEPUphysics.NarrowPhaseSystems.Pairs.INarrowPhasePair)">
      <summary>
            Returns a pair to the factory for re-use.
            </summary>
      <param name="pair">Pair to return.</param>
    </member>
    <member name="T:BEPUphysics.Entities.Prefabs.Capsule">
      <summary>
            Pill-shaped object that can collide and move.  After making an entity, add it to a Space so that the engine can manage it.
            </summary>
    </member>
    <member name="M:BEPUphysics.Entities.Prefabs.Capsule.GetCapsuleInformation(Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Quaternion@,System.Single@)">
      <summary>
             Computes an orientation and length from a line segment.
            </summary>
      <param name="start">Starting point of the line segment.</param>
      <param name="end">Endpoint of the line segment.</param>
      <param name="orientation">Orientation of a line that fits the line segment.</param>
      <param name="length">Length of the line segment.</param>
    </member>
    <member name="M:BEPUphysics.Entities.Prefabs.Capsule.#ctor(Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,System.Single)">
      <summary>
             Constructs a new kinematic capsule.
            </summary>
      <param name="start">Line segment start point.</param>
      <param name="end">Line segment end point.</param>
      <param name="radius">Radius of the capsule to expand the line segment by.</param>
    </member>
    <member name="M:BEPUphysics.Entities.Prefabs.Capsule.#ctor(Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,System.Single,System.Single)">
      <summary>
             Constructs a new dynamic capsule.
            </summary>
      <param name="start">Line segment start point.</param>
      <param name="end">Line segment end point.</param>
      <param name="radius">Radius of the capsule to expand the line segment by.</param>
      <param name="mass">Mass of the entity.</param>
    </member>
    <member name="M:BEPUphysics.Entities.Prefabs.Capsule.#ctor(Microsoft.Xna.Framework.Vector3,System.Single,System.Single,System.Single)">
      <summary>
            Constructs a physically simulated capsule.
            </summary>
      <param name="position">Position of the capsule.</param>
      <param name="length">Length of the capsule.</param>
      <param name="radius">Radius of the capsule.</param>
      <param name="mass">Mass of the object.</param>
    </member>
    <member name="M:BEPUphysics.Entities.Prefabs.Capsule.#ctor(Microsoft.Xna.Framework.Vector3,System.Single,System.Single)">
      <summary>
            Constructs a nondynamic capsule.
            </summary>
      <param name="position">Position of the capsule.</param>
      <param name="length">Length of the capsule.</param>
      <param name="radius">Radius of the capsule.</param>
    </member>
    <member name="M:BEPUphysics.Entities.Prefabs.Capsule.#ctor(BEPUphysics.EntityStateManagement.MotionState,System.Single,System.Single,System.Single)">
      <summary>
            Constructs a dynamic capsule.
            </summary>
      <param name="motionState">Motion state specifying the entity's initial state.</param>
      <param name="length">Length of the capsule.</param>
      <param name="radius">Radius of the capsule.</param>
      <param name="mass">Mass of the object.</param>
    </member>
    <member name="M:BEPUphysics.Entities.Prefabs.Capsule.#ctor(BEPUphysics.EntityStateManagement.MotionState,System.Single,System.Single)">
      <summary>
            Constructs a nondynamic capsule.
            </summary>
      <param name="motionState">Motion state specifying the entity's initial state.</param>
      <param name="length">Length of the capsule.</param>
      <param name="radius">Radius of the capsule.</param>
    </member>
    <member name="P:BEPUphysics.Entities.Prefabs.Capsule.Length">
      <summary>
            Gets or sets the length of the capsule.
            </summary>
    </member>
    <member name="P:BEPUphysics.Entities.Prefabs.Capsule.Radius">
      <summary>
            Gets or sets the radius of the capsule.
            </summary>
    </member>
    <member name="T:BEPUphysics.Constraints.TwoEntity.Motors.MotorMode">
      <summary>
            Defines the behavior style of a motor.
            </summary>
    </member>
    <member name="F:BEPUphysics.Constraints.TwoEntity.Motors.MotorMode.VelocityMotor">
      <summary>
            Velocity motors only work to try to reach some relative velocity.
            They have no position goal.
            
            When this type is selected, the motor settings' velocityMotor data will be used.
            </summary>
    </member>
    <member name="F:BEPUphysics.Constraints.TwoEntity.Motors.MotorMode.Servomechanism">
      <summary>
            Servomechanisms change their velocity in order to reach some position goal.
            
            When this type is selected, the motor settings' servo data will be used.
            </summary>
    </member>
    <member name="T:BEPUphysics.Constraints.TwoEntity.Motors.MotorSettings">
      <summary>
            Contains genereal settings for motors.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.Motors.MotorSettings.MaximumForce">
      <summary>
            Gets and sets the maximum impulse that the constraint will attempt to apply when satisfying its requirements.
            This field can be used to simulate friction in a constraint.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.Motors.MotorSettings.Mode">
      <summary>
            Gets or sets what kind of motor this is.
            
            If velocityMotor is chosen, the motor will try to achieve some velocity using the VelocityMotorSettings.
            If servomechanism is chosen, the motor will try to reach some position using the ServoSettings.
            </summary>
    </member>
    <member name="T:BEPUphysics.Constraints.TwoEntity.Motors.MotorSettings1D">
      <summary>
            Contains settings for motors which act on one degree of freedom.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.Motors.MotorSettings1D.Servo">
      <summary>
            Gets the settings that govern the behavior of this motor if it is a servomechanism.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.Motors.MotorSettings1D.VelocityMotor">
      <summary>
            Gets the settings that govern the behavior of this motor if it is a velocity motor.
            </summary>
    </member>
    <member name="T:BEPUphysics.Constraints.TwoEntity.Motors.MotorSettings3D">
      <summary>
            Contains settings for motors which act on three degrees of freedom.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.Motors.MotorSettings3D.Servo">
      <summary>
            Gets the settings that govern the behavior of this motor if it is a servomechanism.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.Motors.MotorSettings3D.VelocityMotor">
      <summary>
            Gets the settings that govern the behavior of this motor if it is a velocity motor.
            </summary>
    </member>
    <member name="T:BEPUphysics.Constraints.TwoEntity.Motors.MotorSettingsOrientation">
      <summary>
            Contains settings for motors which act on two entities' relative orientation.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.Motors.MotorSettingsOrientation.Servo">
      <summary>
            Gets the settings that govern the behavior of this motor if it is a servomechanism.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.Motors.MotorSettingsOrientation.VelocityMotor">
      <summary>
            Gets the settings that govern the behavior of this motor if it is a velocity motor.
            </summary>
    </member>
    <member name="T:BEPUphysics.Constraints.TwoEntity.Motors.ServoSettings">
      <summary>
            Defines the behavior of a servo.
            Used when the MotorSettings' motorType is set to servomechanism.
            </summary>
    </member>
    <member name="F:BEPUphysics.Constraints.TwoEntity.Motors.ServoSettings.baseCorrectiveSpeed">
      <summary>
            Speed at which the servo will try to achieve its goal.
            </summary>
    </member>
    <member name="F:BEPUphysics.Constraints.TwoEntity.Motors.ServoSettings.maxCorrectiveVelocity">
      <summary>
            Maximum extra velocity that the constraint will apply in an effort to correct constraint error.
            </summary>
    </member>
    <member name="F:BEPUphysics.Constraints.TwoEntity.Motors.ServoSettings.maxCorrectiveVelocitySquared">
      <summary>
            Squared maximum extra velocity that the constraint will apply in an effort to correct constraint error.
            </summary>
    </member>
    <member name="F:BEPUphysics.Constraints.TwoEntity.Motors.ServoSettings.springSettings">
      <summary>
            Spring settings define how a constraint responds to velocity and position error.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.Motors.ServoSettings.BaseCorrectiveSpeed">
      <summary>
            Gets and sets the speed at which the servo will try to achieve its goal.
            This is inactive if the constraint is not in servo mode.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.Motors.ServoSettings.MaxCorrectiveVelocity">
      <summary>
            Gets or sets the maximum extra velocity that the constraint will apply in an effort to correct any constraint error.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.Motors.ServoSettings.SpringSettings">
      <summary>
            Gets the spring settings used by the constraint.
            Spring settings define how a constraint responds to velocity and position error.
            </summary>
    </member>
    <member name="T:BEPUphysics.Constraints.TwoEntity.Motors.ServoSettings1D">
      <summary>
            Defines the behavior of a servo that works on one degree of freedom.
            Used when the MotorSettings' motorType is set to servomechanism.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.Motors.ServoSettings1D.Goal">
      <summary>
            Gets or sets the goal position of the servo.
            </summary>
    </member>
    <member name="T:BEPUphysics.Constraints.TwoEntity.Motors.ServoSettings3D">
      <summary>
            Defines the behavior of a servo that works on three degrees of freedom.
            Used when the MotorSettings' motorType is set to servomechanism.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.Motors.ServoSettings3D.Goal">
      <summary>
            Gets or sets the goal position of the servo.
            </summary>
    </member>
    <member name="T:BEPUphysics.Constraints.TwoEntity.Motors.ServoSettingsOrientation">
      <summary>
            Defines the behavior of a servo that works on the relative orientation of two entities.
            Used when the MotorSettings' motorType is set to servomechanism.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.Motors.ServoSettingsOrientation.Goal">
      <summary>
            Gets or sets the goal orientation of the servo.
            </summary>
    </member>
    <member name="T:BEPUphysics.Constraints.TwoEntity.Motors.VelocityMotorSettings">
      <summary>
            Defines the behavior of a velocity motor.
            Used when the MotorSettings' motorType is set to velocityMotor.
            </summary>
    </member>
    <member name="F:BEPUphysics.Constraints.TwoEntity.Motors.VelocityMotorSettings.softness">
      <summary>
            Softness of this constraint.
            Higher values of softness allow the constraint to be violated more.
            Must be greater than zero.
            Sometimes, if a joint system is unstable, increasing the softness of the involved constraints will make it settle down.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.Motors.VelocityMotorSettings.Softness">
      <summary>
            Gets and sets the softness of this constraint.
            Higher values of softness allow the constraint to be violated more.
            Must be greater than zero.
            Sometimes, if a joint system is unstable, increasing the softness of the involved constraints will make it settle down.
            For motors, softness can be used to implement damping.  For a damping constant k, the appropriate softness is 1/k.
            </summary>
    </member>
    <member name="T:BEPUphysics.Constraints.TwoEntity.Motors.VelocityMotorSettings1D">
      <summary>
            Defines the behavior of a velocity motor that works on one degree of freedom.
            Used when the MotorSettings' motorType is set to velocityMotor.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.Motors.VelocityMotorSettings1D.GoalVelocity">
      <summary>
            Gets or sets the goal velocity of the motor.
            </summary>
    </member>
    <member name="T:BEPUphysics.Constraints.TwoEntity.Motors.VelocityMotorSettings3D">
      <summary>
            Defines the behavior of a velocity motor that works on three degrees of freedom.
            Used when the MotorSettings' motorType is set to velocityMotor.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.Motors.VelocityMotorSettings3D.GoalVelocity">
      <summary>
            Gets or sets the goal position of the servo.
            </summary>
    </member>
    <member name="T:BEPUphysics.Constraints.SolverGroups.WeldJoint">
      <summary>
            Restricts the linear and angular motion between two entities.
            </summary>
    </member>
    <member name="M:BEPUphysics.Constraints.SolverGroups.WeldJoint.#ctor">
      <summary>
            Constructs a new constraint which restricts the linear and angular motion between two entities.
            This constructs the internal constraints, but does not configure them.  Before using a constraint constructed in this manner,
            ensure that its active constituent constraints are properly configured.  The entire group as well as all internal constraints are initially inactive (IsActive = false).
            </summary>
    </member>
    <member name="M:BEPUphysics.Constraints.SolverGroups.WeldJoint.#ctor(BEPUphysics.Entities.Entity,BEPUphysics.Entities.Entity)">
      <summary>
            Constructs a new constraint which restricts the linear and angular motion between two entities.
            </summary>
      <param name="connectionA">First entity of the constraint pair.</param>
      <param name="connectionB">Second entity of the constraint pair.</param>
    </member>
    <member name="P:BEPUphysics.Constraints.SolverGroups.WeldJoint.BallSocketJoint">
      <summary>
            Gets the ball socket joint that restricts linear degrees of freedom.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.SolverGroups.WeldJoint.NoRotationJoint">
      <summary>
            Gets the no rotation joint that prevents angular motion.
            </summary>
    </member>
    <member name="T:BEPUphysics.Constraints.SolverGroups.CustomizableSolverGroup">
      <summary>
            Constraint made from other constraints.
            Putting constraints into a solver group can help with organization and, in some cases, performance.
            
            If you have multiple constraints between the same two entities, putting the constraints into a 
            CustomizableSolverGroup can lower lock contention.
            
            Be careful about overloading a single solvergroup; it should be kept relatively small to ensure that the multithreading loads stay balanced.
            </summary>
    </member>
    <member name="M:BEPUphysics.Constraints.SolverGroups.CustomizableSolverGroup.Add(BEPUphysics.Constraints.EntitySolverUpdateable)">
      <summary>
            Adds a new solver updateable to the solver group.
            </summary>
      <param name="solverUpdateable">Solver updateable to add.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.SolverGroups.CustomizableSolverGroup.Remove(BEPUphysics.Constraints.EntitySolverUpdateable)">
      <summary>
            Removes a solver updateable from the solver group.
            </summary>
      <param name="solverUpdateable">Solver updateable to remove.</param>
    </member>
    <member name="T:BEPUphysics.Constraints.Collision.ContactFrictionConstraint">
      <summary>
            Computes the friction force for a contact when central friction cannot be used.
            </summary>
    </member>
    <member name="M:BEPUphysics.Constraints.Collision.ContactFrictionConstraint.#ctor">
      <summary>
             Constructs a new friction constraint.
            </summary>
    </member>
    <member name="M:BEPUphysics.Constraints.Collision.ContactFrictionConstraint.Setup(BEPUphysics.Constraints.Collision.ContactManifoldConstraint,BEPUphysics.Constraints.Collision.ContactPenetrationConstraint)">
      <summary>
             Configures the friction constraint for a new contact.
            </summary>
      <param name="contactManifoldConstraint">Manifold to which the constraint belongs.</param>
      <param name="penetrationConstraint">Penetration constraint associated with this friction constraint.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.Collision.ContactFrictionConstraint.CleanUp">
      <summary>
             Cleans upt he friction constraint.
            </summary>
    </member>
    <member name="M:BEPUphysics.Constraints.Collision.ContactFrictionConstraint.SolveIteration">
      <summary>
            Computes one iteration of the constraint to meet the solver updateable's goal.
            </summary>
      <returns>The rough applied impulse magnitude.</returns>
    </member>
    <member name="M:BEPUphysics.Constraints.Collision.ContactFrictionConstraint.Update(System.Single)">
      <summary>
            Initializes the constraint for this frame.
            </summary>
      <param name="dt">Time since the last frame.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.Collision.ContactFrictionConstraint.ExclusiveUpdate">
      <summary>
            Performs any pre-solve iteration work that needs exclusive
            access to the members of the solver updateable.
            Usually, this is used for applying warmstarting impulses.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.Collision.ContactFrictionConstraint.ContactManifoldConstraint">
      <summary>
             Gets the manifold constraint associated with this friction constraint.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.Collision.ContactFrictionConstraint.PenetrationConstraint">
      <summary>
             Gets the penetration constraint associated with this friction constraint.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.Collision.ContactFrictionConstraint.FrictionDirection">
      <summary>
            Gets the direction in which the friction force acts.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.Collision.ContactFrictionConstraint.TotalForce">
      <summary>
            Gets the total force applied by this friction constraint.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.Collision.ContactFrictionConstraint.RelativeVelocity">
      <summary>
             Gets the relative velocity of the constraint.  This is the velocity along the tangent movement direction.
            </summary>
    </member>
    <member name="T:BEPUphysics.CollisionShapes.ConvexShapes.ConvexShapeEntry">
      <summary>
             Convex shape entry to a WrappedShape.
            </summary>
    </member>
    <member name="F:BEPUphysics.CollisionShapes.ConvexShapes.ConvexShapeEntry.CollisionShape">
      <summary>
            Convex shape of the entry.
            </summary>
    </member>
    <member name="F:BEPUphysics.CollisionShapes.ConvexShapes.ConvexShapeEntry.Transform">
      <summary>
            Local transform of the entry.
            </summary>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.ConvexShapes.ConvexShapeEntry.#ctor(Microsoft.Xna.Framework.Vector3,BEPUphysics.CollisionShapes.ConvexShapes.ConvexShape)">
      <summary>
            Constructs a convex shape entry.
            </summary>
      <param name="position">Local position of the entry.</param>
      <param name="shape">Shape of the entry.</param>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.ConvexShapes.ConvexShapeEntry.#ctor(Microsoft.Xna.Framework.Quaternion,BEPUphysics.CollisionShapes.ConvexShapes.ConvexShape)">
      <summary>
            Constructs a convex shape entry.
            </summary>
      <param name="orientation">Local orientation of the entry.</param>
      <param name="shape">Shape of the entry.</param>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.ConvexShapes.ConvexShapeEntry.#ctor(BEPUphysics.MathExtensions.RigidTransform,BEPUphysics.CollisionShapes.ConvexShapes.ConvexShape)">
      <summary>
            Constructs a convex shape entry.
            </summary>
      <param name="transform">Local transform of the entry.</param>
      <param name="shape">Shape of the entry.</param>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.ConvexShapes.ConvexShapeEntry.#ctor(BEPUphysics.CollisionShapes.ConvexShapes.ConvexShape)">
      <summary>
             Constructs a convex shape entry with identity transformation.
            </summary>
      <param name="shape">Shape of the entry.</param>
    </member>
    <member name="T:BEPUphysics.CollisionShapes.ConvexShapes.WrappedShape">
      <summary>
             Shape that wraps other convex shapes in a convex hull.
             One way to think of it is to collect a bunch of items and wrap shrinkwrap around them.
             That surface is the shape of the WrappedShape.
            </summary>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.ConvexShapes.WrappedShape.#ctor(BEPUphysics.CollisionShapes.ConvexShapes.ConvexShapeEntry,BEPUphysics.CollisionShapes.ConvexShapes.ConvexShapeEntry)">
      <summary>
             Constructs a wrapped shape.
             A constructor is also available which takes a list of objects rather than just a pair.
             The shape will be recentered.  If the center is needed, use the other constructor.
            </summary>
      <param name="firstShape">First shape in the wrapped shape.</param>
      <param name="secondShape">Second shape in the wrapped shape.</param>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.ConvexShapes.WrappedShape.#ctor(BEPUphysics.CollisionShapes.ConvexShapes.ConvexShapeEntry,BEPUphysics.CollisionShapes.ConvexShapes.ConvexShapeEntry,Microsoft.Xna.Framework.Vector3@)">
      <summary>
             Constructs a wrapped shape.
             A constructor is also available which takes a list of objects rather than just a pair.
             The shape will be recentered.
            </summary>
      <param name="firstShape">First shape in the wrapped shape.</param>
      <param name="secondShape">Second shape in the wrapped shape.</param>
      <param name="center">Center of the shape before recentering..</param>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.ConvexShapes.WrappedShape.#ctor(System.Collections.Generic.IList{BEPUphysics.CollisionShapes.ConvexShapes.ConvexShapeEntry})">
      <summary>
             Constructs a wrapped shape.
             The shape will be recentered; if the center is needed, use the other constructor.
            </summary>
      <param name="shapeEntries">Shape entries used to construct the shape.</param>
      <exception cref="T:System.Exception">Thrown when the shape list is empty.</exception>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.ConvexShapes.WrappedShape.#ctor(System.Collections.Generic.IList{BEPUphysics.CollisionShapes.ConvexShapes.ConvexShapeEntry},Microsoft.Xna.Framework.Vector3@)">
      <summary>
             Constructs a wrapped shape.
             The shape will be recentered.
            </summary>
      <param name="shapeEntries">Shape entries used to construct the shape.</param>
      <param name="center">Center of the shape before recentering.</param>
      <exception cref="T:System.Exception">Thrown when the shape list is empty.</exception>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.ConvexShapes.WrappedShape.GetBoundingBox(BEPUphysics.MathExtensions.RigidTransform@,Microsoft.Xna.Framework.BoundingBox@)">
      <summary>
            Gets the bounding box of the shape given a transform.
            </summary>
      <param name="shapeTransform">Transform to use.</param>
      <param name="boundingBox">Bounding box of the transformed shape.</param>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.ConvexShapes.WrappedShape.GetLocalExtremePointWithoutMargin(Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Vector3@)">
      <summary>
             Gets the extreme point of the shape in local space in a given direction.
            </summary>
      <param name="direction">Direction to find the extreme point in.</param>
      <param name="extremePoint">Extreme point on the shape.</param>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.ConvexShapes.WrappedShape.ComputeMaximumRadius">
      <summary>
            Computes the maximum radius of the shape.
            This is often larger than the actual maximum radius;
            it is simply an approximation that avoids underestimating.
            </summary>
      <returns>Maximum radius of the shape.</returns>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.ConvexShapes.WrappedShape.GetMobileInstance">
      <summary>
            Retrieves an instance of an EntityCollidable that uses this EntityShape.  Mainly used by compound bodies.
            </summary>
      <returns>EntityCollidable that uses this shape.</returns>
    </member>
    <member name="P:BEPUphysics.CollisionShapes.ConvexShapes.WrappedShape.Shapes">
      <summary>
             Gets the shapes in wrapped shape.
            </summary>
    </member>
    <member name="T:BEPUphysics.BroadPhaseSystems.Hierarchies.DynamicHierarchyQueryAccelerator">
      <summary>
             Interface to the DynamicHierarchy's volume query systems.
            </summary>
    </member>
    <member name="M:BEPUphysics.BroadPhaseSystems.Hierarchies.DynamicHierarchyQueryAccelerator.GetEntries(Microsoft.Xna.Framework.BoundingBox,System.Collections.Generic.IList{BEPUphysics.BroadPhaseSystems.BroadPhaseEntry})">
      <summary>
            Collects all entities with bounding boxes which intersect the given bounding box.
            </summary>
      <param name="box">Bounding box to test against the world.</param>
      <param name="entries">Entries of the space which intersect the bounding box.</param>
    </member>
    <member name="M:BEPUphysics.BroadPhaseSystems.Hierarchies.DynamicHierarchyQueryAccelerator.GetEntries(Microsoft.Xna.Framework.BoundingFrustum,System.Collections.Generic.IList{BEPUphysics.BroadPhaseSystems.BroadPhaseEntry})">
      <summary>
            Collects all entities with bounding boxes which intersect the given frustum.
            </summary>
      <param name="frustum">Frustum to test against the world.</param>
      <param name="entries">Entries of the space which intersect the frustum.</param>
    </member>
    <member name="M:BEPUphysics.BroadPhaseSystems.Hierarchies.DynamicHierarchyQueryAccelerator.GetEntries(Microsoft.Xna.Framework.BoundingSphere,System.Collections.Generic.IList{BEPUphysics.BroadPhaseSystems.BroadPhaseEntry})">
      <summary>
            Collects all entities with bounding boxes which intersect the given sphere.
            </summary>
      <param name="sphere">Sphere to test against the world.</param>
      <param name="entries">Entries of the space which intersect the sphere.</param>
    </member>
    <member name="M:BEPUphysics.BroadPhaseSystems.Hierarchies.DynamicHierarchyQueryAccelerator.RayCast(Microsoft.Xna.Framework.Ray,System.Single,System.Collections.Generic.IList{BEPUphysics.BroadPhaseSystems.BroadPhaseEntry})">
      <summary>
            Finds all intersections between the ray and the entities of the space.
            </summary>
      <param name="ray">Ray to test against the structure.</param>
      <param name="maximumLength">Maximum length of the ray in units of the ray's direction's length.</param>
      <param name="entries">Entries which have bounding boxes that overlap the ray.</param>
    </member>
    <member name="M:BEPUphysics.BroadPhaseSystems.Hierarchies.DynamicHierarchyQueryAccelerator.RayCast(Microsoft.Xna.Framework.Ray,System.Collections.Generic.IList{BEPUphysics.BroadPhaseSystems.BroadPhaseEntry})">
      <summary>
            Finds all intersections between the ray and the entities of the space.
            </summary>
      <param name="ray">Ray to test against the structure.</param>
      <param name="entries">Entries which have bounding boxes that overlap the ray.</param>
    </member>
    <member name="T:BEPUphysics.Vehicle.Wheel">
      <summary>
            Supports a Vehicle.
            </summary>
    </member>
    <member name="F:BEPUphysics.Vehicle.Wheel.isActiveInSolver">
      <summary>
            Used for solver early outing.
            </summary>
    </member>
    <member name="M:BEPUphysics.Vehicle.Wheel.#ctor(BEPUphysics.Vehicle.WheelShape)">
      <summary>
            Constructs a new wheel.
            </summary>
      <param name="shape">Shape of the wheel.</param>
    </member>
    <member name="M:BEPUphysics.Vehicle.Wheel.#ctor(BEPUphysics.Vehicle.WheelShape,BEPUphysics.Vehicle.WheelSuspension,BEPUphysics.Vehicle.WheelDrivingMotor,BEPUphysics.Vehicle.WheelBrake,BEPUphysics.Vehicle.WheelSlidingFriction)">
      <summary>
            Constructs a new wheel.
            </summary>
      <param name="shape">Shape of the wheel.</param>
      <param name="suspension">Springy support of the vehicle.</param>
      <param name="motor">Driving force for the wheel.</param>
      <param name="rollingFriction">Friction force resisting the forward and backward motion of the wheel.</param>
      <param name="slidingFriction">Friction force resisting the side to side motion of the wheel.</param>
    </member>
    <member name="M:BEPUphysics.Vehicle.Wheel.ApplyImpulse">
      <summary>
            Applies impulses and returns whether or not this wheel should be updated more.
            </summary>
      <returns>Whether not the wheel is done updating for the frame.</returns>
    </member>
    <member name="P:BEPUphysics.Vehicle.Wheel.Brake">
      <summary>
            Gets the brake for this wheel.
            </summary>
    </member>
    <member name="P:BEPUphysics.Vehicle.Wheel.DrivingMotor">
      <summary>
            Gets the motor that turns the wheel.
            </summary>
    </member>
    <member name="P:BEPUphysics.Vehicle.Wheel.HasSupport">
      <summary>
            Gets whether or not this wheel is sitting on anything.
            </summary>
    </member>
    <member name="P:BEPUphysics.Vehicle.Wheel.LocalForwardDirection">
      <summary>
            Gets or sets the local space forward direction of the wheel.
            </summary>
    </member>
    <member name="P:BEPUphysics.Vehicle.Wheel.Shape">
      <summary>
            Gets or sets the shape of this wheel used to find collisions with the ground.
            </summary>
    </member>
    <member name="P:BEPUphysics.Vehicle.Wheel.SlidingFriction">
      <summary>
            Gets the sliding friction settings for this wheel.
            </summary>
    </member>
    <member name="P:BEPUphysics.Vehicle.Wheel.SupportLocation">
      <summary>
            Gets the current support location of this wheel.
            </summary>
    </member>
    <member name="P:BEPUphysics.Vehicle.Wheel.SupportNormal">
      <summary>
            Gets the normal 
            </summary>
    </member>
    <member name="P:BEPUphysics.Vehicle.Wheel.SupportingEntity">
      <summary>
            Gets the entity currently supporting the wheel.
            </summary>
    </member>
    <member name="P:BEPUphysics.Vehicle.Wheel.Suspension">
      <summary>
            Gets the suspension supporting this wheel.
            </summary>
    </member>
    <member name="P:BEPUphysics.Vehicle.Wheel.Vehicle">
      <summary>
            Gets the vehicle this wheel is attached to.
            </summary>
    </member>
    <member name="P:BEPUphysics.Vehicle.Wheel.WorldForwardDirection">
      <summary>
            Gets or sets the world space forward direction of the wheel.
            </summary>
    </member>
    <member name="T:BEPUphysics.Threading.SimpleThreadManager">
      <summary>
            Manages the engine's threads.
            </summary>
      <remarks>
            Uses a simple round-robin threadpool.
            It is recommended that other thread managers are used instead of this one;
            it is kept for compatability and a fallback in case of problems.
            </remarks>
    </member>
    <member name="M:BEPUphysics.Threading.SimpleThreadManager.WorkerThread.Finalize">
      <summary>
            Shuts down any still living threads.
            </summary>
    </member>
    <member name="M:BEPUphysics.Threading.SimpleThreadManager.WorkerThread.ThreadExecutionLoop">
      <exception cref="T:System.ArithmeticException">Thrown when the thread encounters an invalid state; generally propagated float.NaN's.</exception>
    </member>
    <member name="F:BEPUphysics.Threading.SimpleThreadManager.currentTaskAllocationIndex">
      <summary>
            Index into the thread loop lists, incremented after each task allocation.
            </summary>
    </member>
    <member name="M:BEPUphysics.Threading.SimpleThreadManager.#ctor">
      <summary>
            Constructs the thread manager.
            </summary>
    </member>
    <member name="M:BEPUphysics.Threading.SimpleThreadManager.Finalize">
      <summary>
            Releases resources used by the object.
            </summary>
    </member>
    <member name="M:BEPUphysics.Threading.SimpleThreadManager.WaitForTaskCompletion">
      <summary>
            Blocks the current thread until all tasks have been completed.
            </summary>
    </member>
    <member name="M:BEPUphysics.Threading.SimpleThreadManager.AddThread">
      <summary>
            Adds a thread to the manager.
            </summary>
    </member>
    <member name="M:BEPUphysics.Threading.SimpleThreadManager.AddThread(System.Action{System.Object},System.Object)">
      <summary>
            Adds a thread to the manager.
            </summary>
      <param name="initialization">A function to run to perform any initialization on the new thread.</param>
      <param name="initializationInformation">Data to give the ParameterizedThreadStart for initialization.</param>
    </member>
    <member name="M:BEPUphysics.Threading.SimpleThreadManager.RemoveThread">
      <summary>
            Removes a thread and blocks until success.
            </summary>
    </member>
    <member name="M:BEPUphysics.Threading.SimpleThreadManager.EnqueueTask(System.Action{System.Object},System.Object)">
      <summary>
            Gives the thread manager a new task to run.
            </summary>
      <param name="task">Task to run.</param>
      <param name="taskInformation">Information to be used by the task.</param>
    </member>
    <member name="M:BEPUphysics.Threading.SimpleThreadManager.ForLoop(System.Int32,System.Int32,System.Action{System.Int32})">
      <summary>
            Loops from the starting index (inclusive) to the ending index (exclusive), calling the loopBody at each iteration.
            The forLoop function will not return until all iterations are complete.
            This is meant to be used in a 'fork-join' model; only a single thread should be running a forLoop
            at any time.
            </summary>
      <param name="startIndex">Inclusive starting index.</param>
      <param name="endIndex">Exclusive ending index.</param>
      <param name="loopBody">Function that handles an individual iteration of the loop.</param>
    </member>
    <member name="M:BEPUphysics.Threading.SimpleThreadManager.Dispose">
      <summary>
            Releases threads and resources used by the thread manager.
            </summary>
    </member>
    <member name="M:BEPUphysics.Threading.SimpleThreadManager.EnqueueTaskSequentially(System.Action{System.Object},System.Object)">
      <summary>
            Enqueues a task.
            This method also does not perform any locking; it should only be called when all worker threads of the thread pool are idle and all calls to this method are from the same thread.
            </summary>
      <param name="task">Task to enqueue.</param>
      <param name="taskInformation">Information for the task.</param>
    </member>
    <member name="M:BEPUphysics.Threading.SimpleThreadManager.ShutDown">
      <summary>
            Tells every thread in the thread manager to shut down and waits until completion.
            </summary>
    </member>
    <member name="P:BEPUphysics.Threading.SimpleThreadManager.LoopTasksPerThread">
      <summary>
            Gets or sets the number of tasks to create per thread when doing forLoops.
            </summary>
    </member>
    <member name="P:BEPUphysics.Threading.SimpleThreadManager.ThreadCount">
      <summary>
            Gets the number of threads currently handled by the manager.
            </summary>
    </member>
    <member name="T:BEPUphysics.Materials.MaterialPair">
      <summary>
             A pair of materials.
            </summary>
    </member>
    <member name="F:BEPUphysics.Materials.MaterialPair.MaterialA">
      <summary>
             First material in the pair.
            </summary>
    </member>
    <member name="F:BEPUphysics.Materials.MaterialPair.MaterialB">
      <summary>
             Second material in the pair.
            </summary>
    </member>
    <member name="M:BEPUphysics.Materials.MaterialPair.#ctor(BEPUphysics.Materials.Material,BEPUphysics.Materials.Material)">
      <summary>
             Constructs a new material pair.
            </summary>
      <param name="a">First material in the pair.</param>
      <param name="b">Second material in the pair.</param>
    </member>
    <member name="M:BEPUphysics.Materials.MaterialPair.GetHashCode">
      <summary>
            Returns the hash code for this instance.
            </summary>
      <returns>
            A 32-bit signed integer that is the hash code for this instance.
            </returns>
      <filterpriority>2</filterpriority>
    </member>
    <member name="T:BEPUphysics.PositionUpdating.PositionUpdateMode">
      <summary>
             Update modes for position updateables.
            </summary>
    </member>
    <member name="F:BEPUphysics.PositionUpdating.PositionUpdateMode.Discrete">
      <summary>
            Updates position discretely regardless of its collision pairs.
            </summary>
    </member>
    <member name="F:BEPUphysics.PositionUpdating.PositionUpdateMode.Passive">
      <summary>
            Updates position discretely in isolation; when a Continuous object collides with it,
            its position update will be bounded by the time of impact.
            </summary>
    </member>
    <member name="F:BEPUphysics.PositionUpdating.PositionUpdateMode.Continuous">
      <summary>
            Updates position continuously.  Continuous objects will integrate up to their earliest collision time.
            </summary>
    </member>
    <member name="T:BEPUphysics.CollisionTests.CollisionAlgorithms.MinkowskiToolbox">
      <summary>
             Helper class that supports other systems using minkowski space operations.
            </summary>
    </member>
    <member name="M:BEPUphysics.CollisionTests.CollisionAlgorithms.MinkowskiToolbox.GetLocalTransform(BEPUphysics.MathExtensions.RigidTransform@,BEPUphysics.MathExtensions.RigidTransform@,BEPUphysics.MathExtensions.RigidTransform@)">
      <summary>
             Gets the local transform of B in the space of A.
            </summary>
      <param name="transformA">First transform.</param>
      <param name="transformB">Second transform.</param>
      <param name="localTransformB">Transform of B in the local space of A.</param>
    </member>
    <member name="M:BEPUphysics.CollisionTests.CollisionAlgorithms.MinkowskiToolbox.GetLocalMinkowskiExtremePoint(BEPUphysics.CollisionShapes.ConvexShapes.ConvexShape,BEPUphysics.CollisionShapes.ConvexShapes.ConvexShape,Microsoft.Xna.Framework.Vector3@,BEPUphysics.MathExtensions.RigidTransform@,Microsoft.Xna.Framework.Vector3@)">
      <summary>
             Gets the extreme point of the minkowski difference of shapeA and shapeB in the local space of shapeA.
            </summary>
      <param name="shapeA">First shape.</param>
      <param name="shapeB">Second shape.</param>
      <param name="direction">Extreme point direction in local space.</param>
      <param name="localTransformB">Transform of shapeB in the local space of A.</param>
      <param name="extremePoint">The extreme point in the local space of A.</param>
    </member>
    <member name="M:BEPUphysics.CollisionTests.CollisionAlgorithms.MinkowskiToolbox.GetLocalMinkowskiExtremePoint(BEPUphysics.CollisionShapes.ConvexShapes.ConvexShape,BEPUphysics.CollisionShapes.ConvexShapes.ConvexShape,Microsoft.Xna.Framework.Vector3@,BEPUphysics.MathExtensions.RigidTransform@,Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Vector3@)">
      <summary>
             Gets the extreme point of the minkowski difference of shapeA and shapeB in the local space of shapeA.
            </summary>
      <param name="shapeA">First shape.</param>
      <param name="shapeB">Second shape.</param>
      <param name="direction">Extreme point direction in local space.</param>
      <param name="localTransformB">Transform of shapeB in the local space of A.</param>
      <param name="extremePointA">The extreme point on shapeA.</param>
      <param name="extremePointB">The extreme point on shapeB.</param>
      <param name="extremePoint">The extreme point in the local space of A.</param>
    </member>
    <member name="M:BEPUphysics.CollisionTests.CollisionAlgorithms.MinkowskiToolbox.GetLocalMinkowskiExtremePointWithoutMargin(BEPUphysics.CollisionShapes.ConvexShapes.ConvexShape,BEPUphysics.CollisionShapes.ConvexShapes.ConvexShape,Microsoft.Xna.Framework.Vector3@,BEPUphysics.MathExtensions.RigidTransform@,Microsoft.Xna.Framework.Vector3@)">
      <summary>
             Gets the extreme point of the minkowski difference of shapeA and shapeB in the local space of shapeA, without a margin.
            </summary>
      <param name="shapeA">First shape.</param>
      <param name="shapeB">Second shape.</param>
      <param name="direction">Extreme point direction in local space.</param>
      <param name="localTransformB">Transform of shapeB in the local space of A.</param>
      <param name="extremePoint">The extreme point in the local space of A.</param>
    </member>
    <member name="M:BEPUphysics.CollisionTests.CollisionAlgorithms.MinkowskiToolbox.ExpandMinkowskiSum(System.Single,System.Single,Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Vector3@)">
      <summary>
             Computes the expansion of the minkowski sum due to margins in a given direction.
            </summary>
      <param name="marginA">First margin.</param>
      <param name="marginB">Second margin.</param>
      <param name="direction">Extreme point direction.</param>
      <param name="contribution">Margin contribution to the extreme point.</param>
    </member>
    <member name="M:BEPUphysics.CollisionTests.CollisionAlgorithms.MinkowskiToolbox.ExpandMinkowskiSum(System.Single,System.Single,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Vector3@)">
      <summary>
             Computes the expansion of the minkowski sum due to margins in a given direction.
            </summary>
      <param name="marginA">First margin.</param>
      <param name="marginB">Second margin.</param>
      <param name="direction">Extreme point direction.</param>
      <param name="toExpandA">Margin contribution to the shapeA.</param>
      <param name="toExpandB">Margin contribution to the shapeB.</param>
    </member>
    <member name="T:BEPUphysics.CollisionRuleManagement.CollisionRule">
      <summary>
            Defines a set of rules that collisions can adhere to.
            </summary>
    </member>
    <member name="F:BEPUphysics.CollisionRuleManagement.CollisionRule.Defer">
      <summary>
            Yields the interaction type's determination to a later stage.
            </summary>
    </member>
    <member name="F:BEPUphysics.CollisionRuleManagement.CollisionRule.Normal">
      <summary>
            Uses all of collision detection, including creating a collision pair, creating contacts when appropriate, and responding to those contacts physically.
            If a collision pair is forced to use a 'normal' interaction but both entities in the pair are kinematic, the collision response will be skipped.
            </summary>
    </member>
    <member name="F:BEPUphysics.CollisionRuleManagement.CollisionRule.NoSolver">
      <summary>
            Creates a collision pair and undergoes narrow phase testing, but does not collision response in the solver.
            </summary>
    </member>
    <member name="F:BEPUphysics.CollisionRuleManagement.CollisionRule.NoNarrowPhaseUpdate">
      <summary>
            Creates a broad phase overlap and narrow phase pair but the collision is never updated.  It cannot generate contacts nor undergo solving.
            </summary>
    </member>
    <member name="F:BEPUphysics.CollisionRuleManagement.CollisionRule.NoNarrowPhasePair">
      <summary>
            Creates a broad phase overlap but does not create any narrow phase pairs.  It cannot generate contacts nor undergo solving.
            </summary>
    </member>
    <member name="F:BEPUphysics.CollisionRuleManagement.CollisionRule.NoBroadPhase">
      <summary>
            Does not create a broad phase overlap.  No further collision detection or response takes place.
            </summary>
    </member>
    <member name="T:BEPUphysics.OtherSpaceStages.IDeferredEventCreator">
      <summary>
             Defines an object which can create deferred events.
            </summary>
    </member>
    <member name="M:BEPUphysics.OtherSpaceStages.IDeferredEventCreator.DispatchEvents">
      <summary>
             Dispatches the events created by this creator.
            </summary>
    </member>
    <member name="P:BEPUphysics.OtherSpaceStages.IDeferredEventCreator.DeferredEventDispatcher">
      <summary>
             Gets or sets the deferred event dispatcher that owns this creator.
            </summary>
    </member>
    <member name="P:BEPUphysics.OtherSpaceStages.IDeferredEventCreator.IsActive">
      <summary>
             Gets or sets the activity state of this creator.
            </summary>
    </member>
    <member name="T:BEPUphysics.Collidables.Events.EntryEventManager`1">
      <summary>
             Event manager for BroadPhaseEntries (all types that live in the broad phase).
            </summary>
      <typeparam name="T">Some BroadPhaseEntry subclass.</typeparam>
    </member>
    <member name="M:BEPUphysics.Collidables.Events.EntryEventManager`1.#ctor(`0)">
      <summary>
             Constructs a new event manager.
            </summary>
      <param name="owner">Owner of the event manager.</param>
    </member>
    <member name="M:BEPUphysics.Collidables.Events.EntryEventManager`1.VerifyEventStatus">
      <summary>
            Removes the entity from the space's list of eventful entities if no events are active.
            </summary>
    </member>
    <member name="M:BEPUphysics.Collidables.Events.EntryEventManager`1.RemoveAllEvents">
      <summary>
             Removes all event hooks from the manager.
            </summary>
    </member>
    <member name="P:BEPUphysics.Collidables.Events.EntryEventManager`1.Owner">
      <summary>
             Owner of the event manager.
            </summary>
    </member>
    <member name="T:BEPUphysics.Entities.Prefabs.Cone">
      <summary>
            Cone-shaped object that can collide and move.  After making an entity, add it to a Space so that the engine can manage it.
            </summary>
    </member>
    <member name="M:BEPUphysics.Entities.Prefabs.Cone.#ctor(Microsoft.Xna.Framework.Vector3,System.Single,System.Single,System.Single)">
      <summary>
            Constructs a physically simulated cone.
            </summary>
      <param name="position">Position of the cone.</param>
      <param name="height">Height of the cone.</param>
      <param name="radius">Radius of the cone.</param>
      <param name="mass">Mass of the object.</param>
    </member>
    <member name="M:BEPUphysics.Entities.Prefabs.Cone.#ctor(Microsoft.Xna.Framework.Vector3,System.Single,System.Single)">
      <summary>
            Constructs a nondynamic cone.
            </summary>
      <param name="position">Position of the cone.</param>
      <param name="height">Height of the cone.</param>
      <param name="radius">Radius of the cone.</param>
    </member>
    <member name="M:BEPUphysics.Entities.Prefabs.Cone.#ctor(BEPUphysics.EntityStateManagement.MotionState,System.Single,System.Single,System.Single)">
      <summary>
            Constructs a physically simulated cone.
            </summary>
      <param name="motionState">Motion state specifying the entity's initial state.</param>
      <param name="height">Height of the cone.</param>
      <param name="radius">Radius of the cone.</param>
      <param name="mass">Mass of the object.</param>
    </member>
    <member name="M:BEPUphysics.Entities.Prefabs.Cone.#ctor(BEPUphysics.EntityStateManagement.MotionState,System.Single,System.Single)">
      <summary>
            Constructs a nondynamic cone.
            </summary>
      <param name="motionState">Motion state specifying the entity's initial state.</param>
      <param name="height">Height of the cone.</param>
      <param name="radius">Radius of the cone.</param>
    </member>
    <member name="P:BEPUphysics.Entities.Prefabs.Cone.Height">
      <summary>
            Gets or sets the length of the cone.
            </summary>
    </member>
    <member name="P:BEPUphysics.Entities.Prefabs.Cone.Radius">
      <summary>
            Gets or sets the radius of the cone.
            </summary>
    </member>
    <member name="T:BEPUphysics.Constraints.TwoEntity.Motors.AngularMotor">
      <summary>
            Constraint which attempts to restrict the relative angular motion of two entities.
            Can use a target relative orientation to apply additional force.
            </summary>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.Motors.AngularMotor.#ctor">
      <summary>
            Constructs a new constraint which attempts to restrict the relative angular motion of two entities.
            To finish the initialization, specify the connections (ConnectionA and ConnectionB).
            This constructor sets the constraint's IsActive property to false by default.
            </summary>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.Motors.AngularMotor.#ctor(BEPUphysics.Entities.Entity,BEPUphysics.Entities.Entity)">
      <summary>
            Constructs a new constraint which attempts to restrict the relative angular motion of two entities.
            </summary>
      <param name="connectionA">First connection of the pair.</param>
      <param name="connectionB">Second connection of the pair.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.Motors.AngularMotor.GetLinearJacobianA(Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Vector3@)">
      <summary>
            Gets the linear jacobian entry for the first connected entity.
            </summary>
      <param name="jacobianX">First linear jacobian entry for the first connected entity.</param>
      <param name="jacobianY">Second linear jacobian entry for the first connected entity.</param>
      <param name="jacobianZ">Third linear jacobian entry for the first connected entity.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.Motors.AngularMotor.GetLinearJacobianB(Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Vector3@)">
      <summary>
            Gets the linear jacobian entry for the second connected entity.
            </summary>
      <param name="jacobianX">First linear jacobian entry for the second connected entity.</param>
      <param name="jacobianY">Second linear jacobian entry for the second connected entity.</param>
      <param name="jacobianZ">Third linear jacobian entry for the second connected entity.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.Motors.AngularMotor.GetAngularJacobianA(Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Vector3@)">
      <summary>
            Gets the angular jacobian entry for the first connected entity.
            </summary>
      <param name="jacobianX">First angular jacobian entry for the first connected entity.</param>
      <param name="jacobianY">Second angular jacobian entry for the first connected entity.</param>
      <param name="jacobianZ">Third angular jacobian entry for the first connected entity.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.Motors.AngularMotor.GetAngularJacobianB(Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Vector3@)">
      <summary>
            Gets the angular jacobian entry for the second connected entity.
            </summary>
      <param name="jacobianX">First angular jacobian entry for the second connected entity.</param>
      <param name="jacobianY">Second angular jacobian entry for the second connected entity.</param>
      <param name="jacobianZ">Third angular jacobian entry for the second connected entity.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.Motors.AngularMotor.GetMassMatrix(BEPUphysics.MathExtensions.Matrix3X3@)">
      <summary>
            Gets the mass matrix of the constraint.
            </summary>
      <param name="outputMassMatrix">Constraint's mass matrix.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.Motors.AngularMotor.SolveIteration">
      <summary>
            Applies the corrective impulses required by the constraint.
            </summary>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.Motors.AngularMotor.Update(System.Single)">
      <summary>
            Initializes the constraint for the current frame.
            </summary>
      <param name="dt">Time between frames.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.Motors.AngularMotor.ExclusiveUpdate">
      <summary>
            Performs any pre-solve iteration work that needs exclusive
            access to the members of the solver updateable.
            Usually, this is used for applying warmstarting impulses.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.Motors.AngularMotor.Basis">
      <summary>
            Gets the basis attached to entity A.
            The target velocity/orientation of this motor is transformed by the basis.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.Motors.AngularMotor.Settings">
      <summary>
            Gets the motor's velocity and servo settings.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.Motors.AngularMotor.RelativeVelocity">
      <summary>
            Gets the current relative velocity between the connected entities with respect to the constraint.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.Motors.AngularMotor.TotalImpulse">
      <summary>
            Gets the total impulse applied by this constraint.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.Motors.AngularMotor.Error">
      <summary>
            Gets the current constraint error.
            If the motor is in velocity only mode, error is zero.
            </summary>
    </member>
    <member name="T:BEPUphysics.CollisionTests.CollisionAlgorithms.SphereTester">
      <summary>
             Helper class to test spheres against each other.
            </summary>
    </member>
    <member name="M:BEPUphysics.CollisionTests.CollisionAlgorithms.SphereTester.AreSpheresColliding(BEPUphysics.CollisionShapes.ConvexShapes.SphereShape,BEPUphysics.CollisionShapes.ConvexShapes.SphereShape,Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Vector3@,BEPUphysics.CollisionTests.ContactData@)">
      <summary>
            Computes contact data for two spheres.
            </summary>
      <param name="a">First sphere.</param>
      <param name="b">Second sphere.</param>
      <param name="positionA">Position of the first sphere.</param>
      <param name="positionB">Position of the second sphere.</param>
      <param name="contact">Contact data between the spheres, if any.</param>
      <returns>Whether or not the spheres are touching.</returns>
    </member>
    <member name="T:BEPUphysics.BroadPhaseSystems.BroadPhaseOverlap">
      <summary>
            A pair of overlapping BroadPhaseEntries.
            </summary>
    </member>
    <member name="M:BEPUphysics.BroadPhaseSystems.BroadPhaseOverlap.#ctor(BEPUphysics.BroadPhaseSystems.BroadPhaseEntry,BEPUphysics.BroadPhaseSystems.BroadPhaseEntry)">
      <summary>
            Constructs an overlap.
            </summary>
      <param name="entryA">First entry in the pair.</param>
      <param name="entryB">Second entry in the pair.</param>
    </member>
    <member name="M:BEPUphysics.BroadPhaseSystems.BroadPhaseOverlap.#ctor(BEPUphysics.BroadPhaseSystems.BroadPhaseEntry,BEPUphysics.BroadPhaseSystems.BroadPhaseEntry,BEPUphysics.CollisionRuleManagement.CollisionRule)">
      <summary>
            Constructs an overlap.
            </summary>
      <param name="entryA">First entry in the pair.</param>
      <param name="entryB">Second entry in the pair.</param>
      <param name="collisionRule">Collision rule calculated for the pair.</param>
    </member>
    <member name="M:BEPUphysics.BroadPhaseSystems.BroadPhaseOverlap.GetHashCode">
      <summary>
            Gets the hash code of the object.
            </summary>
      <returns>Hash code of the object.</returns>
    </member>
    <member name="M:BEPUphysics.BroadPhaseSystems.BroadPhaseOverlap.Equals(BEPUphysics.BroadPhaseSystems.BroadPhaseOverlap)">
      <summary>
            Compares the overlaps for equality based on the involved entries.
            </summary>
      <param name="other">Overlap to compare.</param>
      <returns>Whether or not the overlaps were equal.</returns>
    </member>
    <member name="P:BEPUphysics.BroadPhaseSystems.BroadPhaseOverlap.EntryA">
      <summary>
            First entry in the pair.
            </summary>
    </member>
    <member name="P:BEPUphysics.BroadPhaseSystems.BroadPhaseOverlap.EntryB">
      <summary>
            Second entry in the pair.
            </summary>
    </member>
    <member name="P:BEPUphysics.BroadPhaseSystems.BroadPhaseOverlap.CollisionRule">
      <summary>
            Gets the collision rule calculated for the pair.
            </summary>
    </member>
    <member name="T:BEPUphysics.Toolbox">
      <summary>
            Helper class with many algorithms for intersection testing and 3D math.
            </summary>
    </member>
    <member name="F:BEPUphysics.Toolbox.BigEpsilon">
      <summary>
            Large tolerance value.
            </summary>
    </member>
    <member name="F:BEPUphysics.Toolbox.Epsilon">
      <summary>
            Tolerance value.
            </summary>
    </member>
    <member name="F:BEPUphysics.Toolbox.NoVector">
      <summary>
            Represents an invalid Vector3.
            </summary>
    </member>
    <member name="F:BEPUphysics.Toolbox.BackVector">
      <summary>
            Reference for a vector with dimensions (0,0,1).
            </summary>
    </member>
    <member name="F:BEPUphysics.Toolbox.DownVector">
      <summary>
            Reference for a vector with dimensions (0,-1,0).
            </summary>
    </member>
    <member name="F:BEPUphysics.Toolbox.ForwardVector">
      <summary>
            Reference for a vector with dimensions (0,0,-1).
            </summary>
    </member>
    <member name="F:BEPUphysics.Toolbox.IdentityOrientation">
      <summary>
            Refers to the identity quaternion.
            </summary>
    </member>
    <member name="F:BEPUphysics.Toolbox.LeftVector">
      <summary>
            Reference for a vector with dimensions (-1,0,0).
            </summary>
    </member>
    <member name="F:BEPUphysics.Toolbox.RightVector">
      <summary>
            Reference for a vector with dimensions (1,0,0).
            </summary>
    </member>
    <member name="F:BEPUphysics.Toolbox.UpVector">
      <summary>
            Reference for a vector with dimensions (0,1,0).
            </summary>
    </member>
    <member name="F:BEPUphysics.Toolbox.ZeroMatrix">
      <summary>
            Matrix containing zeroes for every element.
            </summary>
    </member>
    <member name="F:BEPUphysics.Toolbox.ZeroVector">
      <summary>
            Reference for a vector with dimensions (0,0,0).
            </summary>
    </member>
    <member name="F:BEPUphysics.Toolbox.RigidIdentity">
      <summary>
            Refers to the rigid identity transformation.
            </summary>
    </member>
    <member name="M:BEPUphysics.Toolbox.FindRayTriangleIntersection(Microsoft.Xna.Framework.Ray@,System.Single,BEPUphysics.CollisionShapes.ConvexShapes.TriangleSidedness,Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Vector3@,BEPUphysics.RayHit@)">
      <summary>
            Determines the intersection between a ray and a triangle.
            </summary>
      <param name="ray">Ray to test.</param>
      <param name="maximumLength">Maximum length to travel in units of the direction's length.</param>
      <param name="sidedness">Sidedness of the triangle to test.</param>
      <param name="a">First vertex of the triangle.</param>
      <param name="b">Second vertex of the triangle.</param>
      <param name="c">Third vertex of the triangle.</param>
      <param name="hit">Hit data of the ray, if any</param>
      <returns>Whether or not the ray and triangle intersect.</returns>
    </member>
    <member name="M:BEPUphysics.Toolbox.GetRayPlaneIntersection(Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,System.Single,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3@,System.Single@)">
      <summary>
            Finds the intersection between the plane and the ray.
            </summary>
      <param name="origin">Location of the start of the ray.</param>
      <param name="direction">Direction of the ray.</param>
      <param name="maximumLength">Maximum length to test in units of the direction's length.</param>
      <param name="planePosition">Position of a point on the plane.</param>
      <param name="planeNormal">Normal of the plane to be intersected.</param>
      <param name="hitLocation">Intersection point.</param>
      <param name="t">Distance, in units of the direction's length, to the hit location.</param>
      <returns>Whether or not the ray intersects the plane.</returns>
    </member>
    <member name="M:BEPUphysics.Toolbox.GetSegmentPlaneIntersection(Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3@)">
      <summary>
            Finds the intersection between the given segment and the given plane defined by three points.
            </summary>
      <param name="a">First endpoint of segment.</param>
      <param name="b">Second enpoint of segment.</param>
      <param name="d">First vertex of a triangle which lies on the plane.</param>
      <param name="e">Second vertex of a triangle which lies on the plane.</param>
      <param name="f">Third vertex of a triangle which lies on the plane.</param>
      <param name="q">Intersection point.</param>
      <returns>Whether or not the segment intersects the plane.</returns>
    </member>
    <member name="M:BEPUphysics.Toolbox.GetSegmentPlaneIntersection(Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Plane,Microsoft.Xna.Framework.Vector3@)">
      <summary>
            Finds the intersection between the given segment and the given plane.
            </summary>
      <param name="a">First endpoint of segment.</param>
      <param name="b">Second enpoint of segment.</param>
      <param name="p">Plane for comparison.</param>
      <param name="q">Intersection point.</param>
      <returns>Whether or not the segment intersects the plane.</returns>
    </member>
    <member name="M:BEPUphysics.Toolbox.GetSegmentPlaneIntersection(Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Plane,System.Single@,Microsoft.Xna.Framework.Vector3@)">
      <summary>
            Finds the intersection between the given segment and the given plane.
            </summary>
      <param name="a">First endpoint of segment.</param>
      <param name="b">Second enpoint of segment.</param>
      <param name="p">Plane for comparison.</param>
      <param name="t">Interval along segment to intersection.</param>
      <param name="q">Intersection point.</param>
      <returns>Whether or not the segment intersects the plane.</returns>
    </member>
    <member name="M:BEPUphysics.Toolbox.GetClosestPointOnTriangleToPoint(Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Vector3@)">
      <summary>
            Determines the closest point on a triangle given by points a, b, and c to point p.
            </summary>
      <param name="a">First vertex of triangle.</param>
      <param name="b">Second vertex of triangle.</param>
      <param name="c">Third vertex of triangle.</param>
      <param name="p">Point for comparison.</param>
      <param name="closestPoint">Closest point on tetrahedron to point.</param>
      <returns>Whether or not the closest point was on the face of the triangle.</returns>
    </member>
    <member name="M:BEPUphysics.Toolbox.GetClosestPointOnTriangleToPoint(Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Vector3@,System.Collections.Generic.List{Microsoft.Xna.Framework.Vector3},Microsoft.Xna.Framework.Vector3@)">
      <summary>
            Determines the closest point on a triangle given by points a, b, and c to point p and provides the subsimplex whose voronoi region contains the point.
            </summary>
      <param name="a">First vertex of triangle.</param>
      <param name="b">Second vertex of triangle.</param>
      <param name="c">Third vertex of triangle.</param>
      <param name="p">Point for comparison.</param>
      <param name="subsimplex">The source of the voronoi region which contains the point.</param>
      <param name="closestPoint">Closest point on tetrahedron to point.</param>
    </member>
    <member name="M:BEPUphysics.Toolbox.GetClosestPointOnTriangleToPoint(System.Collections.Generic.List{Microsoft.Xna.Framework.Vector3},System.Int32,System.Int32,System.Int32,Microsoft.Xna.Framework.Vector3@,System.Collections.Generic.List{System.Int32},System.Collections.Generic.List{System.Single},Microsoft.Xna.Framework.Vector3@)">
      <summary>
            Determines the closest point on a triangle given by points a, b, and c to point p and provides the subsimplex whose voronoi region contains the point.
            </summary>
      <param name="q">Simplex containing triangle for testing.</param>
      <param name="i">Index of first vertex of triangle.</param>
      <param name="j">Index of second vertex of triangle.</param>
      <param name="k">Index of third vertex of triangle.</param>
      <param name="p">Point for comparison.</param>
      <param name="subsimplex">The source of the voronoi region which contains the point, enumerated as a = 0, b = 1, c = 2.</param>
      <param name="baryCoords">Barycentric coordinates of the point on the triangle.</param>
      <param name="closestPoint">Closest point on tetrahedron to point.</param>
    </member>
    <member name="M:BEPUphysics.Toolbox.IsPointInsideTriangle(Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Vector3@)">
      <summary>
            Determines if supplied point is within the triangle as defined by the provided vertices.
            </summary>
      <param name="vA">A vertex of the triangle.</param>
      <param name="vB">A vertex of the triangle.</param>
      <param name="vC">A vertex of the triangle.</param>
      <param name="p">The point for comparison against the triangle.</param>
      <returns>Whether or not the point is within the triangle.</returns>
    </member>
    <member name="M:BEPUphysics.Toolbox.IsPointInsideTriangle(Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Vector3@,System.Single)">
      <summary>
            Determines if supplied point is within the triangle as defined by the provided vertices.
            </summary>
      <param name="vA">A vertex of the triangle.</param>
      <param name="vB">A vertex of the triangle.</param>
      <param name="vC">A vertex of the triangle.</param>
      <param name="p">The point for comparison against the triangle.</param>
      <param name="margin">Extra area on the edges of the triangle to include.  Can be negative.</param>
      <returns>Whether or not the point is within the triangle.</returns>
    </member>
    <member name="M:BEPUphysics.Toolbox.GetClosestPointOnSegmentToPoint(Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Vector3@)">
      <summary>
            Determines the closest point on the provided segment ab to point p.
            </summary>
      <param name="a">First endpoint of segment.</param>
      <param name="b">Second endpoint of segment.</param>
      <param name="p">Point for comparison.</param>
      <param name="closestPoint">Closest point on the edge to p.</param>
    </member>
    <member name="M:BEPUphysics.Toolbox.GetClosestPointOnSegmentToPoint(Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Vector3@,System.Collections.Generic.List{Microsoft.Xna.Framework.Vector3},Microsoft.Xna.Framework.Vector3@)">
      <summary>
            Determines the closest point on the provided segment ab to point p.
            </summary>
      <param name="a">First endpoint of segment.</param>
      <param name="b">Second endpoint of segment.</param>
      <param name="p">Point for comparison.</param>
      <param name="subsimplex">The source of the voronoi region which contains the point.</param>
      <param name="closestPoint">Closest point on the edge to p.</param>
    </member>
    <member name="M:BEPUphysics.Toolbox.GetClosestPointOnSegmentToPoint(System.Collections.Generic.List{Microsoft.Xna.Framework.Vector3},System.Int32,System.Int32,Microsoft.Xna.Framework.Vector3@,System.Collections.Generic.List{System.Int32},System.Collections.Generic.List{System.Single},Microsoft.Xna.Framework.Vector3@)">
      <summary>
            Determines the closest point on the provided segment ab to point p.
            </summary>
      <param name="q">List of points in the containing simplex.</param>
      <param name="i">Index of first endpoint of segment.</param>
      <param name="j">Index of second endpoint of segment.</param>
      <param name="p">Point for comparison.</param>
      <param name="subsimplex">The source of the voronoi region which contains the point, enumerated as a = 0, b = 1.</param>
      <param name="baryCoords">Barycentric coordinates of the point.</param>
      <param name="closestPoint">Closest point on the edge to p.</param>
    </member>
    <member name="M:BEPUphysics.Toolbox.GetDistanceFromPointToLine(Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3)">
      <summary>
            Determines the shortest distance from the point to the line.
            </summary>
      <param name="p">Point to check against the line.</param>
      <param name="a">First point on the line for comparison.</param>
      <param name="b">Second point on the line for comparison.</param>
      <returns>Shortest distance from the point to the line.</returns>
    </member>
    <member name="M:BEPUphysics.Toolbox.GetSquaredDistanceFromPointToLine(Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3)">
      <summary>
            Determines the shortest squared distance from the point to the line.
            </summary>
      <param name="p">Point to check against the line.</param>
      <param name="a">First point on the line.</param>
      <param name="b">Second point on the line.</param>
      <returns>Shortest squared distance from the point to the line.</returns>
    </member>
    <member name="M:BEPUphysics.Toolbox.AreSegmentsParallel(Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3)">
      <summary>
            Determines if the given directions are parallel.
            </summary>
      <param name="dirA">First line direction.</param>
      <param name="dirB">Second line direction.</param>
      <returns>Whether or not the given directions are parallel.</returns>
    </member>
    <member name="M:BEPUphysics.Toolbox.GetClosestPointsBetweenSegments(Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Vector3@)">
      <summary>
            Computes closest points c1 and c2 betwen segments p1q1 and p2q2.
            </summary>
      <param name="p1">First point of first segment.</param>
      <param name="q1">Second point of first segment.</param>
      <param name="p2">First point of second segment.</param>
      <param name="q2">Second point of second segment.</param>
      <param name="c1">Closest point on first segment.</param>
      <param name="c2">Closest point on second segment.</param>
    </member>
    <member name="M:BEPUphysics.Toolbox.GetClosestPointsBetweenSegments(Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Vector3@,System.Single@,System.Single@,Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Vector3@)">
      <summary>
            Computes closest points c1 and c2 betwen segments p1q1 and p2q2.
            </summary>
      <param name="p1">First point of first segment.</param>
      <param name="q1">Second point of first segment.</param>
      <param name="p2">First point of second segment.</param>
      <param name="q2">Second point of second segment.</param>
      <param name="s">Distance along the line to the point for first segment.</param>
      <param name="t">Distance along the line to the point for second segment.</param>
      <param name="c1">Closest point on first segment.</param>
      <param name="c2">Closest point on second segment.</param>
    </member>
    <member name="M:BEPUphysics.Toolbox.GetDistanceBetweenLines(Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3)">
      <summary>
            Determines the minimum distance between two lines.
            </summary>
      <param name="p1">First point of the first line for comparison.</param>
      <param name="p2">Second point of the first line for comparison.</param>
      <param name="p3">First point of the second line for comparison.</param>
      <param name="p4">Second point of the second line for comparison.</param>
      <returns>Minimum distance between two lines.</returns>
    </member>
    <member name="M:BEPUphysics.Toolbox.GetIntersectionParallelSegments(Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Vector3@)">
      <summary>
            Determines the intersection of two parallel segments represented by two points.
            </summary>
      <param name="p1">First endpoint of first segment.</param>
      <param name="q1">Second endpoint of first segment.</param>
      <param name="p2">First endpoint of second segment.</param>
      <param name="q2">Second endpoint of second segment.</param>
      <param name="a">First endpoint of intersection area.</param>
      <param name="b">Last endpoint of intersection area.</param>
      <returns>Whether or not the segments are parallel.</returns>
    </member>
    <member name="M:BEPUphysics.Toolbox.GetLineLineIntersection(Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Vector3@)">
      <summary>
            Finds the shortest line segment between two lines.
            </summary>
      <param name="p1">First point of the first line for comparison.</param>
      <param name="p2">Second point of the first line for comparison.</param>
      <param name="p3">First point of the second line for comparison.</param>
      <param name="p4">Second point of the second line for comparison.</param>
      <param name="pa">First point of the shortest line.</param>
      <param name="pb">Second point of the shortest line.</param>
      <returns>Whether or not an intersection could be identified.</returns>
    </member>
    <member name="M:BEPUphysics.Toolbox.GetLineLineIntersection(Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3@)">
      <summary>
            Finds the intersection point between two coplanar segments.
            Note: Does not explicitly test coplanarity; functionality for non-coplanar parameters is undefined.
            </summary>
      <param name="p1">First point of the first line for comparison.</param>
      <param name="p2">Second point of the first line for comparison.</param>
      <param name="p3">First point of the second line for comparison.</param>
      <param name="p4">Second point of the second line for comparison.</param>
      <param name="intersection">Point of intersection.</param>
      <returns>Intersection between the two coplanar lines.</returns>
    </member>
    <member name="M:BEPUphysics.Toolbox.GetSquaredDistanceLinePoint(Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3)">
      <summary>
            Finds the squared distance from a point to a line.
            </summary>
      <param name="a">First point on the line.</param>
      <param name="b">Second point on the line.</param>
      <param name="p">Point for comparison.</param>
      <returns>Squared distance from the point to the line.</returns>
    </member>
    <member name="M:BEPUphysics.Toolbox.IsPointCollinear(Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3)">
      <summary>
            Determines if the given point is collinear with the line.
            </summary>
      <param name="point">Point for comparison.</param>
      <param name="a">First endpoint of the line.</param>
      <param name="b">Second endpoint of the line.</param>
      <returns>Whether or not the point is collinear with the line.</returns>
    </member>
    <member name="M:BEPUphysics.Toolbox.CompareVectorLengths(Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3)">
      <summary>
            Acts as a comparator condition based on length for two vectors.
            </summary>
      <param name="v1">First vector for comparison.</param>
      <param name="v2">Second vector for comparison.</param>
      <returns>Comparator int.</returns>
    </member>
    <member name="M:BEPUphysics.Toolbox.ArePointsOnOppositeSidesOfPlane(Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Vector3@)">
      <summary>
            Determines if vectors o and p are on opposite sides of the plane defined by a, b, and c.
            </summary>
      <param name="o">First point for comparison.</param>
      <param name="p">Second point for comparison.</param>
      <param name="a">First vertex of the plane.</param>
      <param name="b">Second vertex of plane.</param>
      <param name="c">Third vertex of plane.</param>
      <returns>Whether or not vectors o and p reside on opposite sides of the plane.</returns>
    </member>
    <member name="M:BEPUphysics.Toolbox.GetDistancePointToPlane(Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3)">
      <summary>
            Determines the distance between a point and a plane..
            </summary>
      <param name="point">Point to project onto plane.</param>
      <param name="normal">Normal of the plane.</param>
      <param name="pointOnPlane">Point located on the plane.</param>
      <returns>Distance from the point to the plane.</returns>
    </member>
    <member name="M:BEPUphysics.Toolbox.GetPointProjectedOnPlane(Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3)">
      <summary>
            Determines the location of the point when projected onto the plane defined by the normal and a point on the plane.
            </summary>
      <param name="point">Point to project onto plane.</param>
      <param name="normal">Normal of the plane.</param>
      <param name="pointOnPlane">Point located on the plane.</param>
      <returns>Projected location of point onto plane.</returns>
    </member>
    <member name="M:BEPUphysics.Toolbox.IsPointWithinFaceExtrusion(Microsoft.Xna.Framework.Vector3,System.Collections.Generic.List{Microsoft.Xna.Framework.Plane},Microsoft.Xna.Framework.Vector3)">
      <summary>
            Determines if a point is within a set of planes defined by the edges of a triangle.
            </summary>
      <param name="point">Point for comparison.</param>
      <param name="planes">Edge planes.</param>
      <param name="centroid">A point known to be inside of the planes.</param>
      <returns>Whether or not the point is within the edge planes.</returns>
    </member>
    <member name="M:BEPUphysics.Toolbox.IsPointWithinFaceExtrusion(Microsoft.Xna.Framework.Vector3,System.Collections.Generic.List{Microsoft.Xna.Framework.Plane},Microsoft.Xna.Framework.Vector3,System.Collections.Generic.List{Microsoft.Xna.Framework.Plane}@)">
      <summary>
            Determines if a point lies within the bounds of a set of planes representing edge planes.
            If it is outside, a set of possible separating planes will be provided.
            </summary>
      <param name="point">Location to test for inclusion.</param>
      <param name="planes">Representation of edge planes on a face.</param>
      <param name="centroid">A point determined to be within all planes.</param>
      <param name="separatingPlanes">Possible planes that the point may come from wtihin the object (as with a line segment).</param>
      <returns>Whether or not the point is within the extrusion.</returns>
    </member>
    <member name="M:BEPUphysics.Toolbox.GetClosestPointOnTetrahedronToPoint(Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Vector3@)">
      <summary>
            Determines the closest point on a tetrahedron to a provided point p.
            </summary>
      <param name="a">First vertex of the tetrahedron.</param>
      <param name="b">Second vertex of the tetrahedron.</param>
      <param name="c">Third vertex of the tetrahedron.</param>
      <param name="d">Fourth vertex of the tetrahedron.</param>
      <param name="p">Point for comparison.</param>
      <param name="closestPoint">Closest point on the tetrahedron to the point.</param>
    </member>
    <member name="M:BEPUphysics.Toolbox.GetClosestPointOnTetrahedronToPoint(Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Vector3@,System.Collections.Generic.List{Microsoft.Xna.Framework.Vector3},Microsoft.Xna.Framework.Vector3@)">
      <summary>
            Determines the closest point on a tetrahedron to a provided point p.
            </summary>
      <param name="a">First vertex of the tetrahedron.</param>
      <param name="b">Second vertex of the tetrahedron.</param>
      <param name="c">Third vertex of the tetrahedron.</param>
      <param name="d">Fourth vertex of the tetrahedron.</param>
      <param name="p">Point for comparison.</param>
      <param name="subsimplex">The source of the voronoi region which contains the point.</param>
      <param name="closestPoint">Closest point on the tetrahedron to the point.</param>
    </member>
    <member name="M:BEPUphysics.Toolbox.GetClosestPointOnTetrahedronToPoint(System.Collections.Generic.List{Microsoft.Xna.Framework.Vector3},Microsoft.Xna.Framework.Vector3@,System.Collections.Generic.List{System.Int32},System.Collections.Generic.List{System.Single},Microsoft.Xna.Framework.Vector3@)">
      <summary>
            Determines the closest point on a tetrahedron to a provided point p.
            </summary>
      <param name="tetrahedron">List of 4 points composing the tetrahedron.</param>
      <param name="p">Point for comparison.</param>
      <param name="subsimplex">The source of the voronoi region which contains the point, enumerated as a = 0, b = 1, c = 2, d = 3.</param>
      <param name="baryCoords">Barycentric coordinates of p on the tetrahedron.</param>
      <param name="closestPoint">Closest point on the tetrahedron to the point.</param>
    </member>
    <member name="M:BEPUphysics.Toolbox.GetExtremePointOfSet(Microsoft.Xna.Framework.Vector3,System.Collections.Generic.IList{System.Int32},System.Collections.Generic.IList{Microsoft.Xna.Framework.Vector3},System.Int32@)">
      <summary>
            Finds the vector that is furthest along the given direction within the list.
            </summary>
      <param name="direction">Direction to find the furthest point along.</param>
      <param name="pointIndices">Indices from the point set to test.</param>
      <param name="points">List of all points to be indexed from.</param>
      <returns>The point furthest along the direction in the list of points.</returns>
      <param name="maxIndex">Index of the maximum point in the list.</param>
    </member>
    <member name="M:BEPUphysics.Toolbox.GetExtremePointsOfSet(Microsoft.Xna.Framework.Vector3,System.Collections.Generic.IList{Microsoft.Xna.Framework.Vector3},System.Int32@,System.Int32@)">
      <summary>
            Finds the two points which are most extreme along the given direction within the list.
            </summary>
      <param name="direction">Direction to find the furthest points along.</param>
      <param name="points">List of points to test against.</param>
      <param name="minimum">Index of the point furthest back along the direction in the point list.</param>
      <param name="maximum">Index of the point furthest forward along the direction in the point list.</param>
      <returns>The point furthest along the direction in the list of points.</returns>
    </member>
    <member name="M:BEPUphysics.Toolbox.GetConvexHull(System.Collections.Generic.IList{Microsoft.Xna.Framework.Vector3},System.Collections.Generic.IList{System.Int32})">
      <summary>
            Identifies the indices of points in a set which are on the outer convex hull of the set.
            </summary>
      <param name="points">List of points in the set.</param>
      <param name="indices">List of indices composing the triangulated surface of the convex hull.
            Each group of 3 indices represents a triangle on the surface of the hull.</param>
    </member>
    <member name="M:BEPUphysics.Toolbox.GetConvexHull(System.Collections.Generic.IList{Microsoft.Xna.Framework.Vector3},System.Collections.Generic.IList{Microsoft.Xna.Framework.Vector3})">
      <summary>
            Identifies the points on the surface of hull.
            </summary>
      <param name="points">List of points in the set.</param>
      <param name="outputSurfacePoints">Unique points on the surface of the convex hull.</param>
    </member>
    <member name="M:BEPUphysics.Toolbox.GetConvexHull(System.Collections.Generic.IList{Microsoft.Xna.Framework.Vector3},System.Collections.Generic.IList{System.Int32},System.Collections.Generic.IList{Microsoft.Xna.Framework.Vector3})">
      <summary>
            Identifies the points on the surface of hull.
            </summary>
      <param name="points">List of points in the set.</param>
      <param name="indices">List of indices composing the triangulated surface of the convex hull.
            Each group of 3 indices represents a triangle on the surface of the hull.</param>
      <param name="outputSurfacePoints">Unique points on the surface of the convex hull.</param>
    </member>
    <member name="M:BEPUphysics.Toolbox.RayCastSphere(Microsoft.Xna.Framework.Ray@,Microsoft.Xna.Framework.Vector3@,System.Single,System.Single,BEPUphysics.RayHit@)">
      <summary>
             Tests a ray against a sphere.
            </summary>
      <param name="ray">Ray to test.</param>
      <param name="spherePosition">Position of the sphere.</param>
      <param name="radius">Radius of the sphere.</param>
      <param name="maximumLength">Maximum length of the ray in units of the ray direction's length.</param>
      <param name="hit">Hit data of the ray, if any.</param>
      <returns>Whether or not the ray hits the sphere.</returns>
    </member>
    <member name="M:BEPUphysics.Toolbox.Clamp(System.Single,System.Single,System.Single)">
      <summary>
            Clamps a value between a minimum and maximum.
            </summary>
      <param name="n">Value to clamp.</param>
      <param name="min">Minimum value allowed.</param>
      <param name="max">Maximum value allowed.</param>
      <returns>Clamped value.</returns>
    </member>
    <member name="M:BEPUphysics.Toolbox.AreVectorsEqual(Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3)">
      <summary>
            Compares the vectors for equality.
            </summary>
      <param name="a">First vector for testing.</param>
      <param name="b">Second vector for testing.</param>
      <returns>Whether or not the two vectors are equal.</returns>
    </member>
    <member name="M:BEPUphysics.Toolbox.AreVectorsSimilar(Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3)">
      <summary>
            Determines if two vectors have similar components.
            </summary>
      <param name="a">First vector for comparison.</param>
      <param name="b">Second vector for comparison.</param>
      <returns>Whether or not the vectors are similar.</returns>
    </member>
    <member name="M:BEPUphysics.Toolbox.ContainsSimilarAxis(System.Collections.Generic.List{Microsoft.Xna.Framework.Vector3},Microsoft.Xna.Framework.Vector3)">
      <summary>
            Determines if a list contains a Vector3 representing an axis (both negative and positive), allowing for a small amount of error.
            </summary>
      <param name="list">List to check.</param>
      <param name="toCheck">Axis to check.</param>
      <returns>Whether or not the list contains the provided axis.</returns>
    </member>
    <member name="M:BEPUphysics.Toolbox.GetAngleFromQuaternion(Microsoft.Xna.Framework.Quaternion@)">
      <summary>
            Computes the angle change represented by a normalized quaternion.
            </summary>
      <param name="q">Quaternion to be converted.</param>
      <returns>Angle around the axis represented by the quaternion.</returns>
    </member>
    <member name="M:BEPUphysics.Toolbox.GetAxisAngleFromQuaternion(Microsoft.Xna.Framework.Quaternion@,Microsoft.Xna.Framework.Vector3@,System.Single@)">
      <summary>
            Computes the axis angle representation of a normalized quaternion.
            </summary>
      <param name="q">Quaternion to be converted.</param>
      <param name="axis">Axis represented by the quaternion.</param>
      <param name="angle">Angle around the axis represented by the quaternion.</param>
    </member>
    <member name="M:BEPUphysics.Toolbox.GetCrossProductMatrix(Microsoft.Xna.Framework.Vector3)">
      <summary>
            Returns the cross product matrix for the given vector.
            </summary>
      <param name="v">Vector to be used in finding the cross product matrix.</param>
      <returns>Cross product matrix form of the vector.</returns>
    </member>
    <member name="M:BEPUphysics.Toolbox.GetMatrixFromVector(Microsoft.Xna.Framework.Vector3)">
      <summary>
            Converts a vector into a matrix.
            </summary>
      <param name="v">Vector to be matrix-fied.</param>
      <returns>Matrix form of the vector.</returns>
    </member>
    <member name="M:BEPUphysics.Toolbox.GetOuterProduct(Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3)">
      <summary>
            Computes the outer product of the given vectors.
            </summary>
      <param name="a">First vector.</param>
      <param name="b">Second vector.</param>
      <returns>Outer product result.</returns>
    </member>
    <member name="M:BEPUphysics.Toolbox.GetQuaternionBetweenNormalizedVectors(Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Quaternion@)">
      <summary>
            Computes the quaternion rotation between two normalized vectors.
            </summary>
      <param name="v1">First unit-length vector.</param>
      <param name="v2">Second unit-length vector.</param>
      <param name="q">Quaternion representing the rotation from v1 to v2.</param>
    </member>
    <member name="M:BEPUphysics.Toolbox.GetTransposedVector(Microsoft.Xna.Framework.Vector3)">
      <summary>
            Finds the transposed matrix of a vector.
            </summary>
      <param name="v">Vector to be transposed.</param>
      <returns>Transposed vector in matrix form.</returns>
    </member>
    <member name="M:BEPUphysics.Toolbox.GetVelocityOfPoint(Microsoft.Xna.Framework.Vector3,BEPUphysics.Entities.Entity)">
      <summary>
            Finds the velocity of a point as if it were connected to the given entity.
            </summary>
      <param name="p">Location of point.</param>
      <param name="obj">Collidable for connection.</param>
      <returns>Acceleration of the point.</returns>
    </member>
    <member name="M:BEPUphysics.Toolbox.PruneDirectionalDuplicates(System.Collections.Generic.List{Microsoft.Xna.Framework.Vector3},System.Collections.Generic.List{Microsoft.Xna.Framework.Vector3})">
      <summary>
            Compares elements in the lists, removing any duplicates from the lists.
            Two vectors will be considered duplicate if they are parallel, even if facing opposite directions.
            </summary>
      <param name="a">First set of vectors for comparison.</param>
      <param name="b">Second set of vectors for comparison.</param>
    </member>
    <member name="M:BEPUphysics.Toolbox.UpdateOrientationRK4(Microsoft.Xna.Framework.Quaternion@,BEPUphysics.MathExtensions.Matrix3X3@,Microsoft.Xna.Framework.Vector3@,System.Single,Microsoft.Xna.Framework.Quaternion@)">
      <summary>
            Updates the quaternion using RK4 integration.
            </summary>
      <param name="q">Quaternion to update.</param>
      <param name="localInertiaTensorInverse">Local-space inertia tensor of the object being updated.</param>
      <param name="angularMomentum">Angular momentum of the object.</param>
      <param name="dt">Time since last frame, in seconds.</param>
      <param name="newOrientation">New orientation quaternion.</param>
    </member>
    <member name="M:BEPUphysics.Toolbox.DifferentiateQuaternion(Microsoft.Xna.Framework.Quaternion@,BEPUphysics.MathExtensions.Matrix3X3@,Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Quaternion@)">
      <summary>
            Finds the change in the rotation state quaternion provided the local inertia tensor and angular velocity.
            </summary>
      <param name="orientation">Orienatation of the object.</param>
      <param name="localInertiaTensorInverse">Local-space inertia tensor of the object being updated.</param>
      <param name="angularMomentum">Angular momentum of the object.</param>
      <param name="orientationChange">Change in quaternion.</param>
    </member>
    <member name="M:BEPUphysics.Toolbox.GetSphereVolumeSplitByPlane(Microsoft.Xna.Framework.Vector3,System.Single,System.Single,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,System.Single@)">
      <summary>
            Calculates the volume of the sphere 'below' the given plane.
            </summary>
      <param name="spherePosition">Center of mass of the sphere.</param>
      <param name="sphereVolume">Precalculated total volume of the sphere (4/3 * pi * radius ^ 3).</param>
      <param name="radius">Radius of the sphere.</param>
      <param name="p">A point on the plane.</param>
      <param name="norm">Normal of the plane.</param>
      <param name="volume">Volume of the sphere which is opposite the normal direction.</param>
    </member>
    <member name="T:BEPUphysics.CollisionTests.CollisionAlgorithms.MPRToolbox">
      <summary>
            Contains MPR-based collision queries.
            </summary>
    </member>
    <member name="F:BEPUphysics.CollisionTests.CollisionAlgorithms.MPRToolbox.InnerIterationLimit">
      <summary>
            Number of iterations that the MPR system will run in its inner loop before giving up and returning with failure.
            </summary>
    </member>
    <member name="F:BEPUphysics.CollisionTests.CollisionAlgorithms.MPRToolbox.OuterIterationLimit">
      <summary>
            Number of iterations that the MPR system will run in its outer loop before giving up and moving on to its inner loop.
            </summary>
    </member>
    <member name="M:BEPUphysics.CollisionTests.CollisionAlgorithms.MPRToolbox.AreObjectsColliding(BEPUphysics.CollisionShapes.ConvexShapes.ConvexShape,BEPUphysics.CollisionShapes.ConvexShapes.ConvexShape,BEPUphysics.MathExtensions.RigidTransform@,BEPUphysics.MathExtensions.RigidTransform@)">
      <summary>
            Determines whether or not the given entities are colliding.
            </summary>
      <param name="shapeA">First shape of the pair.</param>
      <param name="shapeB">Second shape of the pair.</param>
      <param name="transformA">Transform to apply to shapeA for the test.</param>
      <param name="transformB">Transform to apply to shapeB for the test.</param>
      <returns>Whether or not the margin-expanded shapes are colliding.</returns>
    </member>
    <member name="M:BEPUphysics.CollisionTests.CollisionAlgorithms.MPRToolbox.AreObjectsColliding(BEPUphysics.CollisionShapes.ConvexShapes.ConvexShape,BEPUphysics.CollisionShapes.ConvexShapes.ConvexShape,BEPUphysics.MathExtensions.RigidTransform@,BEPUphysics.MathExtensions.RigidTransform@,BEPUphysics.CollisionTests.ContactData@)">
      <summary>
            Determines whether or not the given entities are colliding, and if so, returns collision data about them.
            </summary>
      <param name="shapeA">First shape to check.</param>
      <param name="shapeB">Second shape to check.</param>
      <param name="transformA">Transform to apply to shapeA for the test.</param>
      <param name="transformB">Transform to apply to shapeB for the test.</param>
      <param name="contact">Contact data generated by the test, if any.</param>
      <returns>Whether or not the shapes are colliding.</returns>
    </member>
    <member name="M:BEPUphysics.CollisionTests.CollisionAlgorithms.MPRToolbox.FindConservativeDistanceEstimate(BEPUphysics.CollisionShapes.ConvexShapes.ConvexShape,BEPUphysics.CollisionShapes.ConvexShapes.ConvexShape,BEPUphysics.MathExtensions.RigidTransform@,BEPUphysics.MathExtensions.RigidTransform@,Microsoft.Xna.Framework.Vector3@)">
      <summary>
            Finds a estimate of the separation distance between the two bodies' core, non margin-expanded shapes.
            Will be less than or equal to the actual distance.
            </summary>
      <param name="shapeA">First shape to check.</param>
      <param name="shapeB">Second shape to check.</param>
      <param name="transformA">Transform to apply to shapeA for the test.</param>
      <param name="transformB">Transform to apply to shapeB for the test.</param>
      <param name="separatingDirection">Direction along which the distance is measured.</param>
      <returns>Conservative estimate of the distance between the objects.  0 if colliding.</returns>
    </member>
    <member name="M:BEPUphysics.CollisionTests.CollisionAlgorithms.MPRToolbox.FindPenetrationDepth(BEPUphysics.CollisionShapes.ConvexShapes.ConvexShape,BEPUphysics.CollisionShapes.ConvexShapes.ConvexShape,Microsoft.Xna.Framework.Vector3@,BEPUphysics.MathExtensions.RigidTransform@,Microsoft.Xna.Framework.Vector3@)">
      <summary>
            Determines the length of the interpenetrating area along the given normal between the given objects.
            Assumes the two entities are actually colliding.
            </summary>
      <param name="shapeA">First shape to check.</param>
      <param name="shapeB">Second shape to check.</param>
      <param name="v0">Position to warmstart the penetration depth calculation.</param>
      <param name="localTransformB">Transform of shapeB in the local space of A.</param>
      <param name="normal">Direction along which to find the penetration depth.</param>
      <returns>Length of the interpenetrating area along the given normal.</returns>
    </member>
    <member name="M:BEPUphysics.CollisionTests.CollisionAlgorithms.MPRToolbox.IsPointInsideShape(Microsoft.Xna.Framework.Vector3@,BEPUphysics.CollisionShapes.ConvexShapes.ConvexShape,BEPUphysics.MathExtensions.RigidTransform@)">
      <summary>
            Determines whether or the point lies within the entity.
            </summary>
      <param name="p">Location to test for inclusion within the entity.</param>
      <param name="shape">Shape to test.</param>
      <param name="transform">Transform to use for the shape.</param>
      <returns>Whether or not the margin-expanded shape encloses the point.</returns>
    </member>
    <member name="T:BEPUphysics.ProcessingStage">
      <summary>
             Superclass of singlethreaded update systems.
            </summary>
    </member>
    <member name="M:BEPUphysics.ProcessingStage.Update">
      <summary>
             Updates the stage.
            </summary>
    </member>
    <member name="P:BEPUphysics.ProcessingStage.Enabled">
      <summary>
             Gets or sets whether or not the stage should update.
            </summary>
    </member>
    <member name="E:BEPUphysics.ProcessingStage.Starting">
      <summary>
             Fires when the stage starts working.
            </summary>
    </member>
    <member name="E:BEPUphysics.ProcessingStage.Finishing">
      <summary>
             Fires when the stage finishes working.
            </summary>
    </member>
    <member name="T:BEPUphysics.EntityStateManagement.EntityStateWriteBuffer">
      <summary>
             Buffer containing pending writes to entity states.
            </summary>
    </member>
    <member name="M:BEPUphysics.EntityStateManagement.EntityStateWriteBuffer.#ctor">
      <summary>
             Constructs the write buffer.
            </summary>
    </member>
    <member name="M:BEPUphysics.EntityStateManagement.EntityStateWriteBuffer.EnqueuePosition(BEPUphysics.Entities.Entity,Microsoft.Xna.Framework.Vector3@)">
      <summary>
             Enqueues a change to an entity's position.
            </summary>
      <param name="entity">Entity to target.</param>
      <param name="newPosition">New position of the entity.</param>
    </member>
    <member name="M:BEPUphysics.EntityStateManagement.EntityStateWriteBuffer.EnqueueOrientation(BEPUphysics.Entities.Entity,Microsoft.Xna.Framework.Quaternion@)">
      <summary>
             Enqueues a change to an entity's orientation.
            </summary>
      <param name="entity">Entity to target.</param>
      <param name="newOrientationQuaternion">New orientation of the entity.</param>
    </member>
    <member name="M:BEPUphysics.EntityStateManagement.EntityStateWriteBuffer.EnqueueLinearVelocity(BEPUphysics.Entities.Entity,Microsoft.Xna.Framework.Vector3@)">
      <summary>
             Enqueues a change to an entity's linear velocity.
            </summary>
      <param name="entity">Entity to target.</param>
      <param name="newLinearVelocity">New linear velocity of the entity.</param>
    </member>
    <member name="M:BEPUphysics.EntityStateManagement.EntityStateWriteBuffer.EnqueueAngularVelocity(BEPUphysics.Entities.Entity,Microsoft.Xna.Framework.Vector3@)">
      <summary>
             Enqueues a change to an entity's angular velocity.
            </summary>
      <param name="entity">Entity to target.</param>
      <param name="newAngularVelocity">New angular velocity of the entity.</param>
    </member>
    <member name="T:BEPUphysics.EntityStateManagement.StateReadBuffers">
      <summary>
             Manages the buffered states of entities.
            </summary>
    </member>
    <member name="M:BEPUphysics.EntityStateManagement.StateReadBuffers.#ctor(BEPUphysics.EntityStateManagement.BufferedStatesManager)">
      <summary>
             Constructs a read buffer manager.
            </summary>
      <param name="manager">Owning buffered states manager.</param>
    </member>
    <member name="M:BEPUphysics.EntityStateManagement.StateReadBuffers.#ctor(BEPUphysics.EntityStateManagement.BufferedStatesManager,BEPUphysics.Threading.IThreadManager)">
      <summary>
             Constructs a read buffer manager.
            </summary>
      <param name="manager">Owning buffered states manager.</param>
      <param name="threadManager">Thread manager to use.</param>
    </member>
    <member name="M:BEPUphysics.EntityStateManagement.StateReadBuffers.FlipBuffers">
      <summary>
             Acquires a lock on the FlipLocker and forces the internal buffers to flip.
            </summary>
    </member>
    <member name="M:BEPUphysics.EntityStateManagement.StateReadBuffers.GetState(System.Int32)">
      <summary>
             Gets the state of the entity associated with the given index.
             Does not lock the FlipLocker.
            </summary>
      <param name="motionStateIndex">Index of the entity.</param>
      <returns>MotionState of the entity at the index.</returns>
    </member>
    <member name="M:BEPUphysics.EntityStateManagement.StateReadBuffers.GetStates(BEPUphysics.EntityStateManagement.MotionState[])">
      <summary>
             Gets the states of all entities atomically.
            </summary>
      <param name="states">Entity states.</param>
      <exception cref="T:System.InvalidOperationException">Thrown when the array is too small.</exception>
    </member>
    <member name="P:BEPUphysics.EntityStateManagement.StateReadBuffers.Enabled">
      <summary>
             Gets or sets whether or not the buffers are active.
            </summary>
      <exception cref="T:System.InvalidOperationException">Thrown if the read buffers are disabled while the interpolated states are enabled.</exception>
    </member>
    <member name="P:BEPUphysics.EntityStateManagement.StateReadBuffers.FlipLocker">
      <summary>
             Gets the synchronization object which is locked during internal buffer flips.
             Acquiring a lock on this object will prevent the manager from flipping the buffers
             for the duration of the lock.
            </summary>
    </member>
    <member name="T:BEPUphysics.CollisionTests.ContactRefresher">
      <summary>
             Helper class that refreshes manifolds to keep them recent.
            </summary>
    </member>
    <member name="M:BEPUphysics.CollisionTests.ContactRefresher.ContactRefresh(BEPUphysics.DataStructures.RawList{BEPUphysics.CollisionTests.Contact},BEPUphysics.DataStructures.RawValueList{BEPUphysics.CollisionTests.ContactSupplementData},BEPUphysics.MathExtensions.RigidTransform@,BEPUphysics.MathExtensions.RigidTransform@,BEPUphysics.DataStructures.RawList{System.Int32})">
      <summary>
            Refreshes the contact manifold, removing any out of date contacts
            and updating others.
            </summary>
    </member>
    <member name="T:BEPUphysics.CollisionTests.CollisionAlgorithms.GJK.GJKToolbox">
      <summary>
             Helper class containing various tests based on GJK.
            </summary>
    </member>
    <member name="F:BEPUphysics.CollisionTests.CollisionAlgorithms.GJK.GJKToolbox.MaximumGJKIterations">
      <summary>
            Maximum number of iterations the GJK algorithm will do.  If the iterations exceed this number, the system will immediately quit and return whatever information it has at the time.
            </summary>
    </member>
    <member name="F:BEPUphysics.CollisionTests.CollisionAlgorithms.GJK.GJKToolbox.HighGJKIterations">
      <summary>
            Defines how many iterations are required to consider a GJK attempt to be 'probably stuck' and proceed with protective measures.
            </summary>
    </member>
    <member name="M:BEPUphysics.CollisionTests.CollisionAlgorithms.GJK.GJKToolbox.AreShapesIntersecting(BEPUphysics.CollisionShapes.ConvexShapes.ConvexShape,BEPUphysics.CollisionShapes.ConvexShapes.ConvexShape,BEPUphysics.MathExtensions.RigidTransform@,BEPUphysics.MathExtensions.RigidTransform@)">
      <summary>
             Tests if the pair is intersecting.
            </summary>
      <param name="shapeA">First shape of the pair.</param>
      <param name="shapeB">Second shape of the pair.</param>
      <param name="transformA">Transform to apply to the first shape.</param>
      <param name="transformB">Transform to apply to the second shape.</param>
      <returns>Whether or not the shapes are intersecting.</returns>
    </member>
    <member name="M:BEPUphysics.CollisionTests.CollisionAlgorithms.GJK.GJKToolbox.AreShapesIntersecting(BEPUphysics.CollisionShapes.ConvexShapes.ConvexShape,BEPUphysics.CollisionShapes.ConvexShapes.ConvexShape,BEPUphysics.MathExtensions.RigidTransform@,BEPUphysics.MathExtensions.RigidTransform@,Microsoft.Xna.Framework.Vector3@)">
      <summary>
             Tests if the pair is intersecting.
            </summary>
      <param name="shapeA">First shape of the pair.</param>
      <param name="shapeB">Second shape of the pair.</param>
      <param name="transformA">Transform to apply to the first shape.</param>
      <param name="transformB">Transform to apply to the second shape.</param>
      <param name="localSeparatingAxis">Warmstartable separating axis used by the method to quickly early-out if possible.  Updated to the latest separating axis after each run.</param>
      <returns>Whether or not the objects were intersecting.</returns>
    </member>
    <member name="M:BEPUphysics.CollisionTests.CollisionAlgorithms.GJK.GJKToolbox.GetClosestPoints(BEPUphysics.CollisionShapes.ConvexShapes.ConvexShape,BEPUphysics.CollisionShapes.ConvexShapes.ConvexShape,BEPUphysics.MathExtensions.RigidTransform@,BEPUphysics.MathExtensions.RigidTransform@,Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Vector3@)">
      <summary>
             Gets the closest points between the shapes.
            </summary>
      <param name="shapeA">First shape of the pair.</param>
      <param name="shapeB">Second shape of the pair.</param>
      <param name="transformA">Transform to apply to the first shape.</param>
      <param name="transformB">Transform to apply to the second shape.</param>
      <param name="closestPointA">Closest point on the first shape to the second shape.</param>
      <param name="closestPointB">Closest point on the second shape to the first shape.</param>
      <returns>Whether or not the objects were intersecting.  If they are intersecting, then the closest points cannot be identified.</returns>
    </member>
    <member name="M:BEPUphysics.CollisionTests.CollisionAlgorithms.GJK.GJKToolbox.GetClosestPoints(BEPUphysics.CollisionShapes.ConvexShapes.ConvexShape,BEPUphysics.CollisionShapes.ConvexShapes.ConvexShape,BEPUphysics.MathExtensions.RigidTransform@,BEPUphysics.MathExtensions.RigidTransform@,BEPUphysics.CollisionTests.CollisionAlgorithms.GJK.CachedSimplex@,Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Vector3@)">
      <summary>
             Gets the closest points between the shapes.
            </summary>
      <param name="shapeA">First shape of the pair.</param>
      <param name="shapeB">Second shape of the pair.</param>
      <param name="transformA">Transform to apply to the first shape.</param>
      <param name="transformB">Transform to apply to the second shape.</param>
      <param name="cachedSimplex">Simplex from a previous updated used to warmstart the current attempt.  Updated after each run.</param>
      <param name="closestPointA">Closest point on the first shape to the second shape.</param>
      <param name="closestPointB">Closest point on the second shape to the first shape.</param>
      <returns>Whether or not the objects were intersecting.  If they are intersecting, then the closest points cannot be identified.</returns>
    </member>
    <member name="M:BEPUphysics.CollisionTests.CollisionAlgorithms.GJK.GJKToolbox.RayCast(Microsoft.Xna.Framework.Ray,BEPUphysics.CollisionShapes.ConvexShapes.ConvexShape,BEPUphysics.MathExtensions.RigidTransform@,System.Single,BEPUphysics.RayHit@)">
      <summary>
             Tests a ray against a convex shape.
            </summary>
      <param name="ray">Ray to test against the shape.</param>
      <param name="shape">Shape to test.</param>
      <param name="shapeTransform">Transform to apply to the shape for the test.</param>
      <param name="maximumLength">Maximum length of the ray in units of the ray direction's length.</param>
      <param name="hit">Hit data of the ray cast, if any.</param>
      <returns>Whether or not the ray hit the shape.</returns>
    </member>
    <member name="M:BEPUphysics.CollisionTests.CollisionAlgorithms.GJK.GJKToolbox.ConvexCast(BEPUphysics.CollisionShapes.ConvexShapes.ConvexShape,BEPUphysics.CollisionShapes.ConvexShapes.ConvexShape,Microsoft.Xna.Framework.Vector3@,BEPUphysics.MathExtensions.RigidTransform@,BEPUphysics.MathExtensions.RigidTransform@,BEPUphysics.RayHit@)">
      <summary>
             Sweeps a shape against another shape using a given sweep vector.
            </summary>
      <param name="sweptShape">Shape to sweep.</param>
      <param name="target">Shape being swept against.</param>
      <param name="sweep">Sweep vector for the sweptShape.</param>
      <param name="startingSweptTransform">Starting transform of the sweptShape.</param>
      <param name="targetTransform">Transform to apply to the target shape.</param>
      <param name="hit">Hit data of the sweep test, if any.</param>
      <returns>Whether or not the swept shape hit the other shape.</returns>
    </member>
    <member name="M:BEPUphysics.CollisionTests.CollisionAlgorithms.GJK.GJKToolbox.ConvexCast(BEPUphysics.CollisionShapes.ConvexShapes.ConvexShape,BEPUphysics.CollisionShapes.ConvexShapes.ConvexShape,Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Vector3@,BEPUphysics.MathExtensions.RigidTransform@,BEPUphysics.MathExtensions.RigidTransform@,BEPUphysics.RayHit@)">
      <summary>
             Sweeps two shapes against another.
            </summary>
      <param name="shapeA">First shape being swept.</param>
      <param name="shapeB">Second shape being swept.</param>
      <param name="sweepA">Sweep vector for the first shape.</param>
      <param name="sweepB">Sweep vector for the second shape.</param>
      <param name="transformA">Transform to apply to the first shape.</param>
      <param name="transformB">Transform to apply to the second shape.</param>
      <param name="hit">Hit data of the sweep test, if any.</param>
      <returns>Whether or not the swept shapes hit each other..</returns>
    </member>
    <member name="M:BEPUphysics.CollisionTests.CollisionAlgorithms.GJK.GJKToolbox.SphereCast(Microsoft.Xna.Framework.Ray,System.Single,BEPUphysics.CollisionShapes.ConvexShapes.ConvexShape,BEPUphysics.MathExtensions.RigidTransform@,System.Single,BEPUphysics.RayHit@)">
      <summary>
             Casts a fat (sphere expanded) ray against the shape.
            </summary>
      <param name="ray">Ray to test against the shape.</param>
      <param name="radius">Radius of the ray.</param>
      <param name="shape">Shape to test against.</param>
      <param name="shapeTransform">Transform to apply to the shape for the test.</param>
      <param name="maximumLength">Maximum length of the ray in units of the ray direction's length.</param>
      <param name="hit">Hit data of the sphere cast, if any.</param>
      <returns>Whether or not the sphere cast hit the shape.</returns>
    </member>
    <member name="M:BEPUphysics.CollisionTests.CollisionAlgorithms.GJK.GJKToolbox.CCDSphereCast(Microsoft.Xna.Framework.Ray,System.Single,BEPUphysics.CollisionShapes.ConvexShapes.ConvexShape,BEPUphysics.MathExtensions.RigidTransform@,System.Single,BEPUphysics.RayHit@)">
      <summary>
             Casts a fat (sphere expanded) ray against the shape.  If the raycast appears to be stuck in the shape, the cast will be attempted
             with a smaller ray (scaled by the MotionSettings.CoreShapeScaling each time).
            </summary>
      <param name="ray">Ray to test against the shape.</param>
      <param name="radius">Radius of the ray.</param>
      <param name="target">Shape to test against.</param>
      <param name="shapeTransform">Transform to apply to the shape for the test.</param>
      <param name="maximumLength">Maximum length of the ray in units of the ray direction's length.</param>
      <param name="hit">Hit data of the sphere cast, if any.</param>
      <returns>Whether or not the sphere cast hit the shape.</returns>
    </member>
    <member name="T:BEPUphysics.CollisionTests.CollisionAlgorithms.GJK.SimpleSimplex">
      <summary>
             GJK simplex supporting boolean intersection tests.
            </summary>
    </member>
    <member name="F:BEPUphysics.CollisionTests.CollisionAlgorithms.GJK.SimpleSimplex.A">
      <summary>
             First vertex of the simplex.
            </summary>
    </member>
    <member name="F:BEPUphysics.CollisionTests.CollisionAlgorithms.GJK.SimpleSimplex.B">
      <summary>
             Second vertex of the simplex.
            </summary>
    </member>
    <member name="F:BEPUphysics.CollisionTests.CollisionAlgorithms.GJK.SimpleSimplex.C">
      <summary>
             Third vertex of the simplex.
            </summary>
    </member>
    <member name="F:BEPUphysics.CollisionTests.CollisionAlgorithms.GJK.SimpleSimplex.D">
      <summary>
             Fourth vertex of the simplex.
            </summary>
    </member>
    <member name="F:BEPUphysics.CollisionTests.CollisionAlgorithms.GJK.SimpleSimplex.State">
      <summary>
             Current state of the simplex.
            </summary>
    </member>
    <member name="M:BEPUphysics.CollisionTests.CollisionAlgorithms.GJK.SimpleSimplex.GetPointClosestToOrigin(Microsoft.Xna.Framework.Vector3@)">
      <summary>
             Gets the point on the simplex closest to the origin.
            </summary>
      <param name="point">Closest point to the origin.</param>
      <returns>Whether or not the simplex encloses the origin.</returns>
    </member>
    <member name="M:BEPUphysics.CollisionTests.CollisionAlgorithms.GJK.SimpleSimplex.GetPointOnSegmentClosestToOrigin(Microsoft.Xna.Framework.Vector3@)">
      <summary>
             Gets the closest point on the segment to the origin.
            </summary>
      <param name="point">Closest point.</param>
    </member>
    <member name="M:BEPUphysics.CollisionTests.CollisionAlgorithms.GJK.SimpleSimplex.GetPointOnTriangleClosestToOrigin(Microsoft.Xna.Framework.Vector3@)">
      <summary>
             Gets the closest point on the triangle to the origin.
            </summary>
      <param name="point">Closest point.</param>
    </member>
    <member name="M:BEPUphysics.CollisionTests.CollisionAlgorithms.GJK.SimpleSimplex.GetPointOnTetrahedronClosestToOrigin(Microsoft.Xna.Framework.Vector3@)">
      <summary>
             Gets the closest point on the tetrahedron to the origin.
            </summary>
      <param name="point">Closest point.</param>
      <returns>Whether or not the simplex encloses the origin.</returns>
    </member>
    <member name="M:BEPUphysics.CollisionTests.CollisionAlgorithms.GJK.SimpleSimplex.AddNewSimplexPoint(Microsoft.Xna.Framework.Vector3@)">
      <summary>
             Adds a new point to the simplex.
            </summary>
      <param name="point">Point to add.</param>
    </member>
    <member name="M:BEPUphysics.CollisionTests.CollisionAlgorithms.GJK.SimpleSimplex.GetErrorTolerance">
      <summary>
             Gets the error tolerance of the simplex.
            </summary>
      <returns>Error tolerance of the simplex.</returns>
    </member>
    <member name="T:BEPUphysics.CollisionShapes.ConvexShapes.SphereShape">
      <summary>
             Ball-like shape.
            </summary>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.ConvexShapes.SphereShape.#ctor(System.Single)">
      <summary>
             Constructs a new sphere shape.
            </summary>
      <param name="radius">Radius of the sphere.</param>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.ConvexShapes.SphereShape.GetBoundingBox(BEPUphysics.MathExtensions.RigidTransform@,Microsoft.Xna.Framework.BoundingBox@)">
      <summary>
            Gets the bounding box of the shape given a transform.
            </summary>
      <param name="shapeTransform">Transform to use.</param>
      <param name="boundingBox">Bounding box of the transformed shape.</param>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.ConvexShapes.SphereShape.GetLocalExtremePointWithoutMargin(Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Vector3@)">
      <summary>
             Gets the extreme point of the shape in local space in a given direction.
            </summary>
      <param name="direction">Direction to find the extreme point in.</param>
      <param name="extremePoint">Extreme point on the shape.</param>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.ConvexShapes.SphereShape.ComputeMaximumRadius">
      <summary>
            Computes the maximum radius of the shape.
            This is often larger than the actual maximum radius;
            it is simply an approximation that avoids underestimating.
            </summary>
      <returns>Maximum radius of the shape.</returns>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.ConvexShapes.SphereShape.ComputeMinimumRadius">
      <summary>
             Computes the minimum radius of the shape.
             This is often smaller than the actual minimum radius;
             it is simply an approximation that avoids overestimating.
            </summary>
      <returns>Minimum radius of the shape.</returns>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.ConvexShapes.SphereShape.ComputeVolumeDistribution(System.Single@)">
      <summary>
            Computes the volume distribution of the shape as well as its volume.
            The volume distribution can be used to compute inertia tensors when
            paired with mass and other tuning factors.
            </summary>
      <param name="volume">Volume of the shape.</param>
      <returns>Volume distribution of the shape.</returns>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.ConvexShapes.SphereShape.RayTest(Microsoft.Xna.Framework.Ray@,BEPUphysics.MathExtensions.RigidTransform@,System.Single,BEPUphysics.RayHit@)">
      <summary>
            Gets the intersection between the sphere and the ray.
            </summary>
      <param name="ray">Ray to test against the sphere.</param>
      <param name="transform">Transform applied to the convex for the test.</param>
      <param name="maximumLength">Maximum distance to travel in units of the ray direction's length.</param>
      <param name="hit">Ray hit data, if any.</param>
      <returns>Whether or not the ray hit the target.</returns>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.ConvexShapes.SphereShape.ComputeCenter">
      <summary>
            Computes the center of the shape.  This can be considered its 
            center of mass.
            </summary>
      <returns>Center of the shape.</returns>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.ConvexShapes.SphereShape.ComputeCenter(System.Single@)">
      <summary>
            Computes the center of the shape.  This can be considered its 
            center of mass.  This calculation is often associated with the 
            volume calculation, which is given by this method as well.
            </summary>
      <param name="volume">Volume of the shape.</param>
      <returns>Center of the shape.</returns>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.ConvexShapes.SphereShape.ComputeVolume">
      <summary>
            Computes the volume of the shape.
            </summary>
      <returns>Volume of the shape.</returns>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.ConvexShapes.SphereShape.GetMobileInstance">
      <summary>
            Retrieves an instance of an EntityCollidable that uses this EntityShape.  Mainly used by compound bodies.
            </summary>
      <returns>EntityCollidable that uses this shape.</returns>
    </member>
    <member name="P:BEPUphysics.CollisionShapes.ConvexShapes.SphereShape.Radius">
      <summary>
             Gets or sets the radius of the sphere.
            </summary>
    </member>
    <member name="T:BEPUphysics.DataStructures.ObservableList`1">
      <summary>
             List of objects which fires events when it is changed.
            </summary>
      <typeparam name="T">Type of elements in the list.</typeparam>
    </member>
    <member name="M:BEPUphysics.DataStructures.ObservableList`1.#ctor(System.Collections.Generic.IList{`0})">
      <summary>
             Constructs a new observable list.
            </summary>
      <param name="list">List to copy into the internal wrapped list.</param>
    </member>
    <member name="M:BEPUphysics.DataStructures.ObservableList`1.#ctor">
      <summary>
             Constructs an empty observable list.
            </summary>
    </member>
    <member name="M:BEPUphysics.DataStructures.ObservableList`1.#ctor(System.Int32)">
      <summary>
             Constructs an empty observable list with a given capacity.
            </summary>
      <param name="initialCapacity">Initial allocated storage in the list.</param>
    </member>
    <member name="M:BEPUphysics.DataStructures.ObservableList`1.IndexOf(`0)">
      <summary>
            Determines the index of a specific item in the <see cref="T:System.Collections.Generic.IList`1" />.
            </summary>
      <returns>
            The index of <paramref name="item" /> if found in the list; otherwise, -1.
            </returns>
      <param name="item">The object to locate in the <see cref="T:System.Collections.Generic.IList`1" />.</param>
    </member>
    <member name="M:BEPUphysics.DataStructures.ObservableList`1.Insert(System.Int32,`0)">
      <summary>
            Inserts an item to the <see cref="T:System.Collections.Generic.IList`1" /> at the specified index.
            </summary>
      <param name="index">The zero-based index at which <paramref name="item" /> should be inserted.</param>
      <param name="item">The object to insert into the <see cref="T:System.Collections.Generic.IList`1" />.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> is not a valid index in the <see cref="T:System.Collections.Generic.IList`1" />.</exception>
      <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.Generic.IList`1" /> is read-only.</exception>
    </member>
    <member name="M:BEPUphysics.DataStructures.ObservableList`1.RemoveAt(System.Int32)">
      <summary>
            Removes the <see cref="T:System.Collections.Generic.IList`1" /> item at the specified index.
            </summary>
      <param name="index">The zero-based index of the item to remove.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> is not a valid index in the <see cref="T:System.Collections.Generic.IList`1" />.</exception>
      <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.Generic.IList`1" /> is read-only.</exception>
    </member>
    <member name="M:BEPUphysics.DataStructures.ObservableList`1.Add(`0)">
      <summary>
            Adds an item to the <see cref="T:System.Collections.Generic.ICollection`1" />.
            </summary>
      <param name="item">The object to add to the <see cref="T:System.Collections.Generic.ICollection`1" />.</param>
      <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.Generic.ICollection`1" /> is read-only.</exception>
    </member>
    <member name="M:BEPUphysics.DataStructures.ObservableList`1.Clear">
      <summary>
            Removes all items from the <see cref="T:System.Collections.Generic.ICollection`1" />.
            </summary>
      <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.Generic.ICollection`1" /> is read-only. </exception>
    </member>
    <member name="M:BEPUphysics.DataStructures.ObservableList`1.Contains(`0)">
      <summary>
            Determines whether the <see cref="T:System.Collections.Generic.ICollection`1" /> contains a specific value.
            </summary>
      <returns>
            true if <paramref name="item" /> is found in the <see cref="T:System.Collections.Generic.ICollection`1" />; otherwise, false.
            </returns>
      <param name="item">The object to locate in the <see cref="T:System.Collections.Generic.ICollection`1" />.</param>
    </member>
    <member name="M:BEPUphysics.DataStructures.ObservableList`1.CopyTo(`0[],System.Int32)">
      <summary>
            Copies the elements of the <see cref="T:System.Collections.Generic.ICollection`1" /> to an <see cref="T:System.Array" />, starting at a particular <see cref="T:System.Array" /> index.
            </summary>
      <param name="array">The one-dimensional <see cref="T:System.Array" /> that is the destination of the elements copied from <see cref="T:System.Collections.Generic.ICollection`1" />. The <see cref="T:System.Array" /> must have zero-based indexing.</param>
      <param name="arrayIndex">The zero-based index in <paramref name="array" /> at which copying begins.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="array" /> is null.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="arrayIndex" /> is less than 0.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="array" /> is multidimensional.-or-The number of elements in the source <see cref="T:System.Collections.Generic.ICollection`1" /> is greater than the available space from <paramref name="arrayIndex" /> to the end of the destination <paramref name="array" />.-or-Type cannot be cast automatically to the type of the destination <paramref name="array" />.</exception>
    </member>
    <member name="M:BEPUphysics.DataStructures.ObservableList`1.Remove(`0)">
      <summary>
            Removes the first occurrence of a specific object from the <see cref="T:System.Collections.Generic.ICollection`1" />.
            </summary>
      <returns>
            true if <paramref name="item" /> was successfully removed from the <see cref="T:System.Collections.Generic.ICollection`1" />; otherwise, false. This method also returns false if <paramref name="item" /> is not found in the original <see cref="T:System.Collections.Generic.ICollection`1" />.
            </returns>
      <param name="item">The object to remove from the <see cref="T:System.Collections.Generic.ICollection`1" />.</param>
      <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.Generic.ICollection`1" /> is read-only.</exception>
    </member>
    <member name="M:BEPUphysics.DataStructures.ObservableList`1.GetEnumerator">
      <summary>
             Gets an enumerator for the list.
            </summary>
      <returns>Enumerator for the list.</returns>
    </member>
    <member name="P:BEPUphysics.DataStructures.ObservableList`1.Item(System.Int32)">
      <summary>
            Gets or sets the element at the specified index.
            </summary>
      <returns>
            The element at the specified index.
            </returns>
      <param name="index">The zero-based index of the element to get or set.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> is not a valid index in the <see cref="T:System.Collections.Generic.IList`1" />.</exception>
      <exception cref="T:System.NotSupportedException">The property is set and the <see cref="T:System.Collections.Generic.IList`1" /> is read-only.</exception>
    </member>
    <member name="P:BEPUphysics.DataStructures.ObservableList`1.Count">
      <summary>
            Gets the number of elements contained in the <see cref="T:System.Collections.Generic.ICollection`1" />.
            </summary>
      <returns>
            The number of elements contained in the <see cref="T:System.Collections.Generic.ICollection`1" />.
            </returns>
    </member>
    <member name="T:BEPUphysics.NarrowPhaseSystems.Pairs.TerrainConvexPairHandler">
      <summary>
             Handles a terrain-convex collision pair.
            </summary>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.Pairs.TerrainConvexPairHandler.#ctor">
      <summary>
             Constructs a new pair handler.
            </summary>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.Pairs.TerrainConvexPairHandler.Initialize(BEPUphysics.BroadPhaseSystems.BroadPhaseEntry,BEPUphysics.BroadPhaseSystems.BroadPhaseEntry)">
      <summary>
             Initializes the pair handler.
            </summary>
      <param name="entryA">First entry in the pair.</param>
      <param name="entryB">Second entry in the pair.</param>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.Pairs.TerrainConvexPairHandler.UpdateMaterialProperties">
      <summary>
             Forces an update of the pair's material properties.
            </summary>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.Pairs.TerrainConvexPairHandler.OnAddedToNarrowPhase">
      <summary>
             Called when the pair handler is added to the narrow phase.
            </summary>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.Pairs.TerrainConvexPairHandler.CleanUp">
      <summary>
             Cleans up the pair handler.
            </summary>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.Pairs.TerrainConvexPairHandler.UpdateCollision(System.Single)">
      <summary>
             Updates the pair handler.
            </summary>
      <param name="dt">Timestep duration.</param>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.Pairs.TerrainConvexPairHandler.UpdateTimeOfImpact(BEPUphysics.Collidables.Collidable,System.Single)">
      <summary>
             Updates the time of impact for the pair.
            </summary>
      <param name="requester">Collidable requesting the update.</param>
      <param name="dt">Timestep duration.</param>
    </member>
    <member name="T:BEPUphysics.NarrowPhaseSystems.Factories.InstancedMeshConvexPairFactory">
      <summary>
             Manufactures instanced mesh-convex pairs.
            </summary>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.Factories.InstancedMeshConvexPairFactory.GetNarrowPhasePair(BEPUphysics.BroadPhaseSystems.BroadPhaseOverlap)">
      <summary>
             Manufactures and returns a narrow phase pair for the given overlap.
            </summary>
      <param name="overlap">Overlap used to create a pair.</param>
      <returns>Narrow phase pair.</returns>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.Factories.InstancedMeshConvexPairFactory.GiveBack(BEPUphysics.NarrowPhaseSystems.Pairs.INarrowPhasePair)">
      <summary>
            Returns a pair to the factory for re-use.
            </summary>
      <param name="pair">Pair to return.</param>
    </member>
    <member name="T:BEPUphysics.PositionUpdating.DiscretePositionUpdater">
      <summary>
             Discrete position updater.  Similar to the ContinuousPositionUpdater, but
             ignores the continuous state and just updates everything as if it were discrete.
            </summary>
    </member>
    <member name="M:BEPUphysics.PositionUpdating.DiscretePositionUpdater.#ctor(BEPUphysics.TimeStepSettings)">
      <summary>
             Constructs the discrete position updater.
            </summary>
      <param name="timeStepSettings">Time step settings to use.</param>
    </member>
    <member name="M:BEPUphysics.PositionUpdating.DiscretePositionUpdater.#ctor(BEPUphysics.TimeStepSettings,BEPUphysics.Threading.IThreadManager)">
      <summary>
             Constructs the discrete position updater.
            </summary>
      <param name="timeStepSettings">Time step settings to use.</param>
      <param name="threadManager">Thread manager to use.</param>
    </member>
    <member name="M:BEPUphysics.PositionUpdating.DiscretePositionUpdater.Add(BEPUphysics.PositionUpdating.IPositionUpdateable)">
      <summary>
             Adds an updateable to the updater.
            </summary>
      <param name="updateable">Item to add.</param>
      <exception cref="T:System.Exception">Thrown if the updateable already belongs to an updater.</exception>
    </member>
    <member name="M:BEPUphysics.PositionUpdating.DiscretePositionUpdater.Remove(BEPUphysics.PositionUpdating.IPositionUpdateable)">
      <summary>
            Removes an updateable from the updater.
            </summary>
      <param name="updateable">Updateable to remove.</param>
    </member>
    <member name="T:BEPUphysics.NarrowPhaseSystems.Pairs.ContactInformation">
      <summary>
             Contact and some associated data used by the convenience ContactCollection.
            </summary>
    </member>
    <member name="F:BEPUphysics.NarrowPhaseSystems.Pairs.ContactInformation.Contact">
      <summary>
            Contact point in the pair.
            </summary>
    </member>
    <member name="F:BEPUphysics.NarrowPhaseSystems.Pairs.ContactInformation.NormalForce">
      <summary>
            Normal force applied between the objects at the contact point.
            </summary>
    </member>
    <member name="F:BEPUphysics.NarrowPhaseSystems.Pairs.ContactInformation.FrictionForce">
      <summary>
            Friction force applied between the objects at the contact point.
            This is sometimes an approximation due to the varying ways in which
            friction is calculated.
            </summary>
    </member>
    <member name="F:BEPUphysics.NarrowPhaseSystems.Pairs.ContactInformation.RelativeVelocity">
      <summary>
             Relative velocity of the colliding objects at the position of the contact.
            </summary>
    </member>
    <member name="T:BEPUphysics.Entities.Prefabs.TransformableEntity">
      <summary>
            Ball-shaped object that can collide and move.  After making an entity, add it to a Space so that the engine can manage it.
            </summary>
    </member>
    <member name="M:BEPUphysics.Entities.Prefabs.TransformableEntity.#ctor(Microsoft.Xna.Framework.Vector3,BEPUphysics.CollisionShapes.ConvexShapes.ConvexShape,BEPUphysics.MathExtensions.Matrix3X3,System.Single)">
      <summary>
            Constructs a dynamic transformable entity.
            </summary>
      <param name="position">Position of the entity.</param>
      <param name="shape">Shape to transform.</param>
      <param name="transform">Transform to apply to the shape.</param>
      <param name="mass">Mass of the object.</param>
    </member>
    <member name="M:BEPUphysics.Entities.Prefabs.TransformableEntity.#ctor(Microsoft.Xna.Framework.Vector3,BEPUphysics.CollisionShapes.ConvexShapes.ConvexShape,BEPUphysics.MathExtensions.Matrix3X3)">
      <summary>
            Constructs a kinematic transformable entity.
            </summary>
      <param name="position">Position of the entity.</param>
      <param name="shape">Shape to transform.</param>
      <param name="transform">Transform to apply to the shape.</param>
    </member>
    <member name="M:BEPUphysics.Entities.Prefabs.TransformableEntity.#ctor(BEPUphysics.EntityStateManagement.MotionState,BEPUphysics.CollisionShapes.ConvexShapes.ConvexShape,BEPUphysics.MathExtensions.Matrix3X3,System.Single)">
      <summary>
            Constructs a dynamic transformable entity.
            </summary>
      <param name="motionState">Initial motion state of the entity.</param>
      <param name="shape">Shape to transform.</param>
      <param name="transform">Transform to apply to the shape.</param>
      <param name="mass">Mass of the object.</param>
    </member>
    <member name="M:BEPUphysics.Entities.Prefabs.TransformableEntity.#ctor(BEPUphysics.EntityStateManagement.MotionState,BEPUphysics.CollisionShapes.ConvexShapes.ConvexShape,BEPUphysics.MathExtensions.Matrix3X3)">
      <summary>
            Constructs a kinematic transformable entity.
            </summary>
      <param name="motionState">Initial motion state of the entity.</param>
      <param name="shape">Shape to transform.</param>
      <param name="transform">Transform to apply to the shape.</param>
    </member>
    <member name="P:BEPUphysics.Entities.Prefabs.TransformableEntity.Shape">
      <summary>
             Gets the shape on which the transformable shape is based.
            </summary>
    </member>
    <member name="P:BEPUphysics.Entities.Prefabs.TransformableEntity.Transform">
      <summary>
             Gets the linear transform that the shape uses to transform its base shape.
            </summary>
    </member>
    <member name="T:BEPUphysics.Entities.Prefabs.Cylinder">
      <summary>
            Cylinder-shaped object that can collide and move.  After making an entity, add it to a Space so that the engine can manage it.
            </summary>
    </member>
    <member name="M:BEPUphysics.Entities.Prefabs.Cylinder.#ctor(Microsoft.Xna.Framework.Vector3,System.Single,System.Single,System.Single)">
      <summary>
            Constructs a physically simulated cylinder.
            </summary>
      <param name="position">Position of the cylinder.</param>
      <param name="height">Height of the cylinder.</param>
      <param name="radius">Radius of the cylinder.</param>
      <param name="mass">Mass of the object.</param>
    </member>
    <member name="M:BEPUphysics.Entities.Prefabs.Cylinder.#ctor(Microsoft.Xna.Framework.Vector3,System.Single,System.Single)">
      <summary>
            Constructs a nondynamic cylinder.
            </summary>
      <param name="position">Position of the cylinder.</param>
      <param name="height">Height of the cylinder.</param>
      <param name="radius">Radius of the cylinder.</param>
    </member>
    <member name="M:BEPUphysics.Entities.Prefabs.Cylinder.#ctor(BEPUphysics.EntityStateManagement.MotionState,System.Single,System.Single,System.Single)">
      <summary>
            Constructs a physically simulated cylinder.
            </summary>
      <param name="motionState">Motion state specifying the entity's initial state.</param>
      <param name="height">Height of the cylinder.</param>
      <param name="radius">Radius of the cylinder.</param>
      <param name="mass">Mass of the object.</param>
    </member>
    <member name="M:BEPUphysics.Entities.Prefabs.Cylinder.#ctor(BEPUphysics.EntityStateManagement.MotionState,System.Single,System.Single)">
      <summary>
            Constructs a nondynamic cylinder.
            </summary>
      <param name="motionState">Motion state specifying the entity's initial state.</param>
      <param name="height">Height of the cylinder.</param>
      <param name="radius">Radius of the cylinder.</param>
    </member>
    <member name="P:BEPUphysics.Entities.Prefabs.Cylinder.Height">
      <summary>
            Gets or sets the height of the cylinder.
            </summary>
    </member>
    <member name="P:BEPUphysics.Entities.Prefabs.Cylinder.Radius">
      <summary>
            Gets or sets the radius of the cylinder.
            </summary>
    </member>
    <member name="T:BEPUphysics.Constraints.TwoEntity.Motors.LinearAxisMotor">
      <summary>
            Constrains anchors on two entities to move relative to each other on a line.
            </summary>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.Motors.LinearAxisMotor.#ctor">
      <summary>
            Constrains anchors on two entities to move relative to each other on a line.
            To finish the initialization, specify the connections (ConnectionA and ConnectionB) 
            as well as the AnchorA, AnchorB and the Axis (or their entity-local versions).
            This constructor sets the constraint's IsActive property to false by default.
            </summary>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.Motors.LinearAxisMotor.#ctor(BEPUphysics.Entities.Entity,BEPUphysics.Entities.Entity,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3)">
      <summary>
            Constrains anchors on two entities to move relative to each other on a line.
            </summary>
      <param name="connectionA">First connection of the pair.</param>
      <param name="connectionB">Second connection of the pair.</param>
      <param name="anchorA">World space point to attach to connection A that will be constrained.</param>
      <param name="anchorB">World space point to attach to connection B that will be constrained.</param>
      <param name="axis">Limited axis in world space to attach to connection A.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.Motors.LinearAxisMotor.GetLinearJacobianA(Microsoft.Xna.Framework.Vector3@)">
      <summary>
            Gets the linear jacobian entry for the first connected entity.
            </summary>
      <param name="jacobian">Linear jacobian entry for the first connected entity.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.Motors.LinearAxisMotor.GetLinearJacobianB(Microsoft.Xna.Framework.Vector3@)">
      <summary>
            Gets the linear jacobian entry for the second connected entity.
            </summary>
      <param name="jacobian">Linear jacobian entry for the second connected entity.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.Motors.LinearAxisMotor.GetAngularJacobianA(Microsoft.Xna.Framework.Vector3@)">
      <summary>
            Gets the angular jacobian entry for the first connected entity.
            </summary>
      <param name="jacobian">Angular jacobian entry for the first connected entity.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.Motors.LinearAxisMotor.GetAngularJacobianB(Microsoft.Xna.Framework.Vector3@)">
      <summary>
            Gets the angular jacobian entry for the second connected entity.
            </summary>
      <param name="jacobian">Angular jacobian entry for the second connected entity.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.Motors.LinearAxisMotor.GetMassMatrix(System.Single@)">
      <summary>
            Gets the mass matrix of the constraint.
            </summary>
      <param name="outputMassMatrix">Constraint's mass matrix.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.Motors.LinearAxisMotor.SolveIteration">
      <summary>
            Computes one iteration of the constraint to meet the solver updateable's goal.
            </summary>
      <returns>The rough applied impulse magnitude.</returns>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.Motors.LinearAxisMotor.ExclusiveUpdate">
      <summary>
            Performs any pre-solve iteration work that needs exclusive
            access to the members of the solver updateable.
            Usually, this is used for applying warmstarting impulses.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.Motors.LinearAxisMotor.AnchorA">
      <summary>
            Gets or sets the anchor point attached to entity A in world space.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.Motors.LinearAxisMotor.AnchorB">
      <summary>
            Gets or sets the anchor point attached to entity A in world space.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.Motors.LinearAxisMotor.Axis">
      <summary>
            Gets or sets the motorized axis in world space.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.Motors.LinearAxisMotor.LocalAxis">
      <summary>
            Gets or sets the limited axis in the local space of connection A.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.Motors.LinearAxisMotor.LocalOffsetA">
      <summary>
            Gets or sets the offset from the first entity's center of mass to the anchor point in its local space.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.Motors.LinearAxisMotor.LocalOffsetB">
      <summary>
            Gets or sets the offset from the second entity's center of mass to the anchor point in its local space.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.Motors.LinearAxisMotor.OffsetA">
      <summary>
            Gets or sets the offset from the first entity's center of mass to the anchor point in world space.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.Motors.LinearAxisMotor.OffsetB">
      <summary>
            Gets or sets the offset from the second entity's center of mass to the anchor point in world space.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.Motors.LinearAxisMotor.Settings">
      <summary>
            Gets the motor's velocity and servo settings.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.Motors.LinearAxisMotor.RelativeVelocity">
      <summary>
            Gets the current relative velocity between the connected entities with respect to the constraint.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.Motors.LinearAxisMotor.TotalImpulse">
      <summary>
            Gets the total impulse applied by this constraint.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.Motors.LinearAxisMotor.Error">
      <summary>
            Gets the current constraint error.
            If the motor is in velocity only mode, the error will be zero.
            </summary>
    </member>
    <member name="T:BEPUphysics.Constraints.TwoEntity.Joints.TwistJoint">
      <summary>
            Prevents the connected entities from twisting relative to each other.
            Acts like the angular part of a universal joint.
            </summary>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.Joints.TwistJoint.#ctor">
      <summary>
            Constructs a new constraint which prevents the connected entities from twisting relative to each other.
            To finish the initialization, specify the connections (ConnectionA and ConnectionB) 
            as well as the WorldAxisA and WorldAxisB (or their entity-local versions).
            This constructor sets the constraint's IsActive property to false by default.
            </summary>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.Joints.TwistJoint.#ctor(BEPUphysics.Entities.Entity,BEPUphysics.Entities.Entity,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3)">
      <summary>
            Constructs a new constraint which prevents the connected entities from twisting relative to each other.
            </summary>
      <param name="connectionA">First connection of the pair.</param>
      <param name="connectionB">Second connection of the pair.</param>
      <param name="axisA">Twist axis attached to the first connected entity.</param>
      <param name="axisB">Twist axis attached to the second connected entity.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.Joints.TwistJoint.GetLinearJacobianA(Microsoft.Xna.Framework.Vector3@)">
      <summary>
            Gets the linear jacobian entry for the first connected entity.
            </summary>
      <param name="jacobian">Linear jacobian entry for the first connected entity.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.Joints.TwistJoint.GetLinearJacobianB(Microsoft.Xna.Framework.Vector3@)">
      <summary>
            Gets the linear jacobian entry for the second connected entity.
            </summary>
      <param name="jacobian">Linear jacobian entry for the second connected entity.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.Joints.TwistJoint.GetAngularJacobianA(Microsoft.Xna.Framework.Vector3@)">
      <summary>
            Gets the angular jacobian entry for the first connected entity.
            </summary>
      <param name="jacobian">Angular jacobian entry for the first connected entity.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.Joints.TwistJoint.GetAngularJacobianB(Microsoft.Xna.Framework.Vector3@)">
      <summary>
            Gets the angular jacobian entry for the second connected entity.
            </summary>
      <param name="jacobian">Angular jacobian entry for the second connected entity.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.Joints.TwistJoint.GetMassMatrix(System.Single@)">
      <summary>
            Gets the mass matrix of the constraint.
            </summary>
      <param name="outputMassMatrix">Constraint's mass matrix.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.Joints.TwistJoint.SolveIteration">
      <summary>
            Solves for velocity.
            </summary>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.Joints.TwistJoint.Update(System.Single)">
      <summary>
            Do any necessary computations to prepare the constraint for this frame.
            </summary>
      <param name="dt">Simulation step length.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.Joints.TwistJoint.ExclusiveUpdate">
      <summary>
            Performs any pre-solve iteration work that needs exclusive
            access to the members of the solver updateable.
            Usually, this is used for applying warmstarting impulses.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.Joints.TwistJoint.LocalAxisA">
      <summary>
            Gets or sets the axis attached to the first connected entity in its local space.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.Joints.TwistJoint.LocalAxisB">
      <summary>
            Gets or sets the axis attached to the first connected entity in its local space.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.Joints.TwistJoint.WorldAxisA">
      <summary>
            Gets or sets the axis attached to the first connected entity in world space.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.Joints.TwistJoint.WorldAxisB">
      <summary>
            Gets or sets the axis attached to the first connected entity in world space.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.Joints.TwistJoint.RelativeVelocity">
      <summary>
            Gets the current relative velocity between the connected entities with respect to the constraint.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.Joints.TwistJoint.TotalImpulse">
      <summary>
            Gets the total impulse applied by this constraint.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.Joints.TwistJoint.Error">
      <summary>
            Gets the current constraint error.
            </summary>
    </member>
    <member name="T:BEPUphysics.Constraints.SolverGroups.PrismaticJoint">
      <summary>
            Restricts two degrees of linear freedom and all three degrees of angular freedom.
            </summary>
    </member>
    <member name="M:BEPUphysics.Constraints.SolverGroups.PrismaticJoint.#ctor">
      <summary>
            Constructs a new constraint which restricts two degrees of linear freedom and all three degrees of angular freedom.
            This constructs the internal constraints, but does not configure them.  Before using a constraint constructed in this manner,
            ensure that its active constituent constraints are properly configured.  The entire group as well as all internal constraints are initially inactive (IsActive = false).
            </summary>
    </member>
    <member name="M:BEPUphysics.Constraints.SolverGroups.PrismaticJoint.#ctor(BEPUphysics.Entities.Entity,BEPUphysics.Entities.Entity,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3)">
      <summary>
            Constructs a new constraint which restricts two degrees of linear freedom and all three degrees of angular freedom.
            </summary>
      <param name="connectionA">First entity of the constraint pair.</param>
      <param name="connectionB">Second entity of the constraint pair.</param>
      <param name="lineAnchor">Location of the anchor for the line to be attached to connectionA in world space.</param>
      <param name="lineDirection">Axis in world space to be attached to connectionA along which connectionB can move.</param>
      <param name="pointAnchor">Location of the anchor for the point to be attached to connectionB in world space.</param>
    </member>
    <member name="P:BEPUphysics.Constraints.SolverGroups.PrismaticJoint.AngularJoint">
      <summary>
            Gets the angular joint which removes three degrees of freedom.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.SolverGroups.PrismaticJoint.Limit">
      <summary>
            Gets the distance limits for the slider.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.SolverGroups.PrismaticJoint.Motor">
      <summary>
            Gets the slider motor.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.SolverGroups.PrismaticJoint.PointOnLineJoint">
      <summary>
            Gets the line joint that restricts two linear degrees of freedom.
            </summary>
    </member>
    <member name="T:BEPUphysics.CollisionTests.Manifolds.StaticMeshConvexContactManifold">
      <summary>
             Manages persistent contacts between a static mesh and a convex.
            </summary>
    </member>
    <member name="M:BEPUphysics.CollisionTests.Manifolds.StaticMeshConvexContactManifold.CleanUp">
      <summary>
             Cleans up the manifold.
            </summary>
    </member>
    <member name="M:BEPUphysics.CollisionTests.Manifolds.StaticMeshConvexContactManifold.Initialize(BEPUphysics.Collidables.Collidable,BEPUphysics.Collidables.Collidable)">
      <summary>
             Initializes the manifold.
            </summary>
      <param name="newCollidableA">First collidable.</param>
      <param name="newCollidableB">Second collidable.</param>
    </member>
    <member name="P:BEPUphysics.CollisionTests.Manifolds.StaticMeshConvexContactManifold.Mesh">
      <summary>
             Gets the static mesh associated with this pair.
            </summary>
    </member>
    <member name="T:BEPUphysics.Threading.ThreadTaskManager">
      <summary>
            Keeps track of the threads currently available to the physics engine.
            </summary>
    </member>
    <member name="M:BEPUphysics.Threading.ThreadTaskManager.WorkerThread.ThreadExecutionLoop">
      <exception cref="T:System.ArithmeticException">Thrown when the thread encounters an invalid state; generally propagated float.NaN's.</exception>
    </member>
    <member name="F:BEPUphysics.Threading.ThreadTaskManager.currentTaskAllocationIndex">
      <summary>
            Index into the thread loop lists, incremented after each task allocation.
            </summary>
    </member>
    <member name="M:BEPUphysics.Threading.ThreadTaskManager.#ctor">
      <summary>
            Constructs a new thread task manager.
            </summary>
    </member>
    <member name="M:BEPUphysics.Threading.ThreadTaskManager.Finalize">
      <summary>
            Releases resources used by the object.
            </summary>
    </member>
    <member name="M:BEPUphysics.Threading.ThreadTaskManager.WaitForTaskCompletion">
      <summary>
            Blocks the current thread until all tasks have been completed.
            </summary>
    </member>
    <member name="M:BEPUphysics.Threading.ThreadTaskManager.AddThread">
      <summary>
            Adds a thread to the manager.
            </summary>
    </member>
    <member name="M:BEPUphysics.Threading.ThreadTaskManager.AddThread(System.Action{System.Object},System.Object)">
      <summary>
            Adds a thread to the manager.
            </summary>
      <param name="initialization">A function to run to perform any initialization on the new thread.</param>
      <param name="initializationInformation">Data to give the ParameterizedThreadStart for initialization.</param>
    </member>
    <member name="M:BEPUphysics.Threading.ThreadTaskManager.RemoveThread">
      <summary>
            Removes a thread from the manager.
            </summary>
    </member>
    <member name="M:BEPUphysics.Threading.ThreadTaskManager.EnqueueTask(System.Action{System.Object},System.Object)">
      <summary>
            Gives the thread manager a new task to run.
            </summary>
      <param name="task">Task to run.</param>
      <param name="taskInformation">Information to be used by the task.</param>
    </member>
    <member name="M:BEPUphysics.Threading.ThreadTaskManager.ForLoop(System.Int32,System.Int32,System.Action{System.Int32})">
      <summary>
            Loops from the starting index (inclusive) to the ending index (exclusive), calling the loopBody at each iteration.
            The forLoop function will not return until all iterations are complete.
            This is meant to be used in a 'fork-join' model; only a single thread should be running a forLoop
            at any time.
            </summary>
      <param name="startIndex">Inclusive starting index.</param>
      <param name="endIndex">Exclusive ending index.</param>
      <param name="loopBody">Function that handles an individual iteration of the loop.</param>
    </member>
    <member name="M:BEPUphysics.Threading.ThreadTaskManager.Dispose">
      <summary>
            Releases resources used by the object.
            </summary>
    </member>
    <member name="M:BEPUphysics.Threading.ThreadTaskManager.EnqueueTaskSequentially(System.Action{System.Object},System.Object)">
      <summary>
            Enqueues a task.
            This method also does not perform any locking; it should only be called when all worker threads of the thread pool are idle and all calls to this method are from the same thread.
            </summary>
      <param name="task">Task to enqueue.</param>
      <param name="taskInformation">Information for the task.</param>
    </member>
    <member name="P:BEPUphysics.Threading.ThreadTaskManager.LoopTasksPerThread">
      <summary>
            Gets or sets the number of tasks to create per thread when doing forLoops.
            </summary>
    </member>
    <member name="P:BEPUphysics.Threading.ThreadTaskManager.ThreadCount">
      <summary>
            Gets the number of threads currently handled by the manager.
            </summary>
    </member>
    <member name="T:BEPUphysics.ResourceManagement.LockingResourcePool`1">
      <summary>
            Uses a spinlock to safely access resources.
            </summary>
      <typeparam name="T">Type of object to store in the pool.</typeparam>
    </member>
    <member name="M:BEPUphysics.ResourceManagement.LockingResourcePool`1.#ctor(System.Int32,System.Action{`0})">
      <summary>
            Constructs a new thread-unsafe resource pool.
            </summary>
      <param name="initialResourceCount">Number of resources to include in the pool by default.</param>
      <param name="initializer">Function to initialize new instances in the resource pool with.</param>
    </member>
    <member name="M:BEPUphysics.ResourceManagement.LockingResourcePool`1.#ctor(System.Int32)">
      <summary>
            Constructs a new thread-unsafe resource pool.
            </summary>
      <param name="initialResourceCount">Number of resources to include in the pool by default.</param>
    </member>
    <member name="M:BEPUphysics.ResourceManagement.LockingResourcePool`1.#ctor">
      <summary>
            Constructs a new thread-unsafe resource pool.
            </summary>
    </member>
    <member name="M:BEPUphysics.ResourceManagement.LockingResourcePool`1.GiveBack(`0)">
      <summary>
            Gives an item back to the resource pool.
            </summary>
      <param name="item">Item to return.</param>
    </member>
    <member name="M:BEPUphysics.ResourceManagement.LockingResourcePool`1.Initialize(System.Int32)">
      <summary>
            Initializes the pool with some resources.
            Throws away excess resources.
            </summary>
      <param name="initialResourceCount">Number of resources to include.</param>
    </member>
    <member name="M:BEPUphysics.ResourceManagement.LockingResourcePool`1.Take">
      <summary>
            Takes an item from the resource pool.
            </summary>
      <returns>Item to take.</returns>
    </member>
    <member name="P:BEPUphysics.ResourceManagement.LockingResourcePool`1.Count">
      <summary>
            Gets the number of resources in the pool.
            Even if the resource count hits 0, resources
            can still be requested; they will be allocated
            dynamically.
            </summary>
    </member>
    <member name="T:BEPUphysics.EntityStateManagement.BufferedStatesAccessor">
      <summary>
             Acts as an entity's view into the buffered states system.
             Buffered states are updated each frame and contain the latest known states.
             These states can also be written to.  Writes will not be immediately visible;
             the next frame's write buffer flush will write the changes to the entities.
            </summary>
    </member>
    <member name="M:BEPUphysics.EntityStateManagement.BufferedStatesAccessor.#ctor(BEPUphysics.EntityStateManagement.EntityBufferedStates)">
      <summary>
             Constructs a new accessor.
            </summary>
      <param name="bufferedStates">The owning states system.</param>
    </member>
    <member name="P:BEPUphysics.EntityStateManagement.BufferedStatesAccessor.WriteBuffer">
      <summary>
             Gets and sets the states write buffer used when buffered properties are written.
            </summary>
    </member>
    <member name="P:BEPUphysics.EntityStateManagement.BufferedStatesAccessor.Position">
      <summary>
             Gets or sets the buffered position of the entity.
            </summary>
    </member>
    <member name="P:BEPUphysics.EntityStateManagement.BufferedStatesAccessor.Orientation">
      <summary>
             Gets or sets the buffered orientation quaternion of the entity.
            </summary>
    </member>
    <member name="P:BEPUphysics.EntityStateManagement.BufferedStatesAccessor.OrientationMatrix">
      <summary>
             Gets or sets the buffered orientation matrix of the entity.
            </summary>
    </member>
    <member name="P:BEPUphysics.EntityStateManagement.BufferedStatesAccessor.LinearVelocity">
      <summary>
             Gets or sets the buffered linear velocity of the entity.
            </summary>
    </member>
    <member name="P:BEPUphysics.EntityStateManagement.BufferedStatesAccessor.AngularVelocity">
      <summary>
             Gets or sets the buffered angular velocity of the entity.
            </summary>
    </member>
    <member name="P:BEPUphysics.EntityStateManagement.BufferedStatesAccessor.WorldTransform">
      <summary>
             Gets or sets the buffered world transform of the entity.
            </summary>
    </member>
    <member name="P:BEPUphysics.EntityStateManagement.BufferedStatesAccessor.MotionState">
      <summary>
             Gets or sets the buffered motion state of the entity.
            </summary>
    </member>
    <member name="T:BEPUphysics.DataStructures.RawValueList`1">
      <summary>
             No-frills list used for value types that contain no reference types.
            </summary>
      <typeparam name="T">Type of the elements in the list.</typeparam>
    </member>
    <member name="F:BEPUphysics.DataStructures.RawValueList`1.Elements">
      <summary>
             Directly accessible array of elements in the list.
             Be careful about which operations are applied to the array;
             if in doubt, use the regular access methods.
            </summary>
    </member>
    <member name="M:BEPUphysics.DataStructures.RawValueList`1.#ctor">
      <summary>
             Constructs an empty list.
            </summary>
    </member>
    <member name="M:BEPUphysics.DataStructures.RawValueList`1.#ctor(System.Int32)">
      <summary>
             Constructs an empty list.
            </summary>
      <param name="initialCapacity">Initial capacity of the list.</param>
      <exception cref="T:System.ArgumentException">Thrown when the initial capcity is less than or equal to zero.</exception>
    </member>
    <member name="M:BEPUphysics.DataStructures.RawValueList`1.RemoveAt(System.Int32)">
      <summary>
             Removes an element from the list.
            </summary>
      <param name="index">Index of the element to remove.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">Thrown when the index is not present in the list.</exception>
    </member>
    <member name="M:BEPUphysics.DataStructures.RawValueList`1.Add(`0@)">
      <summary>
             Adds an element to the list.
            </summary>
      <param name="item">Item to add.</param>
    </member>
    <member name="M:BEPUphysics.DataStructures.RawValueList`1.Clear">
      <summary>
             Clears the list of all elements.
            </summary>
    </member>
    <member name="M:BEPUphysics.DataStructures.RawValueList`1.Remove(`0@)">
      <summary>
             Removes an element from the list.
            </summary>
      <param name="item">Item to remove.</param>
      <returns>Whether or not the item was present in the list.</returns>
    </member>
    <member name="M:BEPUphysics.DataStructures.RawValueList`1.IndexOf(`0@)">
      <summary>
             Gets the index of an element in the list.
            </summary>
      <param name="item">Item to search for.</param>
      <returns>Index of the searched element.</returns>
    </member>
    <member name="P:BEPUphysics.DataStructures.RawValueList`1.Count">
      <summary>
             The number of elements in the list.
            </summary>
    </member>
    <member name="P:BEPUphysics.DataStructures.RawValueList`1.Capacity">
      <summary>
             Gets or sets the current size allocated for the list.
            </summary>
    </member>
    <member name="T:BEPUphysics.CollisionRuleManagement.CollisionGroup">
      <summary>
            A group which can have interaction rules created between it and other collision groups.
            Every entity has a collision group and considers the group's interaction rules in collisions with other entities.
            </summary>
    </member>
    <member name="M:BEPUphysics.CollisionRuleManagement.CollisionGroup.#ctor">
      <summary>
            Constructs a new collision group.
            </summary>
    </member>
    <member name="M:BEPUphysics.CollisionRuleManagement.CollisionGroup.DefineCollisionRule(BEPUphysics.CollisionRuleManagement.CollisionGroup,BEPUphysics.CollisionRuleManagement.CollisionGroup,BEPUphysics.CollisionRuleManagement.CollisionRule,BEPUphysics.Space)">
      <summary>
            Defines the CollisionRule between the two groups for a given space.
            </summary>
      <param name="groupA">First CollisionGroup of the pair.</param>
      <param name="groupB">Second CollisionGroup of the pair.</param>
      <param name="rule">CollisionRule to use between the pair.</param>
      <param name="space">Space to add the rule to.</param>
    </member>
    <member name="M:BEPUphysics.CollisionRuleManagement.CollisionGroup.DefineCollisionRulesBetweenSets(System.Collections.Generic.List{BEPUphysics.CollisionRuleManagement.CollisionGroup},System.Collections.Generic.List{BEPUphysics.CollisionRuleManagement.CollisionGroup},BEPUphysics.CollisionRuleManagement.CollisionRule,BEPUphysics.Space)">
      <summary>
            Defines a CollisionRule between every group in the first set and every group in the second set for a given space.
            </summary>
      <param name="aGroups">First set of groups.</param>
      <param name="bGroups">Second set of groups.</param>
      <param name="rule">Collision rule to define between the sets.</param>
      <param name="space">Space to add the rules to.</param>
    </member>
    <member name="M:BEPUphysics.CollisionRuleManagement.CollisionGroup.DefineCollisionRulesInSet(System.Collections.Generic.List{BEPUphysics.CollisionRuleManagement.CollisionGroup},BEPUphysics.CollisionRuleManagement.CollisionRule,BEPUphysics.CollisionRuleManagement.CollisionRule,BEPUphysics.Space)">
      <summary>
            Defines a CollisionRule between every group in a set with itself and the others in the set for a given space.
            </summary>
      <param name="groups">Set of CollisionGroups.</param>
      <param name="self">CollisionRule between each group and itself.</param>
      <param name="other">CollisionRule between each group and every other group in the set.</param>
      <param name="space">Space to add the rules to.</param>
    </member>
    <member name="M:BEPUphysics.CollisionRuleManagement.CollisionGroup.DefineCollisionRulesWithSet(BEPUphysics.CollisionRuleManagement.CollisionGroup,System.Collections.Generic.List{BEPUphysics.CollisionRuleManagement.CollisionGroup},BEPUphysics.CollisionRuleManagement.CollisionRule,BEPUphysics.Space)">
      <summary>
            Defines a CollisionRule between a group and every group in a set of groups for a given space.
            </summary>
      <param name="group">First CollisionGroup of the pair.</param>
      <param name="groups">Set of CollisionGroups; each group will have its CollisionRule with the first group defined.</param>
      <param name="rule">CollisionRule to use between the pairs.</param>
      <param name="space">Space to add the rules to.</param>
    </member>
    <member name="M:BEPUphysics.CollisionRuleManagement.CollisionGroup.RemoveCollisionRule(BEPUphysics.CollisionRuleManagement.CollisionGroup,BEPUphysics.CollisionRuleManagement.CollisionGroup,BEPUphysics.Space)">
      <summary>
            Removes any rule between the two groups in the space.
            </summary>
      <param name="groupA">First CollisionGroup of the pair.</param>
      <param name="groupB">SecondCollisionGroup of the pair.</param>
      <param name="space">Space to remove the rule from.</param>
    </member>
    <member name="M:BEPUphysics.CollisionRuleManagement.CollisionGroup.RemoveCollisionRulesBetweenSets(System.Collections.Generic.List{BEPUphysics.CollisionRuleManagement.CollisionGroup},System.Collections.Generic.List{BEPUphysics.CollisionRuleManagement.CollisionGroup},BEPUphysics.Space)">
      <summary>
            Removes any rule between every group in the first set and every group in the second set for a given space.
            </summary>
      <param name="aGroups">First set of groups.</param>
      <param name="bGroups">Second set of groups.</param>
      <param name="space">Space to remove the rules from.</param>
    </member>
    <member name="M:BEPUphysics.CollisionRuleManagement.CollisionGroup.RemoveCollisionRulesInSet(System.Collections.Generic.List{BEPUphysics.CollisionRuleManagement.CollisionGroup},BEPUphysics.Space)">
      <summary>
            Removes any rule between every group in a set with itself and the others in the set for a given space.
            </summary>
      <param name="groups">Set of CollisionGroups.</param>
      <param name="space">Space to remove the rules from.</param>
    </member>
    <member name="M:BEPUphysics.CollisionRuleManagement.CollisionGroup.RemoveCollisionRulesWithSet(BEPUphysics.CollisionRuleManagement.CollisionGroup,System.Collections.Generic.List{BEPUphysics.CollisionRuleManagement.CollisionGroup},BEPUphysics.Space)">
      <summary>
            Removes any rule between a group and every group in a set of groups for a given space.
            </summary>
      <param name="group">First CollisionGroup of the pair.</param>
      <param name="groups">Set of CollisionGroups; each group will have its CollisionRule with the first group removed.</param>
      <param name="space">Space to remove the rules from.</param>
    </member>
    <member name="M:BEPUphysics.CollisionRuleManagement.CollisionGroup.GetHashCode">
      <summary>
            Gets a hash code for the object.
            </summary>
      <returns>Hash code for the object.</returns>
    </member>
    <member name="T:BEPUphysics.OtherSpaceStages.ForceUpdater">
      <summary>
             Applies forces to managed objects.
            </summary>
    </member>
    <member name="M:BEPUphysics.OtherSpaceStages.ForceUpdater.#ctor(BEPUphysics.TimeStepSettings)">
      <summary>
             Constructs the force updater.
            </summary>
      <param name="timeStepSettings">Time step settings to use.</param>
    </member>
    <member name="M:BEPUphysics.OtherSpaceStages.ForceUpdater.#ctor(BEPUphysics.TimeStepSettings,BEPUphysics.Threading.IThreadManager)">
      <summary>
             Constructs the force updater.
            </summary>
      <param name="timeStepSettings">Time step settings to use.</param>
      <param name="threadManager">Thread manager to use.</param>
    </member>
    <member name="M:BEPUphysics.OtherSpaceStages.ForceUpdater.Add(BEPUphysics.OtherSpaceStages.IForceUpdateable)">
      <summary>
             Adds a force updateable to the force updater.
            </summary>
      <param name="forceUpdateable">Item to add.</param>
      <exception cref="T:System.Exception">Thrown when the item already belongs to a force updater.</exception>
    </member>
    <member name="M:BEPUphysics.OtherSpaceStages.ForceUpdater.Remove(BEPUphysics.OtherSpaceStages.IForceUpdateable)">
      <summary>
             Removes a force updateable from the force updater.
            </summary>
      <param name="forceUpdateable">Item to remove.</param>
      <exception cref="T:System.Exception">Thrown when the item does not belong to this force updater or its state is corrupted.</exception>
    </member>
    <member name="M:BEPUphysics.OtherSpaceStages.ForceUpdater.ForceUpdateableBecomingDynamic(BEPUphysics.OtherSpaceStages.IForceUpdateable)">
      <summary>
            Notifies the system that a force updateable is becoming dynamic.
            </summary>
      <param name="updateable">Updateable changing state.</param>
    </member>
    <member name="M:BEPUphysics.OtherSpaceStages.ForceUpdater.ForceUpdateableBecomingKinematic(BEPUphysics.OtherSpaceStages.IForceUpdateable)">
      <summary>
            Notifies the system that a force updateable is becoming kinematic.
            </summary>
      <param name="updateable">Updateable changing state.</param>
    </member>
    <member name="P:BEPUphysics.OtherSpaceStages.ForceUpdater.Gravity">
      <summary>
             Gets or sets the gravity applied by the force updater.
            </summary>
    </member>
    <member name="P:BEPUphysics.OtherSpaceStages.ForceUpdater.TimeStepSettings">
      <summary>
             Gets or sets the time step settings used by the force updater.
            </summary>
    </member>
    <member name="T:BEPUphysics.UpdateableSystems.IBeforeNarrowPhaseUpdateable">
      <summary>
             Defines an object which is updated by the space before the narrow phase runs.
            </summary>
    </member>
    <member name="M:BEPUphysics.UpdateableSystems.IBeforeNarrowPhaseUpdateable.Update(System.Single)">
      <summary>
             Updates the updateable before the narrow phase..
            </summary>
      <param name="dt">Time step duration.</param>
    </member>
    <member name="T:BEPUphysics.UpdateableSystems.FluidVolume">
      <summary>
            Volume in which physically simulated objects have a buoyancy force applied to them based on their density and volume.
            </summary>
    </member>
    <member name="M:BEPUphysics.UpdateableSystems.FluidVolume.#ctor(Microsoft.Xna.Framework.Vector3,System.Single,System.Collections.Generic.List{Microsoft.Xna.Framework.Vector3[]},System.Single,System.Single,System.Single,System.Single,BEPUphysics.BroadPhaseSystems.IQueryAccelerator,BEPUphysics.Threading.IThreadManager)">
      <summary>
            Creates a fluid volume.
            </summary>
      <param name="upVector">Up vector of the fluid volume.</param>
      <param name="gravity">Strength of gravity for the purposes of the fluid volume.</param>
      <param name="surfaceTriangles">List of triangles composing the surface of the fluid.  Set up as a list of length 3 arrays of Vector3's.</param>
      <param name="depth">Depth of the fluid back along the surface normal.</param>
      <param name="fluidDensity">Density of the fluid represented in the volume.</param>
      <param name="linearDamping">Fraction by which to reduce the linear momentum of floating objects each update, in addition to any of the body's own damping.</param>
      <param name="angularDamping">Fraction by which to reduce the angular momentum of floating objects each update, in addition to any of the body's own damping.</param>
      <param name="queryAccelerator">System to accelerate queries to find nearby entities.</param>
      <param name="threadManager">Thread manager used by the fluid volume.</param>
    </member>
    <member name="M:BEPUphysics.UpdateableSystems.FluidVolume.RecalculateBoundingBox">
      <summary>
            Recalculates the bounding box of the fluid based on its depth, surface normal, and surface triangles.
            </summary>
    </member>
    <member name="P:BEPUphysics.UpdateableSystems.FluidVolume.UpVector">
      <summary>
             Gets the up vector of the fluid volume.
            </summary>
    </member>
    <member name="P:BEPUphysics.UpdateableSystems.FluidVolume.BoundingBox">
      <summary>
            Bounding box surrounding the surface tris and entire depth of the object.
            </summary>
    </member>
    <member name="P:BEPUphysics.UpdateableSystems.FluidVolume.MaxDepth">
      <summary>
            Maximum depth of the fluid from the surface.
            </summary>
    </member>
    <member name="P:BEPUphysics.UpdateableSystems.FluidVolume.Density">
      <summary>
            Density of the fluid represented in the volume.
            </summary>
    </member>
    <member name="P:BEPUphysics.UpdateableSystems.FluidVolume.SamplePointsPerDimension">
      <summary>
            Number of locations along each of the horizontal axes from which to sample the shape.
            Defaults to 8.
            </summary>
    </member>
    <member name="P:BEPUphysics.UpdateableSystems.FluidVolume.LinearDamping">
      <summary>
            Fraction by which to reduce the linear momentum of floating objects each update.
            </summary>
    </member>
    <member name="P:BEPUphysics.UpdateableSystems.FluidVolume.AngularDamping">
      <summary>
            Fraction by which to reduce the angular momentum of floating objects each update.
            </summary>
    </member>
    <member name="P:BEPUphysics.UpdateableSystems.FluidVolume.FlowDirection">
      <summary>
            Direction in which to exert force on objects within the fluid.
            flowForce and maxFlowSpeed must have valid values as well for the flow to work.
            </summary>
    </member>
    <member name="P:BEPUphysics.UpdateableSystems.FluidVolume.FlowForce">
      <summary>
            Magnitude of the flow's force, in units of flow direction.
            flowDirection and maxFlowSpeed must have valid values as well for the flow to work.
            </summary>
    </member>
    <member name="P:BEPUphysics.UpdateableSystems.FluidVolume.MaxFlowSpeed">
      <summary>
            Maximum speed of the flow; objects will not be accelerated by the flow force beyond this speed.
            flowForce and flowDirection must have valid values as well for the flow to work.
            </summary>
    </member>
    <member name="P:BEPUphysics.UpdateableSystems.FluidVolume.ThreadManager">
      <summary>
             Gets or sets the thread manager used by the fluid volume.
            </summary>
    </member>
    <member name="P:BEPUphysics.UpdateableSystems.FluidVolume.SurfaceTriangles">
      <summary>
            List of coplanar triangles composing the surface of the fluid.
            </summary>
    </member>
    <member name="P:BEPUphysics.UpdateableSystems.FluidVolume.Gravity">
      <summary>
             Gets or sets the gravity used by the fluid volume.
            </summary>
    </member>
    <member name="T:BEPUphysics.Constraints.TwoEntity.JointLimits.SwingLimit">
      <summary>
            Keeps the angle between the axes attached to two entities below some maximum value.
            </summary>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.JointLimits.SwingLimit.#ctor">
      <summary>
            Constructs a new constraint which attempts to restrict the maximum relative angle of two entities to some value.
            To finish the initialization, specify the connections (ConnectionA and ConnectionB) 
            as well as the WorldAxisA, WorldAxisB (or their entity-local versions) and the MaximumAngle.
            This constructor sets the constraint's IsActive property to false by default.
            </summary>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.JointLimits.SwingLimit.#ctor(BEPUphysics.Entities.Entity,BEPUphysics.Entities.Entity,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,System.Single)">
      <summary>
            Constructs a new constraint which attempts to restrict the maximum relative angle of two entities to some value.
            </summary>
      <param name="connectionA">First connection of the pair.</param>
      <param name="connectionB">Second connection of the pair.</param>
      <param name="axisA">Axis attached to the first connected entity.</param>
      <param name="axisB">Axis attached to the second connected entity.</param>
      <param name="maximumAngle">Maximum angle between the axes allowed.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.JointLimits.SwingLimit.GetLinearJacobianA(Microsoft.Xna.Framework.Vector3@)">
      <summary>
            Gets the linear jacobian entry for the first connected entity.
            </summary>
      <param name="jacobian">Linear jacobian entry for the first connected entity.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.JointLimits.SwingLimit.GetLinearJacobianB(Microsoft.Xna.Framework.Vector3@)">
      <summary>
            Gets the linear jacobian entry for the second connected entity.
            </summary>
      <param name="jacobian">Linear jacobian entry for the second connected entity.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.JointLimits.SwingLimit.GetAngularJacobianA(Microsoft.Xna.Framework.Vector3@)">
      <summary>
            Gets the angular jacobian entry for the first connected entity.
            </summary>
      <param name="jacobian">Angular jacobian entry for the first connected entity.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.JointLimits.SwingLimit.GetAngularJacobianB(Microsoft.Xna.Framework.Vector3@)">
      <summary>
            Gets the angular jacobian entry for the second connected entity.
            </summary>
      <param name="jacobian">Angular jacobian entry for the second connected entity.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.JointLimits.SwingLimit.GetMassMatrix(System.Single@)">
      <summary>
            Gets the mass matrix of the constraint.
            </summary>
      <param name="outputMassMatrix">Constraint's mass matrix.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.JointLimits.SwingLimit.SolveIteration">
      <summary>
            Applies the sequential impulse.
            </summary>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.JointLimits.SwingLimit.Update(System.Single)">
      <summary>
            Initializes the constraint for this frame.
            </summary>
      <param name="dt">Time since the last frame.</param>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.JointLimits.SwingLimit.LocalAxisA">
      <summary>
            Gets or sets the axis attached to the first connected entity in its local space.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.JointLimits.SwingLimit.LocalAxisB">
      <summary>
            Gets or sets the axis attached to the first connected entity in its local space.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.JointLimits.SwingLimit.MaximumAngle">
      <summary>
            Maximum angle allowed between the two axes, from 0 to pi.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.JointLimits.SwingLimit.WorldAxisA">
      <summary>
            Gets or sets the axis attached to the first connected entity in world space.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.JointLimits.SwingLimit.WorldAxisB">
      <summary>
            Gets or sets the axis attached to the first connected entity in world space.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.JointLimits.SwingLimit.RelativeVelocity">
      <summary>
            Gets the current relative velocity between the connected entities with respect to the constraint.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.JointLimits.SwingLimit.TotalImpulse">
      <summary>
            Gets the total impulse applied by this constraint.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.JointLimits.SwingLimit.Error">
      <summary>
            Gets the current constraint error.
            </summary>
    </member>
    <member name="T:BEPUphysics.Constraints.SingleEntity.SingleEntityLinearMotor">
      <summary>
            Constraint which tries to push an entity to a desired location.
            </summary>
    </member>
    <member name="F:BEPUphysics.Constraints.SingleEntity.SingleEntityLinearMotor.accumulatedImpulse">
      <summary>
            Sum of forces applied to the constraint in the past.
            </summary>
    </member>
    <member name="F:BEPUphysics.Constraints.SingleEntity.SingleEntityLinearMotor.maxForceDt">
      <summary>
            Maximum impulse that can be applied in a single frame.
            </summary>
    </member>
    <member name="F:BEPUphysics.Constraints.SingleEntity.SingleEntityLinearMotor.maxForceDtSquared">
      <summary>
            Maximum impulse that can be applied in a single frame, squared.
            This is computed in the prestep to avoid doing extra multiplies in the more-often called applyImpulse method.
            </summary>
    </member>
    <member name="M:BEPUphysics.Constraints.SingleEntity.SingleEntityLinearMotor.#ctor(BEPUphysics.Entities.Entity,Microsoft.Xna.Framework.Vector3)">
      <summary>
            Constructs a new single body linear motor.  This motor will try to move a single entity to a goal velocity or to a goal position.
            </summary>
      <param name="entity">Entity to affect.</param>
      <param name="point">Point in world space attached to the entity that will be motorized.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.SingleEntity.SingleEntityLinearMotor.#ctor">
      <summary>
            Constructs a new single body linear motor.  This motor will try to move a single entity to a goal velocity or to a goal position.
            This constructor will start the motor with isActive = false.
            </summary>
    </member>
    <member name="M:BEPUphysics.Constraints.SingleEntity.SingleEntityLinearMotor.SolveIteration">
      <summary>
            Computes one iteration of the constraint to meet the solver updateable's goal.
            </summary>
      <returns>The rough applied impulse magnitude.</returns>
    </member>
    <member name="M:BEPUphysics.Constraints.SingleEntity.SingleEntityLinearMotor.Update(System.Single)">
      <summary>
             Performs the frame's configuration step.
            </summary>
      <param name="dt">Timestep duration.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.SingleEntity.SingleEntityLinearMotor.ExclusiveUpdate">
      <summary>
            Performs any pre-solve iteration work that needs exclusive
            access to the members of the solver updateable.
            Usually, this is used for applying warmstarting impulses.
            </summary>
    </member>
    <member name="M:BEPUphysics.Constraints.SingleEntity.SingleEntityLinearMotor.ComputeMaxForces(System.Single,System.Single)">
      <summary>
            Computes the maxForceDt and maxForceDtSquared fields.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.SingleEntity.SingleEntityLinearMotor.Entity">
      <summary>
            Gets or sets the entity affected by the constraint.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.SingleEntity.SingleEntityLinearMotor.LocalPoint">
      <summary>
            Point attached to the entity in its local space that is motorized.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.SingleEntity.SingleEntityLinearMotor.Point">
      <summary>
            Point attached to the entity in world space that is motorized.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.SingleEntity.SingleEntityLinearMotor.Settings">
      <summary>
            Gets the motor's velocity and servo settings.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.SingleEntity.SingleEntityLinearMotor.RelativeVelocity">
      <summary>
            Gets the current relative velocity between the connected entities with respect to the constraint.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.SingleEntity.SingleEntityLinearMotor.TotalImpulse">
      <summary>
            Gets the total impulse applied by this constraint.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.SingleEntity.SingleEntityLinearMotor.Error">
      <summary>
            Gets the current constraint error.
            If the motor is in velocity only mode, error is zero.
            </summary>
    </member>
    <member name="T:BEPUphysics.CollisionShapes.InstancedMeshShape">
      <summary>
             Local space data associated with an instanced mesh.
             This contains a hierarchy and all the other heavy data needed
             by an InstancedMesh.
            </summary>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.InstancedMeshShape.#ctor(Microsoft.Xna.Framework.Vector3[],System.Int32[])">
      <summary>
             Constructs a new instanced mesh shape.
            </summary>
      <param name="vertices">Vertices of the mesh.</param>
      <param name="indices">Indices of the mesh.</param>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.InstancedMeshShape.ComputeBoundingBox(BEPUphysics.MathExtensions.AffineTransform@,Microsoft.Xna.Framework.BoundingBox@)">
      <summary>
             Computes the bounding box of the transformed mesh shape.
            </summary>
      <param name="transform">Transform to apply to the shape during the bounding box calculation.</param>
      <param name="boundingBox">Bounding box containing the transformed mesh shape.</param>
    </member>
    <member name="P:BEPUphysics.CollisionShapes.InstancedMeshShape.TriangleMesh">
      <summary>
             Gets or sets the TriangleMesh data structure used by this shape.
            </summary>
    </member>
    <member name="T:BEPUphysics.CollisionShapes.ConvexShapes.ConeShape">
      <summary>
             Symmetrical shape with a circular base and a point at the top.
            </summary>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.ConvexShapes.ConeShape.#ctor(System.Single,System.Single)">
      <summary>
             Constructs a new cone shape.
            </summary>
      <param name="height">Height of the cone.</param>
      <param name="radius">Radius of the cone base.</param>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.ConvexShapes.ConeShape.GetLocalExtremePointWithoutMargin(Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Vector3@)">
      <summary>
             Gets the extreme point of the shape in local space in a given direction.
            </summary>
      <param name="direction">Direction to find the extreme point in.</param>
      <param name="extremePoint">Extreme point on the shape.</param>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.ConvexShapes.ConeShape.ComputeMinimumRadius">
      <summary>
             Computes the minimum radius of the shape.
             This is often smaller than the actual minimum radius;
             it is simply an approximation that avoids overestimating.
            </summary>
      <returns>Minimum radius of the shape.</returns>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.ConvexShapes.ConeShape.ComputeMaximumRadius">
      <summary>
            Computes the maximum radius of the shape.
            This is often larger than the actual maximum radius;
            it is simply an approximation that avoids underestimating.
            </summary>
      <returns>Maximum radius of the shape.</returns>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.ConvexShapes.ConeShape.ComputeVolumeDistribution(System.Single@)">
      <summary>
            Computes the volume distribution of the shape as well as its volume.
            The volume distribution can be used to compute inertia tensors when
            paired with mass and other tuning factors.
            </summary>
      <param name="volume">Volume of the shape.</param>
      <returns>Volume distribution of the shape.</returns>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.ConvexShapes.ConeShape.ComputeCenter">
      <summary>
            Computes the center of the shape.  This can be considered its 
            center of mass.
            </summary>
      <returns>Center of the shape.</returns>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.ConvexShapes.ConeShape.ComputeCenter(System.Single@)">
      <summary>
            Computes the center of the shape.  This can be considered its 
            center of mass.  This calculation is often associated with the 
            volume calculation, which is given by this method as well.
            </summary>
      <param name="volume">Volume of the shape.</param>
      <returns>Center of the shape.</returns>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.ConvexShapes.ConeShape.ComputeVolume">
      <summary>
            Computes the volume of the shape.
            </summary>
      <returns>Volume of the shape.</returns>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.ConvexShapes.ConeShape.GetMobileInstance">
      <summary>
            Retrieves an instance of an EntityCollidable that uses this EntityShape.  Mainly used by compound bodies.
            </summary>
      <returns>EntityCollidable that uses this shape.</returns>
    </member>
    <member name="P:BEPUphysics.CollisionShapes.ConvexShapes.ConeShape.Height">
      <summary>
             Gets or sets the height of the cone.
            </summary>
    </member>
    <member name="P:BEPUphysics.CollisionShapes.ConvexShapes.ConeShape.Radius">
      <summary>
             Gets or sets the radius of the cone base.
            </summary>
    </member>
    <member name="T:BEPUphysics.ISpace">
      <summary>
             Defines the minimum interface required for a Space object which acts as the main simulation class.
            </summary>
    </member>
    <member name="M:BEPUphysics.ISpace.Add(BEPUphysics.ISpaceObject)">
      <summary>
             Adds a space object to the simulation.
            </summary>
      <param name="spaceObject">Space object to add.</param>
    </member>
    <member name="M:BEPUphysics.ISpace.Remove(BEPUphysics.ISpaceObject)">
      <summary>
             Removes a space object from the simulation.
            </summary>
      <param name="spaceObject">Space object to remove.</param>
    </member>
    <member name="M:BEPUphysics.ISpace.Update">
      <summary>
             Performs a single timestep.
            </summary>
    </member>
    <member name="M:BEPUphysics.ISpace.Update(System.Single)">
      <summary>
            Performs as many timesteps as necessary to get as close to the elapsed time as possible.
            </summary>
      <param name="dt">Elapsed time from the previous frame.</param>
    </member>
    <member name="M:BEPUphysics.ISpace.RayCast(Microsoft.Xna.Framework.Ray,BEPUphysics.RayCastResult@)">
      <summary>
            Tests a ray against the space.
            </summary>
      <param name="ray">Ray to test.</param>
      <param name="result">Hit data of the ray, if any.</param>
      <returns>Whether or not the ray hit anything.</returns>
    </member>
    <member name="M:BEPUphysics.ISpace.RayCast(Microsoft.Xna.Framework.Ray,System.Func{BEPUphysics.BroadPhaseSystems.BroadPhaseEntry,System.Boolean},BEPUphysics.RayCastResult@)">
      <summary>
            Tests a ray against the space.
            </summary>
      <param name="ray">Ray to test.</param>
      <param name="filter">Delegate to prune out hit candidates before performing a ray cast against them.</param>
      <param name="result">Hit data of the ray, if any.</param>
      <returns>Whether or not the ray hit anything.</returns>
    </member>
    <member name="M:BEPUphysics.ISpace.RayCast(Microsoft.Xna.Framework.Ray,System.Single,BEPUphysics.RayCastResult@)">
      <summary>
            Tests a ray against the space.
            </summary>
      <param name="ray">Ray to test.</param>
      <param name="maximumLength">Maximum length of the ray in units of the ray direction's length.</param>
      <param name="result">Hit data of the ray, if any.</param>
      <returns>Whether or not the ray hit anything.</returns>
    </member>
    <member name="M:BEPUphysics.ISpace.RayCast(Microsoft.Xna.Framework.Ray,System.Single,System.Func{BEPUphysics.BroadPhaseSystems.BroadPhaseEntry,System.Boolean},BEPUphysics.RayCastResult@)">
      <summary>
            Tests a ray against the space.
            </summary>
      <param name="ray">Ray to test.</param>
      <param name="maximumLength">Maximum length of the ray in units of the ray direction's length.</param>
      <param name="filter">Delegate to prune out hit candidates before performing a ray cast against them.</param>
      <param name="result">Hit data of the ray, if any.</param>
      <returns>Whether or not the ray hit anything.</returns>
    </member>
    <member name="M:BEPUphysics.ISpace.RayCast(Microsoft.Xna.Framework.Ray,System.Single,System.Collections.Generic.IList{BEPUphysics.RayCastResult})">
      <summary>
            Tests a ray against the space, possibly returning multiple hits.
            </summary>
      <param name="ray">Ray to test.</param>
      <param name="maximumLength">Maximum length of the ray in units of the ray direction's length.</param>
      <param name="outputRayCastResults">Hit data of the ray, if any.</param>
      <returns>Whether or not the ray hit anything.</returns>
    </member>
    <member name="M:BEPUphysics.ISpace.RayCast(Microsoft.Xna.Framework.Ray,System.Single,System.Func{BEPUphysics.BroadPhaseSystems.BroadPhaseEntry,System.Boolean},System.Collections.Generic.IList{BEPUphysics.RayCastResult})">
      <summary>
            Tests a ray against the space, possibly returning multiple hits.
            </summary>
      <param name="ray">Ray to test.</param>
      <param name="maximumLength">Maximum length of the ray in units of the ray direction's length.</param>
      <param name="filter">Delegate to prune out hit candidates before performing a ray cast against them.</param>
      <param name="outputRayCastResults">Hit data of the ray, if any.</param>
      <returns>Whether or not the ray hit anything.</returns>
    </member>
    <member name="P:BEPUphysics.ISpace.Entities">
      <summary>
             Gets the list of entities in the space.
            </summary>
    </member>
    <member name="T:BEPUphysics.Space">
      <summary>
             Main simulation class of BEPUphysics.  Contains various updating stages addition/removal methods for getting objects into the simulation.
            </summary>
    </member>
    <member name="M:BEPUphysics.Space.#ctor">
      <summary>
             Constructs a new space for things to live in.
            </summary>
    </member>
    <member name="M:BEPUphysics.Space.Add(BEPUphysics.ISpaceObject)">
      <summary>
             Adds a space object to the simulation.
            </summary>
      <param name="spaceObject">Space object to add.</param>
    </member>
    <member name="M:BEPUphysics.Space.Remove(BEPUphysics.ISpaceObject)">
      <summary>
             Removes a space object from the simulation.
            </summary>
      <param name="spaceObject">Space object to remove.</param>
    </member>
    <member name="M:BEPUphysics.Space.Update">
      <summary>
             Performs a single timestep.
            </summary>
    </member>
    <member name="M:BEPUphysics.Space.Update(System.Single)">
      <summary>
            Performs as many timesteps as necessary to get as close to the elapsed time as possible.
            </summary>
      <param name="dt">Elapsed time from the previous frame.</param>
    </member>
    <member name="M:BEPUphysics.Space.RayCast(Microsoft.Xna.Framework.Ray,BEPUphysics.RayCastResult@)">
      <summary>
            Tests a ray against the space.
            </summary>
      <param name="ray">Ray to test.</param>
      <param name="result">Hit data of the ray, if any.</param>
      <returns>Whether or not the ray hit anything.</returns>
    </member>
    <member name="M:BEPUphysics.Space.RayCast(Microsoft.Xna.Framework.Ray,System.Func{BEPUphysics.BroadPhaseSystems.BroadPhaseEntry,System.Boolean},BEPUphysics.RayCastResult@)">
      <summary>
            Tests a ray against the space.
            </summary>
      <param name="ray">Ray to test.</param>
      <param name="filter">Delegate to prune out hit candidates before performing a ray cast against them.</param>
      <param name="result">Hit data of the ray, if any.</param>
      <returns>Whether or not the ray hit anything.</returns>
    </member>
    <member name="M:BEPUphysics.Space.RayCast(Microsoft.Xna.Framework.Ray,System.Single,BEPUphysics.RayCastResult@)">
      <summary>
            Tests a ray against the space.
            </summary>
      <param name="ray">Ray to test.</param>
      <param name="maximumLength">Maximum length of the ray in units of the ray direction's length.</param>
      <param name="result">Hit data of the ray, if any.</param>
      <returns>Whether or not the ray hit anything.</returns>
    </member>
    <member name="M:BEPUphysics.Space.RayCast(Microsoft.Xna.Framework.Ray,System.Single,System.Func{BEPUphysics.BroadPhaseSystems.BroadPhaseEntry,System.Boolean},BEPUphysics.RayCastResult@)">
      <summary>
            Tests a ray against the space.
            </summary>
      <param name="ray">Ray to test.</param>
      <param name="maximumLength">Maximum length of the ray in units of the ray direction's length.</param>
      <param name="filter">Delegate to prune out hit candidates before performing a ray cast against them.</param>
      <param name="result">Hit data of the ray, if any.</param>
      <returns>Whether or not the ray hit anything.</returns>
    </member>
    <member name="M:BEPUphysics.Space.RayCast(Microsoft.Xna.Framework.Ray,System.Single,System.Collections.Generic.IList{BEPUphysics.RayCastResult})">
      <summary>
            Tests a ray against the space, possibly returning multiple hits.
            </summary>
      <param name="ray">Ray to test.</param>
      <param name="maximumLength">Maximum length of the ray in units of the ray direction's length.</param>
      <param name="outputRayCastResults">Hit data of the ray, if any.</param>
      <returns>Whether or not the ray hit anything.</returns>
    </member>
    <member name="M:BEPUphysics.Space.RayCast(Microsoft.Xna.Framework.Ray,System.Single,System.Func{BEPUphysics.BroadPhaseSystems.BroadPhaseEntry,System.Boolean},System.Collections.Generic.IList{BEPUphysics.RayCastResult})">
      <summary>
            Tests a ray against the space, possibly returning multiple hits.
            </summary>
      <param name="ray">Ray to test.</param>
      <param name="maximumLength">Maximum length of the ray in units of the ray direction's length.</param>
      <param name="filter">Delegate to prune out hit candidates before performing a ray cast against them.</param>
      <param name="outputRayCastResults">Hit data of the ray, if any.</param>
      <returns>Whether or not the ray hit anything.</returns>
    </member>
    <member name="M:BEPUphysics.Space.Dispose">
      <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
      <filterpriority>2</filterpriority>
    </member>
    <member name="P:BEPUphysics.Space.TimeStepSettings">
      <summary>
             Gets or sets the time step settings used by the space.
            </summary>
    </member>
    <member name="P:BEPUphysics.Space.ThreadManager">
      <summary>
             Gets or sets the thread manager used by the space.
            </summary>
    </member>
    <member name="P:BEPUphysics.Space.SpaceObjectBuffer">
      <summary>
             Gets or sets the space object buffer used by the space.
             The space object buffer allows objects to be safely asynchronously
             added to and removed from the space.
            </summary>
    </member>
    <member name="P:BEPUphysics.Space.EntityStateWriteBuffer">
      <summary>
             Gets or sets the entity state write buffer used by the space.
             The write buffer contains buffered writes to entity states that are
             flushed each frame when the buffer is updated.
            </summary>
    </member>
    <member name="P:BEPUphysics.Space.DeactivationManager">
      <summary>
             Gets or sets the deactivation manager used by the space.
             The deactivation manager controls the activity state objects, putting them
             to sleep and managing the connections between objects and simulation islands.
            </summary>
    </member>
    <member name="P:BEPUphysics.Space.ForceUpdater">
      <summary>
             Gets or sets the force updater used by the space.
             The force updater applies forces to all dynamic objects in the space each frame.
            </summary>
    </member>
    <member name="P:BEPUphysics.Space.BoundingBoxUpdater">
      <summary>
             Gets or sets the bounding box updater used by the space.
             The bounding box updater updates the bounding box of mobile collidables each frame.
            </summary>
    </member>
    <member name="P:BEPUphysics.Space.BroadPhase">
      <summary>
            Gets or sets the broad phase used by the space.
            The broad phase finds overlaps between broad phase entries and passes
            them off to the narrow phase for processing.
            </summary>
    </member>
    <member name="P:BEPUphysics.Space.NarrowPhase">
      <summary>
             Gets or sets the narrow phase used by the space.
             The narrow phase uses overlaps found by the broad phase
             to create pair handlers.  Those pair handlers can go on to 
             create things like contacts and constraints.
            </summary>
    </member>
    <member name="P:BEPUphysics.Space.Solver">
      <summary>
             Gets or sets the solver used by the space.
             The solver iteratively finds a solution to the constraints in the simulation.
            </summary>
    </member>
    <member name="P:BEPUphysics.Space.PositionUpdater">
      <summary>
             Gets or sets the position updater used by the space.
             The position updater moves everything around each frame.
            </summary>
    </member>
    <member name="P:BEPUphysics.Space.BufferedStates">
      <summary>
             Gets or sets the buffered states manager used by the space.
             The buffered states manager keeps track of read buffered entity states
             and also interpolated states based on the time remaining from internal
             time steps.
            </summary>
    </member>
    <member name="P:BEPUphysics.Space.DeferredEventDispatcher">
      <summary>
             Gets or sets the deferred event dispatcher used by the space.
             The event dispatcher gathers up deferred events created
             over the course of a timestep and dispatches them sequentially at the end.
            </summary>
    </member>
    <member name="P:BEPUphysics.Space.DuringForcesUpdateables">
      <summary>
             Gets or sets the updateable manager that handles updateables that update during force application.
            </summary>
    </member>
    <member name="P:BEPUphysics.Space.BeforeNarrowPhaseUpdateables">
      <summary>
             Gets or sets the updateable manager that handles updateables that update before the narrow phase.
            </summary>
    </member>
    <member name="P:BEPUphysics.Space.EndOfTimeStepUpdateables">
      <summary>
             Gets or sets the updateable manager that handles updateables that update at the end of a timestep.
            </summary>
    </member>
    <member name="P:BEPUphysics.Space.EndOfFrameUpdateables">
      <summary>
             Gets or sets the updateable manager that handles updateables that update at the end of a frame.
            </summary>
    </member>
    <member name="P:BEPUphysics.Space.Entities">
      <summary>
             Gets the list of entities in the space.
            </summary>
    </member>
    <member name="T:BEPUphysics.Paths.CurveEndpointBehavior">
      <summary>
            Defines how a curve behaves beyond an endpoint.
            </summary>
    </member>
    <member name="F:BEPUphysics.Paths.CurveEndpointBehavior.Wrap">
      <summary>
            When the time exceeds the endpoint, it wraps around to the other end of the curve.
            </summary>
    </member>
    <member name="F:BEPUphysics.Paths.CurveEndpointBehavior.Clamp">
      <summary>
            Times exceeding the endpoint are clamped to the endpoint's value.
            </summary>
    </member>
    <member name="F:BEPUphysics.Paths.CurveEndpointBehavior.Mirror">
      <summary>
            Times exceeding the endpoint will reverse direction and sample backwards.
            </summary>
    </member>
    <member name="T:BEPUphysics.Materials.MaterialManager">
      <summary>
             Manages the relationship between materials.
            </summary>
    </member>
    <member name="F:BEPUphysics.Materials.MaterialManager.BouncinessBlendMethod">
      <summary>
            Determines how to factor together friction values from two objects in a collision.
            Defaults to using the maximum bounciness of the pair.
            </summary>
    </member>
    <member name="F:BEPUphysics.Materials.MaterialManager.BouncinessBlender">
      <summary>
            The property blender used by default in collision bounciness.
            Uses the space's bounciness PropertyBlendMethod to blend.
            </summary>
    </member>
    <member name="F:BEPUphysics.Materials.MaterialManager.FrictionBlendMethod">
      <summary>
            Determines how to factor together bounciness values from two objects in a collision.
            Defaults to using the average friction of the pair.
            </summary>
    </member>
    <member name="F:BEPUphysics.Materials.MaterialManager.FrictionBlender">
      <summary>
            The property blender used by default in collision friction.
            Uses the space's friction PropertyBlendMethod to blend.
            </summary>
    </member>
    <member name="F:BEPUphysics.Materials.MaterialManager.DefaultKineticFriction">
      <summary>
             Default coefficient of kinetic friction.
            </summary>
    </member>
    <member name="F:BEPUphysics.Materials.MaterialManager.DefaultStaticFriction">
      <summary>
             Default coefficient of static friction.
            </summary>
    </member>
    <member name="F:BEPUphysics.Materials.MaterialManager.DefaultBounciness">
      <summary>
             Default coefficient of restitution.
            </summary>
    </member>
    <member name="M:BEPUphysics.Materials.MaterialManager.GetInteractionProperties(BEPUphysics.Materials.Material,BEPUphysics.Materials.Material,BEPUphysics.Materials.InteractionProperties@)">
      <summary>
             Computes the interaction properties between two materials.
            </summary>
      <param name="materialA">First material of the pair.</param>
      <param name="materialB">Second material of the pair.</param>
      <param name="properties">Interaction properties between two materials.</param>
    </member>
    <member name="M:BEPUphysics.Materials.MaterialManager.GetStaticFriction(BEPUphysics.Materials.Material,BEPUphysics.Materials.Material,System.Single@)">
      <summary>
             Blends the static friction of the two materials together.
            </summary>
      <param name="materialA">First material of the pair.</param>
      <param name="materialB">Second material of the pair.</param>
      <param name="blendedCoefficient">Blended friction coefficient.</param>
    </member>
    <member name="M:BEPUphysics.Materials.MaterialManager.GetKineticFriction(BEPUphysics.Materials.Material,BEPUphysics.Materials.Material,System.Single@)">
      <summary>
             Blends the kinetic friction of the two materials together.
            </summary>
      <param name="materialA">First material of the pair.</param>
      <param name="materialB">Second material of the pair.</param>
      <param name="blendedCoefficient">Blended friction coefficient.</param>
    </member>
    <member name="M:BEPUphysics.Materials.MaterialManager.GetBounciness(BEPUphysics.Materials.Material,BEPUphysics.Materials.Material,System.Single@)">
      <summary>
             Blends the bounciness of the two materials together.
            </summary>
      <param name="materialA">First material of the pair.</param>
      <param name="materialB">Second material of the pair.</param>
      <param name="blendedCoefficient">Blended bounciness.</param>
    </member>
    <member name="M:BEPUphysics.Materials.MaterialManager.GetStaticFriction(BEPUphysics.Materials.Material,BEPUphysics.Materials.Material,BEPUphysics.Materials.PropertyBlender,System.Single@)">
      <summary>
             Blends the static friction of the two materials together.
            </summary>
      <param name="materialA">First material of the pair.</param>
      <param name="materialB">Second material of the pair.</param>
      <param name="blender">Blender to use to blend the material properties.</param>
      <param name="blendedCoefficient">Blended friction coefficient.</param>
    </member>
    <member name="M:BEPUphysics.Materials.MaterialManager.GetKineticFriction(BEPUphysics.Materials.Material,BEPUphysics.Materials.Material,BEPUphysics.Materials.PropertyBlender,System.Single@)">
      <summary>
             Blends the kinetic friction of the two materials together.
            </summary>
      <param name="materialA">First material of the pair.</param>
      <param name="materialB">Second material of the pair.</param>
      <param name="blender">Blender to use to blend the material properties.</param>
      <param name="blendedCoefficient">Blended friction coefficient.</param>
    </member>
    <member name="M:BEPUphysics.Materials.MaterialManager.GetBounciness(BEPUphysics.Materials.Material,BEPUphysics.Materials.Material,BEPUphysics.Materials.PropertyBlender,System.Single@)">
      <summary>
             Blends the bounciness of the two materials together.
            </summary>
      <param name="materialA">First material of the pair.</param>
      <param name="materialB">Second material of the pair.</param>
      <param name="blender">Blender to use to blend the material properties.</param>
      <param name="blendedCoefficient">Blended bounciness coefficient.</param>
    </member>
    <member name="M:BEPUphysics.Materials.MaterialManager.DefaultBouncinessBlender(System.Single,System.Single,System.Object)">
      <summary>
            The property blender used by default in collision bounciness.
            Uses the space's bounciness PropertyBlendMethod to blend.
            </summary>
      <param name="aValue">Value associated with the first object to blend.</param>
      <param name="bValue">Value associated with the second object to blend.</param>
      <param name="extraInfo">Extra data to use in the calculation.</param>
      <returns>Blended property value.</returns>
    </member>
    <member name="M:BEPUphysics.Materials.MaterialManager.DefaultFrictionBlender(System.Single,System.Single,System.Object)">
      <summary>
            The property blender used by default in collision friction.
            Uses the space's friction PropertyBlendMethod to blend.
            </summary>
      <param name="aValue">Value associated with the first object to blend.</param>
      <param name="bValue">Value associated with the second object to blend.</param>
      <param name="extraInfo">Extra data to use in the calculation.</param>
      <returns>Blended property value.</returns>
    </member>
    <member name="P:BEPUphysics.Materials.MaterialManager.MaterialInteractions">
      <summary>
             Gets or sets the material interactions dictionary.
             This dictionary contains all the special relationships between specific materials.
             These interaction properties will override properties obtained by normal blending.
            </summary>
    </member>
    <member name="T:BEPUphysics.UpdateableSystems.ForceFields.ForceField">
      <summary>
            Superclass of objects which apply forces to entities in some field.
            </summary>
    </member>
    <member name="M:BEPUphysics.UpdateableSystems.ForceFields.ForceField.#ctor(BEPUphysics.UpdateableSystems.ForceFields.ForceFieldShape,BEPUphysics.BroadPhaseSystems.IQueryAccelerator)">
      <summary>
            Constructs a force field.
            </summary>
      <param name="shape">Shape to use for the force field.</param>
      <param name="queryAccelerator">Query accelerator used to find entities.</param>
    </member>
    <member name="M:BEPUphysics.UpdateableSystems.ForceFields.ForceField.CalculateImpulse(BEPUphysics.Entities.Entity,System.Single,Microsoft.Xna.Framework.Vector3@)">
      <summary>
            Calculates the impulse to apply to the entity.
            </summary>
      <param name="e">Affected entity.</param>
      <param name="dt">Duration between simulation updates.</param>
      <param name="impulse">Impulse to apply to the entity.</param>
    </member>
    <member name="P:BEPUphysics.UpdateableSystems.ForceFields.ForceField.AllowMultithreading">
      <summary>
             Gets or sets whether or not threading is allowed.
            </summary>
    </member>
    <member name="P:BEPUphysics.UpdateableSystems.ForceFields.ForceField.QueryAccelerator">
      <summary>
             Gets or sets the query accelerator used by the force field to find entities.
            </summary>
    </member>
    <member name="P:BEPUphysics.UpdateableSystems.ForceFields.ForceField.ThreadManager">
      <summary>
             Gets or sets the thread manager used by the force field.
            </summary>
    </member>
    <member name="P:BEPUphysics.UpdateableSystems.ForceFields.ForceField.ForceWakeUp">
      <summary>
            Gets or sets whether the the force field will force affected entities to wake up.
            </summary>
    </member>
    <member name="P:BEPUphysics.UpdateableSystems.ForceFields.ForceField.Shape">
      <summary>
            Gets or sets the shape of the force field used to determine which entities to apply forces to.
            </summary>
    </member>
    <member name="T:BEPUphysics.DataStructures.ObservableDictionary`2">
      <summary>
             Dictionary that provides events when the inner dictionary is changed.
            </summary>
      <typeparam name="TKey">Type of the keys in the dictionary.</typeparam>
      <typeparam name="TValue">Type of the values in the dictionary.</typeparam>
    </member>
    <member name="M:BEPUphysics.DataStructures.ObservableDictionary`2.Add(`0,`1)">
      <summary>
             Adds a pair to the dictionary.
            </summary>
      <param name="key">Key of the element.</param>
      <param name="value">Value of the element.</param>
    </member>
    <member name="M:BEPUphysics.DataStructures.ObservableDictionary`2.Remove(`0)">
      <summary>
             Removes a key and its associated value from the dictionary, if present.
            </summary>
      <param name="key">Key of the element to remove.</param>
      <returns>Whether or not the object was found.</returns>
    </member>
    <member name="M:BEPUphysics.DataStructures.ObservableDictionary`2.Clear">
      <summary>
             Clears the dictionary of all elements.
            </summary>
    </member>
    <member name="P:BEPUphysics.DataStructures.ObservableDictionary`2.WrappedDictionary">
      <summary>
             Gets or sets the dictionary wrapped by the observable dictionary.
             While the inner dictionary can be changed, making modifications to it will
             not trigger any changed events.
            </summary>
    </member>
    <member name="T:BEPUphysics.CollisionShapes.CompoundShapeEntry">
      <summary>
             Contains a shape and its local transform relative to its owning compound shape.
             This is used to construct compound shapes.
            </summary>
    </member>
    <member name="F:BEPUphysics.CollisionShapes.CompoundShapeEntry.LocalTransform">
      <summary>
             Local transform of the shape relative to its owning compound shape.
            </summary>
    </member>
    <member name="F:BEPUphysics.CollisionShapes.CompoundShapeEntry.Shape">
      <summary>
            Shape used by the compound.
            </summary>
    </member>
    <member name="F:BEPUphysics.CollisionShapes.CompoundShapeEntry.Weight">
      <summary>
            Weight of the entry.  This defines how much the entry contributes to its owner
            for the purposes of center of rotation computation.
            </summary>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.CompoundShapeEntry.#ctor(BEPUphysics.CollisionShapes.EntityShape,BEPUphysics.MathExtensions.RigidTransform,System.Single)">
      <summary>
             Constructs a new compound shape entry using the volume of the shape as a weight.
            </summary>
      <param name="shape">Shape to use.</param>
      <param name="localTransform">Local transform of the shape.</param>
      <param name="weight">Weight of the entry.  This defines how much the entry contributes to its owner
             for the purposes of center of rotation computation.</param>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.CompoundShapeEntry.#ctor(BEPUphysics.CollisionShapes.EntityShape,Microsoft.Xna.Framework.Vector3,System.Single)">
      <summary>
             Constructs a new compound shape entry using the volume of the shape as a weight.
            </summary>
      <param name="shape">Shape to use.</param>
      <param name="position">Local position of the shape.</param>
      <param name="weight">Weight of the entry.  This defines how much the entry contributes to its owner
             for the purposes of center of mass and inertia computation.</param>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.CompoundShapeEntry.#ctor(BEPUphysics.CollisionShapes.EntityShape,Microsoft.Xna.Framework.Quaternion,System.Single)">
      <summary>
             Constructs a new compound shape entry using the volume of the shape as a weight.
            </summary>
      <param name="shape">Shape to use.</param>
      <param name="orientation">Local orientation of the shape.</param>
      <param name="weight">Weight of the entry.  This defines how much the entry contributes to its owner
             for the purposes of center of rotation computation.</param>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.CompoundShapeEntry.#ctor(BEPUphysics.CollisionShapes.EntityShape,System.Single)">
      <summary>
             Constructs a new compound shape entry using the volume of the shape as a weight.
            </summary>
      <param name="shape">Shape to use.</param>
      <param name="weight">Weight of the entry.  This defines how much the entry contributes to its owner
             for the purposes of center of rotation computation.</param>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.CompoundShapeEntry.#ctor(BEPUphysics.CollisionShapes.EntityShape,BEPUphysics.MathExtensions.RigidTransform)">
      <summary>
             Constructs a new compound shape entry using the volume of the shape as a weight.
            </summary>
      <param name="shape">Shape to use.</param>
      <param name="localTransform">Local transform of the shape.</param>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.CompoundShapeEntry.#ctor(BEPUphysics.CollisionShapes.EntityShape,Microsoft.Xna.Framework.Vector3)">
      <summary>
             Constructs a new compound shape entry using the volume of the shape as a weight.
            </summary>
      <param name="shape">Shape to use.</param>
      <param name="position">Local position of the shape.</param>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.CompoundShapeEntry.#ctor(BEPUphysics.CollisionShapes.EntityShape,Microsoft.Xna.Framework.Quaternion)">
      <summary>
             Constructs a new compound shape entry using the volume of the shape as a weight.
            </summary>
      <param name="shape">Shape to use.</param>
      <param name="orientation">Local orientation of the shape.</param>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.CompoundShapeEntry.#ctor(BEPUphysics.CollisionShapes.EntityShape)">
      <summary>
             Constructs a new compound shape entry using the volume of the shape as a weight.
            </summary>
      <param name="shape">Shape to use.</param>
    </member>
    <member name="T:BEPUphysics.CollisionShapes.CompoundShape">
      <summary>
             Shape composed of multiple other shapes.
            </summary>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.CompoundShape.#ctor(System.Collections.Generic.IList{BEPUphysics.CollisionShapes.CompoundShapeEntry},Microsoft.Xna.Framework.Vector3@)">
      <summary>
             Constructs a compound shape.
            </summary>
      <param name="shapes">Shape entries used to create the compound.</param>
      <param name="center">Computed center of the compound shape, using the entry weights.</param>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.CompoundShape.#ctor(System.Collections.Generic.IList{BEPUphysics.CollisionShapes.CompoundShapeEntry})">
      <summary>
             Constructs a compound shape.
            </summary>
      <param name="shapes">Shape entries used to create the compound.</param>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.CompoundShape.ComputeMinimumRadius">
      <summary>
             Computes the minimum radius of the shape.
             This is often smaller than the actual minimum radius;
             it is simply an approximation that avoids overestimating.
            </summary>
      <returns>Minimum radius of the shape.</returns>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.CompoundShape.ComputeMaximumRadius">
      <summary>
            Computes the maximum radius of the shape.
            This is often larger than the actual maximum radius;
            it is simply an approximation that avoids underestimating.
            </summary>
      <returns>Maximum radius of the shape.</returns>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.CompoundShape.ComputeCenter">
      <summary>
            Computes the center of the shape.  This can be considered its 
            center of mass, based on the weightings of entries in the shape.
            For properly calibrated compound shapes, this will return a zero vector,
            since the shape recenters itself on construction.
            </summary>
      <returns>Center of the shape.</returns>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.CompoundShape.ComputeCenter(System.Collections.Generic.IList{BEPUphysics.Collidables.MobileCollidables.CompoundChildData})">
      <summary>
             Computes the center of a compound using its child data.
             Children are weighted using their volumes for contribution to the center of 'mass.'
            </summary>
      <param name="childData">Child data to use to compute the center.</param>
      <returns>Center of the children.</returns>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.CompoundShape.ComputeCenter(System.Collections.Generic.IList{BEPUphysics.CollisionShapes.CompoundShapeEntry})">
      <summary>
             Computes the center of a compound using its child data.
             Children are weighted using their volumes for contribution to the center of 'mass.'
            </summary>
      <param name="childData">Child data to use to compute the center.</param>
      <returns>Center of the children.</returns>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.CompoundShape.ComputeVolume">
      <summary>
            Computes the volume of the shape.
            </summary>
      <returns>Volume of the shape.</returns>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.CompoundShape.ComputeVolumeDistribution(System.Single@)">
      <summary>
            Computes the volume distribution of the shape as well as its volume.
            The volume distribution can be used to compute inertia tensors when
            paired with mass and other tuning factors.
            </summary>
      <param name="volume">Volume of the shape.</param>
      <returns>Volume distribution of the shape.</returns>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.CompoundShape.ComputeVolumeDistribution">
      <summary>
            Computes the volume distribution of the shape.
            </summary>
      <returns>Volume distribution of the shape.</returns>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.CompoundShape.ComputeVolumeDistribution(System.Collections.Generic.IList{BEPUphysics.CollisionShapes.CompoundShapeEntry},Microsoft.Xna.Framework.Vector3@)">
      <summary>
            Computes the volume distribution and center of the shape.
            </summary>
      <param name="entries">Mass-weighted entries of the compound.</param>
      <param name="center">Center of the compound.</param>
      <returns>Volume distribution of the shape.</returns>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.CompoundShape.GetContribution(BEPUphysics.CollisionShapes.EntityShape,BEPUphysics.MathExtensions.RigidTransform@,Microsoft.Xna.Framework.Vector3@,System.Single)">
      <summary>
             Gets the volume distribution contributed by a single shape.
            </summary>
      <param name="shape">Shape to use to compute a contribution.</param>
      <param name="transform">Transform of the shape.</param>
      <param name="center">Center to use when computing the distribution.</param>
      <param name="weight">Weighting to apply to the contribution.</param>
      <returns>Volume distribution of the contribution.</returns>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.CompoundShape.TransformContribution(BEPUphysics.MathExtensions.RigidTransform@,Microsoft.Xna.Framework.Vector3@,BEPUphysics.MathExtensions.Matrix3X3@,System.Single)">
      <summary>
            Modifies a contribution using a transform, position, and weight.
            </summary>
      <param name="transform">Transform to use to modify the contribution.</param>
      <param name="center">Center to use to modify the contribution.</param>
      <param name="baseContribution">Original unmodified contribution.</param>
      <param name="weight">Weight of the contribution.</param>
      <returns>Transformed contribution.</returns>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.CompoundShape.GetMobileInstance">
      <summary>
            Retrieves an instance of an EntityCollidable that uses this EntityShape.  Mainly used by compound bodies.
            </summary>
      <returns>EntityCollidable that uses this shape.</returns>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.CompoundShape.ComputeCenter(System.Single@)">
      <summary>
            Computes the center of the shape and its volume.
            </summary>
      <param name="volume">Volume of the compound.</param>
      <returns>Volume of the compound.</returns>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.CompoundShape.ComputeDistributionInformation(BEPUphysics.CollisionShapes.ShapeDistributionInformation@)">
      <summary>
            Computes a variety of shape information all at once.
            </summary>
      <param name="shapeInfo">Properties of the shape.</param>
    </member>
    <member name="P:BEPUphysics.CollisionShapes.CompoundShape.Shapes">
      <summary>
             Gets the list of shapes in the compound shape.
            </summary>
      <exception cref="T:System.Exception">Thrown if the set shapes list has 0 shapes in it.</exception>
    </member>
    <member name="T:BEPUphysics.EntityStateManagement.BufferedStatesManager">
      <summary>
             Manages the buffered and interpolated states of entities.
            </summary>
    </member>
    <member name="M:BEPUphysics.EntityStateManagement.BufferedStatesManager.#ctor">
      <summary>
             Constructs a new manager.
            </summary>
    </member>
    <member name="M:BEPUphysics.EntityStateManagement.BufferedStatesManager.#ctor(BEPUphysics.Threading.IThreadManager)">
      <summary>
             Constructs a new manager.
            </summary>
      <param name="threadManager">Thread manager to be used by the manager.</param>
    </member>
    <member name="M:BEPUphysics.EntityStateManagement.BufferedStatesManager.Add(BEPUphysics.Entities.Entity)">
      <summary>
             Adds an entity to the manager.
            </summary>
      <param name="e">Entity to add.</param>
      <exception cref="T:System.InvalidOperationException">Thrown if the entity already belongs to a states manager.</exception>
    </member>
    <member name="M:BEPUphysics.EntityStateManagement.BufferedStatesManager.Remove(BEPUphysics.Entities.Entity)">
      <summary>
             Removes an entity from the manager.
            </summary>
      <param name="e">Entity to remove.</param>
      <exception cref="T:System.InvalidOperationException">Thrown if the entity does not belong to this manager.</exception>
    </member>
    <member name="P:BEPUphysics.EntityStateManagement.BufferedStatesManager.ReadBuffers">
      <summary>
             Gets the buffers of last known entity states.
            </summary>
    </member>
    <member name="P:BEPUphysics.EntityStateManagement.BufferedStatesManager.InterpolatedStates">
      <summary>
             Gets the entity states blended between the current frame and previous frame based on
             the time remaining in internal time stepping.
            </summary>
    </member>
    <member name="P:BEPUphysics.EntityStateManagement.BufferedStatesManager.Entities">
      <summary>
             Gets the list of entities in the manager.
            </summary>
    </member>
    <member name="P:BEPUphysics.EntityStateManagement.BufferedStatesManager.Enabled">
      <summary>
             Gets or sets whether or not the buffered states manager and its submanagers are updating.
            </summary>
    </member>
    <member name="T:BEPUphysics.NarrowPhaseSystems.Pairs.BoxPairHandler">
      <summary>
             Pair handler that manages a pair of two boxes.
            </summary>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.Pairs.BoxPairHandler.#ctor">
      <summary>
             Constructs a new box pair handler.
            </summary>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.Pairs.BoxPairHandler.Initialize(BEPUphysics.BroadPhaseSystems.BroadPhaseEntry,BEPUphysics.BroadPhaseSystems.BroadPhaseEntry)">
      <summary>
             Initializes the pair handler.
            </summary>
      <param name="entryA">First entry in the pair.</param>
      <param name="entryB">Second entry in the pair.</param>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.Pairs.BoxPairHandler.UpdateMaterialProperties">
      <summary>
             Forces an update of the pair's material properties.
            </summary>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.Pairs.BoxPairHandler.OnAddedToNarrowPhase">
      <summary>
             Called when the pair handler is added to the narrow phase.
            </summary>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.Pairs.BoxPairHandler.CleanUp">
      <summary>
             Cleans up the pair handler.
            </summary>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.Pairs.BoxPairHandler.UpdateCollision(System.Single)">
      <summary>
             Updates the pair handler.
            </summary>
      <param name="dt">Timestep duration.</param>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.Pairs.BoxPairHandler.UpdateTimeOfImpact(BEPUphysics.Collidables.Collidable,System.Single)">
      <summary>
             Updates the time of impact for the pair.
            </summary>
      <param name="requester">Collidable requesting the update.</param>
      <param name="dt">Timestep duration.</param>
    </member>
    <member name="T:BEPUphysics.NarrowPhaseSystems.Factories.CompoundInstancedMeshPairFactory">
      <summary>
             Manufactures compound-instanced mesh pairs.
            </summary>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.Factories.CompoundInstancedMeshPairFactory.GetNarrowPhasePair(BEPUphysics.BroadPhaseSystems.BroadPhaseOverlap)">
      <summary>
             Manufactures and returns a narrow phase pair for the given overlap.
            </summary>
      <param name="overlap">Overlap used to create a pair.</param>
      <returns>Narrow phase pair.</returns>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.Factories.CompoundInstancedMeshPairFactory.GiveBack(BEPUphysics.NarrowPhaseSystems.Pairs.INarrowPhasePair)">
      <summary>
            Returns a pair to the factory for re-use.
            </summary>
      <param name="pair">Pair to return.</param>
    </member>
    <member name="T:BEPUphysics.Entities.EntitySolverUpdateableCollection">
      <summary>
             Convenience collection for easily scanning the two entity constraints connected to an entity.
            </summary>
    </member>
    <member name="T:BEPUphysics.Entities.EntitySolverUpdateableCollection.Enumerator">
      <summary>
             Enumerator for the EntityConstraintCollection.
            </summary>
    </member>
    <member name="M:BEPUphysics.Entities.EntitySolverUpdateableCollection.Enumerator.#ctor(System.Collections.Generic.List{BEPUphysics.DeactivationManagement.ISimulationIslandConnection})">
      <summary>
            Constructs an enumerator for the solver updateables list.
            </summary>
      <param name="connections">List of solver updateables to enumerate.</param>
    </member>
    <member name="M:BEPUphysics.Entities.EntitySolverUpdateableCollection.Enumerator.Dispose">
      <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
      <filterpriority>2</filterpriority>
    </member>
    <member name="M:BEPUphysics.Entities.EntitySolverUpdateableCollection.Enumerator.MoveNext">
      <summary>
            Advances the enumerator to the next element of the collection.
            </summary>
      <returns>
            true if the enumerator was successfully advanced to the next element; false if the enumerator has passed the end of the collection.
            </returns>
      <exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created. </exception>
      <filterpriority>2</filterpriority>
    </member>
    <member name="M:BEPUphysics.Entities.EntitySolverUpdateableCollection.Enumerator.Reset">
      <summary>
            Sets the enumerator to its initial position, which is before the first element in the collection.
            </summary>
      <exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created. </exception>
      <filterpriority>2</filterpriority>
    </member>
    <member name="P:BEPUphysics.Entities.EntitySolverUpdateableCollection.Enumerator.Current">
      <summary>
            Gets the element in the collection at the current position of the enumerator.
            </summary>
      <returns>
            The element in the collection at the current position of the enumerator.
            </returns>
    </member>
    <member name="M:BEPUphysics.Entities.EntitySolverUpdateableCollection.#ctor(System.Collections.Generic.List{BEPUphysics.DeactivationManagement.ISimulationIslandConnection})">
      <summary>
            Constructs a new constraint collection.
            </summary>
      <param name="connections">Solver updateables to enumerate over.</param>
    </member>
    <member name="M:BEPUphysics.Entities.EntitySolverUpdateableCollection.GetEnumerator">
      <summary>
            Gets an enumerator for the collection.
            </summary>
      <returns>Enumerator for the collection.</returns>
    </member>
    <member name="T:BEPUphysics.Constraints.TwoEntity.Joints.NoRotationJoint">
      <summary>
            Constrains two entities so that they cannot rotate relative to each other.
            </summary>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.Joints.NoRotationJoint.#ctor">
      <summary>
            Constructs a new constraint which prevents relative angular motion between the two connected bodies.
            To finish the initialization, specify the connections (ConnectionA and ConnectionB) and the initial orientations
            (InitialOrientationA, InitialOrientationB).
            This constructor sets the constraint's IsActive property to false by default.
            </summary>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.Joints.NoRotationJoint.#ctor(BEPUphysics.Entities.Entity,BEPUphysics.Entities.Entity)">
      <summary>
            Constructs a new constraint which prevents relative angular motion between the two connected bodies.
            </summary>
      <param name="connectionA">First connection of the pair.</param>
      <param name="connectionB">Second connection of the pair.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.Joints.NoRotationJoint.GetLinearJacobianA(Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Vector3@)">
      <summary>
            Gets the linear jacobian entry for the first connected entity.
            </summary>
      <param name="jacobianX">First linear jacobian entry for the first connected entity.</param>
      <param name="jacobianY">Second linear jacobian entry for the first connected entity.</param>
      <param name="jacobianZ">Third linear jacobian entry for the first connected entity.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.Joints.NoRotationJoint.GetLinearJacobianB(Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Vector3@)">
      <summary>
            Gets the linear jacobian entry for the second connected entity.
            </summary>
      <param name="jacobianX">First linear jacobian entry for the second connected entity.</param>
      <param name="jacobianY">Second linear jacobian entry for the second connected entity.</param>
      <param name="jacobianZ">Third linear jacobian entry for the second connected entity.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.Joints.NoRotationJoint.GetAngularJacobianA(Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Vector3@)">
      <summary>
            Gets the angular jacobian entry for the first connected entity.
            </summary>
      <param name="jacobianX">First angular jacobian entry for the first connected entity.</param>
      <param name="jacobianY">Second angular jacobian entry for the first connected entity.</param>
      <param name="jacobianZ">Third angular jacobian entry for the first connected entity.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.Joints.NoRotationJoint.GetAngularJacobianB(Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Vector3@)">
      <summary>
            Gets the angular jacobian entry for the second connected entity.
            </summary>
      <param name="jacobianX">First angular jacobian entry for the second connected entity.</param>
      <param name="jacobianY">Second angular jacobian entry for the second connected entity.</param>
      <param name="jacobianZ">Third angular jacobian entry for the second connected entity.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.Joints.NoRotationJoint.GetMassMatrix(BEPUphysics.MathExtensions.Matrix3X3@)">
      <summary>
            Gets the mass matrix of the constraint.
            </summary>
      <param name="outputMassMatrix">Constraint's mass matrix.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.Joints.NoRotationJoint.SolveIteration">
      <summary>
            Applies the corrective impulses required by the constraint.
            </summary>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.Joints.NoRotationJoint.Update(System.Single)">
      <summary>
            Initializes the constraint for the current frame.
            </summary>
      <param name="dt">Time between frames.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.Joints.NoRotationJoint.ExclusiveUpdate">
      <summary>
            Performs any pre-solve iteration work that needs exclusive
            access to the members of the solver updateable.
            Usually, this is used for applying warmstarting impulses.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.Joints.NoRotationJoint.InitialOrientationA">
      <summary>
            Gets or sets the initial orientation of the first connected entity.
            The constraint will try to maintain the relative orientation between the initialOrientationA and initialOrientationB.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.Joints.NoRotationJoint.InitialOrientationB">
      <summary>
            Gets or sets the initial orientation of the second connected entity.
            The constraint will try to maintain the relative orientation between the initialOrientationA and initialOrientationB.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.Joints.NoRotationJoint.RelativeVelocity">
      <summary>
            Gets the current relative velocity between the connected entities with respect to the constraint.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.Joints.NoRotationJoint.TotalImpulse">
      <summary>
            Gets the total impulse applied by this constraint.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.Joints.NoRotationJoint.Error">
      <summary>
            Gets the current constraint error.
            </summary>
    </member>
    <member name="T:BEPUphysics.Constraints.TwoEntity.JointLimits.RevoluteLimit">
      <summary>
            Constraint which prevents the connected entities from rotating relative to each other around an axis beyond given limits.
            </summary>
    </member>
    <member name="F:BEPUphysics.Constraints.TwoEntity.JointLimits.RevoluteLimit.maximumAngle">
      <summary>
            Naximum angle that entities can twist.
            </summary>
    </member>
    <member name="F:BEPUphysics.Constraints.TwoEntity.JointLimits.RevoluteLimit.minimumAngle">
      <summary>
            Minimum angle that entities can twist.
            </summary>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.JointLimits.RevoluteLimit.#ctor">
      <summary>
            Constructs a new constraint which prevents the connected entities from rotating relative to each other around an axis beyond given limits.
            To finish the initialization, specify the connections (ConnectionA and ConnectionB) 
            as well as the TestAxis (or its entity-local version) and the Basis.
            This constructor sets the constraint's IsActive property to false by default.
            </summary>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.JointLimits.RevoluteLimit.#ctor(BEPUphysics.Entities.Entity,BEPUphysics.Entities.Entity,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,System.Single,System.Single)">
      <summary>
            Constructs a new constraint which prevents the connected entities from rotating relative to each other around an axis beyond given limits.
            </summary>
      <param name="connectionA">First connection of the pair.</param>
      <param name="connectionB">Second connection of the pair.</param>
      <param name="limitedAxis">Axis of rotation to be limited.</param>
      <param name="testAxis">Axis attached to connectionB that is tested to determine the current angle.
            Will also be used as the base rotation axis representing 0 degrees.</param>
      <param name="minimumAngle">Minimum twist angle allowed.</param>
      <param name="maximumAngle">Maximum twist angle allowed.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.JointLimits.RevoluteLimit.#ctor(BEPUphysics.Entities.Entity,BEPUphysics.Entities.Entity)">
      <summary>
            Constructs a new constraint which prevents the connected entities from rotating relative to each other around an axis beyond given limits.
            Using this constructor will leave the limit uninitialized.  Before using the limit in a simulation, be sure to set the basis axes using
            Basis.SetLocalAxes or Basis.SetWorldAxes and the test axis using the LocalTestAxis or TestAxis properties.
            </summary>
      <param name="connectionA">First connection of the pair.</param>
      <param name="connectionB">Second connection of the pair.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.JointLimits.RevoluteLimit.GetLinearJacobianA(Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Vector3@)">
      <summary>
            Gets the linear jacobian entry for the first connected entity.
            </summary>
      <param name="jacobianX">First linear jacobian entry for the first connected entity.</param>
      <param name="jacobianY">Second linear jacobian entry for the first connected entity.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.JointLimits.RevoluteLimit.GetLinearJacobianB(Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Vector3@)">
      <summary>
            Gets the linear jacobian entry for the second connected entity.
            </summary>
      <param name="jacobianX">First linear jacobian entry for the second connected entity.</param>
      <param name="jacobianY">Second linear jacobian entry for the second connected entity.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.JointLimits.RevoluteLimit.GetAngularJacobianA(Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Vector3@)">
      <summary>
            Gets the angular jacobian entry for the first connected entity.
            </summary>
      <param name="jacobianX">First angular jacobian entry for the first connected entity.</param>
      <param name="jacobianY">Second angular jacobian entry for the first connected entity.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.JointLimits.RevoluteLimit.GetAngularJacobianB(Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Vector3@)">
      <summary>
            Gets the angular jacobian entry for the second connected entity.
            </summary>
      <param name="jacobianX">First angular jacobian entry for the second connected entity.</param>
      <param name="jacobianY">Second angular jacobian entry for the second connected entity.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.JointLimits.RevoluteLimit.GetMassMatrix(BEPUphysics.MathExtensions.Matrix2X2@)">
      <summary>
            Gets the mass matrix of the revolute limit.
            The revolute limit is special; in terms of solving, it is
            actually sometimes TWO constraints; a minimum plane, and a
            maximum plane.  The M11 field represents the minimum plane mass matrix
            and the M22 field represents the maximum plane mass matrix.
            </summary>
      <param name="massMatrix">Mass matrix of the constraint.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.JointLimits.RevoluteLimit.SolveIteration">
      <summary>
            Computes one iteration of the constraint to meet the solver updateable's goal.
            </summary>
      <returns>The rough applied impulse magnitude.</returns>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.JointLimits.RevoluteLimit.Update(System.Single)">
      <summary>
             Performs the frame's configuration step.
            </summary>
      <param name="dt">Timestep duration.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.JointLimits.RevoluteLimit.ExclusiveUpdate">
      <summary>
            Performs any pre-solve iteration work that needs exclusive
            access to the members of the solver updateable.
            Usually, this is used for applying warmstarting impulses.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.JointLimits.RevoluteLimit.Basis">
      <summary>
            Gets the basis attached to entity A.
            The primary axis represents the limited axis of rotation.
            The x axis defines the 'base' direction corresponding to 0 degrees of relative rotation.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.JointLimits.RevoluteLimit.LocalTestAxis">
      <summary>
            Gets or sets the axis attached to entity B in its local space that will be tested against the limits.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.JointLimits.RevoluteLimit.MaximumAngle">
      <summary>
            Gets or sets the maximum angle that entities can twist.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.JointLimits.RevoluteLimit.MinimumAngle">
      <summary>
            Gets or sets the minimum angle that entities can twist.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.JointLimits.RevoluteLimit.TestAxis">
      <summary>
            Gets or sets the axis attached to entity B in world space that will be tested against the limits.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.JointLimits.RevoluteLimit.RelativeVelocity">
      <summary>
            Gets the current relative velocity between the connected entities with respect to the constraint.
            The revolute limit is special; internally, it is sometimes two constraints.
            The X value of the vector is the "minimum" plane of the limit, and the Y value is the "maximum" plane.
            If a plane isn't active, its error is zero.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.JointLimits.RevoluteLimit.TotalImpulse">
      <summary>
            Gets the total impulse applied by this constraint.
            The x component corresponds to the minimum plane limit,
            while the y component corresponds to the maximum plane limit.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.JointLimits.RevoluteLimit.Error">
      <summary>
            Gets the current constraint error.
            The x component corresponds to the minimum plane limit,
            while the y component corresponds to the maximum plane limit.
            </summary>
    </member>
    <member name="T:BEPUphysics.CollisionTests.CollisionAlgorithms.TriangleConvexPairTester">
      <summary>
             Persistent tester that compares triangles against convex objects.
            </summary>
    </member>
    <member name="F:BEPUphysics.CollisionTests.CollisionAlgorithms.TriangleConvexPairTester.Updated">
      <summary>
             Whether or not the pair tester was updated during the last attempt.
            </summary>
    </member>
    <member name="M:BEPUphysics.CollisionTests.CollisionAlgorithms.TriangleConvexPairTester.GenerateContactCandidate(BEPUphysics.CollisionTests.ContactData@)">
      <summary>
             Generates a contact between the triangle and convex.
            </summary>
      <param name="contact">Contact between the shapes, if any.</param>
      <returns>Whether or not the shapes are colliding.</returns>
    </member>
    <member name="M:BEPUphysics.CollisionTests.CollisionAlgorithms.TriangleConvexPairTester.GetVoronoiRegion(Microsoft.Xna.Framework.Vector3@)">
      <summary>
             Determines what voronoi region a given point is in.
            </summary>
      <param name="p">Point to test.</param>
      <returns>Voronoi region containing the point.</returns>
    </member>
    <member name="M:BEPUphysics.CollisionTests.CollisionAlgorithms.TriangleConvexPairTester.Initialize(BEPUphysics.CollisionShapes.ConvexShapes.ConvexShape,BEPUphysics.CollisionShapes.ConvexShapes.TriangleShape)">
      <summary>
             Initializes the pair tester.
            </summary>
      <param name="convex">Convex shape to use.</param>
      <param name="triangle">Triangle shape to use.</param>
    </member>
    <member name="M:BEPUphysics.CollisionTests.CollisionAlgorithms.TriangleConvexPairTester.CleanUp">
      <summary>
            Cleans up the pair tester.
            </summary>
    </member>
    <member name="T:BEPUphysics.DataStructures.MeshBoundingBoxTree">
      <summary>
             Acceleration structure of triangles surrounded by axis aligned bounding boxes, supporting various speedy queries.
            </summary>
    </member>
    <member name="F:BEPUphysics.DataStructures.MeshBoundingBoxTree.LeafMargin">
      <summary>
            The tiny extra margin added to leaf bounding boxes that allow the volume cost metric to function properly even in degenerate cases.
            </summary>
    </member>
    <member name="M:BEPUphysics.DataStructures.MeshBoundingBoxTree.#ctor(BEPUphysics.DataStructures.MeshBoundingBoxTreeData)">
      <summary>
            Constructs a new tree.
            </summary>
      <param name="data">Data to use to construct the tree.</param>
    </member>
    <member name="M:BEPUphysics.DataStructures.MeshBoundingBoxTree.Reconstruct">
      <summary>
            Reconstructs the tree based on the current data.
            </summary>
    </member>
    <member name="M:BEPUphysics.DataStructures.MeshBoundingBoxTree.Refit">
      <summary>
            Refits the tree based on the current data.
            This process is cheaper to perform than a reconstruction when the topology of the mesh
            does not change.
            </summary>
    </member>
    <member name="M:BEPUphysics.DataStructures.MeshBoundingBoxTree.GetOverlaps(Microsoft.Xna.Framework.BoundingBox,System.Collections.Generic.IList{System.Int32})">
      <summary>
            Gets the triangles whose bounding boxes are overlapped by the query.
            </summary>
      <param name="boundingBox">Shape to query against the tree.</param>
      <param name="outputOverlappedElements">Indices of triangles in the index buffer with bounding boxes which are overlapped by the query.</param>
      <returns>Whether or not any elements were overlapped.</returns>
    </member>
    <member name="M:BEPUphysics.DataStructures.MeshBoundingBoxTree.GetOverlaps(Microsoft.Xna.Framework.BoundingSphere,System.Collections.Generic.IList{System.Int32})">
      <summary>
            Gets the triangles whose bounding boxes are overlapped by the query.
            </summary>
      <param name="boundingSphere">Shape to query against the tree.</param>
      <param name="outputOverlappedElements">Indices of triangles in the index buffer with bounding boxes which are overlapped by the query.</param>
      <returns>Whether or not any elements were overlapped.</returns>
    </member>
    <member name="M:BEPUphysics.DataStructures.MeshBoundingBoxTree.GetOverlaps(Microsoft.Xna.Framework.BoundingFrustum,System.Collections.Generic.IList{System.Int32})">
      <summary>
            Gets the triangles whose bounding boxes are overlapped by the query.
            </summary>
      <param name="boundingFrustum">Shape to query against the tree.</param>
      <param name="outputOverlappedElements">Indices of triangles in the index buffer with bounding boxes which are overlapped by the query.</param>
      <returns>Whether or not any elements were overlapped.</returns>
    </member>
    <member name="M:BEPUphysics.DataStructures.MeshBoundingBoxTree.GetOverlaps(Microsoft.Xna.Framework.Ray,System.Collections.Generic.IList{System.Int32})">
      <summary>
            Gets the triangles whose bounding boxes are overlapped by the query.
            </summary>
      <param name="ray">Shape to query against the tree.</param>
      <param name="outputOverlappedElements">Indices of triangles in the index buffer with bounding boxes which are overlapped by the query.</param>
      <returns>Whether or not any elements were overlapped.</returns>
    </member>
    <member name="M:BEPUphysics.DataStructures.MeshBoundingBoxTree.GetOverlaps(Microsoft.Xna.Framework.Ray,System.Single,System.Collections.Generic.IList{System.Int32})">
      <summary>
            Gets the triangles whose bounding boxes are overlapped by the query.
            </summary>
      <param name="ray">Shape to query against the tree.</param>
      <param name="maximumLength">Maximum length of the ray in units of the ray's length.</param>
      <param name="outputOverlappedElements">Indices of triangles in the index buffer with bounding boxes which are overlapped by the query.</param>
      <returns>Whether or not any elements were overlapped.</returns>
    </member>
    <member name="P:BEPUphysics.DataStructures.MeshBoundingBoxTree.BoundingBox">
      <summary>
            Gets the bounding box surrounding the tree.
            </summary>
    </member>
    <member name="P:BEPUphysics.DataStructures.MeshBoundingBoxTree.Data">
      <summary>
            Gets or sets the data used to construct the tree.
            When set, the tree will be reconstructed.
            </summary>
    </member>
    <member name="T:BEPUphysics.BroadPhaseSystems.Hierarchies.DynamicHierarchyNode">
      <summary>
            Node within the binary hierarchy.
            </summary>
    </member>
    <member name="F:BEPUphysics.BroadPhaseSystems.Hierarchies.DynamicHierarchyNode.BoundingBox">
      <summary>
            Bounding box all entities that are children of the node.
            </summary>
    </member>
    <member name="M:BEPUphysics.BroadPhaseSystems.Hierarchies.DynamicHierarchyNode.#ctor">
      <summary>
            Constructs a DBH node.
            </summary>
    </member>
    <member name="M:BEPUphysics.BroadPhaseSystems.Hierarchies.DynamicHierarchyNode.CollectBoundingBoxLines(System.Collections.Generic.List{Microsoft.Xna.Framework.Graphics.VertexPositionColor},System.Boolean)">
      <summary>
            Collects all of the endpoints of lines of bounding boxes within the hierarchy.
            </summary>
      <param name="lineEndpoints">Endpoints of lines of bounding boxes within the hierarchy.</param>
      <param name="includeInternalNodes">Whether or not to collect the lines from internal node bounding boxes.</param>
    </member>
    <member name="M:BEPUphysics.BroadPhaseSystems.Hierarchies.DynamicHierarchyNode.Add(BEPUphysics.BroadPhaseSystems.BroadPhaseEntry)">
      <exception cref="T:System.InvalidOperationException">Thrown when the entity to add to the DynamicBinaryHierarchy has an invalid state.</exception>
    </member>
    <member name="T:BEPUphysics.Paths.QuaternionSlerpCurve">
      <summary>
            Defines a quaternion curve using spherical linear interpolation.
            </summary>
    </member>
    <member name="M:BEPUphysics.Paths.QuaternionSlerpCurve.Evaluate(System.Int32,System.Single,Microsoft.Xna.Framework.Quaternion@)">
      <summary>
            Evaluates the curve section starting at the control point index using
            the weight value.
            </summary>
      <param name="controlPointIndex">Index of the starting control point of the subinterval.</param>
      <param name="weight">Location to evaluate on the subinterval from 0 to 1.</param>
      <param name="value">Value at the given location.</param>
    </member>
    <member name="M:BEPUphysics.Paths.QuaternionSlerpCurve.GetCurveIndexBoundsInformation(System.Int32@,System.Int32@)">
      <summary>
            Gets the curve's bounding index information.
            </summary>
      <param name="minIndex">Index of the minimum control point in the active curve segment.</param>
      <param name="maxIndex">Index of the maximum control point in the active curve segment.</param>
    </member>
    <member name="M:BEPUphysics.Paths.QuaternionSlerpCurve.ControlPointAdded(BEPUphysics.Paths.CurveControlPoint{Microsoft.Xna.Framework.Quaternion},System.Int32)">
      <summary>
            Called when a control point is added.
            </summary>
      <param name="curveControlPoint">New control point.</param>
      <param name="index">Index of the control point.</param>
    </member>
    <member name="M:BEPUphysics.Paths.QuaternionSlerpCurve.ControlPointRemoved(BEPUphysics.Paths.CurveControlPoint{Microsoft.Xna.Framework.Quaternion},System.Int32)">
      <summary>
            Called when a control point is removed.
            </summary>
      <param name="curveControlPoint">Removed control point.</param>
      <param name="oldIndex">Index of the control point before it was removed.</param>
    </member>
    <member name="M:BEPUphysics.Paths.QuaternionSlerpCurve.ControlPointTimeChanged(BEPUphysics.Paths.CurveControlPoint{Microsoft.Xna.Framework.Quaternion},System.Int32,System.Int32)">
      <summary>
            Called when a control point belonging to the curve has its time changed.
            </summary>
      <param name="curveControlPoint">Changed control point.</param>
      <param name="oldIndex">Old index of the control point.</param>
      <param name="newIndex">New index of the control point.</param>
    </member>
    <member name="M:BEPUphysics.Paths.QuaternionSlerpCurve.ControlPointValueChanged(BEPUphysics.Paths.CurveControlPoint{Microsoft.Xna.Framework.Quaternion})">
      <summary>
            Called when a control point belonging to the curve has its value changed.
            </summary>
      <param name="curveControlPoint">Changed control point.</param>
    </member>
    <member name="T:BEPUphysics.EntityStateManagement.InterpolatedStatesManager">
      <summary>
             Manages the interpolated states of entities.  Interpolated states are those
             based on the previous entity states and the current entity states, blended together
             using the time remainder from internal time stepping.
            </summary>
    </member>
    <member name="M:BEPUphysics.EntityStateManagement.InterpolatedStatesManager.#ctor(BEPUphysics.EntityStateManagement.BufferedStatesManager)">
      <summary>
             Constructs a new interpolated states manager.
            </summary>
      <param name="manager">Owning buffered states manager.</param>
    </member>
    <member name="M:BEPUphysics.EntityStateManagement.InterpolatedStatesManager.#ctor(BEPUphysics.EntityStateManagement.BufferedStatesManager,BEPUphysics.Threading.IThreadManager)">
      <summary>
             Constructs a new interpolated states manager.
            </summary>
      <param name="manager">Owning buffered states manager.</param>
      <param name="threadManager">Thread manager to use.</param>
    </member>
    <member name="M:BEPUphysics.EntityStateManagement.InterpolatedStatesManager.FlipBuffers">
      <summary>
             Acquires a lock on the FlipLocker and flips the internal buffers.
            </summary>
    </member>
    <member name="M:BEPUphysics.EntityStateManagement.InterpolatedStatesManager.GetState(System.Int32)">
      <summary>
             Returns an interpolated state associated with an entity with the given index.
             Does not lock the FlipLocker.
            </summary>
      <param name="motionStateIndex">Motion state of the entity.</param>
      <returns>Interpolated state associated with the entity at the given index.</returns>
    </member>
    <member name="M:BEPUphysics.EntityStateManagement.InterpolatedStatesManager.GetStates(BEPUphysics.MathExtensions.RigidTransform[])">
      <summary>
             Gets the interpolated states of all entities.
            </summary>
      <param name="states">Interpolated states of all entities.</param>
      <exception cref="T:System.InvalidOperationException">Thrown when the array is too small to hold the states.</exception>
    </member>
    <member name="P:BEPUphysics.EntityStateManagement.InterpolatedStatesManager.Enabled">
      <summary>
             Gets or sets whether or not the manager is updating.
            </summary>
      <exception cref="T:System.InvalidOperationException">Thrown when enabling the interpolated manager without having the read buffers active.</exception>
    </member>
    <member name="P:BEPUphysics.EntityStateManagement.InterpolatedStatesManager.FlipLocker">
      <summary>
             Gets the synchronization object locked prior to flipping the internal buffers.
             Acquiring a lock on this object will prevent the internal buffers from flipping for the duration
             of the lock.
            </summary>
    </member>
    <member name="P:BEPUphysics.EntityStateManagement.InterpolatedStatesManager.BlendAmount">
      <summary>
             Gets or sets the blending amount to use.
             This is set automatically when the space is using internal timestepping
             (I.E. when Space.Update(dt) is called).  It is a value from 0 to 1
             that defines the amount of the previous and current frames to include
             in the blended state.  A value of 1 means use only the current frame;
             a value of 0 means use only the previous frame.
            </summary>
    </member>
    <member name="T:BEPUphysics.EntityStateManagement.InterpolatedStatesAccessor">
      <summary>
             Accesses an entity's interpolated states.
             Interpolated states are blended states between the previous and current entity states based
             on the time remainder from interal timestepping.
            </summary>
    </member>
    <member name="M:BEPUphysics.EntityStateManagement.InterpolatedStatesAccessor.#ctor(BEPUphysics.EntityStateManagement.EntityBufferedStates)">
      <summary>
             Constructs a new accessor.
            </summary>
      <param name="bufferedStates">Owning entry.</param>
    </member>
    <member name="P:BEPUphysics.EntityStateManagement.InterpolatedStatesAccessor.Position">
      <summary>
             Gets the interpolated position of the entity.
            </summary>
    </member>
    <member name="P:BEPUphysics.EntityStateManagement.InterpolatedStatesAccessor.Orientation">
      <summary>
             Gets the interpolated orientation of the entity.
            </summary>
    </member>
    <member name="P:BEPUphysics.EntityStateManagement.InterpolatedStatesAccessor.OrientationMatrix">
      <summary>
             Gets the interpolated orientation matrix of the entity.
            </summary>
    </member>
    <member name="P:BEPUphysics.EntityStateManagement.InterpolatedStatesAccessor.WorldTransform">
      <summary>
             Gets the interpolated world transform of the entity.
            </summary>
    </member>
    <member name="P:BEPUphysics.EntityStateManagement.InterpolatedStatesAccessor.RigidTransform">
      <summary>
             Gets the interpolated rigid transform of the entity.
            </summary>
    </member>
    <member name="T:BEPUphysics.CollisionTests.CollisionAlgorithms.GeneralConvexPairTester">
      <summary>
             Tests convex shapes against other convex shapes for contact generation.
            </summary>
    </member>
    <member name="F:BEPUphysics.CollisionTests.CollisionAlgorithms.GeneralConvexPairTester.UseSimplexCaching">
      <summary>
             Whether or not to use simplex caching in general case convex-convex collisions.
             This will improve performance in simulations relying on the general case system, 
             but may decrease quality of behavior for curved shapes.
            </summary>
    </member>
    <member name="M:BEPUphysics.CollisionTests.CollisionAlgorithms.GeneralConvexPairTester.GenerateContactCandidate(BEPUphysics.CollisionTests.ContactData@)">
      <summary>
             Generates a contact between the objects, if possible.
            </summary>
      <param name="contact">Contact created between the pair, if possible.</param>
      <returns>Whether or not the objects were colliding.</returns>
    </member>
    <member name="M:BEPUphysics.CollisionTests.CollisionAlgorithms.GeneralConvexPairTester.Initialize(BEPUphysics.Collidables.Collidable,BEPUphysics.Collidables.Collidable)">
      <summary>
             Initializes the pair tester.
            </summary>
      <param name="shapeA">First shape in the pair.</param>
      <param name="shapeB">Second shape in the pair.</param>
    </member>
    <member name="M:BEPUphysics.CollisionTests.CollisionAlgorithms.GeneralConvexPairTester.CleanUp">
      <summary>
             Cleans up the pair tester.
            </summary>
    </member>
    <member name="P:BEPUphysics.CollisionTests.CollisionAlgorithms.GeneralConvexPairTester.CollidableA">
      <summary>
             Gets the first collidable in the pair.
            </summary>
    </member>
    <member name="P:BEPUphysics.CollisionTests.CollisionAlgorithms.GeneralConvexPairTester.CollidableB">
      <summary>
             Gets the second collidable in the pair.
            </summary>
    </member>
    <member name="T:BEPUphysics.CollisionRuleManagement.CollisionRules">
      <summary>
            Stores how an object can interact with other objects through collisions.
            </summary>
    </member>
    <member name="F:BEPUphysics.CollisionRuleManagement.CollisionRules.CollisionGroupRules">
      <summary>
            Defines any special collision rules between collision groups.
            </summary>
    </member>
    <member name="F:BEPUphysics.CollisionRuleManagement.CollisionRules.DefaultCollisionRule">
      <summary>
            If a CollisionRule calculation between two colliding objects results in no defined CollisionRule, this value will be used.
            </summary>
    </member>
    <member name="F:BEPUphysics.CollisionRuleManagement.CollisionRules.DefaultDynamicCollisionGroup">
      <summary>
            When a dynamic entity is created and added to a space without having a specific collision group set beforehand, it inherits this collision group.
            There are no special rules associated with this group by default; entities within this group have normal, full interaction with all other entities.
            Collision group interaction rules can be overriden by entity personal collision rules or entity-to-entity specific collision rules.
            </summary>
    </member>
    <member name="F:BEPUphysics.CollisionRuleManagement.CollisionRules.DefaultKinematicCollisionGroup">
      <summary>
            When a kinematic entity is created and added to a space without having a specific collision group set beforehand, it inherits this collision group.
            Entities in this collision group will not create collision pairs with other entities of this collision group by default.  All other interactions are normal.
            Collision group interaction rules can be overriden by entity personal collision rules or entity-to-entity specific collision rules.
            
            Non-entity collidable objects like static triangle meshes also use this collision group by default.
            </summary>
    </member>
    <member name="M:BEPUphysics.CollisionRuleManagement.CollisionRules.#ctor">
      <summary>
             Constructs a new CollisionRules instance.
            </summary>
    </member>
    <member name="M:BEPUphysics.CollisionRuleManagement.CollisionRules.GetHashCode">
      <summary>
            Serves as a hash function for a particular type. 
            </summary>
      <returns>
            A hash code for the current <see cref="T:System.Object" />.
            </returns>
      <filterpriority>2</filterpriority>
    </member>
    <member name="M:BEPUphysics.CollisionRuleManagement.CollisionRules.AddRule(BEPUphysics.CollisionRuleManagement.ICollisionRulesOwner,BEPUphysics.CollisionRuleManagement.ICollisionRulesOwner,BEPUphysics.CollisionRuleManagement.CollisionRule)">
      <summary>
             Adds an entry in ownerA's Specific relationships list about ownerB.
            </summary>
      <param name="ownerA">Owner of the collision rules that will gain an entry in its Specific relationships.</param>
      <param name="ownerB">Owner of the collision rules that will be added to ownerA's Specific relationships.</param>
      <param name="rule">Rule assigned to the pair.</param>
    </member>
    <member name="M:BEPUphysics.CollisionRuleManagement.CollisionRules.AddRule(BEPUphysics.CollisionRuleManagement.CollisionRules,BEPUphysics.CollisionRuleManagement.ICollisionRulesOwner,BEPUphysics.CollisionRuleManagement.CollisionRule)">
      <summary>
             Adds an entry in rulesA's Specific relationships list about ownerB.
            </summary>
      <param name="rulesA">Collision rules that will gain an entry in its Specific relationships.</param>
      <param name="ownerB">Owner of the collision rules that will be added to ownerA's Specific relationships.</param>
      <param name="rule">Rule assigned to the pair.</param>
    </member>
    <member name="M:BEPUphysics.CollisionRuleManagement.CollisionRules.AddRule(BEPUphysics.CollisionRuleManagement.ICollisionRulesOwner,BEPUphysics.CollisionRuleManagement.CollisionRules,BEPUphysics.CollisionRuleManagement.CollisionRule)">
      <summary>
             Adds an entry in rulesA's Specific relationships list about ownerB.
            </summary>
      <param name="ownerA">Owner of the collision rules that will gain an entry in its Specific relationships.</param>
      <param name="rulesB">Collision rules that will be added to ownerA's Specific relationships.</param>
      <param name="rule">Rule assigned to the pair.</param>
    </member>
    <member name="M:BEPUphysics.CollisionRuleManagement.CollisionRules.RemoveRule(BEPUphysics.CollisionRuleManagement.ICollisionRulesOwner,BEPUphysics.CollisionRuleManagement.ICollisionRulesOwner)">
      <summary>
             Tries to remove a relationship about ownerB from ownerA's Specific list.
            </summary>
      <param name="ownerA">Owner of the collision rules that will lose an entry in its Specific relationships.</param>
      <param name="ownerB">Owner of the collision rules that will be removed from ownerA's Specific relationships.</param>
    </member>
    <member name="M:BEPUphysics.CollisionRuleManagement.CollisionRules.RemoveRule(BEPUphysics.CollisionRuleManagement.CollisionRules,BEPUphysics.CollisionRuleManagement.ICollisionRulesOwner)">
      <summary>
             Tries to remove a relationship about ownerB from rulesA's Specific list.
            </summary>
      <param name="rulesA">Collision rules that will lose an entry in its Specific relationships.</param>
      <param name="ownerB">Owner of the collision rules that will be removed from ownerA's Specific relationships.</param>
    </member>
    <member name="M:BEPUphysics.CollisionRuleManagement.CollisionRules.RemoveRule(BEPUphysics.CollisionRuleManagement.ICollisionRulesOwner,BEPUphysics.CollisionRuleManagement.CollisionRules)">
      <summary>
             Tries to remove a relationship about rulesB from ownerA's Specific list.
            </summary>
      <param name="ownerA">Owner of the collision rules that will lose an entry in its Specific relationships.</param>
      <param name="rulesB">Collision rules that will be removed from ownerA's Specific relationships.</param>
    </member>
    <member name="M:BEPUphysics.CollisionRuleManagement.CollisionRules.GetCollisionRule(BEPUphysics.CollisionRuleManagement.ICollisionRulesOwner,BEPUphysics.CollisionRuleManagement.ICollisionRulesOwner)">
      <summary>
            Uses the CollisionRuleCalculator to get the collision rule between two collision rules owners.
            </summary>
      <param name="ownerA">First owner of the pair.</param>
      <param name="ownerB">Second owner of the pair.</param>
      <returns>CollisionRule between the pair, according to the CollisionRuleCalculator.</returns>
    </member>
    <member name="M:BEPUphysics.CollisionRuleManagement.CollisionRules.GetCollisionRuleDefault(BEPUphysics.CollisionRuleManagement.CollisionRules,BEPUphysics.CollisionRuleManagement.CollisionRules)">
      <summary>
            Determines what collision rule governs the interaction between the two objects.
            </summary>
      <param name="a">First ruleset in the pair.  This entity's space is used to determine the collision detection settings that contain special collision group interaction rules.</param>
      <param name="b">Second ruleset in the pair.</param>
      <returns>Collision rule governing the interaction between the pair.</returns>
    </member>
    <member name="M:BEPUphysics.CollisionRuleManagement.CollisionRules.GetSpecificCollisionRuleDefault(BEPUphysics.CollisionRuleManagement.CollisionRules,BEPUphysics.CollisionRuleManagement.CollisionRules)">
      <summary>
             Default implementation used to calculate collision rules due to the rulesets' specific relationships.
            </summary>
      <param name="a">First ruleset in the pair.</param>
      <param name="b">Second ruleset in the pair.</param>
      <returns>Collision rule governing the interaction between the pair.</returns>
    </member>
    <member name="M:BEPUphysics.CollisionRuleManagement.CollisionRules.GetGroupCollisionRuleDefault(BEPUphysics.CollisionRuleManagement.CollisionRules,BEPUphysics.CollisionRuleManagement.CollisionRules)">
      <summary>
             Default implementation used to calculate collision rules due to the rulesets' collision groups.
            </summary>
      <param name="a">First ruleset in the pair.</param>
      <param name="b">Second ruleset in the pair.</param>
      <returns>Collision rule governing the interaction between the pair.</returns>
    </member>
    <member name="M:BEPUphysics.CollisionRuleManagement.CollisionRules.GetPersonalCollisionRuleDefault(BEPUphysics.CollisionRuleManagement.CollisionRules,BEPUphysics.CollisionRuleManagement.CollisionRules)">
      <summary>
             Default implementation used to calculate collision rules due to the rulesets' personal rules.
            </summary>
      <param name="a">First ruleset in the pair.</param>
      <param name="b">Second ruleset in the pair.</param>
      <returns>Collision rule governing the interaction between the pair.</returns>
    </member>
    <member name="P:BEPUphysics.CollisionRuleManagement.CollisionRules.Group">
      <summary>
            The collision group to which the object owning this instance belongs to.
            This is overridden by any relationships defined in the Specific collection with CollisionRules other than CollisionRule.Defer.
            This is also overriden by the Personal CollisionRule if it is anything but CollisionRule.Defer.
            If the interaction type between the group is defined as CollisionRule.Defer, it is considered to be CollisionRule.normal as the collision group is the final stage.
            </summary>
    </member>
    <member name="P:BEPUphysics.CollisionRuleManagement.CollisionRules.Personal">
      <summary>
            Determines in general how the object owning this instance should react to other objects.
            This is overridden by any relationships defined in the Specific collection with CollisionRules other than CollisionRule.Defer.
            If this is not set to CollisionRule.Defer, it will override the collision group's collision rules.
            </summary>
    </member>
    <member name="P:BEPUphysics.CollisionRuleManagement.CollisionRules.Specific">
      <summary>
            Specifies how the object owning this instance should react to other individual objects.
            Any rules defined in this collection will take priority over the Personal collision rule and the collision group's collision rules.
            Objects that are not in this collection are considered to have a relationship of CollisionRule.Defer.
            </summary>
    </member>
    <member name="P:BEPUphysics.CollisionRuleManagement.CollisionRules.CollisionRuleCalculator">
      <summary>
             Gets or sets the delegate used to calculate collision rules.
             Defaults to CollisionRules.GetCollisionRuleDefault.
            </summary>
    </member>
    <member name="E:BEPUphysics.CollisionRuleManagement.CollisionRules.CollisionRulesChanged">
      <summary>
             Fires when the contained collision rules are altered.
            </summary>
    </member>
    <member name="T:BEPUphysics.NarrowPhaseSystems.Pairs.CompoundStaticMeshPairHandler">
      <summary>
             Handles a compound-static mesh collision pair.
            </summary>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.Pairs.CompoundStaticMeshPairHandler.#ctor">
      <summary>
             Constructs a new pair handler.
            </summary>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.Pairs.CompoundStaticMeshPairHandler.Initialize(BEPUphysics.BroadPhaseSystems.BroadPhaseEntry,BEPUphysics.BroadPhaseSystems.BroadPhaseEntry)">
      <summary>
             Initializes the pair handler.
            </summary>
      <param name="entryA">First entry in the pair.</param>
      <param name="entryB">Second entry in the pair.</param>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.Pairs.CompoundStaticMeshPairHandler.UpdateMaterialProperties">
      <summary>
             Forces an update of the pair's material properties.
            </summary>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.Pairs.CompoundStaticMeshPairHandler.OnAddedToNarrowPhase">
      <summary>
             Called when the pair handler is added to the narrow phase.
            </summary>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.Pairs.CompoundStaticMeshPairHandler.CleanUp">
      <summary>
             Cleans up the pair handler.
            </summary>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.Pairs.CompoundStaticMeshPairHandler.UpdateCollision(System.Single)">
      <summary>
             Updates the pair handler.
            </summary>
      <param name="dt">Timestep duration.</param>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.Pairs.CompoundStaticMeshPairHandler.UpdateTimeOfImpact(BEPUphysics.Collidables.Collidable,System.Single)">
      <summary>
             Updates the time of impact for the pair.
            </summary>
      <param name="requester">Collidable requesting the update.</param>
      <param name="dt">Timestep duration.</param>
    </member>
    <member name="P:BEPUphysics.NarrowPhaseSystems.Pairs.CompoundStaticMeshPairHandler.ChildPairs">
      <summary>
             Gets the pair handlers associated with the compound's children.
            </summary>
    </member>
    <member name="T:BEPUphysics.NarrowPhaseSystems.NarrowPhaseHelper">
      <summary>
             Contains the collision managers dictionary and other helper methods for creating pairs.
            </summary>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.NarrowPhaseHelper.GetPair(BEPUphysics.BroadPhaseSystems.BroadPhaseOverlap@)">
      <summary>
             Gets a narrow phase pair for a given broad phase overlap.
            </summary>
      <param name="pair">Overlap to use to create the pair.</param>
      <returns>A INarrowPhasePair for the overlap.</returns>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.NarrowPhaseHelper.GetPair(BEPUphysics.BroadPhaseSystems.BroadPhaseEntry,BEPUphysics.BroadPhaseSystems.BroadPhaseEntry,BEPUphysics.CollisionRuleManagement.CollisionRule)">
      <summary>
             Gets a narrow phase pair for a given pair of entries.
            </summary>
      <param name="entryA">First entry in the pair.</param>
      <param name="entryB">Second entry in the pair.</param>
      <param name="rule">Collision rule governing the pair.</param>
      <returns>A INarrowPhasePair for the overlap.</returns>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.NarrowPhaseHelper.GetPair(BEPUphysics.BroadPhaseSystems.BroadPhaseEntry,BEPUphysics.BroadPhaseSystems.BroadPhaseEntry)">
      <summary>
             Gets a narrow phase pair for a given pair of entries.
            </summary>
      <param name="entryA">First entry in the pair.</param>
      <param name="entryB">Second entry in the pair.</param>
      <returns>A INarrowPhasePair for the overlap.</returns>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.NarrowPhaseHelper.GetPairHandler(BEPUphysics.Collidables.CollidablePair@,BEPUphysics.CollisionRuleManagement.CollisionRule)">
      <summary>
            Gets a collidable pair handler for a pair of collidables.
            </summary>
      <param name="pair">Pair of collidables to use to create the pair handler.</param>
      <param name="rule">Collision rule governing the pair.</param>
      <returns>CollidablePairHandler for the pair.</returns>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.NarrowPhaseHelper.GetPairHandler(BEPUphysics.Collidables.CollidablePair@)">
      <summary>
            Gets a collidable pair handler for a pair of collidables.
            </summary>
      <param name="pair">Pair of collidables to use to create the pair handler.</param>
      <returns>CollidablePairHandler for the pair.</returns>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.NarrowPhaseHelper.Intersecting(BEPUphysics.Collidables.CollidablePair@)">
      <summary>
            Tests the pair of collidables for intersection without regard for collision rules.
            </summary>
      <param name="pair">Pair to test.</param>
      <returns>Whether or not the pair is intersecting.</returns>
    </member>
    <member name="P:BEPUphysics.NarrowPhaseSystems.NarrowPhaseHelper.GeneralConvexPairFactory">
      <summary>
             The fallback factory used for convex pairs.
            </summary>
    </member>
    <member name="P:BEPUphysics.NarrowPhaseSystems.NarrowPhaseHelper.CollisionManagers">
      <summary>
             Gets or sets the dictionary that defines the factory to use for various type pairs.
            </summary>
    </member>
    <member name="T:BEPUphysics.NarrowPhaseSystems.Factories.SpherePairFactory">
      <summary>
             Manufactures sphere-sphere pairs.
            </summary>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.Factories.SpherePairFactory.GetNarrowPhasePair(BEPUphysics.BroadPhaseSystems.BroadPhaseOverlap)">
      <summary>
             Manufactures and returns a narrow phase pair for the given overlap.
            </summary>
      <param name="overlap">Overlap used to create a pair.</param>
      <returns>Narrow phase pair.</returns>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.Factories.SpherePairFactory.GiveBack(BEPUphysics.NarrowPhaseSystems.Pairs.INarrowPhasePair)">
      <summary>
            Returns a pair to the factory for re-use.
            </summary>
      <param name="pair">Pair to return.</param>
    </member>
    <member name="T:BEPUphysics.Collidables.Events.ContactEventManager`1">
      <summary>
             Event manager for collidables (things which can create contact points).
            </summary>
      <typeparam name="T">Some Collidable subclass.</typeparam>
    </member>
    <member name="M:BEPUphysics.Collidables.Events.ContactEventManager`1.#ctor(`0)">
      <summary>
             Constructs a new event manager.
            </summary>
      <param name="owner">Owner of the event manager.</param>
    </member>
    <member name="M:BEPUphysics.Collidables.Events.ContactEventManager`1.#ctor">
      <summary>
             Constructs a new event manager.
            </summary>
    </member>
    <member name="M:BEPUphysics.Collidables.Events.ContactEventManager`1.RemoveAllEvents">
      <summary>
             Removes all event hooks from the event manager.
            </summary>
    </member>
    <member name="T:BEPUphysics.Entities.Prefabs.Triangle">
      <summary>
            Triangle-shaped object that can collide and move.  After making an entity, add it to a Space so that the engine can manage it.
            </summary>
    </member>
    <member name="M:BEPUphysics.Entities.Prefabs.Triangle.#ctor(Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,System.Single)">
      <summary>
            Constructs a dynamic triangle.
            </summary>
      <param name="v1">Position of the first vertex.</param>
      <param name="v2">Position of the second vertex.</param>
      <param name="v3">Position of the third vertex.</param>
      <param name="mass">Mass of the object.</param>
    </member>
    <member name="M:BEPUphysics.Entities.Prefabs.Triangle.#ctor(Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3)">
      <summary>
            Constructs a nondynamic triangle.
            </summary>
      <param name="v1">Position of the first vertex.</param>
      <param name="v2">Position of the second vertex.</param>
      <param name="v3">Position of the third vertex.</param>
    </member>
    <member name="M:BEPUphysics.Entities.Prefabs.Triangle.#ctor(Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,System.Single)">
      <summary>
            Constructs a dynamic triangle.
            </summary>
      <param name="pos">Position where the triangle is initialy centered.</param>
      <param name="v1">Position of the first vertex.</param>
      <param name="v2">Position of the second vertex.</param>
      <param name="v3">Position of the third vertex.</param>
      <param name="mass">Mass of the object.</param>
    </member>
    <member name="M:BEPUphysics.Entities.Prefabs.Triangle.#ctor(Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3)">
      <summary>
            Constructs a nondynamic triangle.
            </summary>
      <param name="pos">Position where the triangle is initially centered.</param>
      <param name="v1">Position of the first vertex.</param>
      <param name="v2">Position of the second vertex.</param>
      <param name="v3">Position of the third vertex.</param>
    </member>
    <member name="M:BEPUphysics.Entities.Prefabs.Triangle.#ctor(BEPUphysics.EntityStateManagement.MotionState,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,System.Single)">
      <summary>
            Constructs a dynamic triangle.
            </summary>
      <param name="motionState">Motion state specifying the entity's initial state.</param>
      <param name="v1">Position of the first vertex.</param>
      <param name="v2">Position of the second vertex.</param>
      <param name="v3">Position of the third vertex.</param>
      <param name="mass">Mass of the object.</param>
    </member>
    <member name="M:BEPUphysics.Entities.Prefabs.Triangle.#ctor(BEPUphysics.EntityStateManagement.MotionState,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3)">
      <summary>
            Constructs a nondynamic triangle.
            </summary>
      <param name="motionState">Motion state specifying the entity's initial state.</param>
      <param name="v1">Position of the first vertex.</param>
      <param name="v2">Position of the second vertex.</param>
      <param name="v3">Position of the third vertex.</param>
    </member>
    <member name="P:BEPUphysics.Entities.Prefabs.Triangle.LocalVertexA">
      <summary>
             Gets or sets the first vertex of the triangle in local space.
            </summary>
    </member>
    <member name="P:BEPUphysics.Entities.Prefabs.Triangle.LocalVertexB">
      <summary>
             Gets or sets the second vertex of the triangle in local space.
            </summary>
    </member>
    <member name="P:BEPUphysics.Entities.Prefabs.Triangle.LocalVertexC">
      <summary>
             Gets or sets the third vertex of the triangle in local space.
            </summary>
    </member>
    <member name="P:BEPUphysics.Entities.Prefabs.Triangle.VertexA">
      <summary>
             Gets or sets the first vertex of the triangle in world space.
            </summary>
    </member>
    <member name="P:BEPUphysics.Entities.Prefabs.Triangle.VertexB">
      <summary>
             Gets or sets the second vertex of the triangle in world space.
            </summary>
    </member>
    <member name="P:BEPUphysics.Entities.Prefabs.Triangle.VertexC">
      <summary>
             Gets or sets the third vertex of the triangle in world space.
            </summary>
    </member>
    <member name="P:BEPUphysics.Entities.Prefabs.Triangle.Sidedness">
      <summary>
             Gets or sets the sidedness of the triangle.
            </summary>
    </member>
    <member name="T:BEPUphysics.Entities.Prefabs.CompoundBody">
      <summary>
            Acts as a grouping of multiple other objects.  Can be used to form physically simulated concave shapes.
            </summary>
    </member>
    <member name="M:BEPUphysics.Entities.Prefabs.CompoundBody.#ctor(System.Collections.Generic.IList{BEPUphysics.CollisionShapes.CompoundShapeEntry})">
      <summary>
            Creates a new kinematic CompoundBody with the given subbodies.
            </summary>
      <param name="bodies">List of entities to use as subbodies of the compound body.</param>
      <exception cref="T:System.InvalidOperationException">Thrown when the bodies list is empty or there is a mix of kinematic and dynamic entities in the body list.</exception>
    </member>
    <member name="M:BEPUphysics.Entities.Prefabs.CompoundBody.#ctor(System.Collections.Generic.IList{BEPUphysics.CollisionShapes.CompoundShapeEntry},System.Single)">
      <summary>
            Creates a new dynamic CompoundBody with the given subbodies.
            </summary>
      <param name="bodies">List of entities to use as subbodies of the compound body.</param>
      <param name="mass">Mass of the compound.</param>
      <exception cref="T:System.InvalidOperationException">Thrown when the bodies list is empty or there is a mix of kinematic and dynamic entities in the body list.</exception>
    </member>
    <member name="M:BEPUphysics.Entities.Prefabs.CompoundBody.#ctor(System.Collections.Generic.IList{BEPUphysics.Collidables.MobileCollidables.CompoundChildData})">
      <summary>
             Constructs a kinematic compound body from the children data.
            </summary>
      <param name="children">Children data to construct the compound from.</param>
    </member>
    <member name="M:BEPUphysics.Entities.Prefabs.CompoundBody.#ctor(System.Collections.Generic.IList{BEPUphysics.Collidables.MobileCollidables.CompoundChildData},System.Single)">
      <summary>
             Constructs a dynamic compound body from the children data.
            </summary>
      <param name="children">Children data to construct the compound from.</param>
      <param name="mass">Mass of the compound body.</param>
    </member>
    <member name="P:BEPUphysics.Entities.Prefabs.CompoundBody.Shapes">
      <summary>
             Gets the list of shapes in the compound.
            </summary>
    </member>
    <member name="T:BEPUphysics.Constraints.TwoEntity.JointLimits.TwistLimit">
      <summary>
            Prevents the connected entities from twisting relative to each other beyond given limits.
            </summary>
    </member>
    <member name="F:BEPUphysics.Constraints.TwoEntity.JointLimits.TwistLimit.maximumAngle">
      <summary>
            Naximum angle that entities can twist.
            </summary>
    </member>
    <member name="F:BEPUphysics.Constraints.TwoEntity.JointLimits.TwistLimit.minimumAngle">
      <summary>
            Minimum angle that entities can twist.
            </summary>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.JointLimits.TwistLimit.#ctor">
      <summary>
            Constructs a new constraint which prevents the connected entities from twisting relative to each other beyond given limits.
            To finish the initialization, specify the connections (ConnectionA and ConnectionB) 
            as well as the BasisA, BasisB and the MinimumAngle and MaximumAngle.
            This constructor sets the constraint's IsActive property to false by default.
            </summary>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.JointLimits.TwistLimit.#ctor(BEPUphysics.Entities.Entity,BEPUphysics.Entities.Entity,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,System.Single,System.Single)">
      <summary>
            Constructs a new constraint which prevents the connected entities from twisting relative to each other beyond given limits.
            </summary>
      <param name="connectionA">First connection of the pair.</param>
      <param name="connectionB">Second connection of the pair.</param>
      <param name="axisA">Twist axis attached to the first connected entity.</param>
      <param name="axisB">Twist axis attached to the second connected entity.</param>
      <param name="minimumAngle">Minimum twist angle allowed.</param>
      <param name="maximumAngle">Maximum twist angle allowed.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.JointLimits.TwistLimit.GetLinearJacobianA(Microsoft.Xna.Framework.Vector3@)">
      <summary>
            Gets the linear jacobian entry for the first connected entity.
            </summary>
      <param name="jacobian">Linear jacobian entry for the first connected entity.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.JointLimits.TwistLimit.GetLinearJacobianB(Microsoft.Xna.Framework.Vector3@)">
      <summary>
            Gets the linear jacobian entry for the second connected entity.
            </summary>
      <param name="jacobian">Linear jacobian entry for the second connected entity.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.JointLimits.TwistLimit.GetAngularJacobianA(Microsoft.Xna.Framework.Vector3@)">
      <summary>
            Gets the angular jacobian entry for the first connected entity.
            </summary>
      <param name="jacobian">Angular jacobian entry for the first connected entity.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.JointLimits.TwistLimit.GetAngularJacobianB(Microsoft.Xna.Framework.Vector3@)">
      <summary>
            Gets the angular jacobian entry for the second connected entity.
            </summary>
      <param name="jacobian">Angular jacobian entry for the second connected entity.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.JointLimits.TwistLimit.GetMassMatrix(System.Single@)">
      <summary>
            Gets the mass matrix of the constraint.
            </summary>
      <param name="outputMassMatrix">Constraint's mass matrix.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.JointLimits.TwistLimit.SetupJointTransforms(Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3)">
      <summary>
            Sets up the joint transforms by automatically creating perpendicular vectors to complete the bases.
            </summary>
      <param name="worldTwistAxisA">Twist axis in world space to attach to entity A.</param>
      <param name="worldTwistAxisB">Twist axis in world space to attach to entity B.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.JointLimits.TwistLimit.SolveIteration">
      <summary>
            Solves for velocity.
            </summary>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.JointLimits.TwistLimit.Update(System.Single)">
      <summary>
            Do any necessary computations to prepare the constraint for this frame.
            </summary>
      <param name="dt">Simulation step length.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.JointLimits.TwistLimit.ExclusiveUpdate">
      <summary>
            Performs any pre-solve iteration work that needs exclusive
            access to the members of the solver updateable.
            Usually, this is used for applying warmstarting impulses.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.JointLimits.TwistLimit.BasisA">
      <summary>
            Gets the basis attached to entity A.
            The primary axis represents the twist axis attached to entity A.
            The x axis and y axis represent a plane against which entity B's attached x axis is projected to determine the twist angle.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.JointLimits.TwistLimit.BasisB">
      <summary>
            Gets the basis attached to entity B.
            The primary axis represents the twist axis attached to entity A.
            The x axis is projected onto the plane defined by localTransformA's x and y axes
            to get the twist angle.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.JointLimits.TwistLimit.MaximumAngle">
      <summary>
            Gets or sets the maximum angle that entities can twist.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.JointLimits.TwistLimit.MinimumAngle">
      <summary>
            Gets or sets the minimum angle that entities can twist.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.JointLimits.TwistLimit.RelativeVelocity">
      <summary>
            Gets the current relative velocity between the connected entities with respect to the constraint.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.JointLimits.TwistLimit.TotalImpulse">
      <summary>
            Gets the total impulse applied by this constraint.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.JointLimits.TwistLimit.Error">
      <summary>
            Gets the current constraint error.
            </summary>
    </member>
    <member name="T:BEPUphysics.Constraints.Collision.ContactPenetrationConstraint">
      <summary>
            Computes the forces necessary to keep two entities from going through each other at a contact point.
            </summary>
    </member>
    <member name="M:BEPUphysics.Constraints.Collision.ContactPenetrationConstraint.#ctor">
      <summary>
             Constructs a new penetration constraint.
            </summary>
    </member>
    <member name="M:BEPUphysics.Constraints.Collision.ContactPenetrationConstraint.Setup(BEPUphysics.Constraints.Collision.ContactManifoldConstraint,BEPUphysics.CollisionTests.Contact)">
      <summary>
             Configures the penetration constraint.
            </summary>
      <param name="contactManifoldConstraint">Owning manifold constraint.</param>
      <param name="contact">Contact associated with the penetration constraint.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.Collision.ContactPenetrationConstraint.CleanUp">
      <summary>
             Cleans up the constraint.
            </summary>
    </member>
    <member name="M:BEPUphysics.Constraints.Collision.ContactPenetrationConstraint.SolveIteration">
      <summary>
            Computes and applies an impulse to keep the colliders from penetrating.
            </summary>
      <returns>Impulse applied.</returns>
    </member>
    <member name="M:BEPUphysics.Constraints.Collision.ContactPenetrationConstraint.Update(System.Single)">
      <summary>
             Performs the frame's configuration step.
            </summary>
      <param name="dt">Timestep duration.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.Collision.ContactPenetrationConstraint.ExclusiveUpdate">
      <summary>
            Performs any pre-solve iteration work that needs exclusive
            access to the members of the solver updateable.
            Usually, this is used for applying warmstarting impulses.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.Collision.ContactPenetrationConstraint.Contact">
      <summary>
             Gets the contact associated with this penetration constraint.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.Collision.ContactPenetrationConstraint.NormalForce">
      <summary>
            Gets the total normal force applied by this penetration constraint to maintain the separation of the involved entities.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.Collision.ContactPenetrationConstraint.RelativeVelocity">
      <summary>
             Gets the relative velocity between the associated entities at the contact point along the contact normal.
            </summary>
    </member>
    <member name="T:BEPUphysics.CollisionShapes.ConvexShapes.OrientedConvexShapeEntry">
      <summary>
             A shape associated with an orientation.
            </summary>
    </member>
    <member name="F:BEPUphysics.CollisionShapes.ConvexShapes.OrientedConvexShapeEntry.CollisionShape">
      <summary>
             The entry's shape.
            </summary>
    </member>
    <member name="F:BEPUphysics.CollisionShapes.ConvexShapes.OrientedConvexShapeEntry.Orientation">
      <summary>
             The entry's orientation.
            </summary>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.ConvexShapes.OrientedConvexShapeEntry.#ctor(Microsoft.Xna.Framework.Quaternion,BEPUphysics.CollisionShapes.ConvexShapes.ConvexShape)">
      <summary>
             Constructs a new entry.
            </summary>
      <param name="orientation">Orientation of the entry.</param>
      <param name="shape">Shape of the entry.</param>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.ConvexShapes.OrientedConvexShapeEntry.#ctor(BEPUphysics.CollisionShapes.ConvexShapes.ConvexShape)">
      <summary>
             Constructs a new entry with identity orientation.
            </summary>
      <param name="shape">Shape of the entry.</param>
    </member>
    <member name="T:BEPUphysics.CollisionShapes.ConvexShapes.MinkowskiSumShape">
      <summary>
             A shape composed of the pointwise summation of all points in child shapes.
             For example, the minkowski sum of two spheres would be a sphere with the radius of both spheres combined.
             The minkowski sum of a box and a sphere would be a rounded box.
            </summary>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.ConvexShapes.MinkowskiSumShape.#ctor(BEPUphysics.CollisionShapes.ConvexShapes.OrientedConvexShapeEntry,BEPUphysics.CollisionShapes.ConvexShapes.OrientedConvexShapeEntry,Microsoft.Xna.Framework.Vector3@)">
      <summary>
            Constructs a minkowski sum shape.
            A minkowski sum can be created from more than two objects; use the other constructors.
            The sum will be recentered on its local origin.
            </summary>
      <param name="firstShape">First entry in the sum.</param>
      <param name="secondShape">Second entry in the sum.</param>
      <param name="center">Center of the minkowski sum computed pre-recentering.</param>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.ConvexShapes.MinkowskiSumShape.#ctor(System.Collections.Generic.IList{BEPUphysics.CollisionShapes.ConvexShapes.OrientedConvexShapeEntry},Microsoft.Xna.Framework.Vector3@)">
      <summary>
            Constructs a minkowski sum shape.
            The sum will be recentered on its local origin.
            </summary>
      <param name="shapeEntries">Entries composing the minkowski sum.</param>
      <param name="center">Center of the minkowski sum computed pre-recentering.</param>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.ConvexShapes.MinkowskiSumShape.#ctor(BEPUphysics.CollisionShapes.ConvexShapes.OrientedConvexShapeEntry,BEPUphysics.CollisionShapes.ConvexShapes.OrientedConvexShapeEntry)">
      <summary>
            Constructs a minkowski sum shape.
            A minkowski sum can be created from more than two objects; use the other constructors.
            The sum will be recentered on its local origin.  The computed center is outputted by the other constructor.
            </summary>
      <param name="firstShape">First entry in the sum.</param>
      <param name="secondShape">Second entry in the sum.</param>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.ConvexShapes.MinkowskiSumShape.#ctor(System.Collections.Generic.IList{BEPUphysics.CollisionShapes.ConvexShapes.OrientedConvexShapeEntry})">
      <summary>
            Constructs a minkowski sum shape.
            The sum will be recentered on its local origin.  The computed center is outputted by the other constructor.
            </summary>
      <param name="shapeEntries">Entries composing the minkowski sum.</param>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.ConvexShapes.MinkowskiSumShape.GetLocalExtremePointWithoutMargin(Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Vector3@)">
      <summary>
             Gets the extreme point of the shape in local space in a given direction.
            </summary>
      <param name="direction">Direction to find the extreme point in.</param>
      <param name="extremePoint">Extreme point on the shape.</param>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.ConvexShapes.MinkowskiSumShape.ComputeMinimumRadius">
      <summary>
             Computes the minimum radius of the shape.
             This is often smaller than the actual minimum radius;
             it is simply an approximation that avoids overestimating.
            </summary>
      <returns>Minimum radius of the shape.</returns>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.ConvexShapes.MinkowskiSumShape.ComputeMaximumRadius">
      <summary>
            Computes the maximum radius of the shape.
            This is often larger than the actual maximum radius;
            it is simply an approximation that avoids underestimating.
            </summary>
      <returns>Maximum radius of the shape.</returns>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.ConvexShapes.MinkowskiSumShape.GetMobileInstance">
      <summary>
            Retrieves an instance of an EntityCollidable that uses this EntityShape.  Mainly used by compound bodies.
            </summary>
      <returns>EntityCollidable that uses this shape.</returns>
    </member>
    <member name="P:BEPUphysics.CollisionShapes.ConvexShapes.MinkowskiSumShape.Shapes">
      <summary>
             Gets the list of shapes in the minkowski sum.
            </summary>
    </member>
    <member name="P:BEPUphysics.CollisionShapes.ConvexShapes.MinkowskiSumShape.LocalOffset">
      <summary>
             Gets the local offset of the elements in the minkowski sum.
             This is required because convex shapes need to be centered on their local origin.
            </summary>
    </member>
    <member name="T:BEPUphysics.Threading.SpecializedThreadManager">
      <summary>
            Manages the engine's threads.
            </summary>
      <remarks>
            Separates the management of ThreadTasks and loops
            into specialized systems.  Should have generally higher
            performance than the SimpleThreadManager.
            </remarks>
    </member>
    <member name="M:BEPUphysics.Threading.SpecializedThreadManager.#ctor">
      <summary>
            Constructs a new specialized thread manager
            that manages loops and tasks separately.
            </summary>
    </member>
    <member name="M:BEPUphysics.Threading.SpecializedThreadManager.Finalize">
      <summary>
            Releases resources used by the object.
            </summary>
    </member>
    <member name="M:BEPUphysics.Threading.SpecializedThreadManager.AddThread">
      <summary>
            Adds a new worker thread to the engine.
            </summary>
    </member>
    <member name="M:BEPUphysics.Threading.SpecializedThreadManager.AddThread(System.Action{System.Object},System.Object)">
      <summary>
            Adds a new worker thread to the engine.
            </summary>
      <param name="initialization">Function that the new thread will call before entering its work loop.</param>
      <param name="initializationInformation">Data to give the initializer.</param>
    </member>
    <member name="M:BEPUphysics.Threading.SpecializedThreadManager.RemoveThread">
      <summary>
            Removes a worker thread from the engine.
            </summary>
    </member>
    <member name="M:BEPUphysics.Threading.SpecializedThreadManager.EnqueueTask(System.Action{System.Object},System.Object)">
      <summary>
            Enqueues a task to the thread manager.
            This should be safe to call from multiple threads and from other tasks.
            </summary>
      <param name="taskBody">Method to run.</param>
      <param name="taskInformation">Data to give to the task.</param>
    </member>
    <member name="M:BEPUphysics.Threading.SpecializedThreadManager.ForLoop(System.Int32,System.Int32,System.Action{System.Int32})">
      <summary>
            Loops from the starting index (inclusive) to the ending index (exclusive), calling the loopBody at each iteration.
            The forLoop function will not return until all iterations are complete.
            This is meant to be used in a 'fork-join' model; only a single thread should be running a forLoop
            at any time.
            </summary>
      <param name="startIndex">Inclusive starting index.</param>
      <param name="endIndex">Exclusive ending index.</param>
      <param name="loopBody">Function that handles an individual iteration of the loop.</param>
    </member>
    <member name="M:BEPUphysics.Threading.SpecializedThreadManager.WaitForTaskCompletion">
      <summary>
            Waits until all tasks enqueued using enqueueTask are complete.
            </summary>
    </member>
    <member name="M:BEPUphysics.Threading.SpecializedThreadManager.Dispose">
      <summary>
            Releases resources used by the object.
            </summary>
    </member>
    <member name="P:BEPUphysics.Threading.SpecializedThreadManager.LoopManager">
      <summary>
            Gets or sets the loop manager used by this threading system.
            The loop manager is used to specifically parallelize forloops.
            </summary>
    </member>
    <member name="P:BEPUphysics.Threading.SpecializedThreadManager.TaskManager">
      <summary>
            Gets or sets the task manager used by this threading system.
            The task manager is used for anything that isn't strictly a 
            for loop.
            </summary>
    </member>
    <member name="P:BEPUphysics.Threading.SpecializedThreadManager.ThreadCount">
      <summary>
            Gets the number of threads in use by the manager.
            </summary>
    </member>
    <member name="T:BEPUphysics.Paths.CurveControlPointList`1">
      <summary>
            Collection of control points in a curve.
            </summary>
      <typeparam name="TValue">Type of values in the curve.</typeparam>
    </member>
    <member name="M:BEPUphysics.Paths.CurveControlPointList`1.GetEnumerator">
      <summary>
             Gets an enumerator for the list.
            </summary>
      <returns>Enumerator for the list.</returns>
    </member>
    <member name="M:BEPUphysics.Paths.CurveControlPointList`1.Add(BEPUphysics.Paths.CurveControlPoint{`0})">
      <summary>
            Adds a control point to the curve.
            </summary>
      <param name="point">New control point to add to the curve.</param>
    </member>
    <member name="M:BEPUphysics.Paths.CurveControlPointList`1.Add(System.Single,`0)">
      <summary>
            Adds a new control point to the curve.
            </summary>
      <param name="time">Time of the new control point.</param>
      <param name="value">Value of the new control point.</param>
      <returns>Newly created control point.</returns>
    </member>
    <member name="M:BEPUphysics.Paths.CurveControlPointList`1.Remove(BEPUphysics.Paths.CurveControlPoint{`0})">
      <summary>
            Removes the control point from the curve.
            </summary>
      <param name="controlPoint">Control point to remove.</param>
    </member>
    <member name="M:BEPUphysics.Paths.CurveControlPointList`1.RemoveAt(System.Int32)">
      <summary>
            Removes the control point from the curve.
            </summary>
      <param name="index">Index to remove at.</param>
    </member>
    <member name="P:BEPUphysics.Paths.CurveControlPointList`1.Item(System.Int32)">
      <summary>
            Gets the control point at the given index.
            </summary>
      <param name="index">Index into the list.</param>
      <returns>Control point at the index.</returns>
    </member>
    <member name="P:BEPUphysics.Paths.CurveControlPointList`1.Count">
      <summary>
            Gets the number of elements in the list.
            </summary>
    </member>
    <member name="P:BEPUphysics.Paths.CurveControlPointList`1.Curve">
      <summary>
            Gets the curve associated with this control point list.
            </summary>
    </member>
    <member name="T:BEPUphysics.NarrowPhaseSystems.Pairs.StaticMeshConvexPairHandler">
      <summary>
             Handles a static mesh-convex collision pair.
            </summary>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.Pairs.StaticMeshConvexPairHandler.#ctor">
      <summary>
             Constructs a new pair handler.
            </summary>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.Pairs.StaticMeshConvexPairHandler.Initialize(BEPUphysics.BroadPhaseSystems.BroadPhaseEntry,BEPUphysics.BroadPhaseSystems.BroadPhaseEntry)">
      <summary>
             Initializes the pair handler.
            </summary>
      <param name="entryA">First entry in the pair.</param>
      <param name="entryB">Second entry in the pair.</param>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.Pairs.StaticMeshConvexPairHandler.UpdateMaterialProperties">
      <summary>
             Forces an update of the pair's material properties.
            </summary>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.Pairs.StaticMeshConvexPairHandler.OnAddedToNarrowPhase">
      <summary>
             Called when the pair handler is added to the narrow phase.
            </summary>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.Pairs.StaticMeshConvexPairHandler.CleanUp">
      <summary>
             Cleans up the pair handler.
            </summary>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.Pairs.StaticMeshConvexPairHandler.UpdateCollision(System.Single)">
      <summary>
             Updates the pair handler.
            </summary>
      <param name="dt">Timestep duration.</param>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.Pairs.StaticMeshConvexPairHandler.UpdateTimeOfImpact(BEPUphysics.Collidables.Collidable,System.Single)">
      <summary>
             Updates the time of impact for the pair.
            </summary>
      <param name="requester">Collidable requesting the update.</param>
      <param name="dt">Timestep duration.</param>
    </member>
    <member name="T:BEPUphysics.Constraints.TwoEntity.Motors.RevoluteMotor">
      <summary>
            Tries to rotate two entities so that they reach a specified relative orientation or speed around an axis.
            </summary>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.Motors.RevoluteMotor.#ctor">
      <summary>
            Constructs a new constraint tries to rotate two entities so that they reach a specified relative orientation around an axis.
            To finish the initialization, specify the connections (ConnectionA and ConnectionB) 
            as well as the Basis and TestAxis.
            This constructor sets the constraint's IsActive property to false by default.
            </summary>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.Motors.RevoluteMotor.#ctor(BEPUphysics.Entities.Entity,BEPUphysics.Entities.Entity,Microsoft.Xna.Framework.Vector3)">
      <summary>
            Constructs a new constraint tries to rotate two entities so that they reach a specified relative orientation around an axis.
            </summary>
      <param name="connectionA">First connection of the pair.</param>
      <param name="connectionB">Second connection of the pair.</param>
      <param name="freeAxis">Allowed rotation axis of the hinge in world space.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.Motors.RevoluteMotor.GetLinearJacobianA(Microsoft.Xna.Framework.Vector3@)">
      <summary>
            Gets the linear jacobian entry for the first connected entity.
            </summary>
      <param name="jacobian">Linear jacobian entry for the first connected entity.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.Motors.RevoluteMotor.GetLinearJacobianB(Microsoft.Xna.Framework.Vector3@)">
      <summary>
            Gets the linear jacobian entry for the second connected entity.
            </summary>
      <param name="jacobian">Linear jacobian entry for the second connected entity.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.Motors.RevoluteMotor.GetAngularJacobianA(Microsoft.Xna.Framework.Vector3@)">
      <summary>
            Gets the angular jacobian entry for the first connected entity.
            </summary>
      <param name="jacobian">Angular jacobian entry for the first connected entity.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.Motors.RevoluteMotor.GetAngularJacobianB(Microsoft.Xna.Framework.Vector3@)">
      <summary>
            Gets the angular jacobian entry for the second connected entity.
            </summary>
      <param name="jacobian">Angular jacobian entry for the second connected entity.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.Motors.RevoluteMotor.GetMassMatrix(System.Single@)">
      <summary>
            Gets the mass matrix of the constraint.
            </summary>
      <param name="outputMassMatrix">Constraint's mass matrix.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.Motors.RevoluteMotor.SetupJointTransforms(Microsoft.Xna.Framework.Vector3)">
      <summary>
            Sets up the joint transforms by automatically creating perpendicular vectors to complete the bases.
            </summary>
      <param name="freeAxis">Axis around which rotation is allowed.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.Motors.RevoluteMotor.SolveIteration">
      <summary>
            Computes one iteration of the constraint to meet the solver updateable's goal.
            </summary>
      <returns>The rough applied impulse magnitude.</returns>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.Motors.RevoluteMotor.ExclusiveUpdate">
      <summary>
            Performs any pre-solve iteration work that needs exclusive
            access to the members of the solver updateable.
            Usually, this is used for applying warmstarting impulses.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.Motors.RevoluteMotor.Basis">
      <summary>
            Gets the basis attached to entity A.
            The primary axis represents the motorized axis.
            The x axis and y axis represent a plane against which entity B's attached test axis is project to determine the hinge angle.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.Motors.RevoluteMotor.LocalTestAxis">
      <summary>
            Gets or sets the axis attached to entity B in its local space.
            This axis is projected onto the x and y axes of transformA to determine the hinge angle.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.Motors.RevoluteMotor.Settings">
      <summary>
            Gets the motor's velocity and servo settings.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.Motors.RevoluteMotor.TestAxis">
      <summary>
            Gets or sets the axis attached to entity B in world space.
            This axis is projected onto the x and y axes of transformA to determine the hinge angle.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.Motors.RevoluteMotor.RelativeVelocity">
      <summary>
            Gets the current relative velocity between the connected entities with respect to the constraint.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.Motors.RevoluteMotor.TotalImpulse">
      <summary>
            Gets the total impulse applied by this constraint.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.Motors.RevoluteMotor.Error">
      <summary>
            Gets the current constraint error.
            If the motor is in velocity only mode, the error is zero.
            </summary>
    </member>
    <member name="T:BEPUphysics.Collidables.MobileCollidables.CompoundCollidable">
      <summary>
             Collidable used by compound shapes.
            </summary>
    </member>
    <member name="M:BEPUphysics.Collidables.MobileCollidables.CompoundCollidable.#ctor(System.Collections.Generic.IList{BEPUphysics.Collidables.MobileCollidables.CompoundChildData})">
      <summary>
             Constructs a compound collidable using additional information about the shapes in the compound.
            </summary>
      <param name="children">Data representing the children of the compound collidable.</param>
    </member>
    <member name="M:BEPUphysics.Collidables.MobileCollidables.CompoundCollidable.#ctor(System.Collections.Generic.IList{BEPUphysics.Collidables.MobileCollidables.CompoundChildData},Microsoft.Xna.Framework.Vector3@)">
      <summary>
             Constructs a compound collidable using additional information about the shapes in the compound.
            </summary>
      <param name="children">Data representing the children of the compound collidable.</param>
      <param name="center">Location computed to be the center of the compound object.</param>
    </member>
    <member name="M:BEPUphysics.Collidables.MobileCollidables.CompoundCollidable.#ctor(BEPUphysics.CollisionShapes.CompoundShape)">
      <summary>
             Constructs a new CompoundCollidable.
            </summary>
      <param name="compoundShape">Compound shape to use for the collidable.</param>
    </member>
    <member name="M:BEPUphysics.Collidables.MobileCollidables.CompoundCollidable.UpdateWorldTransform(Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Quaternion@)">
      <summary>
             Updates the world transform of the collidable.
            </summary>
      <param name="position">Position to use for the calculation.</param>
      <param name="orientation">Orientation to use for the calculation.</param>
    </member>
    <member name="M:BEPUphysics.Collidables.MobileCollidables.CompoundCollidable.RayCast(Microsoft.Xna.Framework.Ray,System.Single,BEPUphysics.RayHit@)">
      <summary>
            Tests a ray against the entry.
            </summary>
      <param name="ray">Ray to test.</param>
      <param name="maximumLength">Maximum length, in units of the ray's direction's length, to test.</param>
      <param name="rayHit">Hit location of the ray on the entry, if any.</param>
      <returns>Whether or not the ray hit the entry.</returns>
    </member>
    <member name="P:BEPUphysics.Collidables.MobileCollidables.CompoundCollidable.Shape">
      <summary>
             Gets the shape of the collidable.
            </summary>
    </member>
    <member name="P:BEPUphysics.Collidables.MobileCollidables.CompoundCollidable.Children">
      <summary>
             Gets a list of the children in the collidable.
            </summary>
    </member>
    <member name="P:BEPUphysics.Collidables.MobileCollidables.CompoundCollidable.Hierarchy">
      <summary>
             Gets the hierarchy of children used by the collidable.
            </summary>
    </member>
    <member name="T:BEPUphysics.Collidables.MobileCollidables.CompoundChildData">
      <summary>
             Data which can be used to create a CompoundChild.
             This data is not itself a child yet; another system
             will use it as input to construct the children.
            </summary>
    </member>
    <member name="F:BEPUphysics.Collidables.MobileCollidables.CompoundChildData.Entry">
      <summary>
             Shape entry of the compound child.
            </summary>
    </member>
    <member name="F:BEPUphysics.Collidables.MobileCollidables.CompoundChildData.Events">
      <summary>
             Event manager for the new child.
            </summary>
    </member>
    <member name="F:BEPUphysics.Collidables.MobileCollidables.CompoundChildData.CollisionRules">
      <summary>
             Collision rules for the new child.
            </summary>
    </member>
    <member name="F:BEPUphysics.Collidables.MobileCollidables.CompoundChildData.Material">
      <summary>
             Material for the new child.
            </summary>
    </member>
    <member name="M:BEPUphysics.Collidables.MobileCollidables.CompoundChildData.#ctor(BEPUphysics.CollisionShapes.CompoundShapeEntry,BEPUphysics.Collidables.Events.ContactEventManager{BEPUphysics.Collidables.MobileCollidables.EntityCollidable},BEPUphysics.CollisionRuleManagement.CollisionRules,BEPUphysics.Materials.Material)">
      <summary>
             Constructs data for a compound child.
            </summary>
      <param name="entry">Shape entry for the new child.</param>
      <param name="events">Event manager to use in the new child.</param>
      <param name="collisionRules">Collision rules to use in the new child.</param>
      <param name="material">Material to use in the new child.</param>
    </member>
    <member name="M:BEPUphysics.Collidables.MobileCollidables.CompoundChildData.#ctor(BEPUphysics.CollisionShapes.CompoundShapeEntry,BEPUphysics.Collidables.Events.ContactEventManager{BEPUphysics.Collidables.MobileCollidables.EntityCollidable},BEPUphysics.Materials.Material)">
      <summary>
             Constructs data for a compound child.
            </summary>
      <param name="entry">Shape entry for the new child.</param>
      <param name="events">Event manager to use in the new child.</param>
      <param name="material">Material to use in the new child.</param>
    </member>
    <member name="M:BEPUphysics.Collidables.MobileCollidables.CompoundChildData.#ctor(BEPUphysics.CollisionShapes.CompoundShapeEntry,BEPUphysics.Collidables.Events.ContactEventManager{BEPUphysics.Collidables.MobileCollidables.EntityCollidable})">
      <summary>
             Constructs data for a compound child.
            </summary>
      <param name="entry">Shape entry for the new child.</param>
      <param name="events">Event manager to use in the new child.</param>
    </member>
    <member name="M:BEPUphysics.Collidables.MobileCollidables.CompoundChildData.#ctor(BEPUphysics.CollisionShapes.CompoundShapeEntry,BEPUphysics.CollisionRuleManagement.CollisionRules)">
      <summary>
             Constructs data for a compound child.
            </summary>
      <param name="entry">Shape entry for the new child.</param>
      <param name="collisionRules">Collision rules to use in the new child.</param>
    </member>
    <member name="M:BEPUphysics.Collidables.MobileCollidables.CompoundChildData.#ctor(BEPUphysics.CollisionShapes.CompoundShapeEntry,BEPUphysics.CollisionRuleManagement.CollisionRules,BEPUphysics.Materials.Material)">
      <summary>
             Constructs data for a compound child.
            </summary>
      <param name="entry">Shape entry for the new child.</param>
      <param name="collisionRules">Collision rules to use in the new child.</param>
      <param name="material">Material to use in the new child.</param>
    </member>
    <member name="M:BEPUphysics.Collidables.MobileCollidables.CompoundChildData.#ctor(BEPUphysics.CollisionShapes.CompoundShapeEntry,BEPUphysics.Materials.Material)">
      <summary>
             Constructs data for a compound child.
            </summary>
      <param name="entry">Shape entry for the new child.</param>
      <param name="material">Material to use in the new child.</param>
    </member>
    <member name="M:BEPUphysics.Collidables.MobileCollidables.CompoundChildData.#ctor(BEPUphysics.CollisionShapes.CompoundShapeEntry)">
      <summary>
             Constructs data for a compound child.
            </summary>
      <param name="entry">Shape entry for the new child.</param>
    </member>
    <member name="T:BEPUphysics.Collidables.MobileCollidables.CompoundChild">
      <summary>
             A collidable child of a compound.
            </summary>
    </member>
    <member name="P:BEPUphysics.Collidables.MobileCollidables.CompoundChild.CollisionInformation">
      <summary>
             Gets the Collidable associated with the child.
            </summary>
    </member>
    <member name="P:BEPUphysics.Collidables.MobileCollidables.CompoundChild.Material">
      <summary>
             Gets or sets the material associated with the child.
            </summary>
    </member>
    <member name="P:BEPUphysics.Collidables.MobileCollidables.CompoundChild.Entry">
      <summary>
            Gets the index of the shape associated with this child in the CompoundShape's shapes list.
            </summary>
    </member>
    <member name="P:BEPUphysics.Collidables.MobileCollidables.CompoundChild.BoundingBox">
      <summary>
            Gets the bounding box of the child.
            </summary>
    </member>
    <member name="T:BEPUphysics.BroadPhaseSystems.BroadPhase">
      <summary>
             Superclass of all broad phases.  Broad phases collect overlapping broad phase entry pairs.
            </summary>
    </member>
    <member name="M:BEPUphysics.BroadPhaseSystems.BroadPhase.Add(BEPUphysics.BroadPhaseSystems.BroadPhaseEntry)">
      <summary>
            Adds an entry to the broad phase.
            </summary>
      <param name="entry">Entry to add.</param>
    </member>
    <member name="M:BEPUphysics.BroadPhaseSystems.BroadPhase.Remove(BEPUphysics.BroadPhaseSystems.BroadPhaseEntry)">
      <summary>
            Removes an entry from the broad phase.
            </summary>
      <param name="entry">Entry to remove.</param>
    </member>
    <member name="P:BEPUphysics.BroadPhaseSystems.BroadPhase.Locker">
      <summary>
             Gets the object which is locked by the broadphase during synchronized update processes.
            </summary>
    </member>
    <member name="P:BEPUphysics.BroadPhaseSystems.BroadPhase.Overlaps">
      <summary>
            Gets the list of overlaps identified in the previous broad phase update.
            </summary>
    </member>
    <member name="P:BEPUphysics.BroadPhaseSystems.BroadPhase.QueryAccelerator">
      <summary>
             Gets an interface to the broad phase's support for volume-based queries.
            </summary>
    </member>
    <member name="T:BEPUphysics.BroadPhaseSystems.Hierarchies.DynamicHierarchy">
      <summary>
             Broadphase which uses a dynamically changing bounding box tree to calculate overlaps.
             It has good insertion and update speed.
            </summary>
    </member>
    <member name="F:BEPUphysics.BroadPhaseSystems.Hierarchies.DynamicHierarchy.MaximumAllowedVolumeFactor">
      <summary>
            When an internal node is revalidated, its volume is stored.  When a node's volume exceeds its stored volume multiplied by this factor, it is revalidated again.
            </summary>
    </member>
    <member name="F:BEPUphysics.BroadPhaseSystems.Hierarchies.DynamicHierarchy.MaximumChildEntityLoad">
      <summary>
            Maximum fraction of a parent's entities that a child can inherit.
            If a child has as much or more, the validation process is done over again to ensure a more even split.
            </summary>
    </member>
    <member name="F:BEPUphysics.BroadPhaseSystems.Hierarchies.DynamicHierarchy.MaximumEntitiesInLeaves">
      <summary>
            The maximum number of entities present in the leaf nodes of the hierarchy.
            </summary>
    </member>
    <member name="F:BEPUphysics.BroadPhaseSystems.Hierarchies.DynamicHierarchy.MinimumNodeEntitiesRequiredToMultithread">
      <summary>
            The number of entities needed in a particular node to use the multithreaded reconstruction method on it.
            If the node has less, the current thread does the remainder of the subtree itself.
            This only applies if multithreading is currently being used.
            </summary>
    </member>
    <member name="F:BEPUphysics.BroadPhaseSystems.Hierarchies.DynamicHierarchy.Root">
      <summary>
            Highest parent in the hierarchy.
            </summary>
    </member>
    <member name="M:BEPUphysics.BroadPhaseSystems.Hierarchies.DynamicHierarchy.#ctor">
      <summary>
            Constructs a new instance of the hierarchy and sets up the root node.
            </summary>
    </member>
    <member name="M:BEPUphysics.BroadPhaseSystems.Hierarchies.DynamicHierarchy.#ctor(BEPUphysics.Threading.IThreadManager)">
      <summary>
            Constructs a new instance of the hierarchy and sets up the root node.
            </summary>
    </member>
    <member name="M:BEPUphysics.BroadPhaseSystems.Hierarchies.DynamicHierarchy.Add(BEPUphysics.BroadPhaseSystems.BroadPhaseEntry)">
      <summary>
            Adds an entity to the hierarchy.  Called automatically by the Space owning this broad phase system when an entity is added.
            </summary>
      <param name="entry">Entry to add.</param>
    </member>
    <member name="M:BEPUphysics.BroadPhaseSystems.Hierarchies.DynamicHierarchy.Remove(BEPUphysics.BroadPhaseSystems.BroadPhaseEntry)">
      <summary>
            Removes an entity from the hierarchy.  Called automatically by the Space owning this broad phase system when an entity is removed.
            </summary>
      <param name="entry">Entry to add.</param>
    </member>
    <member name="T:BEPUphysics.Collidables.MobileCollidables.MobileMeshCollidable">
      <summary>
             Collidable used by compound shapes.
            </summary>
    </member>
    <member name="M:BEPUphysics.Collidables.MobileCollidables.MobileMeshCollidable.RayCast(Microsoft.Xna.Framework.Ray,System.Single,BEPUphysics.RayHit@)">
      <summary>
            Tests a ray against the entry.
            </summary>
      <param name="ray">Ray to test.</param>
      <param name="maximumLength">Maximum length, in units of the ray's direction's length, to test.</param>
      <param name="rayHit">Hit location of the ray on the entry, if any.</param>
      <returns>Whether or not the ray hit the entry.</returns>
    </member>
    <member name="M:BEPUphysics.Collidables.MobileCollidables.MobileMeshCollidable.RayCast(Microsoft.Xna.Framework.Ray,System.Single,BEPUphysics.CollisionShapes.ConvexShapes.TriangleSidedness,BEPUphysics.RayHit@)">
      <summary>
             Tests a ray against the instance.
            </summary>
      <param name="ray">Ray to test.</param>
      <param name="maximumLength">Maximum length of the ray to test; in units of the ray's direction's length.</param>
      <param name="sidedness">Sidedness to use during the ray cast.  This does not have to be the same as the mesh's sidedness.</param>
      <param name="rayHit">The hit location of the ray on the mesh, if any.</param>
      <returns>Whether or not the ray hit the mesh.</returns>
    </member>
    <member name="P:BEPUphysics.Collidables.MobileCollidables.MobileMeshCollidable.Shape">
      <summary>
             Gets the shape of the collidable.
            </summary>
    </member>
    <member name="P:BEPUphysics.Collidables.MobileCollidables.MobileMeshCollidable.Sidedness">
      <summary>
             Gets or sets the sidedness of the mesh.  This can be used to ignore collisions and rays coming from a direction relative to the winding of the triangle.
            </summary>
    </member>
    <member name="T:BEPUphysics.UpdateableSystems.IEndOfFrameUpdateable">
      <summary>
             Defines an object which is updated by the space at the end of the frame.
            </summary>
    </member>
    <member name="M:BEPUphysics.UpdateableSystems.IEndOfFrameUpdateable.Update(System.Single)">
      <summary>
            Updates the object at the end of the frame.
            </summary>
      <param name="dt">Time step duration.</param>
    </member>
    <member name="T:BEPUphysics.Vehicle.Vehicle">
      <summary>
            Simulates wheeled vehicles using a variety of constraints and shape casts.
            </summary>
    </member>
    <member name="M:BEPUphysics.Vehicle.Vehicle.#ctor(BEPUphysics.Entities.Entity)">
      <summary>
            Constructs a vehicle.
            </summary>
      <param name="shape">Body of the vehicle.</param>
    </member>
    <member name="M:BEPUphysics.Vehicle.Vehicle.#ctor(BEPUphysics.Entities.Entity,System.Collections.Generic.IEnumerable{BEPUphysics.Vehicle.Wheel})">
      <summary>
            Constructs a vehicle.
            </summary>
      <param name="shape">Body of the vehicle.</param>
      <param name="wheelList">List of wheels of the vehicle.</param>
    </member>
    <member name="M:BEPUphysics.Vehicle.Vehicle.OnAdditionToSpace(BEPUphysics.ISpace)">
      <summary>
            Sets up the vehicle's information when being added to the space.
            Called automatically when the space adds the vehicle.
            </summary>
      <param name="newSpace">New owning space.</param>
    </member>
    <member name="M:BEPUphysics.Vehicle.Vehicle.OnRemovalFromSpace(BEPUphysics.ISpace)">
      <summary>
            Sets up the vehicle's information when being added to the space.
            Called automatically when the space adds the vehicle.
            </summary>
    </member>
    <member name="M:BEPUphysics.Vehicle.Vehicle.AddWheel(BEPUphysics.Vehicle.Wheel)">
      <summary>
            Adds a wheel to the vehicle.
            </summary>
      <param name="wheel">WheelTest to add.</param>
    </member>
    <member name="M:BEPUphysics.Vehicle.Vehicle.RemoveWheel(BEPUphysics.Vehicle.Wheel)">
      <summary>
            Removes a wheel from the vehicle.
            </summary>
      <param name="wheel">WheelTest to remove.</param>
    </member>
    <member name="M:BEPUphysics.Vehicle.Vehicle.SolveIteration">
      <summary>
            Updates the vehicle.
            Called automatically when needed by the owning Space.
            </summary>
    </member>
    <member name="M:BEPUphysics.Vehicle.Vehicle.CollectInvolvedEntities(BEPUphysics.DataStructures.RawList{BEPUphysics.Entities.Entity})">
      <summary>
            Adds entities associated with the solver item to the involved entities list.
            Ensure that sortInvolvedEntities() is called at the end of the function.
            This allows the non-batched multithreading system to lock properly.
            </summary>
    </member>
    <member name="M:BEPUphysics.Vehicle.Vehicle.Update(System.Single)">
      <summary>
            Computes information required during the later update.
            Called once before the iteration loop.
            </summary>
      <param name="dt">Time since previous frame in simulation seconds.</param>
    </member>
    <member name="M:BEPUphysics.Vehicle.Vehicle.ExclusiveUpdate">
      <summary>
            Performs any pre-solve iteration work that needs exclusive
            access to the members of the solver updateable.
            Usually, this is used for applying warmstarting impulses.
            </summary>
    </member>
    <member name="M:BEPUphysics.Vehicle.Vehicle.UpdateSolverActivity">
      <summary>
            Updates the activity state of the wheel constraints.
            </summary>
    </member>
    <member name="P:BEPUphysics.Vehicle.Vehicle.Body">
      <summary>
            Gets or sets the entity representing the shape of the car.
            </summary>
    </member>
    <member name="P:BEPUphysics.Vehicle.Vehicle.SupportedWheelCount">
      <summary>
            Number of wheels with supports.
            </summary>
    </member>
    <member name="P:BEPUphysics.Vehicle.Vehicle.Wheels">
      <summary>
            Gets the list of wheels supporting the vehicle.
            </summary>
    </member>
    <member name="T:BEPUphysics.OtherSpaceStages.SpaceObjectBuffer">
      <summary>
             Thead-safely buffers up space objects for addition and removal.
            </summary>
    </member>
    <member name="M:BEPUphysics.OtherSpaceStages.SpaceObjectBuffer.#ctor(BEPUphysics.ISpace)">
      <summary>
             Constructs the buffer.
            </summary>
      <param name="space">Space that owns the buffer.</param>
    </member>
    <member name="M:BEPUphysics.OtherSpaceStages.SpaceObjectBuffer.Add(BEPUphysics.ISpaceObject)">
      <summary>
             Adds a space object to the buffer.
             It will be added to the space the next time the buffer is flushed.
            </summary>
      <param name="spaceObject">Space object to add.</param>
    </member>
    <member name="M:BEPUphysics.OtherSpaceStages.SpaceObjectBuffer.Remove(BEPUphysics.ISpaceObject)">
      <summary>
            Enqueues a removal request to the buffer.
            It will be processed the next time the buffer is flushed.
            </summary>
      <param name="spaceObject">Space object to remove.</param>
    </member>
    <member name="P:BEPUphysics.OtherSpaceStages.SpaceObjectBuffer.Space">
      <summary>
             Gets the space which owns this buffer.
            </summary>
    </member>
    <member name="T:BEPUphysics.ResourceManagement.UnsafeResourcePool`1">
      <summary>
            Manages a resource type, but performs no locking to handle asynchronous access.
            </summary>
      <typeparam name="T">Type of object to store in the pool.</typeparam>
    </member>
    <member name="M:BEPUphysics.ResourceManagement.UnsafeResourcePool`1.#ctor(System.Int32,System.Action{`0})">
      <summary>
            Constructs a new locking resource pool.
            </summary>
      <param name="initialResourceCount">Number of resources to include in the pool by default.</param>
      <param name="initializer">Function to initialize new instances in the resource pool with.</param>
    </member>
    <member name="M:BEPUphysics.ResourceManagement.UnsafeResourcePool`1.#ctor(System.Int32)">
      <summary>
            Constructs a new locking resource pool.
            </summary>
      <param name="initialResourceCount">Number of resources to include in the pool by default.</param>
    </member>
    <member name="M:BEPUphysics.ResourceManagement.UnsafeResourcePool`1.#ctor">
      <summary>
            Constructs a new locking resource pool.
            </summary>
    </member>
    <member name="M:BEPUphysics.ResourceManagement.UnsafeResourcePool`1.GiveBack(`0)">
      <summary>
            Gives an item back to the resource pool.
            </summary>
      <param name="item">Item to return.</param>
    </member>
    <member name="M:BEPUphysics.ResourceManagement.UnsafeResourcePool`1.Initialize(System.Int32)">
      <summary>
            Initializes the pool with some resources.
            Throws away excess resources.
            </summary>
      <param name="initialResourceCount">Number of resources to include.</param>
    </member>
    <member name="M:BEPUphysics.ResourceManagement.UnsafeResourcePool`1.Take">
      <summary>
            Takes an item from the resource pool.
            </summary>
      <returns>Item to take.</returns>
    </member>
    <member name="P:BEPUphysics.ResourceManagement.UnsafeResourcePool`1.Count">
      <summary>
            Gets the number of resources in the pool.
            Even if the resource count hits 0, resources
            can still be requested; they will be allocated
            dynamically.
            </summary>
    </member>
    <member name="T:BEPUphysics.Paths.ConstantAngularSpeedCurve">
      <summary>
            Wrapper around an orientation curve that specifies a specific velocity at which to travel.
            </summary>
    </member>
    <member name="M:BEPUphysics.Paths.ConstantAngularSpeedCurve.#ctor(System.Single,BEPUphysics.Paths.Curve{Microsoft.Xna.Framework.Quaternion})">
      <summary>
            Constructs a new constant speed curve.
            </summary>
      <param name="speed">Speed to maintain while traveling around a curve.</param>
      <param name="curve">Curve to wrap.</param>
    </member>
    <member name="M:BEPUphysics.Paths.ConstantAngularSpeedCurve.#ctor(System.Single,BEPUphysics.Paths.Curve{Microsoft.Xna.Framework.Quaternion},System.Int32)">
      <summary>
            Constructs a new constant speed curve.
            </summary>
      <param name="speed">Speed to maintain while traveling around a curve.</param>
      <param name="curve">Curve to wrap.</param>
      <param name="sampleCount">Number of samples to use when constructing the wrapper curve.
            More samples increases the accuracy of the speed requirement at the cost of performance.</param>
    </member>
    <member name="T:BEPUphysics.Settings.CollisionDetectionSettings">
      <summary>
             Settings class containing global information about collision detection.
            </summary>
    </member>
    <member name="F:BEPUphysics.Settings.CollisionDetectionSettings.ContactInvalidationLengthSquared">
      <summary>
            For persistent manifolds, contacts are represented by an offset in local space of two colliding bodies.
            The distance between these offsets transformed into world space and projected onto a plane defined by the contact normal squared is compared against this value.
            If this value is exceeded, the contact is removed from the contact manifold.
            
            If the world is smaller or larger than 'normal' for the engine, adjusting this value proportionally can improve contact caching behavior.
            The default value of .01f works well for worlds that operate on the order of 1 unit.
            </summary>
    </member>
    <member name="F:BEPUphysics.Settings.CollisionDetectionSettings.ContactMinimumSeparationDistanceSquared">
      <summary>
            In persistent manifolds, if two contacts are too close together, then 
            the system will not use one of them.  This avoids redundant constraints.
            </summary>
    </member>
    <member name="F:BEPUphysics.Settings.CollisionDetectionSettings.AllowedPenetration">
      <summary>
            The default amount of allowed penetration into the margin before position correcting impulses will be applied.
            Defaults to .005f.
            </summary>
    </member>
    <member name="F:BEPUphysics.Settings.CollisionDetectionSettings.DefaultMargin">
      <summary>
            Default collision margin around objects.  Margins help prevent objects from interpenetrating and improve stability.
            Defaults to .04f.
            </summary>
    </member>
    <member name="P:BEPUphysics.Settings.CollisionDetectionSettings.NonconvexNormalAngleDifferenceMinimum">
      <summary>
            In regular convex manifolds, two contacts are considered redundant if their positions are too close together.  
            In nonconvex manifolds, the normal must also be tested, since a contact in the same location could have a different normal.
            This property is the minimum angle in radians between normals below which contacts are considered redundant.
            </summary>
    </member>
    <member name="T:BEPUphysics.DeactivationManagement.SimulationIslandSearchState">
      <summary>
             Defines the current state of a simulation island member in a split attempt.
            </summary>
    </member>
    <member name="T:BEPUphysics.UpdateableSystems.ForceFields.VolumeForceFieldShape">
      <summary>
            Defines the area in which a force field works using an entity's shape.
            </summary>
    </member>
    <member name="M:BEPUphysics.UpdateableSystems.ForceFields.VolumeForceFieldShape.#ctor(BEPUphysics.UpdateableSystems.DetectorVolume)">
      <summary>
            Constructs a new force field shape using a detector volume.
            </summary>
      <param name="volume">Volume to use.</param>
    </member>
    <member name="M:BEPUphysics.UpdateableSystems.ForceFields.VolumeForceFieldShape.GetPossiblyAffectedEntities">
      <summary>
            Determines the possibly involved entities.
            </summary>
      <returns>Possibly involved entities.</returns>
    </member>
    <member name="M:BEPUphysics.UpdateableSystems.ForceFields.VolumeForceFieldShape.IsEntityAffected(BEPUphysics.Entities.Entity)">
      <summary>
            Determines if the entity is affected by the force field.
            </summary>
      <param name="testEntity">Entity to test.</param>
      <returns>Whether the entity is affected.</returns>
    </member>
    <member name="P:BEPUphysics.UpdateableSystems.ForceFields.VolumeForceFieldShape.Volume">
      <summary>
            Gets or sets the volume used by the shape.
            </summary>
    </member>
    <member name="T:BEPUphysics.EntityStateManagement.EntityBufferedStates">
      <summary>
             Contains a single entity's buffered states.
            </summary>
    </member>
    <member name="M:BEPUphysics.EntityStateManagement.EntityBufferedStates.#ctor(BEPUphysics.Entities.Entity)">
      <summary>
             Constructs a new buffered states entry.
            </summary>
      <param name="entity">Owning entity.</param>
    </member>
    <member name="P:BEPUphysics.EntityStateManagement.EntityBufferedStates.BufferedStatesManager">
      <summary>
             Gets the buffered states manager that owns this entry.
            </summary>
    </member>
    <member name="P:BEPUphysics.EntityStateManagement.EntityBufferedStates.States">
      <summary>
             Gets the buffered states accessor for this entity.
             Contains the current snapshot of the entity's states.
            </summary>
    </member>
    <member name="P:BEPUphysics.EntityStateManagement.EntityBufferedStates.InterpolatedStates">
      <summary>
             Gets the interpolated states accessor for this entity.
             Contains a blended snapshot between the previous and current states based on the
             internal timestepping remainder.
            </summary>
    </member>
    <member name="P:BEPUphysics.EntityStateManagement.EntityBufferedStates.MotionStateIndex">
      <summary>
             Gets the motion state index of this entity.
            </summary>
    </member>
    <member name="P:BEPUphysics.EntityStateManagement.EntityBufferedStates.Entity">
      <summary>
             Gets the entity owning this entry.
            </summary>
    </member>
    <member name="T:BEPUphysics.DataStructures.TinyList`1">
      <summary>
            Special datatype used for heapless lists without unsafe/stackalloc.
            Designed for object types or reference-sized structs (int, float...).
            Stores a maximum of 8 entries.
            </summary>
      <typeparam name="T">Struct type to use.</typeparam>
    </member>
    <member name="M:BEPUphysics.DataStructures.TinyList`1.ToString">
      <summary>
            Creates a string representation of the list.
            </summary>
      <returns>String representation of the list.</returns>
    </member>
    <member name="M:BEPUphysics.DataStructures.TinyList`1.Add(`0)">
      <summary>
            Tries to add an element to the list.
            </summary>
      <param name="item">Item to add.</param>
      <returns>Whether or not the item could be added.
            Will return false when the list is full.</returns>
    </member>
    <member name="M:BEPUphysics.DataStructures.TinyList`1.Clear">
      <summary>
            Clears the list.
            </summary>
    </member>
    <member name="M:BEPUphysics.DataStructures.TinyList`1.IndexOf(`0)">
      <summary>
            Gets the index of the item in the list, if it is present.
            </summary>
      <param name="item">Item to look for.</param>
      <returns>Index of the item, if present.  -1 otherwise.</returns>
    </member>
    <member name="M:BEPUphysics.DataStructures.TinyList`1.Remove(`0)">
      <summary>
            Tries to remove an element from the list.
            </summary>
      <param name="item">Item to remove.</param>
      <returns>Whether or not the item existed in the list.</returns>
    </member>
    <member name="M:BEPUphysics.DataStructures.TinyList`1.RemoveAt(System.Int32)">
      <summary>
            Removes the item at the specified index.
            </summary>
      <param name="index">Index of the element to remove.</param>
      <returns>Whether or not the item could be removed.
            Returns false if the index is out of bounds.</returns>
    </member>
    <member name="P:BEPUphysics.DataStructures.TinyList`1.Count">
      <summary>
            Gets the current number of elements in the list.
            </summary>
    </member>
    <member name="P:BEPUphysics.DataStructures.TinyList`1.Item(System.Int32)">
      <summary>
            Gets the item at the specified index.
            </summary>
      <param name="index">Index to retrieve.</param>
      <returns>Retrieved item.</returns>
    </member>
    <member name="T:BEPUphysics.CollisionShapes.StaticMeshShape">
      <summary>
             The local space information needed by a StaticMesh.
             Since the hierarchy is in world space and owned by the StaticMesh collidable,
             this is a pretty lightweight object.
            </summary>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.StaticMeshShape.#ctor(Microsoft.Xna.Framework.Vector3[],System.Int32[],BEPUphysics.MathExtensions.AffineTransform)">
      <summary>
             Constructs a new StaticMeshShape.
            </summary>
      <param name="vertices">Vertices of the mesh.</param>
      <param name="indices">Indices of the mesh.</param>
      <param name="worldTransform">World transform to use in the local space data.</param>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.StaticMeshShape.#ctor(Microsoft.Xna.Framework.Vector3[],System.Int32[])">
      <summary>
             Constructs a new StaticMeshShape.
            </summary>
      <param name="vertices">Vertices of the mesh.</param>
      <param name="indices">Indices of the mesh.</param>
    </member>
    <member name="P:BEPUphysics.CollisionShapes.StaticMeshShape.TriangleMeshData">
      <summary>
             Gets the triangle mesh data composing the StaticMeshShape.
            </summary>
    </member>
    <member name="T:BEPUphysics.OtherSpaceStages.DeferredEventDispatcher">
      <summary>
             Manages the deferred events spawned by IDeferredEventCreators and dispatches them on update.
            </summary>
    </member>
    <member name="M:BEPUphysics.OtherSpaceStages.DeferredEventDispatcher.#ctor">
      <summary>
             Constructs the dispatcher.
            </summary>
    </member>
    <member name="M:BEPUphysics.OtherSpaceStages.DeferredEventDispatcher.AddEventCreator(BEPUphysics.OtherSpaceStages.IDeferredEventCreator)">
      <summary>
             Adds an event creator.
            </summary>
      <param name="creator">Creator to add.</param>
      <exception cref="T:System.ArgumentException">Thrown when the creator is already managed by a dispatcher.</exception>
    </member>
    <member name="M:BEPUphysics.OtherSpaceStages.DeferredEventDispatcher.RemoveEventCreator(BEPUphysics.OtherSpaceStages.IDeferredEventCreator)">
      <summary>
            Removes an event creator.
            </summary>
      <param name="creator">Creator to remove.</param>
    </member>
    <member name="M:BEPUphysics.OtherSpaceStages.DeferredEventDispatcher.CreatorActivityChanged(BEPUphysics.OtherSpaceStages.IDeferredEventCreator)">
      <summary>
             Notifies the dispatcher that the event activity of a creator has changed.
            </summary>
      <param name="creator">Cretor whose activity has changed.</param>
      <exception cref="T:System.ArgumentException">Thrown when the event creator's state hasn't changed.</exception>
    </member>
    <member name="T:BEPUphysics.DataStructures.TriangleMesh">
      <summary>
             Data structure containing triangle mesh data and its associated bounding box tree.
            </summary>
    </member>
    <member name="M:BEPUphysics.DataStructures.TriangleMesh.#ctor(BEPUphysics.DataStructures.MeshBoundingBoxTreeData)">
      <summary>
             Constructs a new triangle mesh.
            </summary>
      <param name="data">Data to use to construct the mesh.</param>
    </member>
    <member name="M:BEPUphysics.DataStructures.TriangleMesh.RayCast(Microsoft.Xna.Framework.Ray,System.Int32@)">
      <summary>
             Tests a ray against the triangle mesh.
            </summary>
      <param name="ray">Ray to test against the mesh.</param>
      <param name="hitCount">Number of hits between the ray and the mesh.</param>
      <returns>Whether or not the ray hit the mesh.</returns>
    </member>
    <member name="M:BEPUphysics.DataStructures.TriangleMesh.RayCast(Microsoft.Xna.Framework.Ray,BEPUphysics.RayHit@)">
      <summary>
             Tests a ray against the triangle mesh.
            </summary>
      <param name="ray">Ray to test against the mesh.</param>
      <param name="rayHit">Hit data for the ray, if any.</param>
      <returns>Whether or not the ray hit the mesh.</returns>
    </member>
    <member name="M:BEPUphysics.DataStructures.TriangleMesh.RayCast(Microsoft.Xna.Framework.Ray,BEPUphysics.CollisionShapes.ConvexShapes.TriangleSidedness,BEPUphysics.RayHit@)">
      <summary>
             Tests a ray against the triangle mesh.
            </summary>
      <param name="ray">Ray to test against the mesh.</param>
      <param name="sidedness">Sidedness to apply to the mesh for the ray cast.</param>
      <param name="rayHit">Hit data for the ray, if any.</param>
      <returns>Whether or not the ray hit the mesh.</returns>
    </member>
    <member name="M:BEPUphysics.DataStructures.TriangleMesh.RayCast(Microsoft.Xna.Framework.Ray,System.Collections.Generic.IList{BEPUphysics.RayHit})">
      <summary>
             Tests a ray against the triangle mesh.
            </summary>
      <param name="ray">Ray to test against the mesh.</param>
      <param name="hits">Hit data for the ray, if any.</param>
      <returns>Whether or not the ray hit the mesh.</returns>
    </member>
    <member name="M:BEPUphysics.DataStructures.TriangleMesh.RayCast(Microsoft.Xna.Framework.Ray,BEPUphysics.CollisionShapes.ConvexShapes.TriangleSidedness,System.Collections.Generic.IList{BEPUphysics.RayHit})">
      <summary>
             Tests a ray against the triangle mesh.
            </summary>
      <param name="ray">Ray to test against the mesh.</param>
      <param name="sidedness">Sidedness to apply to the mesh for the ray cast.</param>
      <param name="hits">Hit data for the ray, if any.</param>
      <returns>Whether or not the ray hit the mesh.</returns>
    </member>
    <member name="M:BEPUphysics.DataStructures.TriangleMesh.RayCast(Microsoft.Xna.Framework.Ray,System.Single,BEPUphysics.RayHit@)">
      <summary>
             Tests a ray against the triangle mesh.
            </summary>
      <param name="ray">Ray to test against the mesh.</param>
      <param name="maximumLength">Maximum length of the ray in units of the ray direction's length.</param>
      <param name="rayHit">Hit data for the ray, if any.</param>
      <returns>Whether or not the ray hit the mesh.</returns>
    </member>
    <member name="M:BEPUphysics.DataStructures.TriangleMesh.RayCast(Microsoft.Xna.Framework.Ray,System.Single,BEPUphysics.CollisionShapes.ConvexShapes.TriangleSidedness,BEPUphysics.RayHit@)">
      <summary>
             Tests a ray against the triangle mesh.
            </summary>
      <param name="ray">Ray to test against the mesh.</param>
      <param name="maximumLength">Maximum length of the ray in units of the ray direction's length.</param>
      <param name="sidedness">Sidedness to apply to the mesh for the ray cast.</param>
      <param name="rayHit">Hit data for the ray, if any.</param>
      <returns>Whether or not the ray hit the mesh.</returns>
    </member>
    <member name="M:BEPUphysics.DataStructures.TriangleMesh.RayCast(Microsoft.Xna.Framework.Ray,System.Single,System.Collections.Generic.IList{BEPUphysics.RayHit})">
      <summary>
             Tests a ray against the triangle mesh.
            </summary>
      <param name="ray">Ray to test against the mesh.</param>
      <param name="maximumLength">Maximum length of the ray in units of the ray direction's length.</param>
      <param name="hits">Hit data for the ray, if any.</param>
      <returns>Whether or not the ray hit the mesh.</returns>
    </member>
    <member name="M:BEPUphysics.DataStructures.TriangleMesh.RayCast(Microsoft.Xna.Framework.Ray,System.Single,BEPUphysics.CollisionShapes.ConvexShapes.TriangleSidedness,System.Collections.Generic.IList{BEPUphysics.RayHit})">
      <summary>
             Tests a ray against the triangle mesh.
            </summary>
      <param name="ray">Ray to test against the mesh.</param>
      <param name="maximumLength">Maximum length of the ray in units of the ray direction's length.</param>
      <param name="sidedness">Sidedness to apply to the mesh for the ray cast.</param>
      <param name="hits">Hit data for the ray, if any.</param>
      <returns>Whether or not the ray hit the mesh.</returns>
    </member>
    <member name="M:BEPUphysics.DataStructures.TriangleMesh.GetVerticesAndIndicesFromModel(Microsoft.Xna.Framework.Graphics.Model,Microsoft.Xna.Framework.Vector3[]@,System.Int32[]@)">
      <summary>
            Gets an array of vertices and indices from the provided model.
            </summary>
      <param name="collisionModel">Model to use for the collision shape.</param>
      <param name="vertices">Compiled set of vertices from the model.</param>
      <param name="indices">Compiled set of indices from the model.</param>
    </member>
    <member name="P:BEPUphysics.DataStructures.TriangleMesh.Data">
      <summary>
             Gets or sets the bounding box data used in the mesh.
            </summary>
    </member>
    <member name="P:BEPUphysics.DataStructures.TriangleMesh.Tree">
      <summary>
             Gets the bounding box tree that accelerates queries to this triangle mesh.
            </summary>
    </member>
    <member name="T:BEPUphysics.NarrowPhaseSystems.Pairs.InstancedMeshConvexPairHandler">
      <summary>
             Handles a instanced mesh-convex collision pair.
            </summary>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.Pairs.InstancedMeshConvexPairHandler.#ctor">
      <summary>
             Constructs a pair handler.
            </summary>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.Pairs.InstancedMeshConvexPairHandler.Initialize(BEPUphysics.BroadPhaseSystems.BroadPhaseEntry,BEPUphysics.BroadPhaseSystems.BroadPhaseEntry)">
      <summary>
             Initializes the pair handler.
            </summary>
      <param name="entryA">First entry in the pair.</param>
      <param name="entryB">Second entry in the pair.</param>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.Pairs.InstancedMeshConvexPairHandler.UpdateMaterialProperties">
      <summary>
             Forces an update of the pair's material properties.
            </summary>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.Pairs.InstancedMeshConvexPairHandler.OnAddedToNarrowPhase">
      <summary>
             Called when the pair handler is added to the narrow phase.
            </summary>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.Pairs.InstancedMeshConvexPairHandler.CleanUp">
      <summary>
             Cleans up the pair handler.
            </summary>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.Pairs.InstancedMeshConvexPairHandler.UpdateCollision(System.Single)">
      <summary>
             Updates the pair handler.
            </summary>
      <param name="dt">Timestep duration.</param>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.Pairs.InstancedMeshConvexPairHandler.UpdateTimeOfImpact(BEPUphysics.Collidables.Collidable,System.Single)">
      <summary>
             Updates the time of impact for the pair.
            </summary>
      <param name="requester">Collidable requesting the update.</param>
      <param name="dt">Timestep duration.</param>
    </member>
    <member name="T:BEPUphysics.Constraints.SolverSettings">
      <summary>
            Contains information about how a wheel solves its constraints.
            </summary>
    </member>
    <member name="F:BEPUphysics.Constraints.SolverSettings.currentIterations">
      <summary>
            Used to count how many iterations have taken place so far.
            </summary>
    </member>
    <member name="F:BEPUphysics.Constraints.SolverSettings.DefaultMinimumImpulse">
      <summary>
            The value to assign to new constraints' SolverSettings.MinimumImpulse.
            Impulses with magnitudes below this value will count as effectively zero in determining iteration early outs unless changed in the constraint's solver settings.
            High values quicken the short circuit but can cause instability, while low values will often prevent short circuiting, possibly increasing accuracy but harming performance.
            Defaults to .001f.
            </summary>
    </member>
    <member name="F:BEPUphysics.Constraints.SolverSettings.DefaultMinimumIterations">
      <summary>
            The value to assign to new constraints' SolverSettings.MinimumIterations.
            Constraints are able to skip extra calculations if deemed appropriate after they complete the minimum iterations.
            Higher values force the system to wait longer before trying to early out, possibly improving behavior.
            Defaults to 1.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.SolverSettings.MaximumIterations">
      <summary>
            Gets or sets the maximum iterations that the wheel constraint can undergo.
            If the space's iteration count is lower than this, the solver will only attempt
            as many iterations as the space iteration count.
            Lower iteration counts are less accurate, but can improve performance.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.SolverSettings.MinimumIterations">
      <summary>
            Gets or sets the minimum number of iterations that will be applied.
            If an impulse of magnitude smaller than the MinimumImpulse is applied, a 'tiny impulses' counter increases.  Once it exceeds the MinimumIterations,
            the system can decide to stop solving to save time if appropriate.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.SolverSettings.MinimumImpulse">
      <summary>
            Gets or sets the lower limit for impulses.  Impulses applied with magnitudes less than this will increment the 'tiny impulse' counter, which is checked
            against the MinimumIterations property.  If there's been too many tiny impulses in a row, then the system will stop trying to solve to save time.
            Higher values will allow the system to give up earlier, but can harm accuracy.
            </summary>
    </member>
    <member name="T:BEPUphysics.Constraints.Collision.ConvexContactManifoldConstraint">
      <summary>
             Contact manifold constraint that is used by manifolds whose normals are assumed to be
             essentially the same.  This assumption can only be maintained between two convex objects.
            </summary>
    </member>
    <member name="M:BEPUphysics.Constraints.Collision.ConvexContactManifoldConstraint.#ctor">
      <summary>
             Constructs a new convex contact manifold constraint.
            </summary>
    </member>
    <member name="M:BEPUphysics.Constraints.Collision.ConvexContactManifoldConstraint.CleanUp">
      <summary>
             Cleans up the constraint.
            </summary>
    </member>
    <member name="M:BEPUphysics.Constraints.Collision.ConvexContactManifoldConstraint.AddContact(BEPUphysics.CollisionTests.Contact)">
      <summary>
             Adds a contact to be managed by the constraint.
            </summary>
      <param name="contact">Contact to add.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.Collision.ConvexContactManifoldConstraint.RemoveContact(BEPUphysics.CollisionTests.Contact)">
      <summary>
             Removes a contact from the constraint.
            </summary>
      <param name="contact">Contact to remove.</param>
    </member>
    <member name="P:BEPUphysics.Constraints.Collision.ConvexContactManifoldConstraint.TwistFriction">
      <summary>
             Gets the twist friction constraint used by the manifold.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.Collision.ConvexContactManifoldConstraint.SlidingFriction">
      <summary>
             Gets the sliding friction constraint used by the manifold.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.Collision.ConvexContactManifoldConstraint.ContactPenetrationConstraints">
      <summary>
             Gets the penetration constraints used by the manifold.
            </summary>
    </member>
    <member name="T:BEPUphysics.CollisionTests.CollisionAlgorithms.BoxContactData">
      <summary>
            Stores basic data used by some collision systems.
            </summary>
    </member>
    <member name="F:BEPUphysics.CollisionTests.CollisionAlgorithms.BoxContactData.Position">
      <summary>
            Position of the candidate contact.
            </summary>
    </member>
    <member name="F:BEPUphysics.CollisionTests.CollisionAlgorithms.BoxContactData.Depth">
      <summary>
            Depth of the candidate contact.
            </summary>
    </member>
    <member name="F:BEPUphysics.CollisionTests.CollisionAlgorithms.BoxContactData.Id">
      <summary>
            Id of the candidate contact.
            </summary>
    </member>
    <member name="M:BEPUphysics.CollisionTests.CollisionAlgorithms.BoxContactData.Equals(BEPUphysics.CollisionTests.CollisionAlgorithms.BoxContactData)">
      <summary>
            Returns true if the other data has the same id.
            </summary>
      <param name="other">Data to compare.</param>
      <returns>True if the other data has the same id, false otherwise.</returns>
    </member>
    <member name="F:BEPUphysics.CollisionTests.CollisionAlgorithms.BoxContactDataCache.Count">
      <summary>
            Number of elements in the cache.
            </summary>
    </member>
    <member name="M:BEPUphysics.CollisionTests.CollisionAlgorithms.BoxContactDataCache.RemoveAt(System.Int32)">
      <summary>
            Removes an item at the given index.
            </summary>
      <param name="index">Index to remove.</param>
    </member>
    <member name="T:BEPUphysics.CollisionTests.CollisionAlgorithms.BoxBoxCollider">
      <summary>
            Contains helper methods for testing collisions between boxes.
            </summary>
    </member>
    <member name="M:BEPUphysics.CollisionTests.CollisionAlgorithms.BoxBoxCollider.AreBoxesColliding(BEPUphysics.CollisionShapes.ConvexShapes.BoxShape,BEPUphysics.CollisionShapes.ConvexShapes.BoxShape,BEPUphysics.MathExtensions.RigidTransform@,BEPUphysics.MathExtensions.RigidTransform@)">
      <summary>
            Determines if the two boxes are colliding.
            </summary>
      <param name="a">First box to collide.</param>
      <param name="b">Second box to collide.</param>
      <param name="transformA">Transform to apply to shape a.</param>
      <param name="transformB">Transform to apply to shape b.</param>
      <returns>Whether or not the boxes collide.</returns>
    </member>
    <member name="M:BEPUphysics.CollisionTests.CollisionAlgorithms.BoxBoxCollider.AreBoxesColliding(BEPUphysics.CollisionShapes.ConvexShapes.BoxShape,BEPUphysics.CollisionShapes.ConvexShapes.BoxShape,BEPUphysics.MathExtensions.RigidTransform@,BEPUphysics.MathExtensions.RigidTransform@,System.Single@,Microsoft.Xna.Framework.Vector3@)">
      <summary>
            Determines if the two boxes are colliding.
            </summary>
      <param name="a">First box to collide.</param>
      <param name="b">Second box to collide.</param>
      <param name="separationDistance">Distance of separation.</param>
      <param name="separatingAxis">Axis of separation.</param>
      <param name="transformA">Transform to apply to shape A.</param>
      <param name="transformB">Transform to apply to shape B.</param>
      <returns>Whether or not the boxes collide.</returns>
    </member>
    <member name="M:BEPUphysics.CollisionTests.CollisionAlgorithms.BoxBoxCollider.AreBoxesCollidingWithPenetration(BEPUphysics.CollisionShapes.ConvexShapes.BoxShape,BEPUphysics.CollisionShapes.ConvexShapes.BoxShape,BEPUphysics.MathExtensions.RigidTransform@,BEPUphysics.MathExtensions.RigidTransform@,System.Single@,Microsoft.Xna.Framework.Vector3@)">
      <summary>
            Determines if the two boxes are colliding, including penetration depth data.
            </summary>
      <param name="a">First box to collide.</param>
      <param name="b">Second box to collide.</param>
      <param name="distance">Distance of separation or penetration.</param>
      <param name="axis">Axis of separation or penetration.</param>
      <param name="transformA">Transform to apply to shape A.</param>
      <param name="transformB">Transform to apply to shape B.</param>
      <returns>Whether or not the boxes collide.</returns>
    </member>
    <member name="M:BEPUphysics.CollisionTests.CollisionAlgorithms.BoxBoxCollider.AreBoxesColliding(BEPUphysics.CollisionShapes.ConvexShapes.BoxShape,BEPUphysics.CollisionShapes.ConvexShapes.BoxShape,BEPUphysics.MathExtensions.RigidTransform@,BEPUphysics.MathExtensions.RigidTransform@,System.Single@,Microsoft.Xna.Framework.Vector3@,BEPUphysics.DataStructures.TinyStructList{BEPUphysics.CollisionTests.CollisionAlgorithms.BoxContactData}@)">
      <summary>
            Determines if the two boxes are colliding and computes contact data.
            </summary>
      <param name="a">First box to collide.</param>
      <param name="b">Second box to collide.</param>
      <param name="distance">Distance of separation or penetration.</param>
      <param name="axis">Axis of separation or penetration.</param>
      <param name="contactData">Computed contact data.</param>
      <param name="transformA">Transform to apply to shape A.</param>
      <param name="transformB">Transform to apply to shape B.</param>
      <returns>Whether or not the boxes collide.</returns>
    </member>
    <member name="M:BEPUphysics.CollisionTests.CollisionAlgorithms.BoxBoxCollider.AreBoxesColliding(BEPUphysics.CollisionShapes.ConvexShapes.BoxShape,BEPUphysics.CollisionShapes.ConvexShapes.BoxShape,BEPUphysics.MathExtensions.RigidTransform@,BEPUphysics.MathExtensions.RigidTransform@,System.Single@,Microsoft.Xna.Framework.Vector3@,BEPUphysics.CollisionTests.CollisionAlgorithms.BoxContactDataCache@)">
      <summary>
            Determines if the two boxes are colliding and computes contact data.
            </summary>
      <param name="a">First box to collide.</param>
      <param name="b">Second box to collide.</param>
      <param name="distance">Distance of separation or penetration.</param>
      <param name="axis">Axis of separation or penetration.</param>
      <param name="contactData">Contact positions, depths, and ids.</param>
      <param name="transformA">Transform to apply to shape A.</param>
      <param name="transformB">Transform to apply to shape B.</param>
      <returns>Whether or not the boxes collide.</returns>
    </member>
    <member name="T:BEPUphysics.Collidables.MobileCollidables.CompoundHierarchy">
      <summary>
             Hierarchy of children used to accelerate queries and tests for compound collidables.
            </summary>
    </member>
    <member name="M:BEPUphysics.Collidables.MobileCollidables.CompoundHierarchy.#ctor(BEPUphysics.Collidables.MobileCollidables.CompoundCollidable)">
      <summary>
             Constructs a new compound hierarchy.
            </summary>
      <param name="owner">Owner of the hierarchy.</param>
    </member>
    <member name="P:BEPUphysics.Collidables.MobileCollidables.CompoundHierarchy.Tree">
      <summary>
             Gets the bounding box tree of the hierarchy.
            </summary>
    </member>
    <member name="P:BEPUphysics.Collidables.MobileCollidables.CompoundHierarchy.Owner">
      <summary>
             Gets the CompoundCollidable that owns this hierarchy.
            </summary>
    </member>
    <member name="T:BEPUphysics.Collidables.CollidableCollection">
      <summary>
             List of collidable objects overlapping another collidable.
            </summary>
    </member>
    <member name="T:BEPUphysics.Collidables.CollidableCollection.Enumerator">
      <summary>
             Enumerator for the CollidableCollection.
            </summary>
    </member>
    <member name="M:BEPUphysics.Collidables.CollidableCollection.Enumerator.#ctor(BEPUphysics.Collidables.CollidableCollection)">
      <summary>
             Constructs an enumerator.
            </summary>
      <param name="collection">Collection to which the enumerator belongs.</param>
    </member>
    <member name="M:BEPUphysics.Collidables.CollidableCollection.Enumerator.Dispose">
      <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
      <filterpriority>2</filterpriority>
    </member>
    <member name="M:BEPUphysics.Collidables.CollidableCollection.Enumerator.MoveNext">
      <summary>
            Advances the enumerator to the next element of the collection.
            </summary>
      <returns>
            true if the enumerator was successfully advanced to the next element; false if the enumerator has passed the end of the collection.
            </returns>
      <exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created. </exception>
      <filterpriority>2</filterpriority>
    </member>
    <member name="M:BEPUphysics.Collidables.CollidableCollection.Enumerator.Reset">
      <summary>
            Sets the enumerator to its initial position, which is before the first element in the collection.
            </summary>
      <exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created. </exception>
      <filterpriority>2</filterpriority>
    </member>
    <member name="P:BEPUphysics.Collidables.CollidableCollection.Enumerator.Current">
      <summary>
            Gets the element in the collection at the current position of the enumerator.
            </summary>
      <returns>
            The element in the collection at the current position of the enumerator.
            </returns>
    </member>
    <member name="M:BEPUphysics.Collidables.CollidableCollection.#ctor(BEPUphysics.Collidables.Collidable)">
      <summary>
             Constructs a new CollidableCollection.
            </summary>
      <param name="owner">The collidable to which the collection belongs.</param>
    </member>
    <member name="M:BEPUphysics.Collidables.CollidableCollection.GetEnumerator">
      <summary>
             Gets an enumerator which can be used to enumerate over the list.
            </summary>
      <returns>Enumerator for the collection.</returns>
    </member>
    <member name="M:BEPUphysics.Collidables.CollidableCollection.IndexOf(BEPUphysics.Collidables.Collidable)">
      <summary>
            Determines the index of a specific item in the <see cref="T:System.Collections.Generic.IList`1" />.
            </summary>
      <returns>
            The index of <paramref name="item" /> if found in the list; otherwise, -1.
            </returns>
      <param name="item">The object to locate in the <see cref="T:System.Collections.Generic.IList`1" />.</param>
    </member>
    <member name="M:BEPUphysics.Collidables.CollidableCollection.Contains(BEPUphysics.Collidables.Collidable)">
      <summary>
            Determines whether the <see cref="T:System.Collections.Generic.ICollection`1" /> contains a specific value.
            </summary>
      <returns>
            true if <paramref name="item" /> is found in the <see cref="T:System.Collections.Generic.ICollection`1" />; otherwise, false.
            </returns>
      <param name="item">The object to locate in the <see cref="T:System.Collections.Generic.ICollection`1" />.</param>
    </member>
    <member name="M:BEPUphysics.Collidables.CollidableCollection.CopyTo(BEPUphysics.Collidables.Collidable[],System.Int32)">
      <summary>
            Copies the elements of the <see cref="T:System.Collections.Generic.ICollection`1" /> to an <see cref="T:System.Array" />, starting at a particular <see cref="T:System.Array" /> index.
            </summary>
      <param name="array">The one-dimensional <see cref="T:System.Array" /> that is the destination of the elements copied from <see cref="T:System.Collections.Generic.ICollection`1" />. The <see cref="T:System.Array" /> must have zero-based indexing.</param>
      <param name="arrayIndex">The zero-based index in <paramref name="array" /> at which copying begins.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="array" /> is null.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="arrayIndex" /> is less than 0.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="array" /> is multidimensional.-or-The number of elements in the source <see cref="T:System.Collections.Generic.ICollection`1" /> is greater than the available space from <paramref name="arrayIndex" /> to the end of the destination <paramref name="array" />.-or-Type cannot be cast automatically to the type of the destination <paramref name="array" />.</exception>
    </member>
    <member name="P:BEPUphysics.Collidables.CollidableCollection.Item(System.Int32)">
      <summary>
            Gets or sets the element at the specified index.
            </summary>
      <returns>
            The element at the specified index.
            </returns>
      <param name="index">The zero-based index of the element to get or set.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> is not a valid index in the <see cref="T:System.Collections.Generic.IList`1" />.</exception>
      <exception cref="T:System.NotSupportedException">The property is set and the <see cref="T:System.Collections.Generic.IList`1" /> is read-only.</exception>
    </member>
    <member name="P:BEPUphysics.Collidables.CollidableCollection.Count">
      <summary>
            Gets the number of elements contained in the <see cref="T:System.Collections.Generic.ICollection`1" />.
            </summary>
      <returns>
            The number of elements contained in the <see cref="T:System.Collections.Generic.ICollection`1" />.
            </returns>
    </member>
    <member name="T:BEPUphysics.DataStructures.StaticMeshData">
      <summary>
             Collection of triangle mesh data that directly returns vertices from its vertex buffer instead of transforming them first.
            </summary>
    </member>
    <member name="M:BEPUphysics.DataStructures.StaticMeshData.#ctor(Microsoft.Xna.Framework.Vector3[],System.Int32[])">
      <summary>
             Constructs the triangle mesh data.
            </summary>
      <param name="vertices">Vertices to use in the data.</param>
      <param name="indices">Indices to use in the data.</param>
    </member>
    <member name="M:BEPUphysics.DataStructures.StaticMeshData.GetTriangle(System.Int32,Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Vector3@)">
      <summary>
             Gets the triangle vertex positions at a given index.
            </summary>
      <param name="triangleIndex">First index of a triangle's vertices in the index buffer.</param>
      <param name="v1">First vertex of the triangle.</param>
      <param name="v2">Second vertex of the triangle.</param>
      <param name="v3">Third vertex of the triangle.</param>
    </member>
    <member name="M:BEPUphysics.DataStructures.StaticMeshData.GetVertexPosition(System.Int32,Microsoft.Xna.Framework.Vector3@)">
      <summary>
             Gets the position of a vertex in the data.
            </summary>
      <param name="i">Index of the vertex.</param>
      <param name="vertex">Position of the vertex.</param>
    </member>
    <member name="T:BEPUphysics.Vehicle.WheelSlidingFriction">
      <summary>
            Attempts to resist sliding motion of a vehicle.
            </summary>
    </member>
    <member name="F:BEPUphysics.Vehicle.WheelSlidingFriction.DefaultSlidingFrictionBlender">
      <summary>
            Default blender used by WheelSlidingFriction constraints.
            </summary>
    </member>
    <member name="M:BEPUphysics.Vehicle.WheelSlidingFriction.BlendFriction(System.Single,System.Single,System.Object)">
      <summary>
            Computes the friction to use between the vehicle and support for a wheel.
            </summary>
      <param name="wheelFriction">Friction coefficient of the wheel.</param>
      <param name="supportFriction">Friction coefficient of the supporting entity.</param>
      <param name="extraInfo">Any extra information to be considered.</param>
      <returns>Blended friction coefficient.</returns>
    </member>
    <member name="M:BEPUphysics.Vehicle.WheelSlidingFriction.#ctor(System.Single,System.Single)">
      <summary>
            Constructs a new sliding friction object for a wheel.
            </summary>
      <param name="dynamicCoefficient">Coefficient of dynamic sliding friction to be blended with the supporting entity's friction.</param>
      <param name="staticCoefficient">Coefficient of static sliding friction to be blended with the supporting entity's friction.</param>
    </member>
    <member name="P:BEPUphysics.Vehicle.WheelSlidingFriction.BlendedCoefficient">
      <summary>
            Gets the coefficient of sliding friction between the wheel and support.
            This coefficient is the blended result of the supporting entity's friction and the wheel's friction.
            </summary>
    </member>
    <member name="P:BEPUphysics.Vehicle.WheelSlidingFriction.DynamicCoefficient">
      <summary>
            Gets or sets the coefficient of dynamic horizontal sliding friction for this wheel.
            This coefficient and the supporting entity's coefficient of friction will be 
            taken into account to determine the used coefficient at any given time.
            </summary>
    </member>
    <member name="P:BEPUphysics.Vehicle.WheelSlidingFriction.FrictionBlender">
      <summary>
            Gets or sets the function used to blend the supporting entity's friction and the wheel's friction.
            </summary>
    </member>
    <member name="P:BEPUphysics.Vehicle.WheelSlidingFriction.SlidingFrictionAxis">
      <summary>
            Gets the axis along which sliding friction is applied.
            </summary>
    </member>
    <member name="P:BEPUphysics.Vehicle.WheelSlidingFriction.StaticCoefficient">
      <summary>
            Gets or sets the coefficient of static horizontal sliding friction for this wheel.
            This coefficient and the supporting entity's coefficient of friction will be 
            taken into account to determine the used coefficient at any given time.
            </summary>
    </member>
    <member name="P:BEPUphysics.Vehicle.WheelSlidingFriction.StaticFrictionVelocityThreshold">
      <summary>
            Gets or sets the velocity under which the coefficient of static friction will be used instead of the dynamic one.
            </summary>
    </member>
    <member name="P:BEPUphysics.Vehicle.WheelSlidingFriction.TotalImpulse">
      <summary>
            Gets the force 
            </summary>
    </member>
    <member name="P:BEPUphysics.Vehicle.WheelSlidingFriction.Wheel">
      <summary>
            Gets the wheel that this sliding friction applies to.
            </summary>
    </member>
    <member name="P:BEPUphysics.Vehicle.WheelSlidingFriction.SolverSettings">
      <summary>
            Gets the solver settings used by this wheel constraint.
            </summary>
    </member>
    <member name="P:BEPUphysics.Vehicle.WheelSlidingFriction.RelativeVelocity">
      <summary>
             Gets the relative velocity along the sliding direction at the wheel contact.
            </summary>
    </member>
    <member name="T:BEPUphysics.Vehicle.WheelBrake">
      <summary>
            Attempts to resist rolling motion of a vehicle.
            </summary>
    </member>
    <member name="F:BEPUphysics.Vehicle.WheelBrake.DefaultRollingFrictionBlender">
      <summary>
            Default blender used by WheelRollingFriction constraints.
            </summary>
    </member>
    <member name="M:BEPUphysics.Vehicle.WheelBrake.BlendFriction(System.Single,System.Single,System.Object)">
      <summary>
            Computes the friction to use between the vehicle and support for a wheel.
            </summary>
      <param name="wheelFriction">Friction coefficient of the wheel.</param>
      <param name="supportFriction">Friction coefficient of the supporting entity.</param>
      <param name="extraInfo">Any extra information to be considered.</param>
      <returns>Blended friction coefficient.</returns>
    </member>
    <member name="M:BEPUphysics.Vehicle.WheelBrake.#ctor(System.Single,System.Single,System.Single)">
      <summary>
            Constructs a new rolling friction object for a wheel.
            </summary>
      <param name="dynamicBrakingFrictionCoefficient">Coefficient of dynamic friction of the wheel for friction when the brake is active.</param>
      <param name="staticBrakingFrictionCoefficient">Coefficient of static friction of the wheel for friction when the brake is active.</param>
      <param name="rollingFrictionCoefficient">Coefficient of friction of the wheel for rolling friction when the brake isn't active.</param>
    </member>
    <member name="P:BEPUphysics.Vehicle.WheelBrake.BlendedCoefficient">
      <summary>
            Gets the coefficient of rolling friction between the wheel and support.
            This coefficient is the blended result of the supporting entity's friction and the wheel's friction.
            </summary>
    </member>
    <member name="P:BEPUphysics.Vehicle.WheelBrake.DynamicBrakingFrictionCoefficient">
      <summary>
            Gets or sets the coefficient of braking dynamic friction for this wheel.
            This coefficient and the supporting entity's coefficient of friction will be 
            taken into account to determine the used coefficient at any given time.
            This coefficient is used instead of the rollingFrictionCoefficient when 
            isBraking is true.
            </summary>
    </member>
    <member name="P:BEPUphysics.Vehicle.WheelBrake.FrictionAxis">
      <summary>
            Gets the axis along which rolling friction is applied.
            </summary>
    </member>
    <member name="P:BEPUphysics.Vehicle.WheelBrake.FrictionBlender">
      <summary>
            Gets or sets the function used to blend the supporting entity's friction and the wheel's friction.
            </summary>
    </member>
    <member name="P:BEPUphysics.Vehicle.WheelBrake.IsBraking">
      <summary>
            Gets or sets whether or not the wheel is braking.
            When set to true, the brakingFrictionCoefficient is used.
            When false, the rollingFrictionCoefficient is used.
            </summary>
    </member>
    <member name="P:BEPUphysics.Vehicle.WheelBrake.RollingFrictionCoefficient">
      <summary>
            Gets or sets the coefficient of rolling friction for this wheel.
            This coefficient and the supporting entity's coefficient of friction will be 
            taken into account to determine the used coefficient at any given time.
            This coefficient is used instead of the brakingFrictionCoefficient when 
            isBraking is false.
            </summary>
    </member>
    <member name="P:BEPUphysics.Vehicle.WheelBrake.StaticBrakingFrictionCoefficient">
      <summary>
            Gets or sets the coefficient of static dynamic friction for this wheel.
            This coefficient and the supporting entity's coefficient of friction will be 
            taken into account to determine the used coefficient at any given time.
            This coefficient is used instead of the rollingFrictionCoefficient when 
            isBraking is true.
            </summary>
    </member>
    <member name="P:BEPUphysics.Vehicle.WheelBrake.StaticFrictionVelocityThreshold">
      <summary>
            Gets or sets the velocity under which the coefficient of static friction will be used instead of the dynamic one.
            </summary>
    </member>
    <member name="P:BEPUphysics.Vehicle.WheelBrake.TotalImpulse">
      <summary>
            Gets the force 
            </summary>
    </member>
    <member name="P:BEPUphysics.Vehicle.WheelBrake.Wheel">
      <summary>
            Gets the wheel that this rolling friction applies to.
            </summary>
    </member>
    <member name="P:BEPUphysics.Vehicle.WheelBrake.SolverSettings">
      <summary>
            Gets the solver settings used by this wheel constraint.
            </summary>
    </member>
    <member name="P:BEPUphysics.Vehicle.WheelBrake.RelativeVelocity">
      <summary>
             Gets the relative velocity along the braking direction at the wheel contact.
            </summary>
    </member>
    <member name="T:BEPUphysics.UpdateableSystems.DuringForcesUpdateableManager">
      <summary>
             Manages updateables that update during the forces stage.
            </summary>
    </member>
    <member name="M:BEPUphysics.UpdateableSystems.DuringForcesUpdateableManager.#ctor(BEPUphysics.TimeStepSettings)">
      <summary>
             Constructs a manager.
            </summary>
      <param name="timeStepSettings">Time step settings to use.</param>
    </member>
    <member name="M:BEPUphysics.UpdateableSystems.DuringForcesUpdateableManager.#ctor(BEPUphysics.TimeStepSettings,BEPUphysics.Threading.IThreadManager)">
      <summary>
             Constructs a manager.
            </summary>
      <param name="timeStepSettings">Time step settings to use.</param>
      <param name="threadManager">Thread manager to use.</param>
    </member>
    <member name="T:BEPUphysics.UpdateableSystems.BeforeNarrowPhaseUpdateableManager">
      <summary>
             Manages updateables that update before the narrow phase.
            </summary>
    </member>
    <member name="M:BEPUphysics.UpdateableSystems.BeforeNarrowPhaseUpdateableManager.#ctor(BEPUphysics.TimeStepSettings)">
      <summary>
             Constructs a manager.
            </summary>
      <param name="timeStepSettings">Time step settings to use.</param>
    </member>
    <member name="M:BEPUphysics.UpdateableSystems.BeforeNarrowPhaseUpdateableManager.#ctor(BEPUphysics.TimeStepSettings,BEPUphysics.Threading.IThreadManager)">
      <summary>
             Constructs a manager.
            </summary>
      <param name="timeStepSettings">Time step settings to use.</param>
      <param name="threadManager">Thread manager to use.</param>
    </member>
    <member name="T:BEPUphysics.UpdateableSystems.EndOfTimeStepUpdateableManager">
      <summary>
             Manages updateables that update at the end of a time step.
            </summary>
    </member>
    <member name="M:BEPUphysics.UpdateableSystems.EndOfTimeStepUpdateableManager.#ctor(BEPUphysics.TimeStepSettings)">
      <summary>
             Constructs a manager.
            </summary>
      <param name="timeStepSettings">Time step settings to use.</param>
    </member>
    <member name="M:BEPUphysics.UpdateableSystems.EndOfTimeStepUpdateableManager.#ctor(BEPUphysics.TimeStepSettings,BEPUphysics.Threading.IThreadManager)">
      <summary>
             Constructs a manager.
            </summary>
      <param name="timeStepSettings">Time step settings to use.</param>
      <param name="threadManager">Thread manager to use.</param>
    </member>
    <member name="T:BEPUphysics.UpdateableSystems.EndOfFrameUpdateableManager">
      <summary>
             Manages updateables that update at the end of a frame.
            </summary>
    </member>
    <member name="M:BEPUphysics.UpdateableSystems.EndOfFrameUpdateableManager.#ctor(BEPUphysics.TimeStepSettings)">
      <summary>
             Constructs a manager.
            </summary>
      <param name="timeStepSettings">Time step settings to use.</param>
    </member>
    <member name="M:BEPUphysics.UpdateableSystems.EndOfFrameUpdateableManager.#ctor(BEPUphysics.TimeStepSettings,BEPUphysics.Threading.IThreadManager)">
      <summary>
             Constructs a manager.
            </summary>
      <param name="timeStepSettings">Time step settings to use.</param>
      <param name="threadManager">Thread manager to use.</param>
    </member>
    <member name="T:BEPUphysics.TimeStepSettings">
      <summary>
             Contains settings for the instance's time step.
            </summary>
    </member>
    <member name="F:BEPUphysics.TimeStepSettings.TimeStepCountPerFrameMaximum">
      <summary>
            Maximum number of timesteps to perform during a given frame when Space.Update(float) is used.  The unsimulated time will be accumulated for subsequent calls to Space.Update(float).
            Defaults to 10.
            </summary>
    </member>
    <member name="F:BEPUphysics.TimeStepSettings.TimeStepDuration">
      <summary>
            Length of each integration step.  Calling a Space's Update() method moves time forward this much.
            The other method, Space.Update(float), will try to move time forward by the amount specified in the parameter by taking steps of TimeStepDuration size.
            Defaults to 1/60.
            </summary>
    </member>
    <member name="F:BEPUphysics.TimeStepSettings.AccumulatedTime">
      <summary>
            Amount of time accumulated by previous calls to Space.Update(float) that has not yet been simulated.
            </summary>
    </member>
    <member name="T:BEPUphysics.ResourceManagement.Resources">
      <summary>
            Handles allocation and management of commonly used resources.
            </summary>
    </member>
    <member name="M:BEPUphysics.ResourceManagement.Resources.GetRayCastResultList">
      <summary>
            Retrieves a ray cast result list from the resource pool.
            </summary>
      <returns>Empty ray cast result list.</returns>
    </member>
    <member name="M:BEPUphysics.ResourceManagement.Resources.GiveBack(BEPUphysics.DataStructures.RawList{BEPUphysics.RayCastResult})">
      <summary>
            Returns a resource to the pool.
            </summary>
      <param name="list">List to return.</param>
    </member>
    <member name="M:BEPUphysics.ResourceManagement.Resources.GetRayHitList">
      <summary>
            Retrieves a ray hit list from the resource pool.
            </summary>
      <returns>Empty ray hit list.</returns>
    </member>
    <member name="M:BEPUphysics.ResourceManagement.Resources.GiveBack(BEPUphysics.DataStructures.RawList{BEPUphysics.RayHit})">
      <summary>
            Returns a resource to the pool.
            </summary>
      <param name="list">List to return.</param>
    </member>
    <member name="M:BEPUphysics.ResourceManagement.Resources.GetCollisionEntryList">
      <summary>
            Retrieves an CollisionEntry list from the resource pool.
            </summary>
      <returns>Empty CollisionEntry list.</returns>
    </member>
    <member name="M:BEPUphysics.ResourceManagement.Resources.GiveBack(BEPUphysics.DataStructures.RawList{BEPUphysics.BroadPhaseSystems.BroadPhaseEntry})">
      <summary>
            Returns a resource to the pool.
            </summary>
      <param name="list">List to return.</param>
    </member>
    <member name="M:BEPUphysics.ResourceManagement.Resources.GetCompoundChildList">
      <summary>
            Retrieves an CompoundChild list from the resource pool.
            </summary>
      <returns>Empty information list.</returns>
    </member>
    <member name="M:BEPUphysics.ResourceManagement.Resources.GiveBack(BEPUphysics.DataStructures.RawList{BEPUphysics.Collidables.MobileCollidables.CompoundChild})">
      <summary>
            Returns a resource to the pool.
            </summary>
      <param name="list">List to return.</param>
    </member>
    <member name="M:BEPUphysics.ResourceManagement.Resources.GetBoolList">
      <summary>
            Retrieves a bool list from the resource pool.
            </summary>
      <returns>Empty bool list.</returns>
    </member>
    <member name="M:BEPUphysics.ResourceManagement.Resources.GiveBack(System.Collections.Generic.List{System.Boolean})">
      <summary>
            Returns a resource to the pool.
            </summary>
      <param name="list">List to return.</param>
    </member>
    <member name="M:BEPUphysics.ResourceManagement.Resources.GetIntList">
      <summary>
            Retrieves a int list from the resource pool.
            </summary>
      <returns>Empty int list.</returns>
    </member>
    <member name="M:BEPUphysics.ResourceManagement.Resources.GiveBack(System.Collections.Generic.List{System.Int32})">
      <summary>
            Returns a resource to the pool.
            </summary>
      <param name="list">List to return.</param>
    </member>
    <member name="M:BEPUphysics.ResourceManagement.Resources.GetIntQueue">
      <summary>
            Retrieves a int queue from the resource pool.
            </summary>
      <returns>Empty int queue.</returns>
    </member>
    <member name="M:BEPUphysics.ResourceManagement.Resources.GiveBack(System.Collections.Generic.Queue{System.Int32})">
      <summary>
            Returns a resource to the pool.
            </summary>
      <param name="queue">Queue to return.</param>
    </member>
    <member name="M:BEPUphysics.ResourceManagement.Resources.GetFloatList">
      <summary>
            Retrieves a float list from the resource pool.
            </summary>
      <returns>Empty float list.</returns>
    </member>
    <member name="M:BEPUphysics.ResourceManagement.Resources.GiveBack(System.Collections.Generic.List{System.Single})">
      <summary>
            Returns a resource to the pool.
            </summary>
      <param name="list">List to return.</param>
    </member>
    <member name="M:BEPUphysics.ResourceManagement.Resources.GetVectorList">
      <summary>
            Retrieves a Vector3 list from the resource pool.
            </summary>
      <returns>Empty Vector3 list.</returns>
    </member>
    <member name="M:BEPUphysics.ResourceManagement.Resources.GiveBack(System.Collections.Generic.List{Microsoft.Xna.Framework.Vector3})">
      <summary>
            Returns a resource to the pool.
            </summary>
      <param name="list">List to return.</param>
    </member>
    <member name="M:BEPUphysics.ResourceManagement.Resources.GetEntityList">
      <summary>
            Retrieves an Entity list from the resource pool.
            </summary>
      <returns>Empty Entity list.</returns>
    </member>
    <member name="M:BEPUphysics.ResourceManagement.Resources.GiveBack(System.Collections.Generic.List{BEPUphysics.Entities.Entity})">
      <summary>
            Returns a resource to the pool.
            </summary>
      <param name="list">List to return.</param>
    </member>
    <member name="M:BEPUphysics.ResourceManagement.Resources.GetEntityRawList">
      <summary>
            Retrieves an Entity RawList from the resource pool.
            </summary>
      <returns>Empty Entity raw list.</returns>
    </member>
    <member name="M:BEPUphysics.ResourceManagement.Resources.GiveBack(BEPUphysics.DataStructures.RawList{BEPUphysics.Entities.Entity})">
      <summary>
            Returns a resource to the pool.
            </summary>
      <param name="list">List to return.</param>
    </member>
    <member name="M:BEPUphysics.ResourceManagement.Resources.GetEntityQueue">
      <summary>
            Retrieves a Entity queue from the resource pool.
            </summary>
      <returns>Empty Entity queue.</returns>
    </member>
    <member name="M:BEPUphysics.ResourceManagement.Resources.GiveBack(System.Collections.Generic.Queue{BEPUphysics.Entities.Entity})">
      <summary>
            Returns a resource to the pool.
            </summary>
      <param name="queue">Queue to return.</param>
    </member>
    <member name="M:BEPUphysics.ResourceManagement.Resources.GetTriangle(Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Vector3@)">
      <summary>
            Retrieves a Triangle shape from the resource pool.
            </summary>
      <param name="v1">Position of the first vertex.</param>
      <param name="v2">Position of the second vertex.</param>
      <param name="v3">Position of the third vertex.</param>
      <returns>Initialized TriangleShape.</returns>
    </member>
    <member name="M:BEPUphysics.ResourceManagement.Resources.GetTriangle">
      <summary>
            Retrieves a Triangle shape from the resource pool.
            </summary>
      <returns>Initialized TriangleShape.</returns>
    </member>
    <member name="M:BEPUphysics.ResourceManagement.Resources.GiveBack(BEPUphysics.CollisionShapes.ConvexShapes.TriangleShape)">
      <summary>
            Returns a resource to the pool.
            </summary>
      <param name="triangle">Triangle to return.</param>
    </member>
    <member name="T:BEPUphysics.Materials.PropertyBlendMethod">
      <summary>
            Contains the various options available for combining the physical properties of objects during an interaction, such as friction and bounciness.
            </summary>
    </member>
    <member name="F:BEPUphysics.Materials.PropertyBlendMethod.Average">
      <summary>
            Averages the two property values.
            </summary>
    </member>
    <member name="F:BEPUphysics.Materials.PropertyBlendMethod.Max">
      <summary>
            Uses the larger of the two property values.
            </summary>
    </member>
    <member name="F:BEPUphysics.Materials.PropertyBlendMethod.Min">
      <summary>
            Uses the smaller of the two property values.
            </summary>
    </member>
    <member name="F:BEPUphysics.Materials.PropertyBlendMethod.BiasHigh">
      <summary>
            Factors in 75% of the high property value of the pair and 25% of the low property value of the pair.
            </summary>
    </member>
    <member name="F:BEPUphysics.Materials.PropertyBlendMethod.BiasLow">
      <summary>
            Factors in 25% of the high property value of the pair and 75% of the low property value of the pair.
            </summary>
    </member>
    <member name="T:BEPUphysics.Materials.PropertyBlender">
      <summary>
            Function which takes information from each entity and computes a blended property.
            Commonly used for friction and bounciness.
            </summary>
      <param name="aValue">Value associated with the first object to blend.</param>
      <param name="bValue">Value associated with the second object to blend.</param>
      <param name="extraData">Extra data to include in the process.</param>
      <returns>Blended property value.</returns>
    </member>
    <member name="T:BEPUphysics.Entities.MorphableEntity">
      <summary>
             Entity with modifiable collision information.
            </summary>
    </member>
    <member name="M:BEPUphysics.Entities.MorphableEntity.#ctor(BEPUphysics.Collidables.MobileCollidables.EntityCollidable)">
      <summary>
             Constructs a new morphable entity.
            </summary>
      <param name="collisionInformation">Collidable to use with the entity.</param>
    </member>
    <member name="M:BEPUphysics.Entities.MorphableEntity.#ctor(BEPUphysics.Collidables.MobileCollidables.EntityCollidable,System.Single)">
      <summary>
             Constructs a new morphable entity.
            </summary>
      <param name="collisionInformation">Collidable to use with the entity.</param>
      <param name="mass">Mass of the entity.</param>
    </member>
    <member name="M:BEPUphysics.Entities.MorphableEntity.#ctor(BEPUphysics.Collidables.MobileCollidables.EntityCollidable,System.Single,BEPUphysics.MathExtensions.Matrix3X3)">
      <summary>
             Constructs a new morphable entity.
            </summary>
      <param name="collisionInformation">Collidable to use with the entity.</param>
      <param name="mass">Mass of the entity.</param>
      <param name="inertiaTensor">Inertia tensor of the entity.</param>
    </member>
    <member name="M:BEPUphysics.Entities.MorphableEntity.#ctor(BEPUphysics.Collidables.MobileCollidables.EntityCollidable,System.Single,BEPUphysics.MathExtensions.Matrix3X3,System.Single)">
      <summary>
             Constructs a new morphable entity.
            </summary>
      <param name="collisionInformation">Collidable to use with the entity.</param>
      <param name="mass">Mass of the entity.</param>
      <param name="inertiaTensor">Inertia tensor of the entity.</param>
      <param name="volume">Volume of the entity.</param>
    </member>
    <member name="M:BEPUphysics.Entities.MorphableEntity.SetCollisionInformation(BEPUphysics.Collidables.MobileCollidables.EntityCollidable)">
      <summary>
            Sets the collision information of the entity to another collidable.
            </summary>
      <param name="newCollisionInformation">New collidable to use.</param>
    </member>
    <member name="M:BEPUphysics.Entities.MorphableEntity.SetCollisionInformation(BEPUphysics.Collidables.MobileCollidables.EntityCollidable,System.Single)">
      <summary>
            Sets the collision information of the entity to another collidable.
            </summary>
      <param name="newCollisionInformation">New collidable to use.</param>
      <param name="newMass">New mass to use for the entity.</param>
    </member>
    <member name="M:BEPUphysics.Entities.MorphableEntity.SetCollisionInformation(BEPUphysics.Collidables.MobileCollidables.EntityCollidable,System.Single,BEPUphysics.MathExtensions.Matrix3X3)">
      <summary>
            Sets the collision information of the entity to another collidable.
            </summary>
      <param name="newCollisionInformation">New collidable to use.</param>
      <param name="newMass">New mass to use for the entity.</param>
      <param name="newInertia">New inertia tensor to use for the entity.</param>
    </member>
    <member name="P:BEPUphysics.Entities.MorphableEntity.CollisionInformation">
      <summary>
             Gets or sets the collidable associated with the entity.
            </summary>
    </member>
    <member name="T:BEPUphysics.NarrowPhaseSystems.Pairs.GeneralConvexPairHandler">
      <summary>
             Handles a convex-convex collision pair.
            </summary>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.Pairs.GeneralConvexPairHandler.#ctor">
      <summary>
             Constructs a new pair handler.
            </summary>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.Pairs.GeneralConvexPairHandler.Initialize(BEPUphysics.BroadPhaseSystems.BroadPhaseEntry,BEPUphysics.BroadPhaseSystems.BroadPhaseEntry)">
      <summary>
             Initializes the pair handler.
            </summary>
      <param name="entryA">First entry in the pair.</param>
      <param name="entryB">Second entry in the pair.</param>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.Pairs.GeneralConvexPairHandler.UpdateMaterialProperties">
      <summary>
             Forces an update of the pair's material properties.
            </summary>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.Pairs.GeneralConvexPairHandler.OnAddedToNarrowPhase">
      <summary>
             Called when the pair handler is added to the narrow phase.
            </summary>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.Pairs.GeneralConvexPairHandler.CleanUp">
      <summary>
             Cleans up the pair handler.
            </summary>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.Pairs.GeneralConvexPairHandler.UpdateCollision(System.Single)">
      <summary>
             Updates the pair handler.
            </summary>
      <param name="dt">Timestep duration.</param>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.Pairs.GeneralConvexPairHandler.UpdateTimeOfImpact(BEPUphysics.Collidables.Collidable,System.Single)">
      <summary>
             Updates the time of impact for the pair.
            </summary>
      <param name="requester">Collidable requesting the update.</param>
      <param name="dt">Timestep duration.</param>
    </member>
    <member name="T:BEPUphysics.NarrowPhaseSystems.Pairs.CompoundConvexPairHandler">
      <summary>
             Handles a compound and convex collision pair.
            </summary>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.Pairs.CompoundConvexPairHandler.#ctor">
      <summary>
             Constructs a new compound-convex pair handler.
            </summary>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.Pairs.CompoundConvexPairHandler.Initialize(BEPUphysics.BroadPhaseSystems.BroadPhaseEntry,BEPUphysics.BroadPhaseSystems.BroadPhaseEntry)">
      <summary>
             Initializes the pair handler.
            </summary>
      <param name="entryA">First entry in the pair.</param>
      <param name="entryB">Second entry in the pair.</param>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.Pairs.CompoundConvexPairHandler.UpdateMaterialProperties">
      <summary>
             Forces an update of the pair's material properties.
            </summary>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.Pairs.CompoundConvexPairHandler.OnAddedToNarrowPhase">
      <summary>
             Called when the pair handler is added to the narrow phase.
            </summary>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.Pairs.CompoundConvexPairHandler.CleanUp">
      <summary>
             Cleans up the pair handler.
            </summary>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.Pairs.CompoundConvexPairHandler.UpdateCollision(System.Single)">
      <summary>
             Updates the pair handler.
            </summary>
      <param name="dt">Timestep duration.</param>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.Pairs.CompoundConvexPairHandler.UpdateTimeOfImpact(BEPUphysics.Collidables.Collidable,System.Single)">
      <summary>
             Updates the time of impact for the pair.
            </summary>
      <param name="requester">Collidable requesting the update.</param>
      <param name="dt">Timestep duration.</param>
    </member>
    <member name="P:BEPUphysics.NarrowPhaseSystems.Pairs.CompoundConvexPairHandler.ChildPairs">
      <summary>
             Gets a list of the pairs associated with children.
            </summary>
    </member>
    <member name="T:BEPUphysics.Settings.MotionSettings">
      <summary>
             Contains global settings about motion updating.
            </summary>
    </member>
    <member name="F:BEPUphysics.Settings.MotionSettings.UseRk4AngularIntegration">
      <summary>
             Whether or not to use RK4 angular integration.  This can improve simulation quality sometimes, but not always.
             It has a slight performance impact.  Enabling this when ConserveAngularMomentum is set to true may be helpful.
            </summary>
    </member>
    <member name="F:BEPUphysics.Settings.MotionSettings.ConserveAngularMomentum">
      <summary>
             Whether or not to conserve angular momentum.
             This produces slightly more realistic angular behavior, but can reduce stability.
             Consider using a smaller timestep, enabling RK4 angular integration, or both.
            </summary>
    </member>
    <member name="F:BEPUphysics.Settings.MotionSettings.DefaultPositionUpdateMode">
      <summary>
            The default position updating mode used by position updateables.
            </summary>
    </member>
    <member name="F:BEPUphysics.Settings.MotionSettings.UseExtraExpansionForContinuousBoundingBoxes">
      <summary>
            It is possible for an object in danger of being hit by a moving object to have a bounding box which
            does not contain the resulting motion, and CCD will fail to detect a secondary collision.
            Setting this to true will take into account nearby objects' velocities and use them to enlarge the 
            bounding box so that secondary collisions are not missed.
            The larger size of bounding boxes can cause an increase in collision pairs during stressful situations,
            which can harm performance.
            </summary>
    </member>
    <member name="P:BEPUphysics.Settings.MotionSettings.CoreShapeScaling">
      <summary>
             The scaling to apply to the core shapes used for continuous collision detection tests.
             Values should be between 0 and 0.99f.  The smaller the value, the smaller the shapes used
             to perform CCD are, and more collisions are missed.
            </summary>
    </member>
    <member name="T:BEPUphysics.Collidables.Terrain">
      <summary>
             Heightfield-based, unmovable collidable object.
            </summary>
    </member>
    <member name="M:BEPUphysics.Collidables.Terrain.#ctor(BEPUphysics.CollisionShapes.TerrainShape,BEPUphysics.MathExtensions.AffineTransform)">
      <summary>
             Constructs a new Terrain.
            </summary>
      <param name="shape">Shape to use for the terrain.</param>
      <param name="worldTransform">Transform to use for the terrain.</param>
    </member>
    <member name="M:BEPUphysics.Collidables.Terrain.UpdateBoundingBox">
      <summary>
             Updates the bounding box of the terrain.
            </summary>
    </member>
    <member name="M:BEPUphysics.Collidables.Terrain.RayCast(Microsoft.Xna.Framework.Ray,System.Single,BEPUphysics.RayHit@)">
      <summary>
            Tests a ray against the entry.
            </summary>
      <param name="ray">Ray to test.</param>
      <param name="maximumLength">Maximum length, in units of the ray's direction's length, to test.</param>
      <param name="rayHit">Hit location of the ray on the entry, if any.</param>
      <returns>Whether or not the ray hit the entry.</returns>
    </member>
    <member name="M:BEPUphysics.Collidables.Terrain.GetNormal(System.Int32,System.Int32,Microsoft.Xna.Framework.Vector3@)">
      <summary>
             Gets the normal of a vertex at the given indices.
            </summary>
      <param name="i">First dimension index into the heightmap array.</param>
      <param name="j">Second dimension index into the heightmap array.</param>
      <param name="normal">Normal at the given indices.</param>
    </member>
    <member name="M:BEPUphysics.Collidables.Terrain.GetPosition(System.Int32,System.Int32,Microsoft.Xna.Framework.Vector3@)">
      <summary>
             Gets the position of a vertex at the given indices.
            </summary>
      <param name="i">First dimension index into the heightmap array.</param>
      <param name="j">Second dimension index into the heightmap array.</param>
      <param name="position">Position at the given indices.</param>
    </member>
    <member name="P:BEPUphysics.Collidables.Terrain.Shape">
      <summary>
             Gets the shape of this collidable.
            </summary>
    </member>
    <member name="P:BEPUphysics.Collidables.Terrain.WorldTransform">
      <summary>
             Gets or sets the affine transform of the terrain.
            </summary>
    </member>
    <member name="P:BEPUphysics.Collidables.Terrain.ImproveBoundaryBehavior">
      <summary>
            Gets or sets whether or not the collision system should attempt to improve contact behavior at the boundaries between triangles.
            This has a slight performance cost, but prevents objects sliding across a triangle boundary from 'bumping,' and otherwise improves
            the robustness of contacts at edges and vertices.
            </summary>
    </member>
    <member name="P:BEPUphysics.Collidables.Terrain.Events">
      <summary>
             Gets the event manager used by the Terrain.
            </summary>
    </member>
    <member name="P:BEPUphysics.Collidables.Terrain.Material">
      <summary>
             Gets or sets the material of the terrain.
            </summary>
    </member>
    <member name="P:BEPUphysics.Collidables.Terrain.Space">
      <summary>
            Gets the space that owns this terrain.
            </summary>
    </member>
    <member name="T:BEPUphysics.Constraints.TwoEntity.Joints.PointOnPlaneJoint">
      <summary>
            Constrains a point on one body to be on a plane defined by another body.
            </summary>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.Joints.PointOnPlaneJoint.#ctor">
      <summary>
            Constructs a new point on plane constraint.
            To finish the initialization, specify the connections (ConnectionA and ConnectionB) 
            as well as the PlaneAnchor, PlaneNormal, and PointAnchor (or their entity-local versions).
            This constructor sets the constraint's IsActive property to false by default.
            </summary>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.Joints.PointOnPlaneJoint.#ctor(BEPUphysics.Entities.Entity,BEPUphysics.Entities.Entity,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3)">
      <summary>
            Constructs a new point on plane constraint.
            </summary>
      <param name="connectionA">Entity to which the constraint's plane is attached.</param>
      <param name="connectionB">Entity to which the constraint's point is attached.</param>
      <param name="planeAnchor">A point on the plane.</param>
      <param name="normal">Direction, attached to the first connected entity, defining the plane's normal</param>
      <param name="pointAnchor">The point to constrain to the plane, attached to the second connected object.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.Joints.PointOnPlaneJoint.GetLinearJacobianA(Microsoft.Xna.Framework.Vector3@)">
      <summary>
            Gets the linear jacobian entry for the first connected entity.
            </summary>
      <param name="jacobian">Linear jacobian entry for the first connected entity.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.Joints.PointOnPlaneJoint.GetLinearJacobianB(Microsoft.Xna.Framework.Vector3@)">
      <summary>
            Gets the linear jacobian entry for the second connected entity.
            </summary>
      <param name="jacobian">Linear jacobian entry for the second connected entity.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.Joints.PointOnPlaneJoint.GetAngularJacobianA(Microsoft.Xna.Framework.Vector3@)">
      <summary>
            Gets the angular jacobian entry for the first connected entity.
            </summary>
      <param name="jacobian">Angular jacobian entry for the first connected entity.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.Joints.PointOnPlaneJoint.GetAngularJacobianB(Microsoft.Xna.Framework.Vector3@)">
      <summary>
            Gets the angular jacobian entry for the second connected entity.
            </summary>
      <param name="jacobian">Angular jacobian entry for the second connected entity.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.Joints.PointOnPlaneJoint.GetMassMatrix(System.Single@)">
      <summary>
            Gets the mass matrix of the constraint.
            </summary>
      <param name="outputMassMatrix">Constraint's mass matrix.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.Joints.PointOnPlaneJoint.SolveIteration">
      <summary>
            Computes one iteration of the constraint to meet the solver updateable's goal.
            </summary>
      <returns>The rough applied impulse magnitude.</returns>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.Joints.PointOnPlaneJoint.Update(System.Single)">
      <summary>
             Performs the frame's configuration step.
            </summary>
      <param name="dt">Timestep duration.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.Joints.PointOnPlaneJoint.ExclusiveUpdate">
      <summary>
            Performs any pre-solve iteration work that needs exclusive
            access to the members of the solver updateable.
            Usually, this is used for applying warmstarting impulses.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.Joints.PointOnPlaneJoint.LocalPlaneAnchor">
      <summary>
            Gets or sets the plane's anchor in entity A's local space.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.Joints.PointOnPlaneJoint.LocalPlaneNormal">
      <summary>
            Gets or sets the plane's normal in entity A's local space.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.Joints.PointOnPlaneJoint.LocalPointAnchor">
      <summary>
            Gets or sets the point anchor in entity B's local space.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.Joints.PointOnPlaneJoint.OffsetA">
      <summary>
            Gets the offset from A to the connection point between the entities.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.Joints.PointOnPlaneJoint.OffsetB">
      <summary>
            Gets the offset from B to the connection point between the entities.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.Joints.PointOnPlaneJoint.PlaneAnchor">
      <summary>
            Gets or sets the plane anchor in world space.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.Joints.PointOnPlaneJoint.PlaneNormal">
      <summary>
            Gets or sets the plane's normal in world space.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.Joints.PointOnPlaneJoint.PointAnchor">
      <summary>
            Gets or sets the point anchor in world space.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.Joints.PointOnPlaneJoint.RelativeVelocity">
      <summary>
            Gets the current relative velocity between the connected entities with respect to the constraint.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.Joints.PointOnPlaneJoint.TotalImpulse">
      <summary>
            Gets the total impulse applied by this constraint.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.Joints.PointOnPlaneJoint.Error">
      <summary>
            Gets the current constraint error.
            </summary>
    </member>
    <member name="T:BEPUphysics.Constraints.TwoEntity.Joints.PointOnLineJoint">
      <summary>
            Constrains two entities so that one has a point that stays on a line defined by the other.
            </summary>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.Joints.PointOnLineJoint.#ctor">
      <summary>
            Constructs a joint which constrains a point of one body to be on a line based on the other body.
            To finish the initialization, specify the connections (ConnectionA and ConnectionB),
            the LineAnchor, the LineDirection, and the Point (or the entity-local versions).
            This constructor sets the constraint's IsActive property to false by default.
            </summary>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.Joints.PointOnLineJoint.#ctor(BEPUphysics.Entities.Entity,BEPUphysics.Entities.Entity,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3)">
      <summary>
            Constructs a joint which constrains a point of one body to be on a line based on the other body.
            </summary>
      <param name="connectionA">First connected entity which defines the line.</param>
      <param name="connectionB">Second connected entity which has a point.</param>
      <param name="lineAnchor">Location off of which the line is based in world space.</param>
      <param name="lineDirection">Direction of the line in world space.</param>
      <param name="pointLocation">Location of the point anchored to connectionB in world space.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.Joints.PointOnLineJoint.GetLinearJacobianA(Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Vector3@)">
      <summary>
            Gets the linear jacobian entry for the first connected entity.
            </summary>
      <param name="jacobianX">First linear jacobian entry for the first connected entity.</param>
      <param name="jacobianY">Second linear jacobian entry for the first connected entity.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.Joints.PointOnLineJoint.GetLinearJacobianB(Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Vector3@)">
      <summary>
            Gets the linear jacobian entry for the second connected entity.
            </summary>
      <param name="jacobianX">First linear jacobian entry for the second connected entity.</param>
      <param name="jacobianY">Second linear jacobian entry for the second connected entity.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.Joints.PointOnLineJoint.GetAngularJacobianA(Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Vector3@)">
      <summary>
            Gets the angular jacobian entry for the first connected entity.
            </summary>
      <param name="jacobianX">First angular jacobian entry for the first connected entity.</param>
      <param name="jacobianY">Second angular jacobian entry for the first connected entity.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.Joints.PointOnLineJoint.GetAngularJacobianB(Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Vector3@)">
      <summary>
            Gets the angular jacobian entry for the second connected entity.
            </summary>
      <param name="jacobianX">First angular jacobian entry for the second connected entity.</param>
      <param name="jacobianY">Second angular jacobian entry for the second connected entity.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.Joints.PointOnLineJoint.GetMassMatrix(BEPUphysics.MathExtensions.Matrix2X2@)">
      <summary>
            Gets the mass matrix of the constraint.
            </summary>
      <param name="massMatrix">Constraint's mass matrix.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.Joints.PointOnLineJoint.SolveIteration">
      <summary>
            Calculates and applies corrective impulses.
            Called automatically by space.
            </summary>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.Joints.PointOnLineJoint.Update(System.Single)">
      <summary>
             Performs the frame's configuration step.
            </summary>
      <param name="dt">Timestep duration.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.Joints.PointOnLineJoint.ExclusiveUpdate">
      <summary>
            Performs any pre-solve iteration work that needs exclusive
            access to the members of the solver updateable.
            Usually, this is used for applying warmstarting impulses.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.Joints.PointOnLineJoint.LineAnchor">
      <summary>
            Gets or sets the line anchor in world space.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.Joints.PointOnLineJoint.LineDirection">
      <summary>
            Gets or sets the line direction in world space.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.Joints.PointOnLineJoint.LocalLineAnchor">
      <summary>
            Gets or sets the line anchor in connection A's local space.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.Joints.PointOnLineJoint.LocalLineDirection">
      <summary>
            Gets or sets the line direction in connection A's local space.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.Joints.PointOnLineJoint.LocalPoint">
      <summary>
            Gets or sets the point's location in connection B's local space.
            The point is the location that is attached to the line.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.Joints.PointOnLineJoint.OffsetA">
      <summary>
            Gets the offset from A to the connection point between the entities.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.Joints.PointOnLineJoint.OffsetB">
      <summary>
            Gets the offset from B to the connection point between the entities.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.Joints.PointOnLineJoint.Point">
      <summary>
            Gets or sets the point's location in world space.
            The point is the location on connection B that is attached to the line.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.Joints.PointOnLineJoint.RelativeVelocity">
      <summary>
            Gets the current relative velocity between the connected entities with respect to the constraint.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.Joints.PointOnLineJoint.TotalImpulse">
      <summary>
            Gets the total impulse applied by this constraint.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.Joints.PointOnLineJoint.Error">
      <summary>
            Gets the current constraint error.
            </summary>
    </member>
    <member name="T:BEPUphysics.Constraints.SolverGroups.PlaneSliderJoint">
      <summary>
            Restricts one linear degree of freedom.
            </summary>
    </member>
    <member name="M:BEPUphysics.Constraints.SolverGroups.PlaneSliderJoint.#ctor">
      <summary>
            Constructs a new constraint which restricts one linear degree of freedom between two entities.
            This constructs the internal constraints, but does not configure them.  Before using a constraint constructed in this manner,
            ensure that its active constituent constraints are properly configured.  The entire group as well as all internal constraints are initially inactive (IsActive = false).
            </summary>
    </member>
    <member name="M:BEPUphysics.Constraints.SolverGroups.PlaneSliderJoint.#ctor(BEPUphysics.Entities.Entity,BEPUphysics.Entities.Entity,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3)">
      <summary>
            Constructs a new constraint which restricts one linear degree of freedom between two entities.
            </summary>
      <param name="connectionA">First entity of the constraint pair.</param>
      <param name="connectionB">Second entity of the constraint pair.</param>
      <param name="planeAnchor">Location of the anchor for the plane to be attached to connectionA in world space.</param>
      <param name="planeNormal">Normal of the plane constraint in world space.</param>
      <param name="xAxis">Direction in world space along which the X axis LinearAxisLimit and LinearAxisMotor work.
            This is usually chosen to be perpendicular to the planeNormal and the yAxis.</param>
      <param name="yAxis">Direction in world space along which the Y axis LinearAxisLimit and LinearAxisMotor work.
            This is usually chosen to be perpendicular to the planeNormal and the xAxis.</param>
      <param name="pointAnchor">Location of the anchor for the point to be attached to connectionB in world space.</param>
    </member>
    <member name="P:BEPUphysics.Constraints.SolverGroups.PlaneSliderJoint.LimitX">
      <summary>
            Gets the distance limit for the slider along plane's X axis.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.SolverGroups.PlaneSliderJoint.LimitY">
      <summary>
            Gets the distance limit for the slider along plane's Y axis.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.SolverGroups.PlaneSliderJoint.MotorX">
      <summary>
            Gets the slider motor for the plane's X axis.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.SolverGroups.PlaneSliderJoint.MotorY">
      <summary>
            Gets the slider motor for the plane's Y axis.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.SolverGroups.PlaneSliderJoint.PointOnPlaneJoint">
      <summary>
            Gets the plane joint that restricts one linear degree of freedom.
            </summary>
    </member>
    <member name="T:BEPUphysics.Constraints.Collision.TwistFrictionConstraint">
      <summary>
            Computes the forces necessary to slow down and stop twisting motion in a collision between two entities.
            </summary>
    </member>
    <member name="M:BEPUphysics.Constraints.Collision.TwistFrictionConstraint.#ctor">
      <summary>
             Constructs a new twist friction constraint.
            </summary>
    </member>
    <member name="M:BEPUphysics.Constraints.Collision.TwistFrictionConstraint.SolveIteration">
      <summary>
            Computes one iteration of the constraint to meet the solver updateable's goal.
            </summary>
      <returns>The rough applied impulse magnitude.</returns>
    </member>
    <member name="M:BEPUphysics.Constraints.Collision.TwistFrictionConstraint.Update(System.Single)">
      <summary>
             Performs the frame's configuration step.
            </summary>
      <param name="dt">Timestep duration.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.Collision.TwistFrictionConstraint.ExclusiveUpdate">
      <summary>
            Performs any pre-solve iteration work that needs exclusive
            access to the members of the solver updateable.
            Usually, this is used for applying warmstarting impulses.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.Collision.TwistFrictionConstraint.ContactManifoldConstraint">
      <summary>
             Gets the contact manifold constraint that owns this constraint.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.Collision.TwistFrictionConstraint.TotalTorque">
      <summary>
            Gets the torque applied by twist friction.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.Collision.TwistFrictionConstraint.RelativeVelocity">
      <summary>
             Gets the angular velocity between the associated entities.
            </summary>
    </member>
    <member name="T:BEPUphysics.CollisionTests.CollisionAlgorithms.BoxSphereTester">
      <summary>
             Static class with methods to help with testing box shapes against sphere shapes.
            </summary>
    </member>
    <member name="M:BEPUphysics.CollisionTests.CollisionAlgorithms.BoxSphereTester.AreShapesColliding(BEPUphysics.CollisionShapes.ConvexShapes.BoxShape,BEPUphysics.CollisionShapes.ConvexShapes.SphereShape,BEPUphysics.MathExtensions.RigidTransform@,Microsoft.Xna.Framework.Vector3@,BEPUphysics.CollisionTests.ContactData@)">
      <summary>
             Tests if a box and sphere are colliding.
            </summary>
      <param name="box">Box to test.</param>
      <param name="sphere">Sphere to test.</param>
      <param name="boxTransform">Transform to apply to the box.</param>
      <param name="spherePosition">Transform to apply to the sphere.</param>
      <param name="contact">Contact point between the shapes, if any.</param>
      <returns>Whether or not the shapes were colliding.</returns>
    </member>
    <member name="T:BEPUphysics.CollisionShapes.ConvexShapes.CylinderShape">
      <summary>
             Symmetrical object with a circular bottom and top.
            </summary>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.ConvexShapes.CylinderShape.#ctor(System.Single,System.Single)">
      <summary>
             Constructs a new cylinder shape.
            </summary>
      <param name="height">Height of the cylinder.</param>
      <param name="radius">Radius of the cylinder.</param>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.ConvexShapes.CylinderShape.GetBoundingBox(BEPUphysics.MathExtensions.RigidTransform@,Microsoft.Xna.Framework.BoundingBox@)">
      <summary>
            Gets the bounding box of the shape given a transform.
            </summary>
      <param name="shapeTransform">Transform to use.</param>
      <param name="boundingBox">Bounding box of the transformed shape.</param>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.ConvexShapes.CylinderShape.GetLocalExtremePointWithoutMargin(Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Vector3@)">
      <summary>
             Gets the extreme point of the shape in local space in a given direction.
            </summary>
      <param name="direction">Direction to find the extreme point in.</param>
      <param name="extremePoint">Extreme point on the shape.</param>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.ConvexShapes.CylinderShape.ComputeMaximumRadius">
      <summary>
            Computes the maximum radius of the shape.
            This is often larger than the actual maximum radius;
            it is simply an approximation that avoids underestimating.
            </summary>
      <returns>Maximum radius of the shape.</returns>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.ConvexShapes.CylinderShape.ComputeMinimumRadius">
      <summary>
             Computes the minimum radius of the shape.
             This is often smaller than the actual minimum radius;
             it is simply an approximation that avoids overestimating.
            </summary>
      <returns>Minimum radius of the shape.</returns>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.ConvexShapes.CylinderShape.ComputeVolumeDistribution(System.Single@)">
      <summary>
            Computes the volume distribution of the shape as well as its volume.
            The volume distribution can be used to compute inertia tensors when
            paired with mass and other tuning factors.
            </summary>
      <param name="volume">Volume of the shape.</param>
      <returns>Volume distribution of the shape.</returns>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.ConvexShapes.CylinderShape.ComputeCenter">
      <summary>
            Computes the center of the shape.  This can be considered its 
            center of mass.
            </summary>
      <returns>Center of the shape.</returns>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.ConvexShapes.CylinderShape.ComputeCenter(System.Single@)">
      <summary>
            Computes the center of the shape.  This can be considered its 
            center of mass.  This calculation is often associated with the 
            volume calculation, which is given by this method as well.
            </summary>
      <param name="volume">Volume of the shape.</param>
      <returns>Center of the shape.</returns>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.ConvexShapes.CylinderShape.ComputeVolume">
      <summary>
            Computes the volume of the shape.
            </summary>
      <returns>Volume of the shape.</returns>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.ConvexShapes.CylinderShape.GetMobileInstance">
      <summary>
            Retrieves an instance of an EntityCollidable that uses this EntityShape.  Mainly used by compound bodies.
            </summary>
      <returns>EntityCollidable that uses this shape.</returns>
    </member>
    <member name="P:BEPUphysics.CollisionShapes.ConvexShapes.CylinderShape.Radius">
      <summary>
             Gets or sets the radius of the cylinder.
            </summary>
    </member>
    <member name="P:BEPUphysics.CollisionShapes.ConvexShapes.CylinderShape.Height">
      <summary>
             Gets or sets the height of the cylinder.
            </summary>
    </member>
    <member name="T:BEPUphysics.CollisionShapes.ConvexShapes.CapsuleShape">
      <summary>
             Sphere-expanded line segment.  Another way of looking at it is a cylinder with half-spheres on each end.
            </summary>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.ConvexShapes.CapsuleShape.#ctor(System.Single,System.Single)">
      <summary>
             Constructs a new capsule shape.
            </summary>
      <param name="length">Length of the capsule's inner line segment.</param>
      <param name="radius">Radius to expand the line segment width.</param>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.ConvexShapes.CapsuleShape.GetLocalExtremePointWithoutMargin(Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Vector3@)">
      <summary>
             Gets the extreme point of the shape in local space in a given direction.
            </summary>
      <param name="direction">Direction to find the extreme point in.</param>
      <param name="extremePoint">Extreme point on the shape.</param>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.ConvexShapes.CapsuleShape.ComputeMinimumRadius">
      <summary>
             Computes the minimum radius of the shape.
             This is often smaller than the actual minimum radius;
             it is simply an approximation that avoids overestimating.
            </summary>
      <returns>Minimum radius of the shape.</returns>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.ConvexShapes.CapsuleShape.ComputeMaximumRadius">
      <summary>
            Computes the maximum radius of the shape.
            This is often larger than the actual maximum radius;
            it is simply an approximation that avoids underestimating.
            </summary>
      <returns>Maximum radius of the shape.</returns>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.ConvexShapes.CapsuleShape.ComputeVolumeDistribution(System.Single@)">
      <summary>
            Computes the volume distribution of the shape as well as its volume.
            The volume distribution can be used to compute inertia tensors when
            paired with mass and other tuning factors.
            </summary>
      <param name="volume">Volume of the shape.</param>
      <returns>Volume distribution of the shape.</returns>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.ConvexShapes.CapsuleShape.ComputeCenter">
      <summary>
            Computes the center of the shape.  This can be considered its 
            center of mass.
            </summary>
      <returns>Center of the shape.</returns>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.ConvexShapes.CapsuleShape.ComputeCenter(System.Single@)">
      <summary>
            Computes the center of the shape.  This can be considered its 
            center of mass.  This calculation is often associated with the 
            volume calculation, which is given by this method as well.
            </summary>
      <param name="volume">Volume of the shape.</param>
      <returns>Center of the shape.</returns>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.ConvexShapes.CapsuleShape.ComputeVolume">
      <summary>
            Computes the volume of the shape.
            </summary>
      <returns>Volume of the shape.</returns>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.ConvexShapes.CapsuleShape.GetMobileInstance">
      <summary>
            Retrieves an instance of an EntityCollidable that uses this EntityShape.  Mainly used by compound bodies.
            </summary>
      <returns>EntityCollidable that uses this shape.</returns>
    </member>
    <member name="P:BEPUphysics.CollisionShapes.ConvexShapes.CapsuleShape.Length">
      <summary>
             Gets or sets the length of the capsule's inner line segment.
            </summary>
    </member>
    <member name="P:BEPUphysics.CollisionShapes.ConvexShapes.CapsuleShape.Radius">
      <summary>
             Gets or sets the radius of the capsule.
            </summary>
    </member>
    <member name="T:BEPUphysics.DeactivationManagement.DeactivationManager">
      <summary>
             Manages the sleeping states of objects.
            </summary>
    </member>
    <member name="M:BEPUphysics.DeactivationManagement.DeactivationManager.#ctor(BEPUphysics.TimeStepSettings)">
      <summary>
             Constructs a deactivation manager.
            </summary>
      <param name="timeStepSettings">The time step settings used by the manager.</param>
    </member>
    <member name="M:BEPUphysics.DeactivationManagement.DeactivationManager.#ctor(BEPUphysics.TimeStepSettings,BEPUphysics.Threading.IThreadManager)">
      <summary>
             Constructs a deactivation manager.
            </summary>
      <param name="timeStepSettings">The time step settings used by the manager.</param>
      <param name="threadManager">Thread manager used by the manager.</param>
    </member>
    <member name="M:BEPUphysics.DeactivationManagement.DeactivationManager.Add(BEPUphysics.DeactivationManagement.ISimulationIslandMember)">
      <summary>
             Adds a simulation island member to the manager.
            </summary>
      <param name="simulationIslandMember">Member to add.</param>
      <exception cref="T:System.Exception">Thrown if the member already belongs to a manager.</exception>
    </member>
    <member name="M:BEPUphysics.DeactivationManagement.DeactivationManager.Remove(BEPUphysics.DeactivationManagement.ISimulationIslandMember)">
      <summary>
            Removes the member from this island.
            </summary>
      <param name="simulationIslandMember">Removes the member from the manager.</param>
    </member>
    <member name="M:BEPUphysics.DeactivationManagement.DeactivationManager.Add(BEPUphysics.DeactivationManagement.ISimulationIslandConnection)">
      <summary>
             Adds a simulation island connection to the deactivation manager.
            </summary>
      <param name="connection">Connection to add.</param>
      <exception cref="T:System.ArgumentException">Thrown if the connection already belongs to a manager.</exception>
    </member>
    <member name="M:BEPUphysics.DeactivationManagement.DeactivationManager.Remove(BEPUphysics.DeactivationManagement.ISimulationIslandConnection)">
      <summary>
             Removes a simulation island connection from the manager.
            </summary>
      <param name="connection">Connection to remove from the manager.</param>
      <exception cref="T:System.ArgumentException">Thrown if the connection does not belong to this manager.</exception>
    </member>
    <member name="M:BEPUphysics.DeactivationManagement.DeactivationManager.RemoveSimulationIslandFromMember(BEPUphysics.DeactivationManagement.ISimulationIslandMember)">
      <summary>
             Strips a member of its simulation island.
            </summary>
      <param name="member">Member to be stripped.</param>
    </member>
    <member name="M:BEPUphysics.DeactivationManagement.DeactivationManager.AddSimulationIslandToMember(BEPUphysics.DeactivationManagement.ISimulationIslandMember)">
      <summary>
             Adds a simulation island to a member.
            </summary>
      <param name="member">Member to gain a simulation island.</param>
      <exception cref="T:System.Exception">Thrown if the member already has a simulation island.</exception>
    </member>
    <member name="P:BEPUphysics.DeactivationManagement.DeactivationManager.VelocityLowerLimit">
      <summary>
             Gets or sets the velocity under which the deactivation system will consider 
             objects to be deactivation candidates (if their velocity stays below the limit
             for the LowVelocityTimeMinimum).
            </summary>
    </member>
    <member name="P:BEPUphysics.DeactivationManagement.DeactivationManager.LowVelocityTimeMinimum">
      <summary>
            Gets or sets the time limit above which the deactivation system will consider
            objects to be deactivation candidates (if their velocity stays below the VelocityLowerLimit for the duration).
            </summary>
    </member>
    <member name="P:BEPUphysics.DeactivationManagement.DeactivationManager.UseStabilization">
      <summary>
             Gets or sets whether or not to use a stabilization effect on nearly motionless objects.
             This removes a lot of energy from a system when things are settling down, allowing them to go 
             to sleep faster.  It also makes most simulations appear a lot more robust.
            </summary>
    </member>
    <member name="P:BEPUphysics.DeactivationManagement.DeactivationManager.MaximumDeactivationsPerFrame">
      <summary>
             Gets or sets the maximum number of objects to attempt to deactivate each frame.
            </summary>
    </member>
    <member name="P:BEPUphysics.DeactivationManagement.DeactivationManager.TimeStepSettings">
      <summary>
             Gets or sets the time step settings used by the deactivation manager in determining which objects 
            </summary>
    </member>
    <member name="P:BEPUphysics.DeactivationManagement.DeactivationManager.SimulationIslands">
      <summary>
             Gets the simulation islands currently in the manager.
            </summary>
    </member>
    <member name="T:BEPUphysics.Collidables.StaticMesh">
      <summary>
             Unmoving, collidable triangle mesh.
            </summary>
      <remarks>
             The acceleration structure for the mesh is created individually for each
             StaticMesh; if you want to create many meshes of the same model, consider using the
             InstancedMesh.
             </remarks>
    </member>
    <member name="M:BEPUphysics.Collidables.StaticMesh.#ctor(Microsoft.Xna.Framework.Vector3[],System.Int32[])">
      <summary>
             Constructs a new static mesh.
            </summary>
      <param name="vertices">Vertex positions of the mesh.</param>
      <param name="indices">Index list of the mesh.</param>
    </member>
    <member name="M:BEPUphysics.Collidables.StaticMesh.#ctor(Microsoft.Xna.Framework.Vector3[],System.Int32[],BEPUphysics.MathExtensions.AffineTransform)">
      <summary>
             Constructs a new static mesh.
            </summary>
      <param name="vertices">Vertex positions of the mesh.</param>
      <param name="indices">Index list of the mesh.</param>
      <param name="worldTransform">Transform to use to create the mesh initially.</param>
    </member>
    <member name="M:BEPUphysics.Collidables.StaticMesh.RayCast(Microsoft.Xna.Framework.Ray,System.Single,BEPUphysics.RayHit@)">
      <summary>
            Tests a ray against the entry.
            </summary>
      <param name="ray">Ray to test.</param>
      <param name="maximumLength">Maximum length, in units of the ray's direction's length, to test.</param>
      <param name="rayHit">Hit location of the ray on the entry, if any.</param>
      <returns>Whether or not the ray hit the entry.</returns>
    </member>
    <member name="M:BEPUphysics.Collidables.StaticMesh.RayCast(Microsoft.Xna.Framework.Ray,System.Single,BEPUphysics.CollisionShapes.ConvexShapes.TriangleSidedness,BEPUphysics.RayHit@)">
      <summary>
             Tests a ray against the mesh.
            </summary>
      <param name="ray">Ray to test.</param>
      <param name="maximumLength">Maximum length to test in units of the ray direction's length.</param>
      <param name="sidedness">Sidedness to use when raycasting.  Doesn't have to be the same as the mesh's own sidedness.</param>
      <param name="rayHit">Data about the ray's intersection with the mesh, if any.</param>
      <returns>Whether or not the ray hit the mesh.</returns>
    </member>
    <member name="P:BEPUphysics.Collidables.StaticMesh.Mesh">
      <summary>
             Gets the TriangleMesh acceleration structure used by the StaticMesh.
            </summary>
    </member>
    <member name="P:BEPUphysics.Collidables.StaticMesh.WorldTransform">
      <summary>
             Gets or sets the world transform of the mesh.
            </summary>
    </member>
    <member name="P:BEPUphysics.Collidables.StaticMesh.Shape">
      <summary>
             Gets the shape used by the mesh.
            </summary>
    </member>
    <member name="P:BEPUphysics.Collidables.StaticMesh.Sidedness">
      <summary>
             Gets or sets the sidedness of the mesh.  This can be used to ignore collisions and rays coming from a direction relative to the winding of the triangle.
            </summary>
    </member>
    <member name="P:BEPUphysics.Collidables.StaticMesh.ImproveBoundaryBehavior">
      <summary>
            Gets or sets whether or not the collision system should attempt to improve contact behavior at the boundaries between triangles.
            This has a slight performance cost, but prevents objects sliding across a triangle boundary from 'bumping,' and otherwise improves
            the robustness of contacts at edges and vertices.
            </summary>
    </member>
    <member name="P:BEPUphysics.Collidables.StaticMesh.Events">
      <summary>
             Gets the event manager used by the mesh.
            </summary>
    </member>
    <member name="P:BEPUphysics.Collidables.StaticMesh.Material">
      <summary>
             Gets or sets the material used by the mesh.
            </summary>
    </member>
    <member name="P:BEPUphysics.Collidables.StaticMesh.Space">
      <summary>
             Gets the space that owns the mesh.
            </summary>
    </member>
    <member name="T:BEPUphysics.SolverSystems.SolverUpdateableChange">
      <summary>
             Stores an enqueued solver updateable addition or removal.
            </summary>
    </member>
    <member name="F:BEPUphysics.SolverSystems.SolverUpdateableChange.ShouldAdd">
      <summary>
             Whether the item is going to be added or removed.
            </summary>
    </member>
    <member name="F:BEPUphysics.SolverSystems.SolverUpdateableChange.Item">
      <summary>
             Item being added or removed.
            </summary>
    </member>
    <member name="M:BEPUphysics.SolverSystems.SolverUpdateableChange.#ctor(System.Boolean,BEPUphysics.SolverSystems.SolverUpdateable)">
      <summary>
             Constructs a new solver updateable change.
            </summary>
      <param name="shouldAdd">Whether the item is going to be added or removed.</param>
      <param name="item">Item to add or remove.</param>
    </member>
    <member name="T:BEPUphysics.Paths.CardinalSpline3D">
      <summary>
            Cardinal spline implementation of the 3D hermite curve.  Uses a tension parameter to control
            the tightness of the curve.  When tension is zero, a cardinal spline acts like a Catmull-Rom spline.
            </summary>
    </member>
    <member name="M:BEPUphysics.Paths.CardinalSpline3D.GetCurveIndexBoundsInformation(System.Int32@,System.Int32@)">
      <summary>
            Gets the curve's bounding index information.
            </summary>
      <param name="minIndex">Index of the minimum control point in the active curve segment.</param>
      <param name="maxIndex">Index of the maximum control point in the active curve segment.</param>
    </member>
    <member name="P:BEPUphysics.Paths.CardinalSpline3D.Tension">
      <summary>
            Gets or sets the tension parameter of the cardinal spline.
            A value of 0 acts like a Catmull-Rom spline, while a 
            value of 1 produces 0-length tangents.
            </summary>
    </member>
    <member name="T:BEPUphysics.Materials.Material">
      <summary>
             Material properties for collidable objects.
            </summary>
    </member>
    <member name="M:BEPUphysics.Materials.Material.#ctor">
      <summary>
             Constructs a new material.
            </summary>
    </member>
    <member name="M:BEPUphysics.Materials.Material.#ctor(System.Single,System.Single,System.Single)">
      <summary>
             Constructs a new material.
            </summary>
      <param name="staticFriction">Static friction to use.</param>
      <param name="kineticFriction">Kinetic friction to use.</param>
      <param name="bounciness">Bounciness to use.</param>
    </member>
    <member name="M:BEPUphysics.Materials.Material.GetHashCode">
      <summary>
            Serves as a hash function for a particular type. 
            </summary>
      <returns>
            A hash code for the current <see cref="T:System.Object" />.
            </returns>
      <filterpriority>2</filterpriority>
    </member>
    <member name="P:BEPUphysics.Materials.Material.KineticFriction">
      <summary>
             Gets or sets the friction coefficient used when the object is sliding quickly and
             no special material relationship is defined between the colliding objects.
            </summary>
    </member>
    <member name="P:BEPUphysics.Materials.Material.StaticFriction">
      <summary>
             Gets or sets the friction coefficient used when the object is sliding slowly and
             no special material relationship is defined between the colliding objects.
            </summary>
    </member>
    <member name="P:BEPUphysics.Materials.Material.Bounciness">
      <summary>
             Gets or sets the coefficient of restitution between the objects when
             no special material relationship is defined between the colliding objects.
            </summary>
    </member>
    <member name="P:BEPUphysics.Materials.Material.Tag">
      <summary>
             Gets or sets user data associated with the material.
            </summary>
    </member>
    <member name="E:BEPUphysics.Materials.Material.MaterialChanged">
      <summary>
             Fires when the material properties change.
            </summary>
    </member>
    <member name="T:BEPUphysics.CollisionTests.ContactSupplementData">
      <summary>
             Extra data associated with a contact point used to refresh contacts each frame.
            </summary>
    </member>
    <member name="F:BEPUphysics.CollisionTests.ContactSupplementData.LocalOffsetA">
      <summary>
            Offset from the center of the first object to the contact point in the object's local space.
            </summary>
    </member>
    <member name="F:BEPUphysics.CollisionTests.ContactSupplementData.LocalOffsetB">
      <summary>
            Offset from the center of the second object to the contact point in the object's local space.
            </summary>
    </member>
    <member name="F:BEPUphysics.CollisionTests.ContactSupplementData.BasePenetrationDepth">
      <summary>
            Original penetration depth computed at the associatd contact.
            </summary>
    </member>
    <member name="T:BEPUphysics.CollisionRuleManagement.CollisionGroupPair">
      <summary>
            Storage strucure containing two CollisionGroup instances used as a key in a collision rules dictionary.
            </summary>
    </member>
    <member name="F:BEPUphysics.CollisionRuleManagement.CollisionGroupPair.A">
      <summary>
            First collision group in the pair.
            </summary>
    </member>
    <member name="F:BEPUphysics.CollisionRuleManagement.CollisionGroupPair.B">
      <summary>
            Second collision group in the pair.
            </summary>
    </member>
    <member name="M:BEPUphysics.CollisionRuleManagement.CollisionGroupPair.#ctor(BEPUphysics.CollisionRuleManagement.CollisionGroup,BEPUphysics.CollisionRuleManagement.CollisionGroup)">
      <summary>
            Constructs a new collision group pair.
            </summary>
      <param name="groupA">First collision group in the pair.</param>
      <param name="groupB">Second collision group in the pair.</param>
    </member>
    <member name="M:BEPUphysics.CollisionRuleManagement.CollisionGroupPair.Equals(System.Object)">
      <summary>
            Determines whether or not the two objects are equal.
            Use the IEquatable interface implementation if possible.
            </summary>
      <param name="obj">Object to compare.</param>
      <returns>Whether or not the two objects are equal.</returns>
    </member>
    <member name="M:BEPUphysics.CollisionRuleManagement.CollisionGroupPair.GetHashCode">
      <summary>
            Gets the hash code of the entity type pair.
            </summary>
      <returns>Hash code of the entity type pair.</returns>
    </member>
    <member name="T:BEPUphysics.NarrowPhaseSystems.Pairs.SpherePairHandler">
      <summary>
             Handles a sphere-sphere collision pair.
            </summary>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.Pairs.SpherePairHandler.Initialize(BEPUphysics.BroadPhaseSystems.BroadPhaseEntry,BEPUphysics.BroadPhaseSystems.BroadPhaseEntry)">
      <summary>
             Initializes the pair handler.
            </summary>
      <param name="entryA">First entry in the pair.</param>
      <param name="entryB">Second entry in the pair.</param>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.Pairs.SpherePairHandler.UpdateMaterialProperties">
      <summary>
             Forces an update of the pair's material properties.
            </summary>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.Pairs.SpherePairHandler.OnAddedToNarrowPhase">
      <summary>
             Called when the pair handler is added to the narrow phase.
            </summary>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.Pairs.SpherePairHandler.CleanUp">
      <summary>
             Cleans up the pair handler.
            </summary>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.Pairs.SpherePairHandler.UpdateCollision(System.Single)">
      <summary>
             Updates the pair handler.
            </summary>
      <param name="dt">Timestep duration.</param>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.Pairs.SpherePairHandler.UpdateTimeOfImpact(BEPUphysics.Collidables.Collidable,System.Single)">
      <summary>
             Updates the time of impact for the pair.
            </summary>
      <param name="requester">Collidable requesting the update.</param>
      <param name="dt">Timestep duration.</param>
    </member>
    <member name="T:BEPUphysics.NarrowPhaseSystems.Pairs.CompoundPairHandler">
      <summary>
             Handles a compound-compound collision pair.
            </summary>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.Pairs.CompoundPairHandler.#ctor">
      <summary>
             Constructs a new compound pair handler.
            </summary>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.Pairs.CompoundPairHandler.Initialize(BEPUphysics.BroadPhaseSystems.BroadPhaseEntry,BEPUphysics.BroadPhaseSystems.BroadPhaseEntry)">
      <summary>
             Initializes the pair handler.
            </summary>
      <param name="entryA">First entry in the pair.</param>
      <param name="entryB">Second entry in the pair.</param>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.Pairs.CompoundPairHandler.UpdateMaterialProperties">
      <summary>
             Forces an update of the pair's material properties.
            </summary>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.Pairs.CompoundPairHandler.OnAddedToNarrowPhase">
      <summary>
             Called when the pair handler is added to the narrow phase.
            </summary>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.Pairs.CompoundPairHandler.CleanUp">
      <summary>
             Cleans up the pair handler.
            </summary>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.Pairs.CompoundPairHandler.UpdateCollision(System.Single)">
      <summary>
             Updates the pair handler.
            </summary>
      <param name="dt">Timestep duration.</param>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.Pairs.CompoundPairHandler.UpdateTimeOfImpact(BEPUphysics.Collidables.Collidable,System.Single)">
      <summary>
             Updates the time of impact for the pair.
            </summary>
      <param name="requester">Collidable requesting the update.</param>
      <param name="dt">Timestep duration.</param>
    </member>
    <member name="P:BEPUphysics.NarrowPhaseSystems.Pairs.CompoundPairHandler.ChildPairs">
      <summary>
             Gets the pair handlers associated with children of the compound.
            </summary>
    </member>
    <member name="T:BEPUphysics.NarrowPhaseSystems.Pairs.BoxSpherePairHandler">
      <summary>
             Handles a box and sphere in a collision.
            </summary>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.Pairs.BoxSpherePairHandler.Initialize(BEPUphysics.BroadPhaseSystems.BroadPhaseEntry,BEPUphysics.BroadPhaseSystems.BroadPhaseEntry)">
      <summary>
             Initializes the pair handler.
            </summary>
      <param name="entryA">First entry in the pair.</param>
      <param name="entryB">Second entry in the pair.</param>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.Pairs.BoxSpherePairHandler.UpdateMaterialProperties">
      <summary>
             Forces an update of the pair's material properties.
            </summary>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.Pairs.BoxSpherePairHandler.OnAddedToNarrowPhase">
      <summary>
             Called when the pair handler is added to the narrow phase.
            </summary>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.Pairs.BoxSpherePairHandler.CleanUp">
      <summary>
             Cleans up the pair handler.
            </summary>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.Pairs.BoxSpherePairHandler.UpdateCollision(System.Single)">
      <summary>
             Updates the pair handler.
            </summary>
      <param name="dt">Timestep duration.</param>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.Pairs.BoxSpherePairHandler.UpdateTimeOfImpact(BEPUphysics.Collidables.Collidable,System.Single)">
      <summary>
             Updates the time of impact for the pair.
            </summary>
      <param name="requester">Collidable requesting the update.</param>
      <param name="dt">Timestep duration.</param>
    </member>
    <member name="T:BEPUphysics.NarrowPhaseSystems.Factories.BoxPairFactory">
      <summary>
             Manufactures box-box pairs.
            </summary>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.Factories.BoxPairFactory.GetNarrowPhasePair(BEPUphysics.BroadPhaseSystems.BroadPhaseOverlap)">
      <summary>
             Manufactures and returns a narrow phase pair for the given overlap.
            </summary>
      <param name="overlap">Overlap used to create a pair.</param>
      <returns>Narrow phase pair.</returns>
    </member>
    <member name="M:BEPUphysics.NarrowPhaseSystems.Factories.BoxPairFactory.GiveBack(BEPUphysics.NarrowPhaseSystems.Pairs.INarrowPhasePair)">
      <summary>
            Returns a pair to the factory for re-use.
            </summary>
      <param name="pair">Pair to return.</param>
    </member>
    <member name="T:BEPUphysics.Settings.CollisionResponseSettings">
      <summary>
             Contains global settings relating to the collision response system.
            </summary>
    </member>
    <member name="F:BEPUphysics.Settings.CollisionResponseSettings.BouncinessVelocityThreshold">
      <summary>
            Impact velocity above which the bouciness of the object pair is taken into account.  Below the threshold, no extra energy is added.
            </summary>
    </member>
    <member name="F:BEPUphysics.Settings.CollisionResponseSettings.MaximumPositionCorrectionSpeed">
      <summary>
            Maximum speed at which interpenetrating objects or out of alignment joints will attempt to correct.
            Only applies when the Baumgarte method is used when useSplitImpulsePositionCorrection is set to false for contacts.
            Defaults to 2.
            </summary>
    </member>
    <member name="F:BEPUphysics.Settings.CollisionResponseSettings.PenetrationRecoveryStiffness">
      <summary>
            Fraction of position error to convert into corrective momentum when using the Baumgarte position correction method,
            active when useSplitImpulsePositionCorrection is set to false.
            Defaults to .2.
            </summary>
    </member>
    <member name="F:BEPUphysics.Settings.CollisionResponseSettings.StaticFrictionVelocityThreshold">
      <summary>
            Magnitude of relative velocity at a contact point below which staticFriction is used.
            dynamicFriction is used when velocity exceeds this threshold.
            Defaults to .2.
            </summary>
    </member>
    <member name="F:BEPUphysics.Settings.CollisionResponseSettings.TwistFrictionFactor">
      <summary>
            Value by which a collision pair's friction coefficient will be multiplied to get the twist friction coefficient.
            Defaults to 1.
            </summary>
    </member>
    <member name="T:BEPUphysics.PositionUpdating.ContinuousPositionUpdater">
      <summary>
             Updates objects according to the position update mode.
             This allows continuous objects to avoid missing collisions.
            </summary>
    </member>
    <member name="F:BEPUphysics.PositionUpdating.ContinuousPositionUpdater.MultithreadingThreshold">
      <summary>
             Number of objects in a list required to use multithreading.
            </summary>
    </member>
    <member name="M:BEPUphysics.PositionUpdating.ContinuousPositionUpdater.#ctor(BEPUphysics.TimeStepSettings)">
      <summary>
             Constructs the position updater.
            </summary>
      <param name="timeStepSettings">Time step settings to use.</param>
    </member>
    <member name="M:BEPUphysics.PositionUpdating.ContinuousPositionUpdater.#ctor(BEPUphysics.TimeStepSettings,BEPUphysics.Threading.IThreadManager)">
      <summary>
             Constructs the position updater.
            </summary>
      <param name="timeStepSettings">Time step settings to use.</param>
      <param name="threadManager">Thread manager to use.</param>
    </member>
    <member name="M:BEPUphysics.PositionUpdating.ContinuousPositionUpdater.UpdateableModeChanged(BEPUphysics.PositionUpdating.ICCDPositionUpdateable,BEPUphysics.PositionUpdating.PositionUpdateMode)">
      <summary>
             Notifies the position updater that an updateable has changed state.
            </summary>
      <param name="updateable">Updateable with changed state.</param>
      <param name="previousMode">Previous state the updateable was in.</param>
    </member>
    <member name="M:BEPUphysics.PositionUpdating.ContinuousPositionUpdater.Add(BEPUphysics.PositionUpdating.IPositionUpdateable)">
      <summary>
             Adds an object to the position updater.
            </summary>
      <param name="updateable">Updateable to add.</param>
      <exception cref="T:System.Exception">Thrown if the updateable already belongs to a position updater.</exception>
    </member>
    <member name="M:BEPUphysics.PositionUpdating.ContinuousPositionUpdater.Remove(BEPUphysics.PositionUpdating.IPositionUpdateable)">
      <summary>
             Removes an updateable from the updater.
            </summary>
      <param name="updateable">Item to remove.</param>
      <exception cref="T:System.Exception">Thrown if the updater does not own the updateable.</exception>
    </member>
    <member name="T:BEPUphysics.Entities.Prefabs.WrappedBody">
      <summary>
            A shape formed from the convex hull around its subbodies.  Can collide and move.  After making an entity, add it to a Space so that the engine can manage it.
            </summary>
    </member>
    <member name="M:BEPUphysics.Entities.Prefabs.WrappedBody.#ctor(System.Collections.Generic.IList{BEPUphysics.CollisionShapes.ConvexShapes.ConvexShapeEntry},System.Single)">
      <exception cref="T:System.ArgumentException">Thrown when the subbodies list contains zero entities.</exception>
    </member>
    <member name="M:BEPUphysics.Entities.Prefabs.WrappedBody.#ctor(System.Collections.Generic.IList{BEPUphysics.CollisionShapes.ConvexShapes.ConvexShapeEntry})">
      <exception cref="T:System.ArgumentException">Thrown when the subbodies list contains zero entities.</exception>
    </member>
    <member name="M:BEPUphysics.Entities.Prefabs.WrappedBody.#ctor(Microsoft.Xna.Framework.Vector3,System.Collections.Generic.IList{BEPUphysics.CollisionShapes.ConvexShapes.ConvexShapeEntry},System.Single)">
      <summary>
            Constructs a physically simulated box.
            </summary>
      <param name="position">Position of the box.</param>
      <param name="subBodies">List of entities composing the body.</param>
      <param name="mass">Mass of the object.</param>
    </member>
    <member name="M:BEPUphysics.Entities.Prefabs.WrappedBody.#ctor(Microsoft.Xna.Framework.Vector3,System.Collections.Generic.IList{BEPUphysics.CollisionShapes.ConvexShapes.ConvexShapeEntry})">
      <summary>
            Constructs a nondynamic wrapped body.
            </summary>
      <param name="position">Position of the box.</param>
      <param name="subBodies">List of entities composing the body.</param>
    </member>
    <member name="M:BEPUphysics.Entities.Prefabs.WrappedBody.#ctor(BEPUphysics.EntityStateManagement.MotionState,System.Collections.Generic.IList{BEPUphysics.CollisionShapes.ConvexShapes.ConvexShapeEntry},System.Single)">
      <summary>
            Constructs a dynamic wrapped body.
            </summary>
      <param name="motionState">Motion state specifying the entity's initial state.</param>
      <param name="subBodies">List of entities composing the body.</param>
      <param name="mass">Mass of the object.</param>
    </member>
    <member name="M:BEPUphysics.Entities.Prefabs.WrappedBody.#ctor(BEPUphysics.EntityStateManagement.MotionState,System.Collections.Generic.IList{BEPUphysics.CollisionShapes.ConvexShapes.ConvexShapeEntry})">
      <summary>
            Constructs a nondynamic wrapped body.
            </summary>
      <param name="motionState">Motion state specifying the entity's initial state.</param>
      <param name="subBodies">List of entities composing the body.</param>
    </member>
    <member name="P:BEPUphysics.Entities.Prefabs.WrappedBody.Shapes">
      <summary>
             Gets the list of shapes in the wrapped body.
            </summary>
    </member>
    <member name="T:BEPUphysics.Constraints.TwoEntity.Joints.SwivelHingeAngularJoint">
      <summary>
            Constrains two bodies so that they can rotate relative to each other like a modified door hinge.
            Instead of removing two degrees of freedom, only one is removed so that the second connection to the constraint can twist.
            </summary>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.Joints.SwivelHingeAngularJoint.#ctor">
      <summary>
            Constructs a new constraint which allows relative angular motion around a hinge axis and a twist axis.
            To finish the initialization, specify the connections (ConnectionA and ConnectionB) 
            as well as the WorldHingeAxis and WorldTwistAxis (or their entity-local versions).
            This constructor sets the constraint's IsActive property to false by default.
            </summary>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.Joints.SwivelHingeAngularJoint.#ctor(BEPUphysics.Entities.Entity,BEPUphysics.Entities.Entity,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3)">
      <summary>
            Constructs a new constraint which allows relative angular motion around a hinge axis and a twist axis.
            </summary>
      <param name="connectionA">First connection of the pair.</param>
      <param name="connectionB">Second connection of the pair.</param>
      <param name="worldHingeAxis">Hinge axis attached to connectionA.
            The connected entities will be able to rotate around this axis relative to each other.</param>
      <param name="worldTwistAxis">Twist axis attached to connectionB.
            The connected entities will be able to rotate around this axis relative to each other.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.Joints.SwivelHingeAngularJoint.GetLinearJacobianA(Microsoft.Xna.Framework.Vector3@)">
      <summary>
            Gets the linear jacobian entry for the first connected entity.
            </summary>
      <param name="jacobian">Linear jacobian entry for the first connected entity.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.Joints.SwivelHingeAngularJoint.GetLinearJacobianB(Microsoft.Xna.Framework.Vector3@)">
      <summary>
            Gets the linear jacobian entry for the second connected entity.
            </summary>
      <param name="jacobian">Linear jacobian entry for the second connected entity.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.Joints.SwivelHingeAngularJoint.GetAngularJacobianA(Microsoft.Xna.Framework.Vector3@)">
      <summary>
            Gets the angular jacobian entry for the first connected entity.
            </summary>
      <param name="jacobian">Angular jacobian entry for the first connected entity.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.Joints.SwivelHingeAngularJoint.GetAngularJacobianB(Microsoft.Xna.Framework.Vector3@)">
      <summary>
            Gets the angular jacobian entry for the second connected entity.
            </summary>
      <param name="jacobian">Angular jacobian entry for the second connected entity.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.Joints.SwivelHingeAngularJoint.GetMassMatrix(System.Single@)">
      <summary>
            Gets the mass matrix of the constraint.
            </summary>
      <param name="outputMassMatrix">Constraint's mass matrix.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.Joints.SwivelHingeAngularJoint.SolveIteration">
      <summary>
            Solves for velocity.
            </summary>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.Joints.SwivelHingeAngularJoint.Update(System.Single)">
      <summary>
            Do any necessary computations to prepare the constraint for this frame.
            </summary>
      <param name="dt">Simulation step length.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.TwoEntity.Joints.SwivelHingeAngularJoint.ExclusiveUpdate">
      <summary>
            Performs any pre-solve iteration work that needs exclusive
            access to the members of the solver updateable.
            Usually, this is used for applying warmstarting impulses.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.Joints.SwivelHingeAngularJoint.LocalHingeAxis">
      <summary>
            Gets or sets the hinge axis attached to entity A in its local space.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.Joints.SwivelHingeAngularJoint.LocalTwistAxis">
      <summary>
            Gets or sets the twist axis attached to entity B in its local space.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.Joints.SwivelHingeAngularJoint.WorldHingeAxis">
      <summary>
            Gets or sets the hinge axis attached to entity A in world space.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.Joints.SwivelHingeAngularJoint.WorldTwistAxis">
      <summary>
            Gets or sets the axis attached to the first connected entity in world space.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.Joints.SwivelHingeAngularJoint.RelativeVelocity">
      <summary>
            Gets the current relative velocity between the connected entities with respect to the constraint.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.Joints.SwivelHingeAngularJoint.TotalImpulse">
      <summary>
            Gets the total impulse applied by this constraint.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.TwoEntity.Joints.SwivelHingeAngularJoint.Error">
      <summary>
            Gets the current constraint error.
            </summary>
    </member>
    <member name="T:BEPUphysics.Constraints.Collision.NonConvexContactManifoldConstraint">
      <summary>
             Collision constraint for non-convex manifolds.  These manifolds are usually used in cases
             where the contacts are coming from multiple objects or from non-convex objects.  The normals
             will likely face more than one direction.
            </summary>
    </member>
    <member name="M:BEPUphysics.Constraints.Collision.NonConvexContactManifoldConstraint.#ctor">
      <summary>
             Constructs a new nonconvex manifold constraint.
            </summary>
    </member>
    <member name="M:BEPUphysics.Constraints.Collision.NonConvexContactManifoldConstraint.CleanUp">
      <summary>
             Cleans up the constraint.
            </summary>
    </member>
    <member name="M:BEPUphysics.Constraints.Collision.NonConvexContactManifoldConstraint.AddContact(BEPUphysics.CollisionTests.Contact)">
      <summary>
             Adds a contact to be managed by the constraint.
            </summary>
      <param name="contact">Contact to add.</param>
    </member>
    <member name="M:BEPUphysics.Constraints.Collision.NonConvexContactManifoldConstraint.RemoveContact(BEPUphysics.CollisionTests.Contact)">
      <summary>
             Removes a contact from the constraint.
            </summary>
      <param name="contact">Contact to remove.</param>
    </member>
    <member name="P:BEPUphysics.Constraints.Collision.NonConvexContactManifoldConstraint.ContactPenetrationConstraints">
      <summary>
             Gets the penetration constraints in the manifold.
            </summary>
    </member>
    <member name="P:BEPUphysics.Constraints.Collision.NonConvexContactManifoldConstraint.ContactFrictionConstraints">
      <summary>
             Gets the friction constraints in the manifold.
            </summary>
    </member>
    <member name="T:BEPUphysics.CollisionTests.Manifolds.InstancedMeshConvexContactManifold">
      <summary>
             Manages persistent contacts between a convex and an instanced mesh.
            </summary>
    </member>
    <member name="M:BEPUphysics.CollisionTests.Manifolds.InstancedMeshConvexContactManifold.CleanUp">
      <summary>
             Cleans up the manifold.
            </summary>
    </member>
    <member name="M:BEPUphysics.CollisionTests.Manifolds.InstancedMeshConvexContactManifold.Initialize(BEPUphysics.Collidables.Collidable,BEPUphysics.Collidables.Collidable)">
      <summary>
             Initializes the manifold.
            </summary>
      <param name="newCollidableA">First collidable.</param>
      <param name="newCollidableB">Second collidable.</param>
    </member>
    <member name="P:BEPUphysics.CollisionTests.Manifolds.InstancedMeshConvexContactManifold.Mesh">
      <summary>
             Gets the mesh of the pair.
            </summary>
    </member>
    <member name="T:BEPUphysics.CollisionTests.Manifolds.BoxContactManifold">
      <summary>
             Manages persistent contact data between two boxes.
            </summary>
    </member>
    <member name="M:BEPUphysics.CollisionTests.Manifolds.BoxContactManifold.#ctor">
      <summary>
             Constructs a new manifold.
            </summary>
    </member>
    <member name="M:BEPUphysics.CollisionTests.Manifolds.BoxContactManifold.Update(System.Single)">
      <summary>
             Updates the manifold.
            </summary>
      <param name="dt">Timestep duration.</param>
    </member>
    <member name="M:BEPUphysics.CollisionTests.Manifolds.BoxContactManifold.Initialize(BEPUphysics.Collidables.Collidable,BEPUphysics.Collidables.Collidable)">
      <summary>
             Initializes the manifold.
            </summary>
      <param name="newCollidableA">First collidable.</param>
      <param name="newCollidableB">Second collidable.</param>
      <exception cref="T:System.Exception">Thrown when the collidables being used are not of the proper type.</exception>
    </member>
    <member name="M:BEPUphysics.CollisionTests.Manifolds.BoxContactManifold.CleanUp">
      <summary>
             Cleans up the manifold.
            </summary>
    </member>
    <member name="P:BEPUphysics.CollisionTests.Manifolds.BoxContactManifold.CollidableA">
      <summary>
             Gets the first collidable in the pair.
            </summary>
    </member>
    <member name="P:BEPUphysics.CollisionTests.Manifolds.BoxContactManifold.CollidableB">
      <summary>
            Gets the second collidable in the pair.
            </summary>
    </member>
    <member name="T:BEPUphysics.CollisionShapes.ShapeDistributionInformation">
      <summary>
             Contains data about the distribution of volume in a shape.
            </summary>
    </member>
    <member name="F:BEPUphysics.CollisionShapes.ShapeDistributionInformation.VolumeDistribution">
      <summary>
             The distribution of volume in a shape.
             This can be scaled to create an inertia tensor for a shape.
            </summary>
    </member>
    <member name="F:BEPUphysics.CollisionShapes.ShapeDistributionInformation.Center">
      <summary>
            The center of a shape.
            </summary>
    </member>
    <member name="F:BEPUphysics.CollisionShapes.ShapeDistributionInformation.Volume">
      <summary>
            The volume of a shape.
            </summary>
    </member>
    <member name="T:BEPUphysics.CollisionShapes.ConvexShapes.ConvexHullShape">
      <summary>
             Convex wrapping around a point set.
            </summary>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.ConvexShapes.ConvexHullShape.#ctor(System.Collections.Generic.IList{Microsoft.Xna.Framework.Vector3})">
      <summary>
             Constructs a new convex hull shape.
             The point set will be recentered on the local origin.
             If that offset is needed, use the other constructor which outputs the computed center.
            </summary>
      <param name="vertices">Point set to use to construct the convex hull.</param>
      <exception cref="T:System.ArgumentException">Thrown when the point set is empty.</exception>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.ConvexShapes.ConvexHullShape.#ctor(System.Collections.Generic.IList{Microsoft.Xna.Framework.Vector3},Microsoft.Xna.Framework.Vector3@)">
      <summary>
             Constructs a new convex hull shape.
             The point set will be recentered on the local origin.
            </summary>
      <param name="vertices">Point set to use to construct the convex hull.</param>
      <param name="center">Computed center of the convex hull shape prior to recentering.</param>
      <exception cref="T:System.ArgumentException">Thrown when the point set is empty.</exception>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.ConvexShapes.ConvexHullShape.#ctor(System.Collections.Generic.IList{Microsoft.Xna.Framework.Vector3},Microsoft.Xna.Framework.Vector3@,System.Collections.Generic.IList{System.Int32},System.Collections.Generic.IList{Microsoft.Xna.Framework.Vector3})">
      <summary>
             Constructs a new convex hull shape.
             The point set will be recentered on the local origin.
            </summary>
      <param name="vertices">Point set to use to construct the convex hull.</param>
      <param name="center">Computed center of the convex hull shape prior to recentering.</param>
      <param name="outputHullTriangleIndices">Triangle indices computed on the surface of the point set.</param>
      <param name="outputUniqueSurfaceVertices">Unique vertices on the surface of the convex hull.</param>
      <exception cref="T:System.ArgumentException">Thrown when the point set is empty.</exception>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.ConvexShapes.ConvexHullShape.GetBoundingBox(BEPUphysics.MathExtensions.RigidTransform@,Microsoft.Xna.Framework.BoundingBox@)">
      <summary>
            Gets the bounding box of the shape given a transform.
            </summary>
      <param name="shapeTransform">Transform to use.</param>
      <param name="boundingBox">Bounding box of the transformed shape.</param>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.ConvexShapes.ConvexHullShape.ComputeCenter">
      <summary>
            Computes the center of the shape.  This can be considered its 
            center of mass.
            </summary>
      <returns>Center of the shape.</returns>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.ConvexShapes.ConvexHullShape.ComputeCenter(System.Single@)">
      <summary>
            Computes the center of the shape.  This can be considered its 
            center of mass.  This calculation is often associated with the 
            volume calculation, which is given by this method as well.
            </summary>
      <param name="volume">Volume of the shape.</param>
      <returns>Center of the shape.</returns>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.ConvexShapes.ConvexHullShape.ComputeVolume">
      <summary>
            Computes the volume of the shape.
            </summary>
      <returns>Volume of the shape.</returns>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.ConvexShapes.ConvexHullShape.ComputeCenter(System.Single@,System.Collections.Generic.IList{System.Int32},System.Collections.Generic.IList{Microsoft.Xna.Framework.Vector3})">
      <summary>
             Computes the center, volume, and surface triangles of the convex hull shape.
            </summary>
      <param name="volume">Volume of the hull.</param>
      <param name="outputLocalSurfaceTriangles">Surface triangles of the hull.</param>
      <returns>Center of the hull.</returns>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.ConvexShapes.ConvexHullShape.ComputeCenter(System.Collections.Generic.IList{Microsoft.Xna.Framework.Vector3})">
      <summary>
             Computes the center of a convex hull defined by the point set.
            </summary>
      <param name="vertices">Point set defining the convex hull.</param>
      <returns>Center of the convex hull.</returns>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.ConvexShapes.ConvexHullShape.ComputeCenter(System.Collections.Generic.IList{Microsoft.Xna.Framework.Vector3},System.Single@)">
      <summary>
             Computes the center and volume of a convex hull defined by a pointset.
            </summary>
      <param name="vertices">Point set defining the convex hull.</param>
      <param name="volume">Volume of the convex hull.</param>
      <returns>Center of the convex hull.</returns>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.ConvexShapes.ConvexHullShape.ComputeCenter(System.Collections.Generic.IList{Microsoft.Xna.Framework.Vector3},System.Collections.Generic.IList{Microsoft.Xna.Framework.Vector3})">
      <summary>
             Computes the center and surface triangles of a convex hull defined by a point set.
            </summary>
      <param name="vertices">Point set defining the convex hull.</param>
      <param name="outputLocalSurfaceVertices">Local positions of vertices on the convex hull.</param>
      <returns>Center of the convex hull.</returns>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.ConvexShapes.ConvexHullShape.ComputeCenter(System.Collections.Generic.IList{Microsoft.Xna.Framework.Vector3},System.Collections.Generic.IList{System.Int32},System.Collections.Generic.IList{Microsoft.Xna.Framework.Vector3})">
      <summary>
             Computes the center and surface triangles of a convex hull defined by a point set.
            </summary>
      <param name="vertices">Point set defining the convex hull.</param>
      <param name="outputSurfaceTriangles">Indices of surface triangles of the convex hull.</param>
      <param name="outputLocalSurfaceVertices">Local positions of vertices on the convex hull.</param>
      <returns>Center of the convex hull.</returns>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.ConvexShapes.ConvexHullShape.ComputeCenter(System.Collections.Generic.IList{Microsoft.Xna.Framework.Vector3},System.Single@,System.Collections.Generic.IList{System.Int32},System.Collections.Generic.IList{Microsoft.Xna.Framework.Vector3})">
      <summary>
             Computes the center, volume, and surface triangles of a convex hull defined by a point set.
            </summary>
      <param name="vertices">Point set defining the convex hull.</param>
      <param name="volume">Volume of the convex hull.</param>
      <param name="outputSurfaceTriangles">Indices of surface triangles of the convex hull.</param>
      <param name="outputLocalSurfaceVertices">Local positions of vertices on the convex hull.</param>
      <returns>Center of the convex hull.</returns>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.ConvexShapes.ConvexHullShape.ComputeVolumeDistribution(System.Single@)">
      <summary>
            Computes the volume distribution of the shape as well as its volume.
            The volume distribution can be used to compute inertia tensors when
            paired with mass and other tuning factors.
            </summary>
      <param name="volume">Volume of the shape.</param>
      <returns>Volume distribution of the shape.</returns>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.ConvexShapes.ConvexHullShape.ComputeVolumeDistribution(System.Single,System.Collections.Generic.IList{System.Int32})">
      <summary>
             Computes the volume distribution of the convex hull, its volume, and its surface triangles.
            </summary>
      <param name="volume">Volume of the convex hull.</param>
      <param name="localSurfaceTriangles">Surface triangles of the convex hull.</param>
      <returns>Volume distribution of the convex hull.</returns>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.ConvexShapes.ConvexHullShape.ComputeMaximumRadius">
      <summary>
            Computes the maximum radius of the shape.
            This is often larger than the actual maximum radius;
            it is simply an approximation that avoids underestimating.
            </summary>
      <returns>Maximum radius of the shape.</returns>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.ConvexShapes.ConvexHullShape.ComputeMinimumRadius">
      <summary>
             Computes the minimum radius of the shape.
             This is often smaller than the actual minimum radius;
             it is simply an approximation that avoids overestimating.
            </summary>
      <returns>Minimum radius of the shape.</returns>
    </member>
    <member name="M:BEPUphysics.CollisionShapes.ConvexShapes.ConvexHullShape.GetMobileInstance">
      <summary>
            Retrieves an instance of an EntityCollidable that uses this EntityShape.  Mainly used by compound bodies.
            </summary>
      <returns>EntityCollidable that uses this shape.</returns>
    </member>
    <member name="P:BEPUphysics.CollisionShapes.ConvexShapes.ConvexHullShape.Vertices">
      <summary>
             Gets the point set of the convex hull.
            </summary>
    </member>
    <member name="T:BEPUphysics.Collidables.EntityCollidableCollection">
      <summary>
             Enumerable collection of entities associated with a collidable.
            </summary>
    </member>
    <member name="T:BEPUphysics.Collidables.EntityCollidableCollection.Enumerator">
      <summary>
             Enumerator for the EntityCollidableCollection.
            </summary>
    </member>
    <member name="M:BEPUphysics.Collidables.EntityCollidableCollection.Enumerator.#ctor(BEPUphysics.Collidables.EntityCollidableCollection)">
      <summary>
             Constructs a new enumerator.
            </summary>
      <param name="collection">Owning collection.</param>
    </member>
    <member name="M:BEPUphysics.Collidables.EntityCollidableCollection.Enumerator.Dispose">
      <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
      <filterpriority>2</filterpriority>
    </member>
    <member name="M:BEPUphysics.Collidables.EntityCollidableCollection.Enumerator.MoveNext">
      <summary>
            Advances the enumerator to the next element of the collection.
            </summary>
      <returns>
            true if the enumerator was successfully advanced to the next element; false if the enumerator has passed the end of the collection.
            </returns>
      <exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created. </exception>
      <filterpriority>2</filterpriority>
    </member>
    <member name="M:BEPUphysics.Collidables.EntityCollidableCollection.Enumerator.Reset">
      <summary>
            Sets the enumerator to its initial position, which is before the first element in the collection.
            </summary>
      <exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created. </exception>
      <filterpriority>2</filterpriority>
    </member>
    <member name="P:BEPUphysics.Collidables.EntityCollidableCollection.Enumerator.Current">
      <summary>
            Gets the element in the collection at the current position of the enumerator.
            </summary>
      <returns>
            The element in the collection at the current position of the enumerator.
            </returns>
    </member>
    <member name="M:BEPUphysics.Collidables.EntityCollidableCollection.#ctor(BEPUphysics.Collidables.MobileCollidables.EntityCollidable)">
      <summary>
             Constructs a new EntityCollidableCollection.
            </summary>
      <param name="owner">Owner of the collection.</param>
    </member>
    <member name="M:BEPUphysics.Collidables.EntityCollidableCollection.GetEnumerator">
      <summary>
             Gets an enumerator over the entities in the collection.
            </summary>
      <returns>Enumerator over the entities in the collection.</returns>
    </member>
    <member name="T:XNAnimation.Effects.SkinnedModelBasicEffect">
      <summary>
            Represents an effect that supports skinning, normal, specular and diffuse textures, 
            and phong lighting with multiple point light sources. This effect can use shader model 2.0
            or 3.0, according to the number of lights enabled.
            </summary>
    </member>
    <member name="M:XNAnimation.Effects.SkinnedModelBasicEffect.#ctor(Microsoft.Xna.Framework.Graphics.GraphicsDevice,XNAnimation.Effects.SkinnedModelBasicEffect)">
      <summary>Initializes a new instance of the 
            <see cref="T:XNAnimation.Effects.SkinnedModelBasicEffect" />
            class.
            </summary>
      <param name="graphicsDevice">The graphics device that will create the effect.</param>
      <param name="clone">The effect to clone.</param>
    </member>
    <member name="P:XNAnimation.Effects.SkinnedModelBasicEffect.Bones">
      <summary>
            Gets or sets the bone matrices of the skeleton.
            </summary>
    </member>
    <member name="P:XNAnimation.Effects.SkinnedModelBasicEffect.View">
      <summary>
            Gets or sets the camera view matrix.
            </summary>
    </member>
    <member name="P:XNAnimation.Effects.SkinnedModelBasicEffect.Projection">
      <summary>
            Gets or sets the camera projection matrix.
            </summary>
    </member>
    <member name="P:XNAnimation.Effects.SkinnedModelBasicEffect.DiffuseMapEnabled">
      <summary>
            Enables diffuse texture.
            </summary>
    </member>
    <member name="P:XNAnimation.Effects.SkinnedModelBasicEffect.GlowMapEnabled">
      <summary>
            Enables diffuse texture.
            </summary>
    </member>
    <member name="P:XNAnimation.Effects.SkinnedModelBasicEffect.DiffuseMap">
      <summary>
            Gets or sets diffuse texture.
            </summary>
    </member>
    <member name="P:XNAnimation.Effects.SkinnedModelBasicEffect.SpecularMap">
      <summary>
            Gets or sets normal map texture.
            </summary>
    </member>
    <member name="P:XNAnimation.Effects.SkinnedModelBasicEffect.NormalMapEnabled">
      <summary>
            Enables normal map texture.
            </summary>
    </member>
    <member name="P:XNAnimation.Effects.SkinnedModelBasicEffect.NormalMap">
      <summary>
            Gets or sets normal map texture.
            </summary>
    </member>
    <member name="T:XNAnimation.Controllers.InterpolationMode">
      <summary>
            Specifies how translations, orientations and scales are interpolated between keyframes.
            </summary>
    </member>
    <member name="F:XNAnimation.Controllers.InterpolationMode.None">
      <summary>
            Does not use interpolation.
            </summary>
    </member>
    <member name="F:XNAnimation.Controllers.InterpolationMode.Linear">
      <summary>
            Linear interpolation. Supported on translations and scales.
            </summary>
    </member>
    <member name="F:XNAnimation.Controllers.InterpolationMode.Cubic">
      <summary>
            Cubic interpolation. Supported on translations and scales.
            </summary>
    </member>
    <member name="F:XNAnimation.Controllers.InterpolationMode.Spherical">
      <summary>
            Spherical interpolation. Only supported on orientations.
            </summary>
    </member>
    <member name="T:XNAnimation.Controllers.PlaybackMode">
      <summary>
            Specifies how an animation clip is played.
            </summary>
    </member>
    <member name="F:XNAnimation.Controllers.PlaybackMode.Forward">
      <summary>
            Plays the animation clip in the forward way.
            </summary>
    </member>
    <member name="F:XNAnimation.Controllers.PlaybackMode.Backward">
      <summary>
            Plays the animation clip in the backward way.
            </summary>
    </member>
    <member name="T:XNAnimation.Controllers.IAnimationController">
      <summary>
            Defines an interface for an animation controller.
            </summary>
    </member>
    <member name="M:XNAnimation.Controllers.IAnimationController.StartClip(XNAnimation.AnimationClip)">
      <summary>
            Starts the playback of an animation clip from the beginning.
            </summary>
      <param name="animationClip">The animation clip to be played.</param>
    </member>
    <member name="M:XNAnimation.Controllers.IAnimationController.PlayClip(XNAnimation.AnimationClip)">
      <summary>
            Plays an animation clip.
            </summary>
      <param name="animationClip">The animation clip to be played.</param>
    </member>
    <member name="M:XNAnimation.Controllers.IAnimationController.CrossFade(XNAnimation.AnimationClip,System.TimeSpan)">
      <summary>
            Interpolates linearly between two animation clips, fading out the current 
            animation clip and fading in a new one.
            </summary>
      <param name="animationClip">The animation clip to be faded in.</param>
      <param name="fadeTime">Time used to fade in and out the animation clips.</param>
    </member>
    <member name="M:XNAnimation.Controllers.IAnimationController.CrossFade(XNAnimation.AnimationClip,System.TimeSpan,XNAnimation.Controllers.InterpolationMode,XNAnimation.Controllers.InterpolationMode,XNAnimation.Controllers.InterpolationMode)">
      <summary>
            Interpolates between two animation clips, fading out the current animation clip 
            and fading in a new one.
            </summary>
      <param name="animationClip">The animation clip to be faded in.</param>
      <param name="fadeTime">Time used to fade in and out the animation clips.</param>
      <param name="translationInterpolation">How translations are interpolated between animation clips.</param>
      <param name="orientationInterpolation">How orientations are interpolated between animation clips.</param>
      <param name="scaleInterpolation">How scales are interpolated between animation clips.</param>
    </member>
    <member name="M:XNAnimation.Controllers.IAnimationController.Update(System.TimeSpan,Microsoft.Xna.Framework.Matrix)">
      <summary>
            Updates the animation clip time and calculates the new skeleton's bone pose.
            </summary>
      <param name="elapsedTime">Time elapsed since the last update.</param>
      <param name="parent">The parent bone for the current skeleton's root bone.</param>
    </member>
    <member name="P:XNAnimation.Controllers.IAnimationController.AnimationClip">
      <summary>
            Gets the animation clip being played.
            </summary>
    </member>
    <member name="P:XNAnimation.Controllers.IAnimationController.Time">
      <summary>
            Gets os sets the current animation playback time.
            </summary>
    </member>
    <member name="P:XNAnimation.Controllers.IAnimationController.Speed">
      <summary>
            Gets os sets the animation playback speed.
            </summary>
    </member>
    <member name="P:XNAnimation.Controllers.IAnimationController.LoopEnabled">
      <summary>
            Enables animation looping.
            </summary>
    </member>
    <member name="P:XNAnimation.Controllers.IAnimationController.PlaybackMode">
      <summary>
            Gets os sets the animation playback mode.
            </summary>
    </member>
    <member name="P:XNAnimation.Controllers.IAnimationController.TranslationInterpolation">
      <summary>
            Gets os sets how translations are interpolated between animation keyframes.
            Supports linear and cubic interpolation.
            </summary>
    </member>
    <member name="P:XNAnimation.Controllers.IAnimationController.OrientationInterpolation">
      <summary>
            Gets os sets how orientations are interpolated between animation keyframes.
            Supports linear and spherical interpolation.
            </summary>
    </member>
    <member name="P:XNAnimation.Controllers.IAnimationController.ScaleInterpolation">
      <summary>
            Gets os sets how scales are interpolated between animation keyframes.
            Supports linear and cubic interpolation.
            </summary>
    </member>
    <member name="P:XNAnimation.Controllers.IAnimationController.HasFinished">
      <summary>
            Returns whether the animation has finished.
            </summary>
    </member>
    <member name="P:XNAnimation.Controllers.IAnimationController.IsPlaying">
      <summary>
            Returns whether the animation is playing.
            </summary>
    </member>
    <member name="P:XNAnimation.Controllers.IAnimationController.LocalBonePoses">
      <summary>
            Gets the local pose of all skeleton's bones in depth-first order.
            </summary>
    </member>
    <member name="P:XNAnimation.Controllers.IAnimationController.SkinnedBoneTransforms">
      <summary>
            Gets the final transformation of all skeleton's bonse in depth-first order.
            This transformation is used to transfom the model's mesh vertices.
            </summary>
    </member>
    <member name="T:XNAnimation.Controllers.IBlendable">
      <summary>
            Defines an interface for blendable animations.
            </summary>
    </member>
    <member name="P:XNAnimation.Controllers.IBlendable.LocalBonePoses">
      <summary>
            Gets the local pose of all skeleton's bones in depth-first order.
            </summary>
    </member>
    <member name="P:XNAnimation.Controllers.IBlendable.BlendWeight">
      <summary>
            Gets or sets the blend weight.
            The blend weight must be a positive value between 0 and 1.
            </summary>
    </member>
    <member name="T:XNAnimation.Resource1">
      <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
    </member>
    <member name="P:XNAnimation.Resource1.ResourceManager">
      <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
    </member>
    <member name="P:XNAnimation.Resource1.Culture">
      <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
    </member>
    <member name="M:XNAnimation.AnimationChannel.GetKeyframeIndexByTime(System.TimeSpan)">
      <summary>
            Return the nearest keyframe for the given time
            </summary>
      <param name="time">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:XNAnimation.Controllers.ISkeletonController">
      <summary>
            Defines an interface for an skeleton controller.
            </summary>
    </member>
    <member name="M:XNAnimation.Controllers.ISkeletonController.SetBonePose(System.String,XNAnimation.Pose@)">
      <summary>
            Sets a custom pose for an skeleton's bone.
            </summary>
      <param name="channelName">The name of the bone.</param>
      <param name="pose">The custom pose to be set.</param>
    </member>
    <member name="M:XNAnimation.Controllers.ISkeletonController.SetBonePose(System.String,XNAnimation.Pose)">
      <summary>
            Sets a custom pose for an skeleton's bone.
            </summary>
      <param name="channelName">The name of the bone.</param>
      <param name="pose">The custom pose to be set.</param>
    </member>
    <member name="P:XNAnimation.Controllers.ISkeletonController.LocalBonePoses">
      <summary>
            Gets the local pose of all skeleton's bones in depth-first order.
            </summary>
    </member>
    <member name="T:XNAnimation.Controllers.BlendMode">
      <summary>
            Specify how animation clips are blended.
            </summary>
    </member>
    <member name="F:XNAnimation.Controllers.BlendMode.Interpolate">
      <summary>
            Blends animation clips interpolation between them.
            </summary>
    </member>
    <member name="F:XNAnimation.Controllers.BlendMode.Additive">
      <summary>
            Blends animation clips additively.
            </summary>
    </member>
    <member name="T:XNAnimation.Controllers.BlendLayer">
      <summary>
            Enumerates the available blend layers.
            </summary>
    </member>
    <member name="F:XNAnimation.Controllers.BlendLayer.One">
      <summary>
            First blend layer.
            </summary>
    </member>
    <member name="F:XNAnimation.Controllers.BlendLayer.Two">
      <summary>
            Second blend layer.
            </summary>
    </member>
    <member name="F:XNAnimation.Controllers.BlendLayer.Three">
      <summary>
            Third blend layer.
            </summary>
    </member>
    <member name="F:XNAnimation.Controllers.BlendLayer.Four">
      <summary>
            Fourth blend layer.
            </summary>
    </member>
    <member name="T:XNAnimation.Controllers.IBlendController">
      <summary>
            Defines an interface for an animation blend controller.
            </summary>
    </member>
    <member name="P:XNAnimation.Controllers.IBlendController.BlendMode">
      <summary>
            Gets or sets the animation blend mode.
            </summary>
    </member>
    <member name="T:XNAnimation.Controllers.AnimationController">
      <summary>
            Controls how animations are played and interpolated.
            </summary>
    </member>
    <member name="M:XNAnimation.Controllers.AnimationController.#ctor(XNAnimation.SkinnedModelBoneCollection)">
      <summary>Initializes a new instance of the 
            <see cref="T:XNAnimation.Controllers.AnimationController" />
            class.
            </summary>
      <param name="skeleton">The skeleton of the model to be animated</param>
    </member>
    <member name="M:XNAnimation.Controllers.AnimationController.StartClip(XNAnimation.AnimationClip)">
      <inheritdoc />
    </member>
    <member name="M:XNAnimation.Controllers.AnimationController.PlayClip(XNAnimation.AnimationClip)">
      <inheritdoc />
    </member>
    <member name="M:XNAnimation.Controllers.AnimationController.CrossFade(XNAnimation.AnimationClip,System.TimeSpan)">
      <inheritdoc />
    </member>
    <member name="M:XNAnimation.Controllers.AnimationController.CrossFade(XNAnimation.AnimationClip,System.TimeSpan,XNAnimation.Controllers.InterpolationMode,XNAnimation.Controllers.InterpolationMode,XNAnimation.Controllers.InterpolationMode)">
      <inheritdoc />
    </member>
    <member name="M:XNAnimation.Controllers.AnimationController.Update(System.TimeSpan,Microsoft.Xna.Framework.Matrix)">
      <inheritdoc />
    </member>
    <member name="M:XNAnimation.Controllers.AnimationController.UpdateCrossFadeTime(System.TimeSpan)">
      <summary>
            Updates the CrossFade time
            </summary>
      <param name="elapsedTime">Time elapsed since the last update.</param>
    </member>
    <member name="M:XNAnimation.Controllers.AnimationController.UpdateAnimationTime(System.TimeSpan)">
      <summary>
            Updates the animation clip time.
            </summary>
      <param name="elapsedTime">Time elapsed since the last update.</param>
    </member>
    <member name="M:XNAnimation.Controllers.AnimationController.UpdateChannelPoses">
      <summary>
            Updates the pose of all skeleton's bones.
            </summary>
    </member>
    <member name="M:XNAnimation.Controllers.AnimationController.InterpolateChannelPose(XNAnimation.AnimationChannel,System.TimeSpan,XNAnimation.Pose@)">
      <summary>
            Retrieves and interpolates the pose of an animation channel.
            </summary>
      <param name="animationChannel">Name of the animation channel.</param>
      <param name="animationTime">Current animation clip time.</param>
      <param name="outPose">The output interpolated pose.</param>
    </member>
    <member name="M:XNAnimation.Controllers.AnimationController.UpdateAbsoluteBoneTransforms(Microsoft.Xna.Framework.Matrix@)">
      <summary>
            Calculates the final configuration of all skeleton's bones used to transform
            the model's mesh.
            </summary>
      <param name="parent">
      </param>
    </member>
    <member name="P:XNAnimation.Controllers.AnimationController.AnimationClip">
      <inheritdoc />
    </member>
    <member name="P:XNAnimation.Controllers.AnimationController.Time">
      <inheritdoc />
    </member>
    <member name="P:XNAnimation.Controllers.AnimationController.Speed">
      <inheritdoc />
    </member>
    <member name="P:XNAnimation.Controllers.AnimationController.LoopEnabled">
      <inheritdoc />
    </member>
    <member name="P:XNAnimation.Controllers.AnimationController.PlaybackMode">
      <inheritdoc />
    </member>
    <member name="P:XNAnimation.Controllers.AnimationController.TranslationInterpolation">
      <inheritdoc />
    </member>
    <member name="P:XNAnimation.Controllers.AnimationController.OrientationInterpolation">
      <inheritdoc />
    </member>
    <member name="P:XNAnimation.Controllers.AnimationController.ScaleInterpolation">
      <inheritdoc />
    </member>
    <member name="P:XNAnimation.Controllers.AnimationController.HasFinished">
      <inheritdoc />
    </member>
    <member name="P:XNAnimation.Controllers.AnimationController.IsPlaying">
      <inheritdoc />
    </member>
    <member name="P:XNAnimation.Controllers.AnimationController.LocalBonePoses">
      <inheritdoc />
    </member>
    <member name="P:XNAnimation.Controllers.AnimationController.SkinnedBoneTransforms">
      <inheritdoc />
    </member>
    <member name="P:XNAnimation.Controllers.AnimationController.BlendWeight">
      <inheritdoc />
    </member>
    <member name="T:XNAnimation.SkinnedModelBone">
      <summary>
            Represents a bone from a skeleton
            </summary>
    </member>
    <member name="P:XNAnimation.SkinnedModelBone.Index">
      <summary>
            Gets the index of this bone in depth-first order.
            </summary>
    </member>
    <member name="P:XNAnimation.SkinnedModelBone.Name">
      <summary>
            Gets the name of this bone.
            </summary>
    </member>
    <member name="P:XNAnimation.SkinnedModelBone.Parent">
      <summary>
            Gets the parent of this bone.
            </summary>
    </member>
    <member name="P:XNAnimation.SkinnedModelBone.Children">
      <summary>
            Gets a collection of bones that are children of this bone.
            </summary>
    </member>
    <member name="P:XNAnimation.SkinnedModelBone.BindPose">
      <summary>
            Gets the pose of this bone relative to its parent.
            </summary>
    </member>
    <member name="P:XNAnimation.SkinnedModelBone.InverseBindPoseTransform">
      <summary>
            Gets a matrix used to transform model's mesh vertices putting them in the same 
            coordinate system of this bone.
            </summary>
    </member>
    <member name="T:XNAnimation.Controllers.SkeletonController">
      <summary>
            Controls the pose of each bone in a skeleton. Allows custom skeleton poses to be blended 
            with other <see cref="T:XNAnimation.Controllers.IBlendable" /> objects.
            </summary>
    </member>
    <member name="M:XNAnimation.Controllers.SkeletonController.#ctor(XNAnimation.SkinnedModelBoneDictionary)">
      <summary>Initializes a new instance of the 
            <see cref="T:XNAnimation.Controllers.SkeletonController"></see>
            class.
            </summary>
      <param name="skeletonDictionary">
      </param>
    </member>
    <member name="M:XNAnimation.Controllers.SkeletonController.SetBonePose(System.String,XNAnimation.Pose@)">
      <inheritdoc />
    </member>
    <member name="M:XNAnimation.Controllers.SkeletonController.SetBonePose(System.String,XNAnimation.Pose)">
      <inheritdoc />
    </member>
    <member name="P:XNAnimation.Controllers.SkeletonController.LocalBonePoses">
      <inheritdoc />
    </member>
    <member name="P:XNAnimation.Controllers.SkeletonController.BlendWeight">
      <inheritdoc />
    </member>
    <member name="T:DPSF.DefaultParticleSystemMagnet">
      <summary>
            The base class that all Magnet classes inherit from. This class cannot be instantiated directly.
            A Magnet of a Particle System has an affect on its Particles, such as attracting or repelling them.
            </summary>
    </member>
    <member name="T:DPSF.DefaultParticleSystemMagnet.MagnetModes">
      <summary>
            The Modes that the Magnet can be in
            </summary>
    </member>
    <member name="T:DPSF.DefaultParticleSystemMagnet.DistanceFunctions">
      <summary>
            How much the Magnet should affect the Particles based on the Magnet's
            Max Distance and Strength
            </summary>
    </member>
    <member name="T:DPSF.DefaultParticleSystemMagnet.MagnetTypes">
      <summary>
            The Types of Magnets available to choose from (i.e. which Magnet class is being used)
            </summary>
    </member>
    <member name="F:DPSF.DefaultParticleSystemMagnet.Mode">
      <summary>
            The current Mode that the Magnet is in
            </summary>
    </member>
    <member name="F:DPSF.DefaultParticleSystemMagnet.DistanceFunction">
      <summary>
            The Function to use to determine how much a Particle should be affected by 
            the Magnet based on how far away from the Magnet it is
            </summary>
    </member>
    <member name="F:DPSF.DefaultParticleSystemMagnet.meMagnetType">
      <summary>
            Holds the Type of Magnet this is
            </summary>
    </member>
    <member name="F:DPSF.DefaultParticleSystemMagnet.MinDistance">
      <summary>
            The Min Distance that the Magnet should be able to affect Particles at. If the
            Particle is closer to the Magnet than this distance, the Magnet will not affect
            the Particle.
            </summary>
    </member>
    <member name="F:DPSF.DefaultParticleSystemMagnet.MaxDistance">
      <summary>
            The Max Distance that the Magnet should be able to affect Particles at. If the
            Particle is further away from the Magnet tan this distance, the Manget will not
            affect the Particle.
            </summary>
    </member>
    <member name="F:DPSF.DefaultParticleSystemMagnet.MaxForce">
      <summary>
            The Max Force that the Magnet is able to exert on a Particle
            </summary>
    </member>
    <member name="F:DPSF.DefaultParticleSystemMagnet.UserDefinedMagnetType">
      <summary>
            The Type of User-Defined Magnet this is. User-defined Magnet classes will all have a 
            MagnetType = MagnetTypes.UserDefined, so this field can be used to distinguish between 
            different user-defined Magnet classes.
            This may be used in conjunction with the "Other" Magnet Mode to distinguish which type of 
            custom user effect the Magnet should have on the Particles.
            </summary>
    </member>
    <member name="M:DPSF.DefaultParticleSystemMagnet.#ctor(DPSF.DefaultParticleSystemMagnet.MagnetModes,DPSF.DefaultParticleSystemMagnet.DistanceFunctions,System.Single,System.Single,System.Single,System.Int32)">
      <summary>
            Explicit Constructor
            </summary>
      <param name="eMode">The Mode that the Magnet should be in</param>
      <param name="eDistanceFunction">The Function to use to determine how much a Particle should be affected by 
            the Magnet based on how far away from the Magnet it is</param>
      <param name="fMinDistance">The Min Distance that the Magnet should be able to affect Particles at. If the
            Particle is closer to the Magnet than this distance, the Magnet will not affect the Particle.</param>
      <param name="fMaxDistance">The Max Distance that the Magnet should be able to affect Particles at. If the
            Particle is further away from the Magnet tan this distance, the Manget will not affect the Particle.</param>
      <param name="fMaxForce">The Max Force that the Magnet is able to exert on a Particle</param>
      <param name="iType">The Type of Magnet this is. This may be used in conjunction with the "Other" Magnet
            Mode to distinguish which type of custom user effect the Magnet should have on the Particles.</param>
    </member>
    <member name="M:DPSF.DefaultParticleSystemMagnet.#ctor(DPSF.DefaultParticleSystemMagnet)">
      <summary>
            Copy Constructor
            </summary>
      <param name="cMagnetToCopy">The Magnet to copy from</param>
    </member>
    <member name="M:DPSF.DefaultParticleSystemMagnet.CopyFrom(DPSF.DefaultParticleSystemMagnet)">
      <summary>
            Copies the given Magnet's data into this Magnet's data
            </summary>
      <param name="cMagnetToCopy">The Magnet to copy from</param>
    </member>
    <member name="P:DPSF.DefaultParticleSystemMagnet.MagnetType">
      <summary>
            Gets what Type of Magnet this is
            </summary>
    </member>
    <member name="P:DPSF.DefaultParticleSystemMagnet.ID">
      <summary>
            Get the unique ID of this Magnet
            </summary>
    </member>
    <member name="T:DPSF.MagnetPoint">
      <summary>
            Magnet that attracts particles to/from a single point in 3D space
            </summary>
    </member>
    <member name="F:DPSF.MagnetPoint.PositionData">
      <summary>
            The Position, Velocity, and Acceleration of the Magnet
            </summary>
    </member>
    <member name="M:DPSF.MagnetPoint.#ctor(Microsoft.Xna.Framework.Vector3,DPSF.DefaultParticleSystemMagnet.MagnetModes,DPSF.DefaultParticleSystemMagnet.DistanceFunctions,System.Single,System.Single,System.Single,System.Int32)">
      <summary>
            Explicit Constructor
            </summary>
      <param name="sPosition">The 3D Position of the Magnet</param>
      <param name="eMode">The Mode that the Magnet should be in</param>
      <param name="eDistanceFunction">The Function to use to determine how much a Particle should be affected by 
            the Magnet based on how far away from the Magnet it is</param>
      <param name="fMinDistance">The Min Distance that the Magnet should be able to affect Particles at. If the
            Particle is closer to the Magnet than this distance, the Magnet will not affect the Particle.</param>
      <param name="fMaxDistance">The Max Distance that the Magnet should be able to affect Particles at. If the
            Particle is further away from the Magnet tan this distance, the Manget will not affect the Particle.</param>
      <param name="fMaxForce">The Max Force that the Magnet is able to exert on a Particle</param>
      <param name="iType">The Type of Magnet this is. This may be used in conjunction with the "Other" Magnet
            Mode to distinguish which type of custom user effect the Magnet should have on the Particles.</param>
    </member>
    <member name="M:DPSF.MagnetPoint.#ctor(DPSF.Position3D,DPSF.DefaultParticleSystemMagnet.MagnetModes,DPSF.DefaultParticleSystemMagnet.DistanceFunctions,System.Single,System.Single,System.Single,System.Int32)">
      <summary>
            Explicit Constructor
            </summary>
      <param name="cPositionData">The 3D Position, Velocity, and Acceleration of the Magnet</param>
      <param name="eMode">The Mode that the Magnet should be in</param>
      <param name="eDistanceFunction">The Function to use to determine how much a Particle should be affected by 
            the Magnet based on how far away from the Magnet it is</param>
      <param name="fMinDistance">The Min Distance that the Magnet should be able to affect Particles at. If the
            Particle is closer to the Magnet than this distance, the Magnet will not affect the Particle.</param>
      <param name="fMaxDistance">The Max Distance that the Magnet should be able to affect Particles at. If the
            Particle is further away from the Magnet tan this distance, the Manget will not affect the Particle.</param>
      <param name="fMaxForce">The Max Force that the Magnet is able to exert on a Particle</param>
      <param name="iType">The Type of Magnet this is. This may be used in conjunction with the "Other" Magnet
            Mode to distinguish which type of custom user effect the Magnet should have on the Particles.</param>
    </member>
    <member name="M:DPSF.MagnetPoint.#ctor(DPSF.MagnetPoint)">
      <summary>
            Copy Constructor
            </summary>
      <param name="cMagnetToCopy">The Point Magnet to copy from</param>
    </member>
    <member name="M:DPSF.MagnetPoint.CopyFrom(DPSF.MagnetPoint)">
      <summary>
            Copies the given Point Magnet's data into this Point Magnet's data
            </summary>
      <param name="cMagnetToCopy">The Point Magnet to copy from</param>
    </member>
    <member name="T:DPSF.MagnetLine">
      <summary>
            Magnet that attracts particles to/from an infinite line in 3D space
            </summary>
    </member>
    <member name="F:DPSF.MagnetLine.msDirection">
      <summary>
            The Direction that the Line points in
            </summary>
    </member>
    <member name="M:DPSF.MagnetLine.#ctor(Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,DPSF.DefaultParticleSystemMagnet.MagnetModes,DPSF.DefaultParticleSystemMagnet.DistanceFunctions,System.Single,System.Single,System.Single,System.Int32)">
      <summary>
            Explicit Constructor
            </summary>
      <param name="sPositionOnLine">A 3D Position that the Line Magnet passes through</param>
      <param name="sDirection">The Direction that the Line points in</param>
      <param name="eMode">The Mode that the Magnet should be in</param>
      <param name="eDistanceFunction">The Function to use to determine how much a Particle should be affected by 
            the Magnet based on how far away from the Magnet it is</param>
      <param name="fMinDistance">The Min Distance that the Magnet should be able to affect Particles at. If the
            Particle is closer to the Magnet than this distance, the Magnet will not affect the Particle.</param>
      <param name="fMaxDistance">The Max Distance that the Magnet should be able to affect Particles at. If the
            Particle is further away from the Magnet tan this distance, the Manget will not affect the Particle.</param>
      <param name="fMaxForce">The Max Force that the Magnet is able to exert on a Particle</param>
      <param name="iType">The Type of Magnet this is. This may be used in conjunction with the "Other" Magnet
            Mode to distinguish which type of custom user effect the Magnet should have on the Particles.</param>
    </member>
    <member name="M:DPSF.MagnetLine.#ctor(DPSF.MagnetLine)">
      <summary>
            Copy Constructor
            </summary>
      <param name="cMagnetToCopy">The Line Magnet to copy from</param>
    </member>
    <member name="M:DPSF.MagnetLine.CopyFrom(DPSF.MagnetLine)">
      <summary>
            Copies the given Line Magnet's data into this Line Magnet's data
            </summary>
      <param name="cMagnetToCopy">The Line Magnet to copy from</param>
    </member>
    <member name="M:DPSF.MagnetLine.SetDirection(Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3)">
      <summary>
            Sets the Direction of the Line by specifying 2 points in 3D space that are on the Line.
            <para>NOTE: The 2 points cannot be the same.</para></summary>
      <param name="sFirstPointOnTheLine">The first point that falls on the Line</param>
      <param name="sSecondPointOnTheLine">The second point that falls on the Line</param>
    </member>
    <member name="P:DPSF.MagnetLine.PositionOnLine">
      <summary>
            A 3D point that the Line passes through
            </summary>
    </member>
    <member name="P:DPSF.MagnetLine.Direction">
      <summary>
            The direction that the Line points in. This direction, along with the opposite (i.e. negative) of 
            this direction form the line, since a line has infinite length. This value is 
            automatically normalized when it is set.
            </summary>
    </member>
    <member name="T:DPSF.MagnetLineSegment">
      <summary>
            Magnet that attracts particles to/from a line with specified end points in 3D space
            </summary>
    </member>
    <member name="M:DPSF.MagnetLineSegment.#ctor(Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,DPSF.DefaultParticleSystemMagnet.MagnetModes,DPSF.DefaultParticleSystemMagnet.DistanceFunctions,System.Single,System.Single,System.Single,System.Int32)">
      <summary>
            Explicit Constructor
            </summary>
      <param name="sEndPoint1Position">The 3D position of the first End Point of the Line Segment Magnet</param>
      <param name="sEndPoint2Position">The 3D position of the second End Point of the Line Segment Magnet</param>
      <param name="eMode">The Mode that the Magnet should be in</param>
      <param name="eDistanceFunction">The Function to use to determine how much a Particle should be affected by 
            the Magnet based on how far away from the Magnet it is</param>
      <param name="fMinDistance">The Min Distance that the Magnet should be able to affect Particles at. If the
            Particle is closer to the Magnet than this distance, the Magnet will not affect the Particle.</param>
      <param name="fMaxDistance">The Max Distance that the Magnet should be able to affect Particles at. If the
            Particle is further away from the Magnet tan this distance, the Manget will not affect the Particle.</param>
      <param name="fMaxForce">The Max Force that the Magnet is able to exert on a Particle</param>
      <param name="iType">The Type of Magnet this is. This may be used in conjunction with the "Other" Magnet
            Mode to distinguish which type of custom user effect the Magnet should have on the Particles.</param>
    </member>
    <member name="M:DPSF.MagnetLineSegment.#ctor(DPSF.MagnetLineSegment)">
      <summary>
            Copy Constructor
            </summary>
      <param name="cMagnetToCopy">The Line Segment Magnet to copy from</param>
    </member>
    <member name="M:DPSF.MagnetLineSegment.CopyFrom(DPSF.MagnetLineSegment)">
      <summary>
            Copies the given Line Segment Magnet's data into this Line Segment Magnet's data
            </summary>
      <param name="cMagnetToCopy">The Line Magnet to copy from</param>
    </member>
    <member name="P:DPSF.MagnetLineSegment.EndPoint1">
      <summary>
            The position of the first End Point
            </summary>
    </member>
    <member name="P:DPSF.MagnetLineSegment.EndPoint2">
      <summary>
            The position of the second End Point
            </summary>
    </member>
    <member name="T:DPSF.MagnetPlane">
      <summary>
            Magnet that attracts particles to/from a plane in 3D space
            </summary>
    </member>
    <member name="F:DPSF.MagnetPlane.msNormal">
      <summary>
            The Normal direction of the Plane
            </summary>
    </member>
    <member name="M:DPSF.MagnetPlane.#ctor(Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,DPSF.DefaultParticleSystemMagnet.MagnetModes,DPSF.DefaultParticleSystemMagnet.DistanceFunctions,System.Single,System.Single,System.Single,System.Int32)">
      <summary>
            Explicit Constructor
            </summary>
      <param name="sPositionOnPlane">A 3D Position on the Plane Magnet's Plane</param>
      <param name="sNormal">The Normal direction of the Plane (i.e. the up direction away from the plane)</param>
      <param name="eMode">The Mode that the Magnet should be in</param>
      <param name="eDistanceFunction">The Function to use to determine how much a Particle should be affected by 
            the Magnet based on how far away from the Magnet it is</param>
      <param name="fMinDistance">The Min Distance that the Magnet should be able to affect Particles at. If the
            Particle is closer to the Magnet than this distance, the Magnet will not affect the Particle.</param>
      <param name="fMaxDistance">The Max Distance that the Magnet should be able to affect Particles at. If the
            Particle is further away from the Magnet tan this distance, the Manget will not affect the Particle.</param>
      <param name="fMaxForce">The Max Force that the Magnet is able to exert on a Particle</param>
      <param name="iType">The Type of Magnet this is. This may be used in conjunction with the "Other" Magnet
            Mode to distinguish which type of custom user effect the Magnet should have on the Particles.</param>
    </member>
    <member name="M:DPSF.MagnetPlane.#ctor(DPSF.MagnetPlane)">
      <summary>
            Copy Constructor
            </summary>
      <param name="cMagnetToCopy">The Plane Magnet to copy from</param>
    </member>
    <member name="M:DPSF.MagnetPlane.CopyFrom(DPSF.MagnetPlane)">
      <summary>
            Copies the given Plane Magnet's data into this Plane Magnet's data
            </summary>
      <param name="cMagnetToCopy">The Plane Magnet to copy from</param>
    </member>
    <member name="P:DPSF.MagnetPlane.PositionOnPlane">
      <summary>
            A 3D point on the Plane
            </summary>
    </member>
    <member name="P:DPSF.MagnetPlane.Normal">
      <summary>
            The Normal direction of the Plane (i.e. the up direction away from the plane). This value is 
            automatically normalized when it is set.
            </summary>
    </member>
    <member name="T:DPSF.IDPSFParticleSystem">
      <summary>
            Interface implemented by all Particle Systems.
            Variables of this type can point to any type of Particle System.
            </summary>
    </member>
    <member name="M:DPSF.IDPSFParticleSystem.Destroy">
      <summary>
            Release all resources used by the Particle System and reset all properties to their default values
            </summary>
    </member>
    <member name="M:DPSF.IDPSFParticleSystem.SetWorldViewProjectionMatrices(Microsoft.Xna.Framework.Matrix,Microsoft.Xna.Framework.Matrix,Microsoft.Xna.Framework.Matrix)">
      <summary>
            Set the World, View, and Projection matrices for this Particle System.
            </summary>
      <param name="cWorld">The World matrix</param>
      <param name="cView">The View matrix</param>
      <param name="cProjection">The Projection matrix</param>
    </member>
    <member name="M:DPSF.IDPSFParticleSystem.SetDefaultEffectAndTechnique">
      <summary>
            Sets the Effect to be the DPSFDefaultEffect, and the Technique to be the default technique for this type of particle system.
            This is done automatically when the particle system is initialized.
            </summary>
    </member>
    <member name="M:DPSF.IDPSFParticleSystem.SetEffectAndTechnique(System.String,System.String)">
      <summary>
            Sets the Effect and Technique to use to draw the Particles
            </summary>
      <param name="sEffect">The Asset Name of the Effect to use</param>
      <param name="sTechnique">The name of the Effect's Technique to use</param>
    </member>
    <member name="M:DPSF.IDPSFParticleSystem.SetEffectAndTechnique(Microsoft.Xna.Framework.Graphics.Effect,System.String)">
      <summary>
            Sets the Effect and Technique to use to draw the Particles
            </summary>
      <param name="cEffect">The Effect to use</param>
      <param name="sTechnique">The name of the Effect's Technique to use</param>
    </member>
    <member name="M:DPSF.IDPSFParticleSystem.SetTechnique(System.String)">
      <summary>
            Set which Technique of the current Effect to use to draw the Particles
            </summary>
      <param name="sTechnique">The name of the Effect's Technique to use</param>
    </member>
    <member name="M:DPSF.IDPSFParticleSystem.SetTexture(System.String)">
      <summary>
            Set the Texture to use to draw the Particles
            </summary>
      <param name="sTexture">The Asset Name of the texture file to use (found in
            the XNA Properties of the file)</param>
    </member>
    <member name="M:DPSF.IDPSFParticleSystem.AddParticle">
      <summary>
            Adds a new Particle to the particle system, at the start of the Active Particle List. 
            This new Particle is initialized using the particle system's Particle Initialization Function
            </summary>
      <returns>True if a particle was added, False if there is not enough memory for another Particle</returns>
    </member>
    <member name="M:DPSF.IDPSFParticleSystem.AddParticles(System.Int32)">
      <summary>
            Adds the specified number of new Particles to the particle system. 
            These new Particles are initialized using the particle systems Particle Initialization Function
            </summary>
      <param name="iNumberOfParticlesToAdd">How many Particles to Add to the particle system</param>
      <returns>Returns how many Particles were able to be added to the particle system</returns>
    </member>
    <member name="M:DPSF.IDPSFParticleSystem.RemoveAllParticles">
      <summary>
            Removes all Active Particles from the Active Particle List and adds them 
            to the Inactive Particle List
            </summary>
    </member>
    <member name="M:DPSF.IDPSFParticleSystem.Update(System.Single)">
      <summary>
            Updates the Particle System. This involves executing the Particle System
            Events, updating all Active Particles according to the Particle Events, and 
            adding new Particles according to the Emitter settings.
            </summary>
      <param name="fElapsedTimeInSeconds">How much time in seconds has 
            elapsed since the last time this function was called</param>
    </member>
    <member name="M:DPSF.IDPSFParticleSystem.UpdateForced(System.Single)">
      <summary>
            Updates the Particle System, even if the the Particle Systems inherits from DrawableGameComponent.
            <para>Updating the Particle System involves executing the Particle System Events, updating all Active 
            Particles according to the Particle Events, and adding new Particles according to the Emitter settings.</para><para>NOTE: If inheriting from DrawableGameComponent and this is called, the Particle System will be updated
            twice per frame; once when it is called here, and again when automatically called by the Game object.
            If not inheriting from DrawableGameComponent, this acts the same as calling Update().</para></summary>
      <param name="fElapsedTimeInSeconds">How much time in seconds has 
            elapsed since the last time this function was called</param>
    </member>
    <member name="M:DPSF.IDPSFParticleSystem.Draw">
      <summary>
            Draws all of the Active Particles to the Graphics Device
            </summary>
    </member>
    <member name="M:DPSF.IDPSFParticleSystem.DrawForced">
      <summary>
            Draws all of the Active Particles to the Graphics Device, even if the the Particle Systems inherits
            from DrawableGameComponent.
            <para>NOTE: If inheriting from DrawableGameComponent and this is called, the Particle System will be drawn
            twice per frame; once when it is called here, and again when automatically called by the Game object.
            If not inheriting from DrawableGameComponent, this acts the same as calling Draw().</para></summary>
    </member>
    <member name="M:DPSF.IDPSFParticleSystem.AutoInitialize(Microsoft.Xna.Framework.Graphics.GraphicsDevice,Microsoft.Xna.Framework.Content.ContentManager,Microsoft.Xna.Framework.Graphics.SpriteBatch)">
      <summary>
            Virtual function to Initialize the Particle System with default values.
            Particle system properties should not be set until after this is called, as 
            they are likely to be reset to their default values.
            </summary>
      <param name="cGraphicsDevice">The Graphics Device the Particle System should use</param>
      <param name="cContentManager">The Content Manager the Particle System should use to load resources</param>
      <param name="cSpriteBatch">The Sprite Batch that the Sprite Particle System should use to draw its particles.
            If this is not initializing a Sprite particle system, or you want the particle system to use its own Sprite Batch,
            pass in null.</param>
    </member>
    <member name="M:DPSF.IDPSFParticleSystem.SetCameraPosition(Microsoft.Xna.Framework.Vector3)">
      <summary>
            Sets the Camera Position of the particle system, so that the particles know how to make themselves face the camera if needed.
            This virtual function does not do anything unless overridden, and all it should do is set an internal Vector3 variable
            (e.g. public Vector3 CameraPosition { get; set; }) to match the given Vector3.
            </summary>
      <param name="cameraPosition">The position that the camera is currently at.</param>
    </member>
    <member name="P:DPSF.IDPSFParticleSystem.DeserializationTexturePath">
      <summary>
            The path used to load the Texture when the InitializeNonSerializableProperties() function is called.
            <para>NOTE: This is automatically set when the SetTexture() function is called.</para></summary>
    </member>
    <member name="P:DPSF.IDPSFParticleSystem.DeserializationEffectPath">
      <summary>
            The path used to load the Effect when the InitializeNonSerializableProperties() function is called.
            <para>NOTE: This is automatically set when the SetEffectAndTechnique(string, string) function is called. </para></summary>
    </member>
    <member name="P:DPSF.IDPSFParticleSystem.DeserializationTechniqueName">
      <summary>
            The Name of the Technique to use when the InitializeNonSerializableProperties() function is called.
            <para>NOTE: This is automatically set when the SetEffectAndTechnique() and SetTechnique() functions are called.</para></summary>
    </member>
    <member name="P:DPSF.IDPSFParticleSystem.Visible">
      <summary>
            Get / Set if this Particle System should Draw its Particles or not.
            <para>NOTE: Setting this to false causes the Draw() function to not draw anything.</para></summary>
    </member>
    <member name="P:DPSF.IDPSFParticleSystem.Enabled">
      <summary>
            Get / Set if this Particle System should Update itself and its Particles or not.
            <para>NOTE: Setting this to false causes the Update() function to not update anything.</para></summary>
    </member>
    <member name="P:DPSF.IDPSFParticleSystem.UpdateOrder">
      <summary>
            The Order in which the Particle System should be Updated relative to other 
            DPSF Particle Systems in the same Particle System Manager. Particle Systems 
            are Updated in ascending order according to their Update Order (i.e. lowest first).
            </summary>
    </member>
    <member name="P:DPSF.IDPSFParticleSystem.DrawOrder">
      <summary>
            The Order in which the Particle System should be Drawn relative to other
            DPSF Particle Systems in the same Particle System Manager. Particle Systems
            are Drawn in ascending order according to their Draw Order (i.e. lowest first)
            </summary>
    </member>
    <member name="P:DPSF.IDPSFParticleSystem.Game">
      <summary>
            Get the Game object set in the constructor, if one was given.
            </summary>
    </member>
    <member name="P:DPSF.IDPSFParticleSystem.GraphicsDevice">
      <summary>
            Get the Graphics Device to draw to
            </summary>
    </member>
    <member name="P:DPSF.IDPSFParticleSystem.InheritsDrawableGameComponent">
      <summary>
            Get if the Particle System is inheriting from DrawableGameComponent or not.
            <para>If inheriting from DrawableGameComponent, the Particle Systems
            are automatically added to the given Game object's Components and the
            Update() and Draw() functions are automatically called by the
            Game object when it updates and draws the rest of its Components.
            If the Update() and Draw() functions are called by the user anyways,
            they will exit without performing any operations, so it is suggested
            to include them anyways to make switching between inheriting and
            not inheriting from DrawableGameComponent seamless; just be aware
            that the updates and draws are actually being performed when the
            Game object is told to update and draw (i.e. when base.Update() and base.Draw()
            are called), not when these functions are being called.</para></summary>
    </member>
    <member name="P:DPSF.IDPSFParticleSystem.ID">
      <summary>
            Get the unique ID of this Particle System.
            <para>NOTE: Each Particle System is automatically assigned a unique ID when it is instantiated.</para></summary>
    </member>
    <member name="P:DPSF.IDPSFParticleSystem.Type">
      <summary>
            Get / Set the Type of Particle System this is.
            </summary>
    </member>
    <member name="P:DPSF.IDPSFParticleSystem.ClassName">
      <summary>
            Get the Name of the Class that this Particle System is using. This can be used to 
            check what type of Particle System this is at run-time.
            </summary>
    </member>
    <member name="P:DPSF.IDPSFParticleSystem.ContentManager">
      <summary>
            Get / Set the Content Manager to use to load Textures and Effects.
            </summary>
    </member>
    <member name="P:DPSF.IDPSFParticleSystem.RenderProperties">
      <summary>
            Get the render properties used to draw the particles.
            </summary>
    </member>
    <member name="P:DPSF.IDPSFParticleSystem.SpriteBatchSettings">
      <summary>
            The Sprite Batch drawing Settings used in the Sprite Batch's Begin() function call.
            <para>NOTE: These settings only have effect if this is a Sprite particle system.</para></summary>
    </member>
    <member name="P:DPSF.IDPSFParticleSystem.AutoMemoryManagerSettings">
      <summary>
            The Settings used to control the Automatic Memory Manager.
            </summary>
    </member>
    <member name="P:DPSF.IDPSFParticleSystem.Emitter">
      <summary>
            The Emitter is used to automatically generate new Particles.
            </summary>
    </member>
    <member name="P:DPSF.IDPSFParticleSystem.RandomNumber">
      <summary>
            Get a Random object used to generate Random Numbers.
            </summary>
    </member>
    <member name="P:DPSF.IDPSFParticleSystem.World">
      <summary>
            Get / Set the World Matrix to use for drawing 3D Particles.
            </summary>
    </member>
    <member name="P:DPSF.IDPSFParticleSystem.View">
      <summary>
            Get / Set the View Matrix to use for drawing 3D Particles.
            </summary>
    </member>
    <member name="P:DPSF.IDPSFParticleSystem.Projection">
      <summary>
            Get / Set the Projection Matrix to use for drawing 3D Particles.
            </summary>
    </member>
    <member name="P:DPSF.IDPSFParticleSystem.WorldViewProjection">
      <summary>
            Gets the result of multiplying the World, View, and Projection matrices.
            </summary>
    </member>
    <member name="P:DPSF.IDPSFParticleSystem.Effect">
      <summary>
            Get / Set the Effect to use to draw the Particles
            </summary>
    </member>
    <member name="P:DPSF.IDPSFParticleSystem.Technique">
      <summary>
            Get / Set which Technique of the current Effect to use to draw the Particles
            </summary>
    </member>
    <member name="P:DPSF.IDPSFParticleSystem.Texture">
      <summary>
            Get / Set the Texture to use to draw the Particles
            </summary>
    </member>
    <member name="P:DPSF.IDPSFParticleSystem.SimulationSpeed">
      <summary>
            Get / Set how fast the Particle System Simulation should run.
            <para>1.0 = normal speed, 0.5 = half speed, 2.0 = double speed.</para><para>NOTE: If a negative value is specified, the Speed Scale is set 
            to zero (pauses the simulation; has same effect as Enabled = false).</para></summary>
    </member>
    <member name="P:DPSF.IDPSFParticleSystem.InternalSimulationSpeed">
      <summary>
            Get / Set how fast the Particle System Simulation should run to look "normal".
            <para>1.0 = normal speed, 0.5 = half speed, 2.0 = double speed.</para><para>This is provided as a way of speeding up / slowing down the simulation to have 
            it look as desired, without having to rescale all of the particle velocities, etc.</para><para>NOTE: If a negative value is specified, the Internal Simulation Speed is set to zero 
            (pauses the simulation; has the same effect as Enabled = false).</para></summary>
    </member>
    <member name="P:DPSF.IDPSFParticleSystem.UpdatesPerSecond">
      <summary>
            Specify how often the Particle System should be Updated.
            <para>NOTE: Specifying a value of zero (default) will cause the Particle 
            System to be Updated every time the Update() function is called 
            (i.e. as often as possible).</para><para>NOTE: If the Update() function is not called often enough to
            keep up with this specified Update rate, the Update function
            updates the Particle Systems as often as possible.</para></summary>
    </member>
    <member name="P:DPSF.IDPSFParticleSystem.ParticleSystemManagerToCopyPropertiesFrom">
      <summary>
            The Particle System Manager whose properties (SimulationSpeed and 
            UpdatesPerSecond) this particle system should follow.
            <para>NOTE: This Particle System's properties will only clone the Manager's properties
            if the Manager's properties are Enabled. For example, the Manager's SimulationSpeed
            will only be copied to this Particle System if the Manager's SimulationSpeedIsEnabled
            property is true.</para><para>NOTE: This value is automatically set to the last Particle System Manager this 
            Particle System is added to.</para></summary>
    </member>
    <member name="P:DPSF.IDPSFParticleSystem.ParticleType">
      <summary>
            Get the type of Particles that this Particle System should draw.
            </summary>
    </member>
    <member name="P:DPSF.IDPSFParticleSystem.NumberOfParticlesAllocatedInMemory">
      <summary>
            Get / Set the absolute Number of Particles to Allocate Memory for.
            <para>NOTE: This value must be greater than or equal to zero.</para><para>NOTE: Even if this many particles aren't used, the space for this many Particles 
            is still allocated in memory.</para></summary>
    </member>
    <member name="P:DPSF.IDPSFParticleSystem.MaxNumberOfParticlesAllowed">
      <summary>
            Get / Set the Max Number of Particles this Particle System is Allowed to contain at any given time.
            <para>NOTE: The Automatic Memory Manager will never allocate space for more Particles than this.</para><para>NOTE: This value must be greater than or equal to zero.</para></summary>
    </member>
    <member name="P:DPSF.IDPSFParticleSystem.NumberOfActiveParticles">
      <summary>
            Get the number of Particles that are currently Active
            </summary>
    </member>
    <member name="P:DPSF.IDPSFParticleSystem.NumberOfParticlesBeingDrawn">
      <summary>
            Get the number of Particles being Drawn. That is, how many Particles 
            are both Active AND Visible.
            </summary>
    </member>
    <member name="P:DPSF.IDPSFParticleSystem.NumberOfParticlesStillPossibleToAdd">
      <summary>
            Get the number of Particles that may still be added before reaching the
            Max Number Of Particles Allowed. If the Max Number Of Particles Allowed is 
            greater than the Number Of Particles Allocated In Memory AND the Auto Memory Manager is
            set to not increase the amount of Allocated Memory, than this returns the number 
            of Particles that may still be added before running out of Memory.
            </summary>
    </member>
    <member name="E:DPSF.IDPSFParticleSystem.UpdateOrderChanged">
      <summary>
            Event Handler that is raised when the UpdateOrder of the Particle System is changed
            </summary>
    </member>
    <member name="E:DPSF.IDPSFParticleSystem.DrawOrderChanged">
      <summary>
            Event Handler that is raised when the DrawOrder of the Particle System is changed
            </summary>
    </member>
    <member name="E:DPSF.IDPSFParticleSystem.EnabledChanged">
      <summary>
            Event Handler that is raised when the Enabled status of the Particle System is changed
            </summary>
    </member>
    <member name="E:DPSF.IDPSFParticleSystem.VisibleChanged">
      <summary>
            Event Handler that is raised when the Visible status of the Particle System is changed
            </summary>
    </member>
    <member name="T:DPSF.DPSF`2">
      <summary>
            The Base Particle System Framework Class.
            This class contains the methods and properties needed to keep track of, update, and draw Particles
            </summary>
      <typeparam name="Particle">The Particle class used to hold a particle's information. The Particle class
            specified must be or inherit from the DPSFParticle class</typeparam>
      <typeparam name="Vertex">The Particle Vertex struct used to hold a vertex's information used for drawing</typeparam>
    </member>
    <member name="T:DPSF.DPSF`2.UpdateParticleSystemDelegate">
      <summary>
            The function prototype that Particle System Events must follow
            </summary>
      <param name="fElapsedTimeInSeconds">How much time in seconds has elapsed since the last update</param>
    </member>
    <member name="T:DPSF.DPSF`2.UpdateParticleDelegate">
      <summary>
            The function prototype that the Particle Events must follow
            </summary>
      <param name="cParticle">The Particle to be updated</param>
      <param name="fElapsedTimeInSeconds">How much time in seconds has elapsed since the last update</param>
    </member>
    <member name="T:DPSF.DPSF`2.InitializeParticleDelegate">
      <summary>
            The function prototype that the Particle Initialization Functions must follow
            </summary>
      <param name="cParticle">The Particle to be initialized</param>
    </member>
    <member name="T:DPSF.DPSF`2.UpdateVertexDelegate">
      <summary>
            The function prototype that the Vertex Update Functions must follow
            </summary>
      <param name="sParticleVertexBuffer">The vertex buffer array</param>
      <param name="iIndexInVertexBuffer">The index in the vertex buffer that the Particle properties should be written to</param>
      <param name="cParticle">The Particle whose properties should be copied to the vertex buffer</param>
    </member>
    <member name="T:DPSF.DPSF`2.CParticleEvents">
      <summary>
            Class to hold all of the Particle Events
            </summary>
    </member>
    <member name="T:DPSF.DPSF`2.CParticleEvents.EParticleEventTypes">
      <summary>
            The Particle Event Types
            </summary>
    </member>
    <member name="T:DPSF.DPSF`2.CParticleEvents.CParticleEvent">
      <summary>
            Class to hold a Particle Event's information
            </summary>
    </member>
    <member name="M:DPSF.DPSF`2.CParticleEvents.CParticleEvent.Equals(System.Object)">
      <summary>
            Override the Equals method
            </summary>
    </member>
    <member name="M:DPSF.DPSF`2.CParticleEvents.CParticleEvent.GetHashCode">
      <summary>
            Override the GetHashCode method
            </summary>
    </member>
    <member name="T:DPSF.DPSF`2.CParticleEvents.CTimedParticleEvent">
      <summary>
            Class to hold a Timed Particle Event's information
            </summary>
    </member>
    <member name="M:DPSF.DPSF`2.CParticleEvents.CTimedParticleEvent.Equals(System.Object)">
      <summary>
            Override the Equals method
            </summary>
    </member>
    <member name="M:DPSF.DPSF`2.CParticleEvents.CTimedParticleEvent.GetHashCode">
      <summary>
            Override the GetHashCode method
            </summary>
    </member>
    <member name="M:DPSF.DPSF`2.CParticleEvents.RemoveEveryTimeEvents(System.Int32)">
      <summary>
            Removes all EveryTime Events in the specified Group.
            Returns the number of Events that were removed.
            </summary>
      <param name="iGroup">The Group to remove the EveryTime Events from</param>
      <returns>Returns the number of Events that were removed.</returns>
    </member>
    <member name="M:DPSF.DPSF`2.CParticleEvents.RemoveAllEveryTimeEvents">
      <summary>
            Removes all EveryTime Events.
            Returns the number of Events that were removed.
            </summary>
      <returns>Returns the number of Events that were removed.</returns>
    </member>
    <member name="M:DPSF.DPSF`2.CParticleEvents.RemoveOneTimeEvents(System.Int32)">
      <summary>
            Removes all OneTime Events in the specified Group.
            Returns the number of Events that were removed.
            </summary>
      <param name="iGroup">The Group to remove the OneTime Events from</param>
      <returns>Returns the number of Events that were removed.</returns>
    </member>
    <member name="M:DPSF.DPSF`2.CParticleEvents.RemoveAllOneTimeEvents">
      <summary>
            Removes all OneTime Events.
            Returns the number of Events that were removed.
            </summary>
      <returns>Returns the number of Events that were removed.</returns>
    </member>
    <member name="M:DPSF.DPSF`2.CParticleEvents.RemoveTimedEvents(System.Int32)">
      <summary>
            Removes all Timed Events in the specified Group.
            Returns the number of Events that were removed.
            </summary>
      <param name="iGroup">The Group to remove the Timed Events from</param>
      <returns>Returns the number of Events that were removed.</returns>
    </member>
    <member name="M:DPSF.DPSF`2.CParticleEvents.RemoveAllTimedEvents">
      <summary>
            Removes all Timed Events.
            Returns the number of Events that were removed.
            </summary>
      <returns>Returns the number of Events that were removed.</returns>
    </member>
    <member name="M:DPSF.DPSF`2.CParticleEvents.RemoveNormalizedTimedEvents(System.Int32)">
      <summary>
            Removes all Normalized Timed Events in the specified Group.
            Returns the number of Events that were removed.
            </summary>
      <param name="iGroup">The Group to remove the Normalized Timed Events from</param>
      <returns>Returns the number of Events that were removed.</returns>
    </member>
    <member name="M:DPSF.DPSF`2.CParticleEvents.RemoveAllNormalizedTimedEvents">
      <summary>
            Removes all Normalized Timed Events.
            Returns the number of Events that were removed.
            </summary>
      <returns>Returns the number of Events that were removed.</returns>
    </member>
    <member name="M:DPSF.DPSF`2.CParticleEvents.RemoveAllTimedAndNormalizedTimedEvents">
      <summary>
            Removes all Timed Events and Normalized Timed Events.
            Returns the number of Events that were removed.
            </summary>
      <returns>Returns the number of Events that were removed.</returns>
    </member>
    <member name="M:DPSF.DPSF`2.CParticleEvents.RemoveAllEvents">
      <summary>
            Removes all Events.
            Returns the number of Events that were removed.
            </summary>
      <returns>Returns the number of Events that were removed.</returns>
    </member>
    <member name="M:DPSF.DPSF`2.CParticleEvents.RemoveAllEventsInGroup(System.Int32)">
      <summary>
            Removes all Events in the specified Group.
            Returns the number of Events that were removed.
            </summary>
      <param name="iGroup">The Group to remove all Events from</param>
      <returns>Returns the number of Events that were removed.</returns>
    </member>
    <member name="T:DPSF.DPSF`2.CParticleSystemEvents">
      <summary>
            Class to hold all of the Particle System Events and related info
            </summary>
    </member>
    <member name="T:DPSF.DPSF`2.CParticleSystemEvents.EParticleSystemEventTypes">
      <summary>
            The Particle System Event Types
            </summary>
    </member>
    <member name="T:DPSF.DPSF`2.CParticleSystemEvents.CParticleSystemEvent">
      <summary>
            Class to hold a Particle System Event's information
            </summary>
    </member>
    <member name="M:DPSF.DPSF`2.CParticleSystemEvents.CParticleSystemEvent.Equals(System.Object)">
      <summary>
            Override the Equals method
            </summary>
    </member>
    <member name="M:DPSF.DPSF`2.CParticleSystemEvents.CParticleSystemEvent.GetHashCode">
      <summary>
            Override the GetHashCode method
            </summary>
    </member>
    <member name="T:DPSF.DPSF`2.CParticleSystemEvents.CTimedParticleSystemEvent">
      <summary>
            Class to hold a Timed Particle System Event's information
            </summary>
    </member>
    <member name="M:DPSF.DPSF`2.CParticleSystemEvents.CTimedParticleSystemEvent.Equals(System.Object)">
      <summary>
            Override the Equals method
            </summary>
    </member>
    <member name="M:DPSF.DPSF`2.CParticleSystemEvents.CTimedParticleSystemEvent.GetHashCode">
      <summary>
            Override the GetHashCode method
            </summary>
    </member>
    <member name="T:DPSF.DPSF`2.CParticleSystemEvents.EParticleSystemEndOfLifeOptions">
      <summary>
            The Options of what should happen when the Particle System reaches the end of its Lifetime
            </summary>
    </member>
    <member name="T:DPSF.DPSF`2.CParticleSystemEvents.CParticleSystemLifetimeData">
      <summary>
            Class to hold the Lifetime information of the Particle System
            </summary>
    </member>
    <member name="M:DPSF.DPSF`2.CParticleSystemEvents.CParticleSystemLifetimeData.Reset">
      <summary>
            Resets the class variables to their default values
            </summary>
    </member>
    <member name="M:DPSF.DPSF`2.CParticleSystemEvents.CParticleSystemLifetimeData.CopyFrom(DPSF.DPSFParticle)">
      <summary>
            Deep copy the ParticleToCopy's values into this Particle
            </summary>
      <param name="ParticleToCopy">The Particle whose values should be Copied</param>
    </member>
    <member name="P:DPSF.DPSF`2.CParticleSystemEvents.CParticleSystemLifetimeData.EndOfLifeOption">
      <summary>
            Get / Set what should happen when the Particle System reaches the end of its Lifetime
            </summary>
    </member>
    <member name="M:DPSF.DPSF`2.CParticleSystemEvents.RemoveEveryTimeEvents(System.Int32)">
      <summary>
            Removes all EveryTime Events in the specified Group.
            Returns the number of Events that were removed.
            </summary>
      <param name="iGroup">The Group to remove the EveryTime Events from</param>
      <returns>Returns the number of Events that were removed.</returns>
    </member>
    <member name="M:DPSF.DPSF`2.CParticleSystemEvents.RemoveAllEveryTimeEvents">
      <summary>
            Removes all EveryTime Events.
            Returns the number of Events that were removed.
            </summary>
      <returns>Returns the number of Events that were removed.</returns>
    </member>
    <member name="M:DPSF.DPSF`2.CParticleSystemEvents.RemoveOneTimeEvents(System.Int32)">
      <summary>
            Removes all OneTime Events in the specified Group.
            Returns the number of Events that were removed.
            </summary>
      <param name="iGroup">The Group to remove the OneTime Events from</param>
      <returns>Returns the number of Events that were removed.</returns>
    </member>
    <member name="M:DPSF.DPSF`2.CParticleSystemEvents.RemoveAllOneTimeEvents">
      <summary>
            Removes all OneTime Events.
            Returns the number of Events that were removed.
            </summary>
      <returns>Returns the number of Events that were removed.</returns>
    </member>
    <member name="M:DPSF.DPSF`2.CParticleSystemEvents.RemoveTimedEvents(System.Int32)">
      <summary>
            Removes all Timed Events in the specified Group.
            Returns the number of Events that were removed.
            </summary>
      <param name="iGroup">The Group to remove the Timed Events from</param>
      <returns>Returns the number of Events that were removed.</returns>
    </member>
    <member name="M:DPSF.DPSF`2.CParticleSystemEvents.RemoveAllTimedEvents">
      <summary>
            Removes all Timed Events.
            Returns the number of Events that were removed.
            </summary>
      <returns>Returns the number of Events that were removed.</returns>
    </member>
    <member name="M:DPSF.DPSF`2.CParticleSystemEvents.RemoveNormalizedTimedEvents(System.Int32)">
      <summary>
            Removes all Normalized Timed Events in the specified Group.
            Returns the number of Events that were removed.
            </summary>
      <param name="iGroup">The Group to remove the Normalized Timed Events from</param>
      <returns>Returns the number of Events that were removed.</returns>
    </member>
    <member name="M:DPSF.DPSF`2.CParticleSystemEvents.RemoveAllNormalizedTimedEvents">
      <summary>
            Removes all Normalized Timed Events.
            Returns the number of Events that were removed.
            </summary>
      <returns>Returns the number of Events that were removed.</returns>
    </member>
    <member name="M:DPSF.DPSF`2.CParticleSystemEvents.RemoveAllTimedAndNormalizedTimedEvents">
      <summary>
            Removes all Timed Events and Normalized Timed Events.
            Returns the number of Events that were removed.
            </summary>
      <returns>Returns the number of Events that were removed.</returns>
    </member>
    <member name="M:DPSF.DPSF`2.CParticleSystemEvents.RemoveAllEvents">
      <summary>
            Removes all Events.
            Returns the number of Events that were removed.
            </summary>
      <returns>Returns the number of Events that were removed.</returns>
    </member>
    <member name="M:DPSF.DPSF`2.CParticleSystemEvents.RemoveAllEventsInGroup(System.Int32)">
      <summary>
            Removes all Events in the specified Group.
            Returns the number of Events that were removed.
            </summary>
      <param name="iGroup">The Group to remove all Events from</param>
      <returns>Returns the number of Events that were removed.</returns>
    </member>
    <member name="M:DPSF.DPSF`2.CParticleSystemEvents.Update(System.Single)">
      <summary>
            Updates the Particle System according to the Particle System Events. This is done automatically
            by the Particle System every frame (i.e. Everytime the Update() function is called).
            </summary>
      <param name="fElapsedTimeInSeconds">How much Time has passed, in seconds, 
            since the last Update</param>
    </member>
    <member name="M:DPSF.DPSF`2.CParticleSystemEvents.Update(System.Single,System.Single)">
      <summary>
            Updates the Particle System according to the Particle System Events
            </summary>
      <param name="fElapsedTimeThisPass">The amount of Elapsed Time to pass
            into the Event Functions being called on this Pass</param>
      <param name="fTotalElapsedTimeThisFrame">How much Time has passed, in seconds, 
            since the last Frame</param>
    </member>
    <member name="P:DPSF.DPSF`2.CParticleSystemEvents.LifetimeData">
      <summary>
            Get / Set the Lifetime information of the Particle System
            </summary>
    </member>
    <member name="F:DPSF.DPSF`2._totalNumberOfParticleSystemsCreated">
      <summary>
            A static int used to keep track of the total number of Particle Systems created
            </summary>
    </member>
    <member name="F:DPSF.DPSF`2._numberOfParticleSystemsCurrentlyInitialized">
      <summary>
            A static int used to keep track of how many DPSF particle systems are initialized at any given moment.
            </summary>
    </member>
    <member name="M:DPSF.DPSF`2.#ctor(Microsoft.Xna.Framework.Game)">
      <summary>
            Constructor
            </summary>
      <param name="cGame">Handle to the Game object being used. Pass in null for this 
            parameter if not using a Game object.</param>
    </member>
    <member name="M:DPSF.DPSF`2.InitializeNoDisplayParticleSystem(System.Int32,System.Int32)">
      <summary>
            Initializes a new No Display Particle System. This type of Particle System does not allow any of the Particles
            to be drawn to a Graphics Device (e.g. the screen).
            </summary>
      <param name="iNumberOfParticlesToAllocateMemoryFor">The Number of Particles memory should
            be Allocated for. If the Auto Memory Manager is enabled (default), this will be dynamically adjusted at
            run-time to make sure there is always roughly as much Memory Allocated as there are Particles. This value
            may also be adjusted manually at run-time.</param>
      <param name="iMaxNumberOfParticlesToAllow">The Maximum Number of Active Particles that are
            Allowed at a single point in time. If the Auto Memory Manager will not be enabled to increase
            memory, this should be less than or equal to the Number Of Particles To Allocate Memory For, 
            as the Particle System can only handle as many Particles as it has Memory Allocated For. Also, the
            Auto Memory Manager will never increase the Allocated Memory to handle more Particles than this value. 
            If this is set to a value lower than the Number Of Particles To Allocate Memory For, then only this many
            Particles will be allowed, even though there is memory allocated for more Particles. This value 
            may also be adjusted manually at run-time.</param>
    </member>
    <member name="M:DPSF.DPSF`2.InitializeSpriteParticleSystem(Microsoft.Xna.Framework.Graphics.GraphicsDevice,Microsoft.Xna.Framework.Content.ContentManager,System.Int32,System.Int32,System.String)">
      <summary>
            Initializes a new Sprite Particle System
            </summary>
      <param name="cGraphicsDevice">Graphics Device to draw to</param>
      <param name="cContentManager">Content Manager used to load Effect files and Textures</param>
      <param name="iNumberOfParticlesToAllocateMemoryFor">The Number of Particles memory should
            be Allocated for. If the Auto Memory Manager is enabled (default), this will be dynamically adjusted at
            run-time to make sure there is always roughly as much Memory Allocated as there are Particles. This value
            may also be adjusted manually at run-time.</param>
      <param name="iMaxNumberOfParticlesToAllow">The Maximum Number of Active Particles that are
            Allowed at a single point in time. If the Auto Memory Manager will not be enabled to increase
            memory, this should be less than or equal to the Number Of Particles To Allocate Memory For, 
            as the Particle System can only handle as many Particles as it has Memory Allocated For. Also, the
            Auto Memory Manager will never increase the Allocated Memory to handle more Particles than this value. 
            If this is set to a value lower than the Number Of Particles To Allocate Memory For, then only this many
            Particles will be allowed, even though there is memory allocated for more Particles. This value 
            may also be adjusted manually at run-time.</param>
      <param name="sTexture">The asset name of the Texture to use to visualize the Particles</param>
    </member>
    <member name="M:DPSF.DPSF`2.InitializeSpriteParticleSystem(Microsoft.Xna.Framework.Graphics.GraphicsDevice,Microsoft.Xna.Framework.Content.ContentManager,System.Int32,System.Int32,System.String,Microsoft.Xna.Framework.Graphics.SpriteBatch)">
      <summary>
            Initializes a new Sprite Particle System
            </summary>
      <param name="cGraphicsDevice">Graphics Device to draw to</param>
      <param name="cContentManager">Content Manager used to load Effect files and Textures</param>
      <param name="iNumberOfParticlesToAllocateMemoryFor">The Number of Particles memory should
            be Allocated for. If the Auto Memory Manager is enabled (default), this will be dynamically adjusted at
            run-time to make sure there is always roughly as much Memory Allocated as there are Particles. This value
            may also be adjusted manually at run-time.</param>
      <param name="iMaxNumberOfParticlesToAllow">The Maximum Number of Active Particles that are
            Allowed at a single point in time. If the Auto Memory Manager will not be enabled to increase
            memory, this should be less than or equal to the Number Of Particles To Allocate Memory For, 
            as the Particle System can only handle as many Particles as it has Memory Allocated For. Also, the
            Auto Memory Manager will never increase the Allocated Memory to handle more Particles than this value. 
            If this is set to a value lower than the Number Of Particles To Allocate Memory For, then only this many
            Particles will be allowed, even though there is memory allocated for more Particles. This value 
            may also be adjusted manually at run-time.</param>
      <param name="sTexture">The asset name of the Texture to use to visualize the Particles</param>
      <param name="cSpriteBatchToDrawWith">The Sprite Batch that this particle system should use to draw its
            particles with.
            <para>If null, the particle system will use its own SpriteBatch to draw its particles.</para><para>If not null, then you must call SpriteBatch.Begin() before calling ParticleSystem.Draw() to
            draw the particle system, and then call SpriteBatch.End() when done drawing the particle system.</para></param>
    </member>
    <member name="M:DPSF.DPSF`2.InitializeSpriteParticleSystem(Microsoft.Xna.Framework.Graphics.GraphicsDevice,Microsoft.Xna.Framework.Content.ContentManager,System.Int32,System.Int32,Microsoft.Xna.Framework.Graphics.Texture2D)">
      <summary>
            Initializes a new Sprite Particle System
            </summary>
      <param name="cGraphicsDevice">Graphics Device to draw to</param>
      <param name="cContentManager">Content Manager used to load Effect files and Textures</param>
      <param name="iNumberOfParticlesToAllocateMemoryFor">The Number of Particles memory should
            be Allocated for. If the Auto Memory Manager is enabled (default), this will be dynamically adjusted at
            run-time to make sure there is always roughly as much Memory Allocated as there are Particles. This value
            may also be adjusted manually at run-time.</param>
      <param name="iMaxNumberOfParticlesToAllow">The Maximum Number of Active Particles that are
            Allowed at a single point in time. If the Auto Memory Manager will not be enabled to increase
            memory, this should be less than or equal to the Number Of Particles To Allocate Memory For, 
            as the Particle System can only handle as many Particles as it has Memory Allocated For. Also, the
            Auto Memory Manager will never increase the Allocated Memory to handle more Particles than this value. 
            If this is set to a value lower than the Number Of Particles To Allocate Memory For, then only this many
            Particles will be allowed, even though there is memory allocated for more Particles. This value 
            may also be adjusted manually at run-time.</param>
      <param name="cTexture">The Texture to use to visualize the Particles</param>
    </member>
    <member name="M:DPSF.DPSF`2.InitializeSpriteParticleSystem(Microsoft.Xna.Framework.Graphics.GraphicsDevice,Microsoft.Xna.Framework.Content.ContentManager,System.Int32,System.Int32,Microsoft.Xna.Framework.Graphics.Texture2D,Microsoft.Xna.Framework.Graphics.SpriteBatch)">
      <summary>
            Initializes a new Sprite Particle System
            </summary>
      <param name="cGraphicsDevice">Graphics Device to draw to</param>
      <param name="cContentManager">Content Manager used to load Effect files and Textures</param>
      <param name="iNumberOfParticlesToAllocateMemoryFor">The Number of Particles memory should
            be Allocated for. If the Auto Memory Manager is enabled (default), this will be dynamically adjusted at
            run-time to make sure there is always roughly as much Memory Allocated as there are Particles. This value
            may also be adjusted manually at run-time.</param>
      <param name="iMaxNumberOfParticlesToAllow">The Maximum Number of Active Particles that are
            Allowed at a single point in time. If the Auto Memory Manager will not be enabled to increase
            memory, this should be less than or equal to the Number Of Particles To Allocate Memory For, 
            as the Particle System can only handle as many Particles as it has Memory Allocated For. Also, the
            Auto Memory Manager will never increase the Allocated Memory to handle more Particles than this value. 
            If this is set to a value lower than the Number Of Particles To Allocate Memory For, then only this many
            Particles will be allowed, even though there is memory allocated for more Particles. This value 
            may also be adjusted manually at run-time.</param>
      <param name="cTexture">The Texture to use to visualize the Particles</param>
      <param name="cSpriteBatchToDrawWith">The Sprite Batch that this particle system should use to draw its
            particles with.
            <para>If null, the particle system will use its own SpriteBatch to draw its particles.</para><para>If not null, then you must call SpriteBatch.Begin() before calling ParticleSystem.Draw() to
            draw the particle system, and then call SpriteBatch.End() when done drawing the particle system.</para></param>
    </member>
    <member name="M:DPSF.DPSF`2.InitializeQuadParticleSystem(Microsoft.Xna.Framework.Graphics.GraphicsDevice,Microsoft.Xna.Framework.Content.ContentManager,System.Int32,System.Int32,DPSF.DPSF{`0,`1}.UpdateVertexDelegate)">
      <summary>
            Initializes a new Quad Particle System
            </summary>
      <param name="cGraphicsDevice">Graphics Device to draw to</param>
      <param name="cContentManager">Content Manager used to load Effect files and Textures</param>
      <param name="iNumberOfParticlesToAllocateMemoryFor">The Number of Particles memory should
            be Allocated for. If the Auto Memory Manager is enabled (default), this will be dynamically adjusted at
            run-time to make sure there is always roughly as much Memory Allocated as there are Particles. This value
            may also be adjusted manually at run-time.</param>
      <param name="iMaxNumberOfParticlesToAllow">The Maximum Number of Active Particles that are
            Allowed at a single point in time. If the Auto Memory Manager will not be enabled to increase
            memory, this should be less than or equal to the Number Of Particles To Allocate Memory For, 
            as the Particle System can only handle as many Particles as it has Memory Allocated For. Also, the
            Auto Memory Manager will never increase the Allocated Memory to handle more Particles than this value. 
            If this is set to a value lower than the Number Of Particles To Allocate Memory For, then only this many
            Particles will be allowed, even though there is memory allocated for more Particles. This value 
            may also be adjusted manually at run-time.</param>
      <param name="cVertexUpdateFunction">Function used to copy a Particle's drawable properties into the vertex buffer</param>
    </member>
    <member name="M:DPSF.DPSF`2.InitializeTexturedQuadParticleSystem(Microsoft.Xna.Framework.Graphics.GraphicsDevice,Microsoft.Xna.Framework.Content.ContentManager,System.Int32,System.Int32,DPSF.DPSF{`0,`1}.UpdateVertexDelegate,System.String)">
      <summary>
            Initializes a new Textured Quad Particle System
            </summary>
      <param name="cGraphicsDevice">Graphics Device to draw to</param>
      <param name="cContentManager">Content Manager used to load Effect files and Textures</param>
      <param name="iNumberOfParticlesToAllocateMemoryFor">The Number of Particles memory should
            be Allocated for. If the Auto Memory Manager is enabled (default), this will be dynamically adjusted at
            run-time to make sure there is always roughly as much Memory Allocated as there are Particles. This value
            may also be adjusted manually at run-time.</param>
      <param name="iMaxNumberOfParticlesToAllow">The Maximum Number of Active Particles that are
            Allowed at a single point in time. If the Auto Memory Manager will not be enabled to increase
            memory, this should be less than or equal to the Number Of Particles To Allocate Memory For, 
            as the Particle System can only handle as many Particles as it has Memory Allocated For. Also, the
            Auto Memory Manager will never increase the Allocated Memory to handle more Particles than this value. 
            If this is set to a value lower than the Number Of Particles To Allocate Memory For, then only this many
            Particles will be allowed, even though there is memory allocated for more Particles. This value 
            may also be adjusted manually at run-time.</param>
      <param name="cVertexUpdateFunction">Function used to copy a Particle's drawable properties into the vertex buffer</param>
      <param name="sTexture">The asset name of the Texture to use to visualize the Particles</param>
    </member>
    <member name="M:DPSF.DPSF`2.InitializeTexturedQuadParticleSystem(Microsoft.Xna.Framework.Graphics.GraphicsDevice,Microsoft.Xna.Framework.Content.ContentManager,System.Int32,System.Int32,DPSF.DPSF{`0,`1}.UpdateVertexDelegate,Microsoft.Xna.Framework.Graphics.Texture2D)">
      <summary>
            Initializes a new Textured Quad Particle System
            </summary>
      <param name="cGraphicsDevice">Graphics Device to draw to</param>
      <param name="cContentManager">Content Manager used to load Effect files and Textures</param>
      <param name="iNumberOfParticlesToAllocateMemoryFor">The Number of Particles memory should
            be Allocated for. If the Auto Memory Manager is enabled (default), this will be dynamically adjusted at
            run-time to make sure there is always roughly as much Memory Allocated as there are Particles. This value
            may also be adjusted manually at run-time.</param>
      <param name="iMaxNumberOfParticlesToAllow">The Maximum Number of Active Particles that are
            Allowed at a single point in time. If the Auto Memory Manager will not be enabled to increase
            memory, this should be less than or equal to the Number Of Particles To Allocate Memory For, 
            as the Particle System can only handle as many Particles as it has Memory Allocated For. Also, the
            Auto Memory Manager will never increase the Allocated Memory to handle more Particles than this value. 
            If this is set to a value lower than the Number Of Particles To Allocate Memory For, then only this many
            Particles will be allowed, even though there is memory allocated for more Particles. This value 
            may also be adjusted manually at run-time.</param>
      <param name="cVertexUpdateFunction">Function used to copy a Particle's drawable properties into the vertex buffer</param>
      <param name="cTexture">The Texture to use to visualize the Particles</param>
    </member>
    <member name="M:DPSF.DPSF`2.InitializeCommonVariables(Microsoft.Xna.Framework.Graphics.GraphicsDevice,Microsoft.Xna.Framework.Content.ContentManager,System.Int32,System.Int32,DPSF.ParticleTypes)">
      <summary>
            Initialize the variables common to all Particle Systems
            </summary>
      <param name="cGraphicsDevice">Graphics Device to draw to</param>
      <param name="cContentManager">Content Manager to use to load Effect files and Textures</param>
      <param name="iNumberOfParticlesToAllocateMemoryFor">The Number of Particles memory should
            be Allocated for. The Maximum Number Of Particles the Particle System should Allow is also
            set to this value initially.</param>
      <param name="iMaxNumberOfParticlesToAllow">The Maximum Number of Active Particles that are
            Allowed at a single point in time. This should be less than or equal to the Number Of Particles 
            To Allocate Memory For if the Auto Memory Manager will not be used, as the Particle System 
            can only handle as many Particles as it has Memory Allocated For.</param>
      <param name="eParticleType">The Type of Particles this Particle System should draw</param>
    </member>
    <member name="M:DPSF.DPSF`2.Destroy">
      <summary>
            Release all resources used by the Particle System and reset all properties to their default values
            </summary>
    </member>
    <member name="M:DPSF.DPSF`2.SetGraphicsDevice(Microsoft.Xna.Framework.Graphics.GraphicsDevice)">
      <summary>
            Sets the Graphics Device to use to the given graphics device.
            <para>NOTE: This only has an effect if the particle system does not inherit from DrawableGameComponent
            (i.e. InheritsDrawableGameComponent == false. i.e. using the DPSF.dll, not DPSFAsDrawableGameComponent.dll), since 
            the Graphics Device is read-only when inheriting from DrawableGameComponent. The Game object's Graphics Device
            is always used when inheriting from DrawableGameComponent.</para></summary>
      <param name="graphicsDevice">The graphics device to use.</param>
    </member>
    <member name="M:DPSF.DPSF`2.SetWorldViewProjectionMatrices(Microsoft.Xna.Framework.Matrix,Microsoft.Xna.Framework.Matrix,Microsoft.Xna.Framework.Matrix)">
      <summary>
            Set the World, View, and Projection matrices for this Particle System.
            <para>NOTE: Sprite particle systems are not affected by the World, View, and Projection matrices.</para></summary>
      <param name="cWorld">The World matrix</param>
      <param name="cView">The View matrix</param>
      <param name="cProjection">The Projection matrix</param>
    </member>
    <member name="M:DPSF.DPSF`2.SetVertexDeclaration(System.Int32,Microsoft.Xna.Framework.Graphics.VertexElement[])">
      <summary>
            Sets the vertex elements to use for each vertex of a particle.
            </summary>
      <param name="numberOfBytesPerVertex">The number of bytes per vertex.</param>
      <param name="elements">The vertex elements that make up the vertex.</param>
    </member>
    <member name="M:DPSF.DPSF`2.SetDefaultEffectAndTechnique">
      <summary>
            Sets the Effect to be the DPSFDefaultEffect, and the Technique to be the default technique for this type of particle system.
            This is done automatically when the particle system is initialized.
            </summary>
    </member>
    <member name="M:DPSF.DPSF`2.SetEffectAndTechnique(System.String,System.String)">
      <summary>
            Sets the Effect and Technique to use to draw the Particles.
            <para>NOTE: This will automatically set the DeserializationEffectPath property to the given sEffect.</para><para>NOTE: This will automatically set the DeserializationTechniqueName property to the given sTechnique.</para></summary>
      <param name="sEffect">The Asset Name of the Effect to use</param>
      <param name="sTechnique">The name of the Effect's Technique to use</param>
    </member>
    <member name="M:DPSF.DPSF`2.SetEffectAndTechnique(Microsoft.Xna.Framework.Graphics.Effect,System.String)">
      <summary>
            Sets the Effect and Technique to use to draw the Particles.
            <para>NOTE: This will automatically set the DeserializationTechniqueName property to the given sTechnique.</para></summary>
      <param name="cEffect">The Effect to use</param>
      <param name="sTechnique">The name of the Effect's Technique to use</param>
    </member>
    <member name="M:DPSF.DPSF`2.SetTechnique(System.String)">
      <summary>
            Set which Technique of the current Effect to use to draw the Particles.
            <para>NOTE: This will automatically set the DeserializationTechniqueName property to the given sTechnique.</para></summary>
      <param name="sTechnique">The name of the Effect's Technique to use</param>
    </member>
    <member name="M:DPSF.DPSF`2.SetTexture(System.String)">
      <summary>
            Set the Texture to use to draw the Particles
            </summary>
      <param name="sTexture">The Asset Name of the texture file to use (found in
            the XNA Properties of the file)</param>
    </member>
    <member name="M:DPSF.DPSF`2.InitializeParticleArrays">
      <summary>
            This allocates the proper amount of space for the Particles and initializes the variables used to draw the Type of Particles specified. 
            For example, if using Textured Quads extra space will need to be allocated to hold the Particles, as each Quad Particle requires four 
            vertices, not one like Point Sprites. Also, the Index Buffer would be initialized, as it is required to draw Quads.
            </summary>
    </member>
    <member name="M:DPSF.DPSF`2.InitializeParticle(`0)">
      <summary>
            Initialize the given Particle using the current Initialization Function
            </summary>
      <param name="cParticle">The Particle to Initialize</param>
    </member>
    <member name="M:DPSF.DPSF`2.AddParticle">
      <summary>
            Adds a new Particle to the particle system, at the start of the Active Particle List. 
            This new Particle is initialized using the particle system's Particle Initialization Function
            </summary>
      <returns>True if a particle was added, False if there is not enough memory for another Particle</returns>
    </member>
    <member name="M:DPSF.DPSF`2.AddParticle(`0)">
      <summary>
            Adds a new Particle to the particle system, at the start of the Active Particle List. Returns true if
            the Particle was added, false if there is not enough memory for another Particle.
            </summary>
      <param name="cParticleToCopy">The Particle to add to the Particle System. If this is null then a
            new Particle is initialized using the particle system's Particle Initialization Function</param>
      <returns>True if a particle was added, False if there is not enough memory for another Particle</returns>
    </member>
    <member name="M:DPSF.DPSF`2.AddParticles(System.Int32)">
      <summary>
            Adds the specified number of new Particles to the particle system. 
            These new Particles are initialized using the particle systems Particle Initialization Function
            </summary>
      <param name="iNumberOfParticlesToAdd">How many Particles to Add to the particle system</param>
      <returns>Returns how many Particles were able to be added to the particle system</returns>
    </member>
    <member name="M:DPSF.DPSF`2.AddParticles(System.Int32,`0)">
      <summary>
            Adds the specified number of new Particles to the particle system, copying the 
            properties of the given Particle To Copy
            </summary>
      <param name="iNumberOfParticlesToAdd">How many copyies of the Particle To Copy to Add 
            to the particle system</param>
      <param name="cParticleToCopy">The Particle to copy from when Adding the Particles to the 
            Particle System. If this is null then the new Particles will be initialized using the 
            particle system's Particle Initialization Function</param>
      <returns>Returns how many Particles were able to be added to the particle system</returns>
    </member>
    <member name="M:DPSF.DPSF`2.RemoveAllParticles">
      <summary>
            Removes all Active Particles from the Active Particle List and adds them 
            to the Inactive Particle List
            </summary>
    </member>
    <member name="M:DPSF.DPSF`2.Update(System.Single)">
      <summary>
            Updates the Particle System. This involves executing the Particle System
            Events, updating all Active Particles according to the Particle Events, and 
            adding new Particles according to the Emitter settings.
            <para>NOTE: This will only Update the Particle System if it does not inherit from DrawableGameComponent, 
            since if it does it will be updated automatically by the Game object.</para></summary>
      <param name="fElapsedTimeInSeconds">How much time in seconds has 
            elapsed since the last time this function was called</param>
    </member>
    <member name="M:DPSF.DPSF`2.UpdateForced(System.Single)">
      <summary>
            Updates the Particle System, even if the the Particle Systems inherits from DrawableGameComponent.
            <para>Updating the Particle System involves executing the Particle System Events, updating all Active 
            Particles according to the Particle Events, and adding new Particles according to the Emitter settings.</para><para>NOTE: If inheriting from DrawableGameComponent and this is called, the Particle System will be updated
            twice per frame; once when it is called here, and again when automatically called by the Game object.
            If not inheriting from DrawableGameComponent, this acts the same as calling Update().</para></summary>
      <param name="fElapsedTimeInSeconds">How much time in seconds has 
            elapsed since the last time this function was called</param>
    </member>
    <member name="M:DPSF.DPSF`2.Update(System.Single,System.Boolean)">
      <summary>
            Updates the Particle System. This involves executing the Particle System
            Events, updating all Active Particles according to the Particle Events, and 
            adding new Particles according to the Emitter's settings.
            </summary>
      <param name="fElapsedTimeInSeconds">How much time in seconds has 
            elapsed since the last time this function was called</param>
      <param name="bCalledByDrawableGameComponent">Indicates if this function was
            called manually by the user or called automatically by the Drawable Game Component.
            If this function Inherits Drawable Game Component, but was not called by
            Drawable Game Component, nothing will be updated since the Particle System will
            automatically be updated when the Game Component's Update() function is called.</param>
    </member>
    <member name="M:DPSF.DPSF`2.AddParticleToVertexBuffer(`0)">
      <summary>
            Adds the given Particle to the list of Particles to be Drawn (i.e. the Vertex Buffer), if it is Visible
            </summary>
      <param name="cParticle">The Particle to add to the Vertex Buffer</param>
    </member>
    <member name="M:DPSF.DPSF`2.Draw">
      <summary>
            Draws all of the Active Particles to the Graphics Device.
            <para>NOTE: This will only Draw the Particle System if it does not inherit from DrawableGameComponent, 
            since if it does it will be drawn automatically by the Game object.</para></summary>
    </member>
    <member name="M:DPSF.DPSF`2.DrawForced">
      <summary>
            Draws all of the Active Particles to the Graphics Device, even if the the Particle Systems inherits
            from DrawableGameComponent.
            <para>NOTE: If inheriting from DrawableGameComponent and this is called, the Particle System will be drawn
            twice per frame; once when it is called here, and again when automatically called by the Game object.
            If not inheriting from DrawableGameComponent, this acts the same as calling Draw().</para></summary>
    </member>
    <member name="M:DPSF.DPSF`2.Draw(System.Boolean)">
      <summary>
            Draws all of the Active Particles to the Graphics Device
            </summary>
      <param name="bCalledByDrawableGameComponent">Indicates if this function was
            called manually by the user or called automatically by the Drawable Game Component.
            If this function Inherits Drawable Game Component, but was not called by
            Drawable Game Component, nothing will be drawn since the Particle System will
            automatically be drawn when the Game Component's Draw() function is called.</param>
    </member>
    <member name="M:DPSF.DPSF`2.ClearRenderStates">
      <summary>
            Resets all of the Sampler States and Vertex Sampler States on the Graphics Device.
            This must be done before any rendering to prevent an XNA 4 bug that causes the graphics device
            to incorrectly track state information, which manifests itself as run-time errors.
            https://connect.microsoft.com/site226/feedback/details/586216/cloned-effect-?wa=wsignin1.0
            </summary>
    </member>
    <member name="M:DPSF.DPSF`2.ApplyRenderState">
      <summary>
            Applies the Particle System's Render State properties to the Graphics Device.
            </summary>
    </member>
    <member name="M:DPSF.DPSF`2.AutoInitialize(Microsoft.Xna.Framework.Graphics.GraphicsDevice,Microsoft.Xna.Framework.Content.ContentManager,Microsoft.Xna.Framework.Graphics.SpriteBatch)">
      <summary>
            Virtual function to Initialize the Particle System with default values.
            Particle system properties should not be set until after this is called, as 
            they are likely to be reset to their default values.
            </summary>
      <param name="cGraphicsDevice">The Graphics Device the Particle System should use</param>
      <param name="cContentManager">The Content Manager the Particle System should use to load resources</param>
      <param name="cSpriteBatch">The Sprite Batch that the Sprite Particle System should use to draw its particles.
            If this is not initializing a Sprite particle system, or you want the particle system to use its own Sprite Batch,
            pass in null.</param>
    </member>
    <member name="M:DPSF.DPSF`2.SetCameraPosition(Microsoft.Xna.Framework.Vector3)">
      <summary>
            Sets the Camera Position of the particle system, so that the particles know how to make themselves face the camera if needed.
            This virtual function does not do anything unless overridden, and all it should do is set an internal Vector3 variable
            (e.g. public Vector3 CameraPosition { get; set; }) to match the given Vector3.
            </summary>
      <param name="cameraPosition">The position that the camera is currently at.</param>
    </member>
    <member name="M:DPSF.DPSF`2.DrawSprite(DPSF.DPSFParticle,Microsoft.Xna.Framework.Graphics.SpriteBatch)">
      <summary>
            Virtual function to draw a Sprite Particle. This function should be used to draw the given
            Particle with the provided SpriteBatch.
            </summary>
      <param name="Particle">The Particle Sprite to Draw</param>
      <param name="cSpriteBatch">The SpriteBatch to use to doing the Drawing</param>
    </member>
    <member name="M:DPSF.DPSF`2.AfterInitialize">
      <summary>
            Virtual function that is called at the end of the Initialize() function.
            This may be used to perform operations after the Particle System has been Initialized, such as 
            initializing other Particle Systems nested within this Particle System.
            </summary>
    </member>
    <member name="M:DPSF.DPSF`2.BeforeDestroy">
      <summary>
            Virtual function that is called at the beginning of the Destroy() function.
            This may be used to perform operations before the Destroy() code is executed.
            </summary>
    </member>
    <member name="M:DPSF.DPSF`2.AfterDestroy">
      <summary>
            Virtual function that is called at the end of the Destroy() function.
            This may be used to perform operations after the Particle System has been Destroyed, such as 
            to destroy other Particle Systems nested within this Particle System.
            </summary>
    </member>
    <member name="M:DPSF.DPSF`2.BeforeUpdate(System.Single)">
      <summary>
            Virtual function that is called at the beginning of the Update() function.
            This may be used to perform operations before the Update() code is executed.
            </summary>
    </member>
    <member name="M:DPSF.DPSF`2.AfterUpdate(System.Single)">
      <summary>
            Virtual function that is called at the end of the Update() function.
            This may be used to perform operations after the Particle System has been updated, such as 
            to Update Particle Systems nested within this Particle System.
            </summary>
    </member>
    <member name="M:DPSF.DPSF`2.BeforeDraw">
      <summary>
            Virtual function that is called at the beginning of the Draw() function.
            This may be used to perform operations before the Draw() code is executed.
            </summary>
    </member>
    <member name="M:DPSF.DPSF`2.AfterDraw">
      <summary>
            Virtual function that is called at the end of the Draw() function.
            This may be used to perform operations after the Particle System has been drawn, such as 
            to Draw Particle Systems nested within this Particle System.
            </summary>
    </member>
    <member name="M:DPSF.DPSF`2.BeforeAddParticle">
      <summary>
            Virtual function that is called at the beginning of the AddParticle() function.
            This may be used to execute some code before a new Particle is initialized and added.
            </summary>
    </member>
    <member name="M:DPSF.DPSF`2.AfterAddParticle">
      <summary>
            Virtual function that is called at the end of the AddParticle() function.
            This may be used to execute some code after a new Particle is initialized and added.
            </summary>
    </member>
    <member name="M:DPSF.DPSF`2.InitializeRenderProperties">
      <summary>
            Virtual function to setup the Render Properties (i.e. BlendState, DepthStencilState, RasterizerState, and SamplerState)
            which will be applied to the Graphics Device before drawing the Particle System's Particles.
            <para>This function is called when initializing the particle system.</para></summary>
    </member>
    <member name="M:DPSF.DPSF`2.SetEffectParameters">
      <summary>
            Virtual function to Set the Effect's Parameters before drawing the Particles.
            </summary>
    </member>
    <member name="P:DPSF.DPSF`2.DeserializationTexturePath">
      <summary>
            The path used to load the Texture when the InitializeNonSerializableProperties() function is called.
            <para>NOTE: This is automatically set when the SetTexture() function is called.</para></summary>
    </member>
    <member name="P:DPSF.DPSF`2.DeserializationEffectPath">
      <summary>
            The path used to load the Effect when the InitializeNonSerializableProperties() function is called.
            <para>NOTE: This is automatically set when the SetEffectAndTechnique(string, string) function is called. </para></summary>
    </member>
    <member name="P:DPSF.DPSF`2.DeserializationTechniqueName">
      <summary>
            The Name of the Technique to use when the InitializeNonSerializableProperties() function is called.
            <para>NOTE: This is automatically set when the SetEffectAndTechnique() and SetTechnique() functions are called.</para></summary>
    </member>
    <member name="P:DPSF.DPSF`2.DPSFDefaultEffect">
      <summary>
            Get the DPSF Default Effect. This Effect is used by default if no other Effect and Technique are
            specified when calling the InitializeXParticleSystem() functions.
            <para>This Effect has several techniques that may be used (<see cref="T:DPSF.DPSFDefaultEffectTechniques" />).</para><para>This Effect also has a number of parameters that may be set:</para><para>1. float xColorBlendAmount may be set to specify how much of the Particle's Color should be blended in 
            with the Texture's Color (0.0 = use Texture's color, 1.0 = use Particle's color, 0.5 (default) = use equal amounts
            of Texture's and Particle's color), and this has an effect when using the Sprites, PointSprites, and 
            TexturedQuads techniques.</para><para>2. float4x4 xView, float4x4 xProjection, float4x4 xWorld should be set when using the Pixels, PointSprites, 
            Quads, and TexturedQuads techniques to specify the View, Projection, and World matrices respectively so that
            the vertices may be transformed propertly from 3D world space to 2D screen space.</para><para>3. texture xTexture should be set when using the Sprites, PointSprites, and TexturedQuads techniques to set
            the texture that should be used to represent the particles.</para><para>4. xViewportHeight may be set to the height of the viewport when using the PointSprites technique to simulate 
            perspective scaling (i.e. the texture gets smaller as it gets further from the camera). Set this to zero (default)
            to not use perspective scaling and have the texture size remain fixed regardless of its distance from the camera.</para><para>5. float xTextureWidth, floatxTextureHeight must be set if using one of the PointSpritesTextureCoordinates
            techniques, and these represent the Width and Height of the Texture.</para></summary>
    </member>
    <member name="P:DPSF.DPSF`2.Visible">
      <summary>
            Get / Set if this Particle System should Draw its Particles or not.
            <para>NOTE: Setting this to false causes the Draw() function to not draw anything, including the 
            BeforeDraw() and AfterDraw() functions not to be called.</para></summary>
    </member>
    <member name="P:DPSF.DPSF`2.Enabled">
      <summary>
            Get / Set if this Particle System should Update itself and its Particles or not.
            <para>NOTE: Setting this to false causes the Update() function to not update anything.</para></summary>
    </member>
    <member name="P:DPSF.DPSF`2.UpdateOrder">
      <summary>
            The Order in which the Particle System should be Updated relative to other 
            DPSF Particle Systems in the same Particle System Manager. Particle Systems 
            are Updated in ascending order according to their Update Order (i.e. lowest first).
            <para>NOTE: The Update Order is one of the few properties that is not reset when
            the particle system is initialized or destroyed.</para></summary>
    </member>
    <member name="P:DPSF.DPSF`2.DrawOrder">
      <summary>
            The Order in which the Particle System should be Drawn relative to other
            DPSF Particle Systems in the same Particle System Manager. Particle Systems
            are Drawn in ascending order according to their Draw Order (i.e. lowest first).
            <para>NOTE: The Draw Order is one of the few properties that is not reset when
            the particle system is initialized or destroyed.</para></summary>
    </member>
    <member name="P:DPSF.DPSF`2.Game">
      <summary>
            Get the Game object set in the constructor, if one was given.
            </summary>
    </member>
    <member name="P:DPSF.DPSF`2.GraphicsDevice">
      <summary>
            Get / Set the Graphics Device to draw to
            </summary>
    </member>
    <member name="P:DPSF.DPSF`2.InheritsDrawableGameComponent">
      <summary>
            Get if the Particle System is inheriting from DrawableGameComponent or not.
            <para>If inheriting from DrawableGameComponent, the Particle Systems
            are automatically added to the given Game object's Components and the
            Update() and Draw() functions are automatically called by the
            Game object when it updates and draws the rest of its Components.
            If the Update() and Draw() functions are called by the user anyways,
            they will exit without performing any operations, so it is suggested
            to include them anyways to make switching between inheriting and
            not inheriting from DrawableGameComponent seemless; just be aware
            that the updates and draws are actually being performed when the
            Game object is told to update and draw (i.e. when base.Update() and base.Draw()
            are called), not when these functions are being called.</para></summary>
    </member>
    <member name="P:DPSF.DPSF`2.ID">
      <summary>
            Get the unique ID of this Particle System.
            <para>NOTE: Each Particle System is automatically assigned a unique ID when it is instanciated.</para></summary>
    </member>
    <member name="P:DPSF.DPSF`2.Type">
      <summary>
            Get / Set the Type of Particle System this is. This is a user provided value that you can use for whatever
            purpose you want; it is not used by the built-in DPSF functionality in any way.
            </summary>
    </member>
    <member name="P:DPSF.DPSF`2.ClassName">
      <summary>
            Get the Name of the Class that this Particle System is using. This can be used to 
            check what type of Particle System this is at run-time.
            </summary>
    </member>
    <member name="P:DPSF.DPSF`2.ContentManager">
      <summary>
            Get / Set the Content Manager to use to load Textures and Effects
            </summary>
    </member>
    <member name="P:DPSF.DPSF`2.IndexBuffer">
      <summary>
            Get / Set the Index Buffer values. The Index Buffer is used when drawing Quads
            </summary>
    </member>
    <member name="P:DPSF.DPSF`2.IndexBufferIndex">
      <summary>
            Get / Set the current position in the Index Buffer
            </summary>
    </member>
    <member name="P:DPSF.DPSF`2.ParticleEvents">
      <summary>
            Particle Events may be used to update Particles
            </summary>
    </member>
    <member name="P:DPSF.DPSF`2.ParticleSystemEvents">
      <summary>
            Particle System Events may be used to update the Particle System
            </summary>
    </member>
    <member name="P:DPSF.DPSF`2.RenderProperties">
      <summary>
            Get the render properties used to draw the particles.
            </summary>
    </member>
    <member name="P:DPSF.DPSF`2.UsingExternalSpriteBatchToDrawParticles">
      <summary>
            Returns if this particle system is dependent on an external Sprite Batch to draw its particles or not.
            <para>If false, the particle system will use its own SpriteBatch to draw its particles.</para><para>If true, then you must call SpriteBatch.Begin() before calling ParticleSystem.Draw() to
            draw the particle system, and then call SpriteBatch.End() when done drawing the particle system, where
            the SpriteBatch referred to here is the one you passed into the InitializeSpriteParticleSystem() function.</para><para>NOTE: This property only applies to Sprite particle systems.</para></summary>
    </member>
    <member name="P:DPSF.DPSF`2.SpriteBatchSettings">
      <summary>
            The Sprite Batch drawing Settings used in the Sprite Batch's Begin() function call.
            <para>NOTE: These settings are only available for Sprite particle systems, and only for
            the Sprite particle systems using their own SpriteBatch (i.e. UsingExternalSpriteBatchToDrawParticles = false).</para></summary>
    </member>
    <member name="P:DPSF.DPSF`2.AutoMemoryManagerSettings">
      <summary>
            The Settings used to control the Automatic Memory Manager
            </summary>
    </member>
    <member name="P:DPSF.DPSF`2.Emitter">
      <summary>
            The Emitter is used to automatically generate new Particles
            </summary>
    </member>
    <member name="P:DPSF.DPSF`2.RandomNumber">
      <summary>
            Get a RandomNumbers object used to generate Random Numbers
            </summary>
    </member>
    <member name="P:DPSF.DPSF`2.World">
      <summary>
            Get / Set the World Matrix to use for drawing 3D Particles
            </summary>
    </member>
    <member name="P:DPSF.DPSF`2.View">
      <summary>
            Get / Set the View Matrix to use for drawing 3D Particles
            </summary>
    </member>
    <member name="P:DPSF.DPSF`2.Projection">
      <summary>
            Get / Set the Projection Matrix to use for drawing 3D Particles
            </summary>
    </member>
    <member name="P:DPSF.DPSF`2.WorldViewProjection">
      <summary>
            Gets the result of multiplying the World, View, and Projection matrices.
            </summary>
    </member>
    <member name="P:DPSF.DPSF`2.VertexElement">
      <summary>
            Set the VertexElement (i.e. Vertex Format) to use for each vertex of a Particle.
            <para>NOTE: VertexElement will not be changed if null value is given.</para></summary>
    </member>
    <member name="P:DPSF.DPSF`2.VertexUpdateFunction">
      <summary>
            Set the function to use to copy a Particle's renderable properties into the Vertex Buffer.
            <para>NOTE: VertexUpdateFunction will not be changed if null value is given.</para></summary>
    </member>
    <member name="P:DPSF.DPSF`2.ParticleInitializationFunction">
      <summary>
            Sets the function to use to Initialize a Particle's properties.
            </summary>
    </member>
    <member name="P:DPSF.DPSF`2.Effect">
      <summary>
            Get / Set the Effect to use to draw the Particles
            </summary>
    </member>
    <member name="P:DPSF.DPSF`2.Technique">
      <summary>
            Get / Set which Technique of the current Effect to use to draw the Particles
            </summary>
    </member>
    <member name="P:DPSF.DPSF`2.Texture">
      <summary>
            Get / Set the Texture to use to draw the Particles
            </summary>
    </member>
    <member name="P:DPSF.DPSF`2.SimulationSpeed">
      <summary>
            Get / Set how fast the Particle System Simulation should run.
            <para>Example: 1.0 = normal speed, 0.5 = half speed, 2.0 = double speed.</para><para>NOTE: If a negative value is specified, the Speed Scale is set 
            to zero (pauses the simulation; has same effect as Enabled = false).</para></summary>
    </member>
    <member name="P:DPSF.DPSF`2.InternalSimulationSpeed">
      <summary>
            Get / Set how fast the Particle System Simulation should run to look "normal".
            <para>1.0 = normal speed, 0.5 = half speed, 2.0 = double speed.</para><para>This is provided as a way of speeding up / slowing down the simulation to have 
            it look as desired, without having to rescale all of the particle velocities, etc.</para><para>NOTE: If a negative value is specified, the Internal Simulation Speed is set to zero 
            (pauses the simulation; has the same effect as Enabled = false).</para></summary>
    </member>
    <member name="P:DPSF.DPSF`2.UpdatesPerSecond">
      <summary>
            Specify how often the Particle System should be Updated.
            <para>NOTE: Specifying a value of zero (default) will cause the Particle 
            System to be Updated every time the Update() function is called 
            (i.e. as often as possible).</para><para>NOTE: If the Update() function is not called often enough to
            keep up with this specified Update rate, the Update function
            updates the Particle Systems as often as possible.</para></summary>
    </member>
    <member name="P:DPSF.DPSF`2.ParticleSystemManagerToCopyPropertiesFrom">
      <summary>
            The Particle System Manager whose properties (SimulationSpeed and 
            UpdatesPerSecond) this particle system should follow.  If null is not specified,
            the Manager's properties will be copied into this particle system immediately.
            <para>NOTE: This Particle System's properties will only clone the Manager's properties
            if the Manager's properties are Enabled. For example, the Manager's SimulationSpeed
            will only be copied to this Particle System if the Manager's SimulationSpeedIsEnabled
            property is true.</para><para>NOTE: This value is automatically set to the last Particle System Manager the 
            Particle System is added to.</para></summary>
    </member>
    <member name="P:DPSF.DPSF`2.ParticleType">
      <summary>
            Get the type of Particles that this Particle System should draw.
            </summary>
    </member>
    <member name="P:DPSF.DPSF`2.NumberOfParticlesAllocatedInMemory">
      <summary>
            Get / Set the absolute Number of Particles to Allocate Memory for.
            <para>NOTE: This value must be greater than or equal to zero.</para><para>NOTE: Even if this many particles aren't used, the space for this many Particles 
            is still allocated in memory.</para></summary>
    </member>
    <member name="P:DPSF.DPSF`2.MaxNumberOfParticlesAllowed">
      <summary>
            Get / Set the Max Number of Particles this Particle System is Allowed to contain at any given time.
            <para>NOTE: The Automatic Memory Manager will never allocate space for more Particles than this.</para><para>NOTE: This value must be greater than or equal to zero.</para></summary>
    </member>
    <member name="P:DPSF.DPSF`2.NumberOfActiveParticles">
      <summary>
            Get the number of Particles that are currently Active
            </summary>
    </member>
    <member name="P:DPSF.DPSF`2.NumberOfParticlesBeingDrawn">
      <summary>
            Get the number of Particles being Drawn. That is, how many Particles 
            are both Active AND Visible.
            </summary>
    </member>
    <member name="P:DPSF.DPSF`2.NumberOfParticlesStillPossibleToAdd">
      <summary>
            Get the number of Particles that may still be added before reaching the
            Max Number Of Particles Allowed. If the Max Number Of Particles Allowed is 
            greater than the Number Of Particles Allocated In Memory AND the Auto Memory Manager is
            set to not increase the amount of Allocated Memory, than this returns the number 
            of Particles that may still be added before running out of Memory.
            </summary>
    </member>
    <member name="P:DPSF.DPSF`2.ActiveParticles">
      <summary>
            Get / Protected Set a Linked List whose Nodes point to the Active Particles.
            <para>NOTE: The Protected Set option is only provided to allow the order of the 
            LinkedListNodes to be changed, changing the update and drawing 
            order of the Particles. Be sure that all of the original LinkedListNodes 
            (and only the original LinkedListNodes, no more) obtained from the 
            Get are included; they may only be rearranged. If they are not, 
            there may (and probably will) be unexpected results.</para></summary>
    </member>
    <member name="P:DPSF.DPSF`2.InactiveParticles">
      <summary>
            Returns a Linked List whose Nodes point to the Inactive Particles
            </summary>
    </member>
    <member name="P:DPSF.DPSF`2.Particles">
      <summary>
            Returns the array of all Particle objects
            </summary>
    </member>
    <member name="T:DPSF.DPSFParticle">
      <summary>
            Class used to hold a Particle's properties.
            This class only holds a Particle's Lifetime information, but may be inherited from
            in order to specify additional Particle properties, such as position, size, color, etc.
            </summary>
    </member>
    <member name="M:DPSF.DPSFParticle.#ctor">
      <summary>
            Constructor to initialize Particle variables
            </summary>
    </member>
    <member name="M:DPSF.DPSFParticle.UpdateElapsedTimeVariables(System.Single)">
      <summary>
            Function to update the Elapsed Time associated variables of the Particle. This is done
            automatically by DPSF when the particle system's Update() function is called, so this
            function does not need to be manually called by the user.
            </summary>
      <param name="fElapsedTimeInSeconds">The amount of time in seconds that 
            has passed since this function was last called</param>
    </member>
    <member name="M:DPSF.DPSFParticle.IsActive">
      <summary>
            Function to tell if a Particle is still Active (alive) or not
            </summary>
      <returns>Returns true if the Particle is Active (alive), false if it is Inactive (dead)</returns>
    </member>
    <member name="M:DPSF.DPSFParticle.Reset">
      <summary>
            Resets the Particles variables to default values
            </summary>
    </member>
    <member name="M:DPSF.DPSFParticle.CopyFrom(DPSF.DPSFParticle)">
      <summary>
            Deep copy the ParticleToCopy's values into this Particle
            </summary>
      <param name="ParticleToCopy">The Particle whose values should be Copied</param>
    </member>
    <member name="P:DPSF.DPSFParticle.ElapsedTime">
      <summary>
            Get / Set how much Time has Elapsed since this Particle was born.
            <para>NOTE: Setting this to be greater than or equal to Lifetime will
            cause the Particle to become InActive and be removed from the Particle 
            System (if Lifetime is greater than zero).</para><para>NOTE: Setting this also sets the Last Elapsed Time to the given value.</para></summary>
    </member>
    <member name="P:DPSF.DPSFParticle.NormalizedElapsedTime">
      <summary>
            Get / Set the Normalized Elapsed Time (0.0 - 1.0) of this Particle (How far through its life it is).
            <para>NOTE: Setting this to be greater than or equal to 1.0 will cause the Particle to become InActive 
            and be removed from the Particle System (if Lifetime is greater than zero).</para><para>NOTE: If the Particle has a Lifetime of zero (is set to live forever), Setting this has no effect,
            and Getting this will always return zero.</para></summary>
    </member>
    <member name="P:DPSF.DPSFParticle.LastElapsedTime">
      <summary>
            Get the Elapsed Time of the Particle at the previous frame
            </summary>
    </member>
    <member name="P:DPSF.DPSFParticle.LastNormalizedElapsedTime">
      <summary>
            Get the Normalized Elapsed Time of the Particle at the previous frame
            </summary>
    </member>
    <member name="P:DPSF.DPSFParticle.Lifetime">
      <summary>
            Get / Set the Lifetime of the Particle (How long it should live for).
            <para>NOTE: Setting this to zero will make the Particle live forever.</para><para>NOTE: Negative Lifetimes are reset to zero.</para></summary>
    </member>
    <member name="P:DPSF.DPSFParticle.Visible">
      <summary>
            Get / Set if the Particle should be Visible (i.e. be drawn) or not
            </summary>
    </member>
    <member name="T:DPSF.DPSFDefaultBaseParticleSystem`2">
      <summary>
            The Base Particle System class that the Default Particle System classes inherit from
            </summary>
      <typeparam name="Particle">The Particle class to use</typeparam>
      <typeparam name="Vertex">The Vertex Format to use</typeparam>
    </member>
    <member name="T:DPSF.DPSFDefaultBaseParticleSystem`2.CInitialProperties">
      <summary>
            Particle System Properties used to initialize a Particle's Properties.
            <para>NOTE: These are only applied to the Particle when the InitializeParticleUsingInitialProperties()
            function is set as the Particle Initialization Function.</para></summary>
    </member>
    <member name="F:DPSF.DPSFDefaultBaseParticleSystem`2.MagnetList">
      <summary>
            A list of Magnets that should affect this Particle System's Particles.
            <para>NOTE: You must add a UpdateParticleXAccordingToMagnets function to the Particle
            Events in order for these Magnets to affect the Particles.</para></summary>
    </member>
    <member name="M:DPSF.DPSFDefaultBaseParticleSystem`2.#ctor(Microsoft.Xna.Framework.Game)">
      <summary>
            Constructor
            </summary>
      <param name="cGame">Handle to the Game object being used. Pass in null for this 
            parameter if not using a Game object.</param>
    </member>
    <member name="M:DPSF.DPSFDefaultBaseParticleSystem`2.InitializeParticleUsingInitialProperties(DPSF.DPSFParticle)">
      <summary>
            Function to Initialize a Default Particle with the Initial Settings
            </summary>
      <param name="Particle">The Particle to be Initialized</param>
    </member>
    <member name="M:DPSF.DPSFDefaultBaseParticleSystem`2.InitializeParticleUsingInitialProperties(DPSF.DPSFParticle,DPSF.DPSFDefaultBaseParticleSystem{`0,`1}.CInitialProperties)">
      <summary>
            Function to Initialize a Default Particle with the Initial Settings
            </summary>
      <param name="Particle">The Particle to be Initialized</param>
      <param name="cInitialProperties">The Initial Settings to use to Initialize the Particle</param>
    </member>
    <member name="M:DPSF.DPSFDefaultBaseParticleSystem`2.UpdateParticlePositionUsingVelocity(DPSF.DPSFDefaultBaseParticle,System.Single)">
      <summary>
            Update a Particle's Position according to its Velocity
            </summary>
      <param name="cParticle">The Particle to update</param>
      <param name="fElapsedTimeInSeconds">How long it has been since the last update</param>
    </member>
    <member name="M:DPSF.DPSFDefaultBaseParticleSystem`2.UpdateParticleVelocityUsingAcceleration(DPSF.DPSFDefaultBaseParticle,System.Single)">
      <summary>
            Update a Particle's Velocity according to its Acceleration
            </summary>
      <param name="cParticle">The Particle to update</param>
      <param name="fElapsedTimeInSeconds">How long it has been since the last update</param>
    </member>
    <member name="M:DPSF.DPSFDefaultBaseParticleSystem`2.UpdateParticlePositionAndVelocityUsingAcceleration(DPSF.DPSFDefaultBaseParticle,System.Single)">
      <summary>
            Updates a Particle's Velocity according to its Acceleration, and then the Position according
            to the new Velocity
            </summary>
      <param name="cParticle">The Particle to update</param>
      <param name="fElapsedTimeInSeconds">How long it has been since the last update</param>
    </member>
    <member name="M:DPSF.DPSFDefaultBaseParticleSystem`2.UpdateParticlePositionUsingExternalForce(DPSF.DPSFDefaultBaseParticle,System.Single)">
      <summary>
            Applies the External Force to the Particle's Position
            </summary>
      <param name="cParticle">The Particle to update</param>
      <param name="fElapsedTimeInSeconds">How long it has been since the last update</param>
    </member>
    <member name="M:DPSF.DPSFDefaultBaseParticleSystem`2.UpdateParticleVelocityUsingExternalForce(DPSF.DPSFDefaultBaseParticle,System.Single)">
      <summary>
            Applies the External Force to the Particle's Velocity
            </summary>
      <param name="cParticle">The Particle to update</param>
      <param name="fElapsedTimeInSeconds">How long it has been since the last update</param>
    </member>
    <member name="M:DPSF.DPSFDefaultBaseParticleSystem`2.UpdateParticleVelocityUsingFriction(DPSF.DPSFDefaultBaseParticle,System.Single)">
      <summary>
            Applies the Particle's Friction to the its Velocity to slow the Particle down to a stop
            </summary>
      <param name="cParticle">The Particle to update</param>
      <param name="fElapsedTimeInSeconds">How long it has been since the last update</param>
    </member>
    <member name="M:DPSF.DPSFDefaultBaseParticleSystem`2.UpdateParticleColorUsingLerp(DPSF.DPSFDefaultBaseParticle,System.Single)">
      <summary>
            Linearly interpolates the Particles Color between it's Start Color and End Color based on the 
            Particle's Normalized Elapsed Time.
            </summary>
      <param name="cParticle">The Particle to update</param>
      <param name="fElapsedTimeInSeconds">How long it has been since the last update</param>
    </member>
    <member name="M:DPSF.DPSFDefaultBaseParticleSystem`2.UpdateParticleTransparencyToFadeOutUsingLerp(DPSF.DPSFDefaultBaseParticle,System.Single)">
      <summary>
            Linearly interpolates the Particles Transparency to fade out based on the Particle's Normalized Elapsed Time.
            <para>If you are also updating the Particle Color using an EveryTime Event, be sure to set the ExecutionOrder of the 
            event calling this function to be greater than that one, so that this function is called AFTER the color update function.</para></summary>
      <param name="cParticle">The Particle to update</param>
      <param name="fElapsedTimeInSeconds">How long it has been since the last update</param>
    </member>
    <member name="M:DPSF.DPSFDefaultBaseParticleSystem`2.UpdateParticleTransparencyToFadeInUsingLerp(DPSF.DPSFDefaultBaseParticle,System.Single)">
      <summary>
            Linearly interpolates the Particles Transparency to fade in based on the Particle's Normalized Elapsed Time.
            <para>If you are also updating the Particle Color using an EveryTime Event, be sure to set the ExecutionOrder of the 
            event calling this function to be greater than that one, so that this function is called AFTER the color update function.</para></summary>
      <param name="cParticle">The Particle to update</param>
      <param name="fElapsedTimeInSeconds">How long it has been since the last update</param>
    </member>
    <member name="M:DPSF.DPSFDefaultBaseParticleSystem`2.UpdateParticleTransparencyWithQuickFadeInAndSlowFadeOut(DPSF.DPSFDefaultBaseParticle,System.Single)">
      <summary>
            Quickly fades particle in when born and slowly fades it out as it gets closer to death.
            <para>If you are also updating the Particle Color using an EveryTime Event, be sure to set the ExecutionOrder of the 
            event calling this function to be greater than that one, so that this function is called AFTER the color update function.</para></summary>
      <param name="cParticle">The Particle to update</param>
      <param name="fElapsedTimeInSeconds">How long it has been since the last update</param>
    </member>
    <member name="M:DPSF.DPSFDefaultBaseParticleSystem`2.UpdateParticleTransparencyWithQuickFadeInAndQuickFadeOut(DPSF.DPSFDefaultBaseParticle,System.Single)">
      <summary>
            Quickly fades particle in when born and quickly fades it out as it approaches its death.
            <para>If you are also updating the Particle Color using an EveryTime Event, be sure to set the ExecutionOrder of the 
            event calling this function to be greater than that one, so that this function is called AFTER the color update function.</para></summary>
      <param name="cParticle">The Particle to update</param>
      <param name="fElapsedTimeInSeconds">How long it has been since the last update</param>
    </member>
    <member name="M:DPSF.DPSFDefaultBaseParticleSystem`2.UpdateParticlePositionAccordingToMagnets(DPSF.DPSFDefaultBaseParticle,System.Single)">
      <summary>
            Calculates how much affect each of the Particle System's Magnets should have on 
            this Particle and updates the Particle's Position accordingly.
            </summary>
      <param name="cParticle">The Particle to update</param>
      <param name="fElapsedTimeInSeconds">How long it has been since the last update</param>
    </member>
    <member name="M:DPSF.DPSFDefaultBaseParticleSystem`2.UpdateParticleVelocityAccordingToMagnets(DPSF.DPSFDefaultBaseParticle,System.Single)">
      <summary>
            Calculates how much affect each of the Particle System's Magnets should have on 
            this Particle and updates the Particle's Velocity accordingly.
            </summary>
      <param name="cParticle">The Particle to update</param>
      <param name="fElapsedTimeInSeconds">How long it has been since the last update</param>
    </member>
    <member name="M:DPSF.DPSFDefaultBaseParticleSystem`2.CalculateForceMagnetShouldExertOnParticle(DPSF.DefaultParticleSystemMagnet,DPSF.DPSFDefaultBaseParticle)">
      <summary>
            Returns the vector force that a Magnet should exert on a Particle
            </summary>
      <param name="cMagnet">The Magnet affecting the Particle</param>
      <param name="cParticle">The Particle being affected by the Magnet</param>
      <returns>Returns the vector force that a Magnet should exert on a Particle</returns>
    </member>
    <member name="M:DPSF.DPSFDefaultBaseParticleSystem`2.UpdateParticleSystemEmitParticlesAutomaticallyOn(System.Single)">
      <summary>
            Sets the Emitter to Emit Particles Automatically
            </summary>
      <param name="fElapsedTimeInSeconds">How long it has been since the last update</param>
    </member>
    <member name="M:DPSF.DPSFDefaultBaseParticleSystem`2.UpdateParticleSystemEmitParticlesAutomaticallyOff(System.Single)">
      <summary>
            Sets the Emitter to not Emit Particles Automatically
            </summary>
      <param name="fElapsedTimeInSeconds">How long it has been since the last update</param>
    </member>
    <member name="M:DPSF.DPSFDefaultBaseParticleSystem`2.UpdateParticleSystemEnableEmitter(System.Single)">
      <summary>
            Enables the Emitter
            </summary>
      <param name="fElapsedTimeInSeconds">How long it has been since the last update</param>
    </member>
    <member name="M:DPSF.DPSFDefaultBaseParticleSystem`2.UpdateParticleSystemDisableEmitter(System.Single)">
      <summary>
            Disables the Emitter
            </summary>
      <param name="fElapsedTimeInSeconds">How long it has been since the last update</param>
    </member>
    <member name="P:DPSF.DPSFDefaultBaseParticleSystem`2.InitialProperties">
      <summary>
            Get the Settings used to specify the Initial Properties of a new Particle.
            <para>NOTE: These are only applied to the Particle when the InitializeParticleUsingInitialProperties()
            function is set as the Particle Initialization Function.</para></summary>
    </member>
    <member name="P:DPSF.DPSFDefaultBaseParticleSystem`2.Name">
      <summary>
            The Name of the Particle System
            </summary>
    </member>
    <member name="T:DPSF.DPSFDefaultSpriteParticleSystem`2">
      <summary>
            The Default Sprite Particle System class
            </summary>
      <typeparam name="Particle">The Particle class to use</typeparam>
      <typeparam name="Vertex">The Vertex Format to use</typeparam>
    </member>
    <member name="T:DPSF.DPSFDefaultSpriteParticleSystem`2.CInitialPropertiesForSprite">
      <summary>
            Particle System Properties used to initialize a Particle's Properties.
            <para>NOTE: These are only applied to the Particle when the InitializeParticleUsingInitialProperties()
            function is set as the Particle Initialization Function.</para></summary>
    </member>
    <member name="M:DPSF.DPSFDefaultSpriteParticleSystem`2.#ctor(Microsoft.Xna.Framework.Game)">
      <summary>
            Constructor
            </summary>
      <param name="cGame">Handle to the Game object being used. Pass in null for this 
            parameter if not using a Game object.</param>
    </member>
    <member name="M:DPSF.DPSFDefaultSpriteParticleSystem`2.DrawSprite(DPSF.DPSFParticle,Microsoft.Xna.Framework.Graphics.SpriteBatch)">
      <summary>
            Function to draw a Sprite Particle. This function should be used to draw the given
            Particle with the provided SpriteBatch.
            </summary>
      <param name="Particle">The Particle Sprite to Draw</param>
      <param name="cSpriteBatch">The SpriteBatch to use to doing the Drawing</param>
    </member>
    <member name="M:DPSF.DPSFDefaultSpriteParticleSystem`2.InitializeParticleUsingInitialProperties(DPSF.DPSFParticle)">
      <summary>
            Function to Initialize a Default Particle with default Properties
            </summary>
      <param name="Particle">The Particle to be Initialized</param>
    </member>
    <member name="M:DPSF.DPSFDefaultSpriteParticleSystem`2.UpdateParticleRotationUsingRotationalVelocity(DPSF.DefaultSpriteParticle,System.Single)">
      <summary>
            Update a Particle's Rotation according to its Rotational Velocity
            </summary>
      <param name="cParticle">The Particle to update</param>
      <param name="fElapsedTimeInSeconds">How long it has been since the last update</param>
    </member>
    <member name="M:DPSF.DPSFDefaultSpriteParticleSystem`2.UpdateParticleRotationalVelocityUsingRotationalAcceleration(DPSF.DefaultSpriteParticle,System.Single)">
      <summary>
            Update a Particle's Rotational Velocity according to its Rotational Acceleration
            </summary>
      <param name="cParticle">The Particle to update</param>
      <param name="fElapsedTimeInSeconds">How long it has been since the last update</param>
    </member>
    <member name="M:DPSF.DPSFDefaultSpriteParticleSystem`2.UpdateParticleRotationAndRotationalVelocityUsingRotationalAcceleration(DPSF.DefaultSpriteParticle,System.Single)">
      <summary>
            Update a Particle's Rotation and Rotational Velocity according to its Rotational Acceleration
            </summary>
      <param name="cParticle">The Particle to update</param>
      <param name="fElapsedTimeInSeconds">How long it has been since the last update</param>
    </member>
    <member name="M:DPSF.DPSFDefaultSpriteParticleSystem`2.UpdateParticleWidthUsingLerp(DPSF.DefaultSpriteParticle,System.Single)">
      <summary>
            Linearly interpolate the Particle's Width between the Start and End Width according
            to the Particle's Normalized Lifetime
            </summary>
      <param name="cParticle">The Particle to update</param>
      <param name="fElapsedTimeInSeconds">How long it has been since the last update</param>
    </member>
    <member name="M:DPSF.DPSFDefaultSpriteParticleSystem`2.UpdateParticleHeightUsingLerp(DPSF.DefaultSpriteParticle,System.Single)">
      <summary>
            Linearly interpolate the Particle's Height between the Start and End Height according
            to the Particle's Normalized Lifetime
            </summary>
      <param name="cParticle">The Particle to update</param>
      <param name="fElapsedTimeInSeconds">How long it has been since the last update</param>
    </member>
    <member name="M:DPSF.DPSFDefaultSpriteParticleSystem`2.UpdateParticleWidthAndHeightUsingLerp(DPSF.DefaultSpriteParticle,System.Single)">
      <summary>
            Linearly interpolate the Particle's Width and Height between the Start and End values according
            to the Particle's Normalized Lifetime
            </summary>
      <param name="cParticle">The Particle to update</param>
      <param name="fElapsedTimeInSeconds">How long it has been since the last update</param>
    </member>
    <member name="M:DPSF.DPSFDefaultSpriteParticleSystem`2.UpdateParticleDepthFromBackToFrontUsingLerp(DPSF.DefaultSpriteParticle,System.Single)">
      <summary>
            Linearly interpolate the Particle's Position.Z value from 1.0 (back) to
            0.0 (front) according to the Particle's Normalized Lifetime
            </summary>
      <param name="cParticle">The Particle to update</param>
      <param name="fElapsedTimeInSeconds">How long it has been since the last update</param>
    </member>
    <member name="M:DPSF.DPSFDefaultSpriteParticleSystem`2.UpdateParticleDepthFromFrontToBackUsingLerp(DPSF.DefaultSpriteParticle,System.Single)">
      <summary>
            Linearly interpolate the Particle's Position.Z value from 0.0 (front) to
            1.0 (back) according to the Particle's Normalized Lifetime
            </summary>
      <param name="cParticle">The Particle to update</param>
      <param name="fElapsedTimeInSeconds">How long it has been since the last update</param>
    </member>
    <member name="M:DPSF.DPSFDefaultSpriteParticleSystem`2.UpdateParticleSystemToSortParticlesByDepth(System.Single)">
      <summary>
            Sorts the Particle System's Active Particles so that the Particles at the back
            (i.e. Position.Z = 1.0) are drawn before the Particles at the front (i.e. 
            Position.Z = 0.0).
            <para>NOTE: This operation is very expensive and should only be used when you are
            using a Shader (i.e. Effect and Technique) and have the 
            SpriteBatchOptions.eSortMode set to SpriteSortMode.Immediate (as this is the
            only mode which allows a Shader to be used with SpriteBatch).</para><para>If you are not using a Shader and want the Particles sorted by Depth, use SpriteSortMode.BackToFront.</para><para>Merge Sort is the sorting algorithm used, as it tends to be best for linked lists.
            TODO - WHILE MERGE SORT SHOULD BE USED, DUE TO TIME CONSTRAINTS A (PROBABLY) SLOWER METHOD (QUICK-SORT)
            IS BEING USED INSTEAD. THIS FUNCTION NEEDS TO BE UPDATED TO USE MERGE SORT STILL.
            THE LINKED LIST MERGE SORT ALGORITHM CAN BE FOUND AT http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html</para></summary>
      <param name="fElapsedTimeInSeconds">How long it has been since the last update</param>
    </member>
    <member name="P:DPSF.DPSFDefaultSpriteParticleSystem`2.InitialProperties">
      <summary>
            Get the Settings used to specify the Initial Properties of a new Particle.
            <para>NOTE: These are only applied to the Particle when the InitializeParticleUsingInitialProperties()
            function is set as the Particle Initialization Function.</para></summary>
    </member>
    <member name="T:DPSF.DPSFDefaultBaseParticle">
      <summary>
            The Base Particle class from which the Default Particle classes inherit from
            </summary>
    </member>
    <member name="F:DPSF.DPSFDefaultBaseParticle.Position">
      <summary>
            The Position of the Particle in 3D space.
            <para>NOTE: For 2D Pixel and Sprite Particles, the Z value can still be used to
            determine which Particles are drawn in front of others (0.0 = front, 
            1.0 = back) when SpriteBatchOptions.eSortMode = SpriteSortMode.BackToFront
            or SpriteSortMode.FrontToBack</para></summary>
    </member>
    <member name="F:DPSF.DPSFDefaultBaseParticle.Color">
      <summary>
            The Color of the Particle, or if using a Texture, the Color to incorporate into the Particle's Texture.
            <para>NOTE: This Color's alpha value controls the transparency of the Particle's Texture.</para></summary>
    </member>
    <member name="F:DPSF.DPSFDefaultBaseParticle.Velocity">
      <summary>
            The Particle's Velocity
            </summary>
    </member>
    <member name="F:DPSF.DPSFDefaultBaseParticle.Acceleration">
      <summary>
            The Particle's Acceleration
            </summary>
    </member>
    <member name="F:DPSF.DPSFDefaultBaseParticle.ExternalForce">
      <summary>
            An External Force that may be applied to the Particle
            </summary>
    </member>
    <member name="F:DPSF.DPSFDefaultBaseParticle.Friction">
      <summary>
            The Friction to apply to the Particle
            </summary>
    </member>
    <member name="F:DPSF.DPSFDefaultBaseParticle.StartColor">
      <summary>
            The Particle's Color when it is born
            </summary>
    </member>
    <member name="F:DPSF.DPSFDefaultBaseParticle.EndColor">
      <summary>
            The Particle's Color when it dies
            </summary>
    </member>
    <member name="M:DPSF.DPSFDefaultBaseParticle.Reset">
      <summary>
            Resets the Particle variables to their default values
            </summary>
    </member>
    <member name="M:DPSF.DPSFDefaultBaseParticle.CopyFrom(DPSF.DPSFParticle)">
      <summary>
            Deep copy all of the Particle properties
            </summary>
      <param name="ParticleToCopy">The Particle to Copy the properties from</param>
    </member>
    <member name="T:DPSF.DefaultSpriteParticle">
      <summary>
            Particle used by the Default Sprite Particle System
            </summary>
    </member>
    <member name="F:DPSF.DefaultSpriteParticle.Rotation">
      <summary>
            How much the Particle should be Rotated
            </summary>
    </member>
    <member name="F:DPSF.DefaultSpriteParticle.Width">
      <summary>
            The Width of the Particle
            </summary>
    </member>
    <member name="F:DPSF.DefaultSpriteParticle.Height">
      <summary>
            The Height of the Particle
            </summary>
    </member>
    <member name="F:DPSF.DefaultSpriteParticle.FlipMode">
      <summary>
            Tells if the Sprite should be flipped Horizontally or Vertically
            </summary>
    </member>
    <member name="F:DPSF.DefaultSpriteParticle.RotationalVelocity">
      <summary>
            The Particle's Rotational Velocity
            </summary>
    </member>
    <member name="F:DPSF.DefaultSpriteParticle.RotationalAcceleration">
      <summary>
            The Particle's Rotational Acceleration
            </summary>
    </member>
    <member name="F:DPSF.DefaultSpriteParticle.StartWidth">
      <summary>
            The Width of the Particle when it is born
            </summary>
    </member>
    <member name="F:DPSF.DefaultSpriteParticle.StartHeight">
      <summary>
            The Height of the Particle when it is born
            </summary>
    </member>
    <member name="F:DPSF.DefaultSpriteParticle.EndWidth">
      <summary>
            The Width of the Particle when it dies
            </summary>
    </member>
    <member name="F:DPSF.DefaultSpriteParticle.EndHeight">
      <summary>
            The Height of the Particle when it dies
            </summary>
    </member>
    <member name="M:DPSF.DefaultSpriteParticle.Scale(System.Single)">
      <summary>
            Scales the Width and Height by the given amount.
            </summary>
      <param name="scale">The amount to scale the Width and Height by.</param>
    </member>
    <member name="M:DPSF.DefaultSpriteParticle.ScaleToWidth(System.Single)">
      <summary>
            Updates the Width to the given value and uniformly scales the Height to maintain the width-to-height ratio.
            </summary>
      <param name="newWidth">The Width the particle should have.</param>
    </member>
    <member name="M:DPSF.DefaultSpriteParticle.ScaleToHeight(System.Single)">
      <summary>
            Updates the Height to the given value and uniformly scales the Width to maintain the width-to-height ratio.
            </summary>
      <param name="newHeight">The Height the particle should have.</param>
    </member>
    <member name="M:DPSF.DefaultSpriteParticle.Reset">
      <summary>
            Resets the Particle variables to their default values
            </summary>
    </member>
    <member name="M:DPSF.DefaultSpriteParticle.CopyFrom(DPSF.DPSFParticle)">
      <summary>
            Deep copy all of the Particle properties
            </summary>
      <param name="ParticleToCopy">The Particle to Copy the properties from</param>
    </member>
    <member name="P:DPSF.DefaultSpriteParticle.Size">
      <summary>
            Sets the Width and Height properties to the given value.
            Gets the Width value, ignoring whether the Height value is the same or not.
            </summary>
    </member>
    <member name="P:DPSF.DefaultSpriteParticle.StartSize">
      <summary>
            Sets the StartWidth and StartHeight properties to the given value.
            Gets the StartWidth value, ignoring whether the StartHeight value is the same or not.
            </summary>
    </member>
    <member name="P:DPSF.DefaultSpriteParticle.EndSize">
      <summary>
            Sets the EndWidth and EndHeight properties to the given value.
            Gets the EndWidth value, ignoring whether the EndHeight value is the same or not.
            </summary>
    </member>
    <member name="T:DPSF.DPSFDefaultQuadParticleSystem`2">
      <summary>
            The Default Quad Particle System class
            </summary>
      <typeparam name="Particle">The Particle class to use</typeparam>
      <typeparam name="Vertex">The Vertex Format to use</typeparam>
    </member>
    <member name="T:DPSF.DPSFDefaultQuadParticleSystem`2.CInitialPropertiesForQuad">
      <summary>
            Particle System Properties used to initialize a Particle's Properties.
            <para>NOTE: These are only applied to the Particle when the InitializeParticleUsingInitialProperties()
            function is set as the Particle Initialization Function.</para></summary>
    </member>
    <member name="M:DPSF.DPSFDefaultQuadParticleSystem`2.#ctor(Microsoft.Xna.Framework.Game)">
      <summary>
            Constructor
            </summary>
      <param name="cGame">Handle to the Game object being used. Pass in null for this 
            parameter if not using a Game object.</param>
    </member>
    <member name="M:DPSF.DPSFDefaultQuadParticleSystem`2.UpdateVertexProperties(DPSF.DefaultQuadParticleVertex[]@,System.Int32,DPSF.DPSFParticle)">
      <summary>
            Function to update the Vertex properties according to the Particle properties
            </summary>
      <param name="sVertexBuffer">The array containing the Vertices to be drawn</param>
      <param name="iIndex">The Index in the array where the Particle's Vertex info should be placed</param>
      <param name="Particle">The Particle to copy the information from</param>
    </member>
    <member name="M:DPSF.DPSFDefaultQuadParticleSystem`2.SetEffectParameters">
      <summary>
            Virtual function to Set the Effect's Parameters before drawing the Particles
            </summary>
    </member>
    <member name="M:DPSF.DPSFDefaultQuadParticleSystem`2.SetCameraPosition(Microsoft.Xna.Framework.Vector3)">
      <summary>
            Sets the camera position, so that the particles know how to make themselves face the camera if needed.
            </summary>
      <param name="cameraPosition">The camera position.</param>
    </member>
    <member name="M:DPSF.DPSFDefaultQuadParticleSystem`2.InitializeParticleUsingInitialProperties(DPSF.DPSFParticle)">
      <summary>
            Function to Initialize a Default Particle with default settings
            </summary>
      <param name="Particle">The Particle to be Initialized</param>
    </member>
    <member name="M:DPSF.DPSFDefaultQuadParticleSystem`2.UpdateParticleRotationUsingRotationalVelocity(DPSF.DefaultQuadParticle,System.Single)">
      <summary>
            Update a Particle's Rotation according to its Rotational Velocity
            </summary>
      <param name="cParticle">The Particle to update</param>
      <param name="fElapsedTimeInSeconds">How long it has been since the last update</param>
    </member>
    <member name="M:DPSF.DPSFDefaultQuadParticleSystem`2.UpdateParticleRotationalVelocityUsingRotationalAcceleration(DPSF.DefaultQuadParticle,System.Single)">
      <summary>
            Update a Particle's Rotational Velocity according to its Rotational Acceleration
            </summary>
      <param name="cParticle">The Particle to update</param>
      <param name="fElapsedTimeInSeconds">How long it has been since the last update</param>
    </member>
    <member name="M:DPSF.DPSFDefaultQuadParticleSystem`2.UpdateParticleRotationAndRotationalVelocityUsingRotationalAcceleration(DPSF.DefaultQuadParticle,System.Single)">
      <summary>
            Update a Particle's Rotation and Rotational Velocity according to its Rotational Acceleration
            </summary>
      <param name="cParticle">The Particle to update</param>
      <param name="fElapsedTimeInSeconds">How long it has been since the last update</param>
    </member>
    <member name="M:DPSF.DPSFDefaultQuadParticleSystem`2.UpdateParticleWidthUsingLerp(DPSF.DefaultQuadParticle,System.Single)">
      <summary>
            Linearly interpolate the Particle's Width between the Start and End Width according
            to the Particle's Normalized Lifetime
            </summary>
      <param name="cParticle">The Particle to update</param>
      <param name="fElapsedTimeInSeconds">How long it has been since the last update</param>
    </member>
    <member name="M:DPSF.DPSFDefaultQuadParticleSystem`2.UpdateParticleHeightUsingLerp(DPSF.DefaultQuadParticle,System.Single)">
      <summary>
            Linearly interpolate the Particle's Height between the Start and End Height according
            to the Particle's Normalized Lifetime
            </summary>
      <param name="cParticle">The Particle to update</param>
      <param name="fElapsedTimeInSeconds">How long it has been since the last update</param>
    </member>
    <member name="M:DPSF.DPSFDefaultQuadParticleSystem`2.UpdateParticleWidthAndHeightUsingLerp(DPSF.DefaultQuadParticle,System.Single)">
      <summary>
            Linearly interpolate the Particle's Width and Height between the Start and End values according
            to the Particle's Normalized Lifetime
            </summary>
      <param name="cParticle">The Particle to update</param>
      <param name="fElapsedTimeInSeconds">How long it has been since the last update</param>
    </member>
    <member name="M:DPSF.DPSFDefaultQuadParticleSystem`2.UpdateParticleToBeConstrainedAroundXAxis(DPSF.DefaultQuadParticle,System.Single)">
      <summary>
            Orientates the Particle to face the camera, but constrains the particle to always be perpendicular to the 
            Y-Z plane.
            </summary>
      <param name="cParticle">The Particle to update.</param>
      <param name="fElapsedTimeInSeconds">How long it has been since the last update.</param>
    </member>
    <member name="M:DPSF.DPSFDefaultQuadParticleSystem`2.UpdateParticleToBeConstrainedAroundYAxis(DPSF.DefaultQuadParticle,System.Single)">
      <summary>
            Orientates the Particle to face the camera, but constrains the particle to always be perpendicular to the 
            X-Z plane (i.e standing straight up).
            </summary>
      <param name="cParticle">The Particle to update.</param>
      <param name="fElapsedTimeInSeconds">How long it has been since the last update.</param>
    </member>
    <member name="M:DPSF.DPSFDefaultQuadParticleSystem`2.UpdateParticleToBeConstrainedAroundZAxis(DPSF.DefaultQuadParticle,System.Single)">
      <summary>
            Orientates the Particle to face the camera, but constrains the particle to always be perpendicular to the 
            X-Y plane.
            </summary>
      <param name="cParticle">The Particle to update.</param>
      <param name="fElapsedTimeInSeconds">How long it has been since the last update.</param>
    </member>
    <member name="M:DPSF.DPSFDefaultQuadParticleSystem`2.UpdateParticleDistanceFromCameraSquared(DPSF.DefaultQuadParticle,System.Single)">
      <summary>
            Updates the Particle's DistanceFromCameraSquared property to reflect how far this Particle is from the Camera.
            </summary>
      <param name="cParticle">The Particle to update.</param>
      <param name="fElapsedTimeInSeconds">How long it has been since the last update.</param>
    </member>
    <member name="M:DPSF.DPSFDefaultQuadParticleSystem`2.UpdateParticleSystemToSortParticlesByDistanceFromCamera(System.Single)">
      <summary>
            Sorts the particles to draw particles furthest from the camera first, in order to achieve proper depth perspective.
            
            <para>NOTE: This operation is very expensive and should only be used when you are
            drawing particles with both opaque and semi-transparent portions, and not using additive blending.</para><para>Merge Sort is the sorting algorithm used, as it tends to be best for linked lists.
            TODO - WHILE MERGE SORT SHOULD BE USED, DUE TO TIME CONSTRAINTS A (PROBABLY) SLOWER METHOD (QUICK-SORT)
            IS BEING USED INSTEAD. THIS FUNCTION NEEDS TO BE UPDATED TO USE MERGE SORT STILL.
            THE LINKED LIST MERGE SORT ALGORITHM CAN BE FOUND AT http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html</para></summary>
      <param name="fElapsedTimeInSeconds">How long it has been since the last update</param>
    </member>
    <member name="P:DPSF.DPSFDefaultQuadParticleSystem`2.InitialProperties">
      <summary>
            Get the Settings used to specify the Initial Properties of a new Particle.
            <para>NOTE: These are only applied to the Particle when the InitializeParticleUsingInitialProperties()
            function is set as the Particle Initialization Function.</para></summary>
    </member>
    <member name="P:DPSF.DPSFDefaultQuadParticleSystem`2.CameraPosition">
      <summary>
            Get / Set the Position of the Camera.
            <para>NOTE: This should be Set (updated) every frame if Billboarding will be used 
            (i.e. Always have the Particles face the Camera).</para></summary>
    </member>
    <member name="T:DPSF.DPSFDefaultTexturedQuadParticleSystem`2">
      <summary>
            The Default Textured Quad Particle System class
            </summary>
      <typeparam name="Particle">The Particle class to use</typeparam>
      <typeparam name="Vertex">The Vertex Format to use</typeparam>
    </member>
    <member name="M:DPSF.DPSFDefaultTexturedQuadParticleSystem`2.#ctor(Microsoft.Xna.Framework.Game)">
      <summary>
            Constructor
            </summary>
      <param name="cGame">Handle to the Game object being used. Pass in null for this 
            parameter if not using a Game object.</param>
    </member>
    <member name="M:DPSF.DPSFDefaultTexturedQuadParticleSystem`2.UpdateVertexProperties(DPSF.DefaultTexturedQuadParticleVertex[]@,System.Int32,DPSF.DPSFParticle)">
      <summary>
            Function to update the Vertex properties according to the Particle properties
            </summary>
      <param name="sVertexBuffer">The array containing the Vertices to be drawn</param>
      <param name="iIndex">The Index in the array where the Particle's Vertex info should be placed</param>
      <param name="Particle">The Particle to copy the information from</param>
    </member>
    <member name="M:DPSF.DPSFDefaultTexturedQuadParticleSystem`2.SetEffectParameters">
      <summary>
            Virtual function to Set the Effect's Parameters before drawing the Particles
            </summary>
    </member>
    <member name="T:DPSF.DPSFDefaultTexturedQuadTextureCoordinatesParticleSystem`2">
      <summary>
            The Default Textured Quad with Texture Coordinates Particle System class
            </summary>
      <typeparam name="Particle">The Particle class to use</typeparam>
      <typeparam name="Vertex">The Vertex Format to use</typeparam>
    </member>
    <member name="M:DPSF.DPSFDefaultTexturedQuadTextureCoordinatesParticleSystem`2.#ctor(Microsoft.Xna.Framework.Game)">
      <summary>
            Constructor
            </summary>
      <param name="cGame">Handle to the Game object being used. Pass in null for this 
            parameter if not using a Game object.</param>
    </member>
    <member name="M:DPSF.DPSFDefaultTexturedQuadTextureCoordinatesParticleSystem`2.UpdateVertexProperties(DPSF.DefaultTexturedQuadParticleVertex[]@,System.Int32,DPSF.DPSFParticle)">
      <summary>
            Function to update the Vertex properties according to the Particle properties
            </summary>
      <param name="sVertexBuffer">The array containing the Vertices to be drawn</param>
      <param name="iIndex">The Index in the array where the Particle's Vertex info should be placed</param>
      <param name="Particle">The Particle to copy the information from</param>
    </member>
    <member name="T:DPSF.DefaultTexturedQuadTextureCoordinatesParticleSystem">
      <summary>
            The Default Textured Quad with Texture Coordinates Particle System to inherit from, which uses Default Textured Quad Texture Coordinates Particles
            </summary>
    </member>
    <member name="M:DPSF.DefaultTexturedQuadTextureCoordinatesParticleSystem.#ctor(Microsoft.Xna.Framework.Game)">
      <summary>
            Constructor
            </summary>
      <param name="cGame">Handle to the Game object being used. Pass in null for this 
            parameter if not using a Game object.</param>
    </member>
    <member name="T:DPSF.DefaultQuadParticle">
      <summary>
            Particle used by the Default Quad Particle System
            </summary>
    </member>
    <member name="F:DPSF.DefaultQuadParticle.Orientation">
      <summary>
            The Orientation of the Particle
            </summary>
    </member>
    <member name="F:DPSF.DefaultQuadParticle.RotationalVelocity">
      <summary>
            The Rotational Velocity of the Particle.
            X = Pitch Velocity, Y = Yaw Velocity, Z = Roll Velocity in radians
            </summary>
    </member>
    <member name="F:DPSF.DefaultQuadParticle.RotationalAcceleration">
      <summary>
            The Rotational Acceleration of the Particle.
            X = Pitch Acceleration, Y = Yaw Acceleration, Z = Roll Acceleration in radians
            </summary>
    </member>
    <member name="F:DPSF.DefaultQuadParticle.Width">
      <summary>
            The Width of the Particle
            </summary>
    </member>
    <member name="F:DPSF.DefaultQuadParticle.Height">
      <summary>
            The Height of the Particle
            </summary>
    </member>
    <member name="F:DPSF.DefaultQuadParticle.StartWidth">
      <summary>
            The Width of the Particle when it is born
            </summary>
    </member>
    <member name="F:DPSF.DefaultQuadParticle.StartHeight">
      <summary>
            The Height of the Particle when it is born
            </summary>
    </member>
    <member name="F:DPSF.DefaultQuadParticle.EndWidth">
      <summary>
            The Width of the Particle when it dies
            </summary>
    </member>
    <member name="F:DPSF.DefaultQuadParticle.EndHeight">
      <summary>
            The Height of the Particle when it dies
            </summary>
    </member>
    <member name="F:DPSF.DefaultQuadParticle.DistanceFromCameraSquared">
      <summary>
            The squared distance between this particle and the camera.
            <para>NOTE: This property is only used if you are sorting the particles based on their distance 
            from the camera, otherwise you can use this property for whatever you like.</para></summary>
    </member>
    <member name="M:DPSF.DefaultQuadParticle.Scale(System.Single)">
      <summary>
            Scales the Width and Height by the given amount.
            </summary>
      <param name="scale">The amount to scale the Width and Height by.</param>
    </member>
    <member name="M:DPSF.DefaultQuadParticle.ScaleToWidth(System.Single)">
      <summary>
            Updates the Width to the given value and uniformly scales the Height to maintain the width-to-height ratio.
            </summary>
      <param name="newWidth">The Width the particle should have.</param>
    </member>
    <member name="M:DPSF.DefaultQuadParticle.ScaleToHeight(System.Single)">
      <summary>
            Updates the Height to the given value and uniformly scales the Width to maintain the width-to-height ratio.
            </summary>
      <param name="newHeight">The Height the particle should have.</param>
    </member>
    <member name="M:DPSF.DefaultQuadParticle.Reset">
      <summary>
            Resets the Particle variables to their default values
            </summary>
    </member>
    <member name="M:DPSF.DefaultQuadParticle.CopyFrom(DPSF.DPSFParticle)">
      <summary>
            Deep copy all of the Particle properties
            </summary>
      <param name="ParticleToCopy">The Particle to Copy the properties from</param>
    </member>
    <member name="P:DPSF.DefaultQuadParticle.Size">
      <summary>
            Sets the Width and Height properties to the given value.
            Gets the Width value, ignoring whether the Height value is the same or not.
            </summary>
    </member>
    <member name="P:DPSF.DefaultQuadParticle.StartSize">
      <summary>
            Sets the StartWidth and StartHeight properties to the given value.
            Gets the StartWidth value, ignoring whether the StartHeight value is the same or not.
            </summary>
    </member>
    <member name="P:DPSF.DefaultQuadParticle.EndSize">
      <summary>
            Sets the EndWidth and EndHeight properties to the given value.
            Gets the EndWidth value, ignoring whether the EndHeight value is the same or not.
            </summary>
    </member>
    <member name="P:DPSF.DefaultQuadParticle.Normal">
      <summary>
            Get / Set the Normal (forward) direction of the Particle (i.e. which direction it is facing)
            </summary>
    </member>
    <member name="P:DPSF.DefaultQuadParticle.Up">
      <summary>
            Get / Set the Up direction of the Particle
            </summary>
    </member>
    <member name="P:DPSF.DefaultQuadParticle.Right">
      <summary>
            Get / Set the Right direction of the Particle
            </summary>
    </member>
    <member name="T:DPSF.DefaultTexturedQuadParticle">
      <summary>
            Particle used by the Default Textured Quad Particle System
            </summary>
    </member>
    <member name="T:DPSF.DefaultTextureQuadTextureCoordinatesParticle">
      <summary>
            Particle used by the Default Textured Quad with Texture Coordinates Particle System
            </summary>
    </member>
    <member name="F:DPSF.DefaultTextureQuadTextureCoordinatesParticle.NormalizedTextureCoordinateLeftTop">
      <summary>
            The Normalized (0.0 - 1.0) Top-Left Texture Coordinate to use for the Particle's image
            </summary>
    </member>
    <member name="F:DPSF.DefaultTextureQuadTextureCoordinatesParticle.NormalizedTextureCoordinateRightBottom">
      <summary>
            The Normalized (0.0 - 1.0) Bottom-Right Texture Coordinate to use for the Particle's image
            </summary>
    </member>
    <member name="M:DPSF.DefaultTextureQuadTextureCoordinatesParticle.SetTextureCoordinates(Microsoft.Xna.Framework.Rectangle,System.Int32,System.Int32)">
      <summary>
            Sets the Normalized Texture Coordinates using the absolute (i.e. non-normalized) top-left coordinate and the dimensions of the Picture in the Texture
            </summary>
      <param name="sTextureCoordinates">The top-left Position and the Dimensions of the Picture in the Texture</param>
      <param name="iTextureWidth">The Width of the Texture that the Picture is in</param>
      <param name="iTextureHeight">The Height of the Texture that the Picture is in</param>
    </member>
    <member name="M:DPSF.DefaultTextureQuadTextureCoordinatesParticle.SetTextureCoordinates(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>
            Sets the Normalized Texture Coordinates using the absolute (i.e. non-normalized) coordinates of the Picture in the Texture
            </summary>
      <param name="iLeft">The X position of the top-left corner of the Picture in the Texture</param>
      <param name="iTop">The Y position of the top-left corner of the Picture in the Texture</param>
      <param name="iRight">The X position of the bottom-right corner of the Picture in the Texture</param>
      <param name="iBottom">The Y position of the bottom-right corner of the Picture in the Texture</param>
      <param name="iTextureWidth">The Width of the Texture that the Picture is in</param>
      <param name="iTextureHeight">The Height of the Texture that the Picture is in</param>
    </member>
    <member name="M:DPSF.DefaultTextureQuadTextureCoordinatesParticle.Reset">
      <summary>
            Resets the Particle variables to their default values
            </summary>
    </member>
    <member name="M:DPSF.DefaultTextureQuadTextureCoordinatesParticle.CopyFrom(DPSF.DPSFParticle)">
      <summary>
            Deep copy all of the Particle properties
            </summary>
      <param name="ParticleToCopy">The Particle to Copy the properties from</param>
    </member>
    <member name="T:DPSF.DPSFDefaultAnimatedTexturedQuadParticleSystem`2">
      <summary>
            The Default Animated Textured Quad Particle System class
            </summary>
      <typeparam name="Particle">The Particle class to use</typeparam>
      <typeparam name="Vertex">The Vertex Format to use</typeparam>
    </member>
    <member name="M:DPSF.DPSFDefaultAnimatedTexturedQuadParticleSystem`2.#ctor(Microsoft.Xna.Framework.Game)">
      <summary>
            Constructor
            </summary>
      <param name="cGame">Handle to the Game object being used. Pass in null for this 
            parameter if not using a Game object.</param>
    </member>
    <member name="M:DPSF.DPSFDefaultAnimatedTexturedQuadParticleSystem`2.UpdateParticleAnimationAndTextureCoordinates(DPSF.DefaultAnimatedTexturedQuadParticle,System.Single)">
      <summary>
            Updates the Animation, as well as the Particle's Texture Coordinates to match the Animation
            </summary>
      <param name="cParticle">The Particle to update</param>
      <param name="fElapsedTimeInSeconds">How long it has been since the last update</param>
    </member>
    <member name="M:DPSF.DPSFDefaultAnimatedTexturedQuadParticleSystem`2.UpdateParticleToDieOnceAnimationFinishesPlaying(DPSF.DefaultAnimatedTexturedQuadParticle,System.Single)">
      <summary>
            Updates the Particle to be removed from the Particle System once the Animation finishes Playing
            </summary>
      <param name="cParticle">The Particle to update</param>
      <param name="fElapsedTimeInSeconds">How long it has been since the last update</param>
    </member>
    <member name="T:DPSF.DefaultAnimatedTexturedQuadParticleSystem">
      <summary>
            The Default Animated Textured Quad Particle System to inherit from, which uses Default Animated Textured Quad Particles
            </summary>
    </member>
    <member name="M:DPSF.DefaultAnimatedTexturedQuadParticleSystem.#ctor(Microsoft.Xna.Framework.Game)">
      <summary>
            Constructor
            </summary>
      <param name="cGame">Handle to the Game object being used. Pass in null for this 
            parameter if not using a Game object.</param>
    </member>
    <member name="T:DPSF.DefaultAnimatedTexturedQuadParticle">
      <summary>
            Particle used by the Default Animated Quad Particle System
            </summary>
    </member>
    <member name="F:DPSF.DefaultAnimatedTexturedQuadParticle.Animation">
      <summary>
            Class to hold this Particle's Animation information
            </summary>
    </member>
    <member name="M:DPSF.DefaultAnimatedTexturedQuadParticle.Reset">
      <summary>
            Resets the Particle variables to their default values
            </summary>
    </member>
    <member name="M:DPSF.DefaultAnimatedTexturedQuadParticle.CopyFrom(DPSF.DPSFParticle)">
      <summary>
            Deep copy all of the Particle properties
            </summary>
      <param name="ParticleToCopy">The Particle to Copy the properties from</param>
    </member>
    <member name="T:DPSF.Orientation2D">
      <summary>
            Class to hold and update an object's 2D Orientation, Rotational Velocity, and Rotational Acceleration
            </summary>
    </member>
    <member name="F:DPSF.Orientation2D.Orientation">
      <summary>
            The object's Rotation (in radians) (i.e. How much it is currently rotated)
            </summary>
    </member>
    <member name="F:DPSF.Orientation2D.RotationalVelocity">
      <summary>
            The object's Rotational Velocity (in radians)
            </summary>
    </member>
    <member name="F:DPSF.Orientation2D.RotationalAcceleration">
      <summary>
            The object's Rotational Acceleration (in radians)
            </summary>
    </member>
    <member name="M:DPSF.Orientation2D.#ctor">
      <summary>
            Default Constructor
            </summary>
    </member>
    <member name="M:DPSF.Orientation2D.#ctor(DPSF.Orientation2D)">
      <summary>
            Copy Constructor
            </summary>
      <param name="cOrienationToCopy">The Orientation2D object to copy</param>
    </member>
    <member name="M:DPSF.Orientation2D.CopyFrom(DPSF.Orientation2D)">
      <summary>
            Copies the given Orientation2D object's data into this object's data
            </summary>
      <param name="cOrientationToCopy">The Orientation2D object to copy from</param>
    </member>
    <member name="M:DPSF.Orientation2D.Rotate(System.Single)">
      <summary>
            Applies the given Rotation to the object's Orientation
            </summary>
      <param name="fRotation">The Rotation in radians that should be applied to the object</param>
    </member>
    <member name="M:DPSF.Orientation2D.Update(System.Single)">
      <summary>
            Update the Orientation and Rotational Velocity according to the Rotational Acceleration
            </summary>
      <param name="fElapsedTimeInSeconds">The time Elapsed in Seconds since the last Update</param>
    </member>
    <member name="M:DPSF.Orientation2D.Rotate(System.Single,System.Single)">
      <summary>
            Returns the new Orientation after applying the given Rotation
            </summary>
      <param name="fRotationToApply">The Rotation in radians to apply to the Current Orientation</param>
      <param name="fCurrentOrientation">The object's Current Orientation in radians</param>
      <returns>Returns the new Orientation after applying the given Rotation</returns>
    </member>
    <member name="M:DPSF.Orientation2D.GetRotationTo(System.Single,System.Single)">
      <summary>
            Returns the Rotation needed to rotate the object from the Current Rotation to
            the Desired Rotation
            </summary>
      <param name="fCurrentRotation">The object's Current Rotation in radians</param>
      <param name="fDesiredRotation">The object's Desired Rotation in radians</param>
      <returns>Returns the Rotation needed to rotate the object from the Current Rotation to
            the Desired Rotation</returns>
    </member>
    <member name="T:DPSF.ParticleTypes">
      <summary>
            The Type of Particles that the Particle Systems can draw. Different Particle Types are drawn in 
            different ways. For example, four vertices are required to draw a Quad, and only one is required 
            to draw a Point Sprite.
            </summary>
    </member>
    <member name="F:DPSF.ParticleTypes.None">
      <summary>
            This is the default settings when we don't know what Type of Particles are going to be used yet.
            A particle system is not considered Initialized until the Particle Type does not equal this.
            </summary>
    </member>
    <member name="F:DPSF.ParticleTypes.NoDisplay">
      <summary>
            Use this when you do not want to draw your particles to the screen, as no vertex buffer will be
            created, saving memory. Also, the Draw() function will do nothing when this Particle Type is used.
            This Particle Type is useful when you just want to collect and analyze particle information without
            visualizing the particles.
            </summary>
    </member>
    <member name="F:DPSF.ParticleTypes.Sprite">
      <summary>
            Texture in 2D screen coordinates. Drawn using a SpriteBatch object. Only allows for 2D roll
            rotations, always faces the camera, and must use a Texture.
            </summary>
    </member>
    <member name="F:DPSF.ParticleTypes.Quad">
      <summary>
            Four vertices in 3D world coordinates. Allows for rotations in all 3 dimensions, does
            not have to always face the camera, may be skewed into any quadrilateral, such as
            a square, rectangle, or trapezoid, and do not use a Texture.
            </summary>
    </member>
    <member name="F:DPSF.ParticleTypes.TexturedQuad">
      <summary>
            Four vertices in 3D world coordinates. Allows for rotations in all 3 dimensions, does
            not have to always face the camera, may be skewed into any quadrilateral, such as
            a square, rectangle, or trapezoid, and must use a Texture.
            </summary>
    </member>
    <member name="T:DPSF.SpriteBatchSettings">
      <summary>
            Class to hold all of the SpriteBatch-specific drawing Settings
            </summary>
    </member>
    <member name="F:DPSF.SpriteBatchSettings.SortMode">
      <summary>
            If you plan on using a Shader (i.e. Effect and Technique) you must use
            Immediate mode. This is a limitation of SpriteBatch.
            </summary>
    </member>
    <member name="F:DPSF.SpriteBatchSettings.TransformationMatrix">
      <summary>
            The Transformation Matrix used in the SpriteBatch.Begin() function call
            </summary>
    </member>
    <member name="T:DPSF.RenderProperties">
      <summary>
            Class to hold all of the drawing Settings
            </summary>
    </member>
    <member name="M:DPSF.RenderProperties.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:DPSF.RenderProperties" /> class, setting each property to its default value.
            </summary>
    </member>
    <member name="M:DPSF.RenderProperties.ResetToDefaults">
      <summary>
            Resets each of the render properties to their default values.
            </summary>
    </member>
    <member name="P:DPSF.RenderProperties.BlendState">
      <summary>
            Get / Set the BlendState to use when drawing the particles.
            <para>Default value is BlendState.AlphaBlend.</para></summary>
    </member>
    <member name="P:DPSF.RenderProperties.DepthStencilState">
      <summary>
            Get / Set the DepthStencilState to use when drawing the particles.
            </summary>
    </member>
    <member name="P:DPSF.RenderProperties.RasterizerState">
      <summary>
            Get / Set the RasterizerState to use when drawing the particles.
            </summary>
    </member>
    <member name="P:DPSF.RenderProperties.SamplerState">
      <summary>
            Get / Set the SamplerState to use when drawing the particles.
            </summary>
    </member>
    <member name="T:DPSF.Position2D">
      <summary>
            Class used to hold and update an object's 2D Position, Velocity, and Acceleration
            </summary>
    </member>
    <member name="F:DPSF.Position2D.Position">
      <summary>
            The object's 2D Position
            </summary>
    </member>
    <member name="F:DPSF.Position2D.Velocity">
      <summary>
            The object's Position
            </summary>
    </member>
    <member name="F:DPSF.Position2D.Acceleration">
      <summary>
            The object's Acceleration
            </summary>
    </member>
    <member name="M:DPSF.Position2D.#ctor">
      <summary>
            Default Constructor
            </summary>
    </member>
    <member name="M:DPSF.Position2D.#ctor(DPSF.Position2D)">
      <summary>
            Copy Constructor
            </summary>
      <param name="cPositionToCopy">The Position2D object to copy</param>
    </member>
    <member name="M:DPSF.Position2D.CopyFrom(DPSF.Position2D)">
      <summary>
            Copies the given Position2D object's data into this objects data
            </summary>
      <param name="cPositionToCopy">The Position2D object to copy</param>
    </member>
    <member name="M:DPSF.Position2D.Update(System.Single)">
      <summary>
            Update the Position and Velocity according to the Acceleration
            </summary>
      <param name="fElapsedTimeInSeconds">The time Elapsed in Seconds since the last Update</param>
    </member>
    <member name="P:DPSF.Position2D.PositionVector3">
      <summary>
            Get / Set the object's 2D Position using a Vector3.
            <para>NOTE: The Z-value is ignored when Setting, and is given a value of zero when Getting.</para><para>NOTE: This function is provided for convenience when using 3D Vectors in 2D coordinate systems.</para></summary>
    </member>
    <member name="P:DPSF.Position2D.VelocityVector3">
      <summary>
            Get / Set the object's 2D Velocity using a Vector3.
            <para>NOTE: The Z-value is ignored when Setting, and is given a value of zero when Getting.</para><para>NOTE: This function is provided for convenience when using 3D Vectors in 2D coordinate systems.</para>para&gt;
            </summary>
    </member>
    <member name="P:DPSF.Position2D.AccelerationVector3">
      <summary>
            Get / Set the object's 2D Acceleration using a Vector3.
            <para>NOTE: The Z-value is ignored when Setting, and is given a value of zero when Getting.</para><para>NOTE: This function is provided for convenience when using 3D Vectors in 2D coordinate systems.</para>para&gt;
            </summary>
    </member>
    <member name="T:DPSF.Orientation3D">
      <summary>
            Class to hold and update an object's 3D Orientation, Rotational Velocity, and Rotational Acceleration
            </summary>
    </member>
    <member name="F:DPSF.Orientation3D.Orientation">
      <summary>
            The object's Orientation
            </summary>
    </member>
    <member name="F:DPSF.Orientation3D.RotationalVelocity">
      <summary>
            The object's Rotational Velocity around its center.
            <para>NOTE: Rotations are specified by giving a 3D Vector, where the direction is the axis to 
            rotate around, and the vector length is the amount (angle in radians) to rotate.
            It can also be thought of as Vector(PitchVelocity, YawVelocity, RollVelocity).</para></summary>
    </member>
    <member name="F:DPSF.Orientation3D.RotationalAcceleration">
      <summary>
            The object's Rotational Acceleration around its center.
            <para>NOTE: Rotations are specified by giving a 3D Vector, where the direction is the axis to 
             rotate around, and the vector length is the amount (angle in radians) to rotate.
             It can also be thought of as Vector(PitchAcceleration, YawAcceleration, RollAcceleration).</para></summary>
    </member>
    <member name="M:DPSF.Orientation3D.#ctor">
      <summary>
            Default Constructor
            </summary>
    </member>
    <member name="M:DPSF.Orientation3D.#ctor(DPSF.Orientation3D)">
      <summary>
            Copy Constructor
            </summary>
      <param name="cOrienationToCopy">The Orienation3D object to copy</param>
    </member>
    <member name="M:DPSF.Orientation3D.CopyFrom(DPSF.Orientation3D)">
      <summary>
            Copies the given Orientation3D object's data into this object's data
            </summary>
      <param name="cOrientationToCopy">The Orientation3D object to copy from</param>
    </member>
    <member name="M:DPSF.Orientation3D.Rotate(Microsoft.Xna.Framework.Matrix)">
      <summary>
            Rotates the object about its center, changing its Orientation
            </summary>
      <param name="sRotationMatrix">The Rotation to apply to the object</param>
    </member>
    <member name="M:DPSF.Orientation3D.Update(System.Single)">
      <summary>
            Update the Position and Velocity according to the Acceleration, as well as the Orientation
            according to the Rotational Velocity and Rotational Acceleration
            </summary>
      <param name="fElapsedTimeInSeconds">The time Elapsed in Seconds since the last Update</param>
    </member>
    <member name="M:DPSF.Orientation3D.Rotate(Microsoft.Xna.Framework.Matrix,Microsoft.Xna.Framework.Quaternion)">
      <summary>
            Returns the given Quaternion rotated about its center, changing its Orientation
            </summary>
      <param name="sRotationMatrix">The Rotation to apply to the Quaternion</param>
      <param name="sQuaterionToRotate">The Quaternion that should be Rotated</param>
      <returns>Returns the given Quaternion rotated about its center, changing its Orientation</returns>
    </member>
    <member name="M:DPSF.Orientation3D.GetRotationTo(Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3)">
      <summary>
            Returns the shortest arc Quaternion Rotation needed to rotate the CurrentDirection to
            be the same as the DestinationDirection.
            This method is based on Stan Melax's article in Game Programming Gems, and
            the code was referenced from OgreVector3.h of the Ogre library (www.Ogre3d.org)
            </summary>
      <param name="CurrentDirection">The current Direction the Vector is facing</param>
      <param name="DesiredDirection">The Direction we want the Vector to face</param>
      <returns>Returns the shortest arc Quaternion Rotation needed to rotate the CurrentDirection to
            be the same as the DestinationDirection.</returns>
    </member>
    <member name="M:DPSF.Orientation3D.GetRotationTo(Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3)">
      <summary>
            Returns the shortest arc Quaternion Rotation needed to rotate the CurrentDirection to
            be the same as the DestinationDirection.
            This method is based on Stan Melax's article in Game Programming Gems, and
            the code was referenced from OgreVector3.h of the Ogre library (www.Ogre3d.org)
            </summary>
      <param name="CurrentDirection">The current Direction the Vector is facing</param>
      <param name="DesiredDirection">The Direction we want the Vector to face</param>
      <param name="sFallbackAxis">The Axis to rotate around if a 180 degree rotation is required</param>
      <returns>Returns the shortest arc Quaternion Rotation needed to rotate the CurrentDirection to
            be the same as the DestinationDirection.</returns>
    </member>
    <member name="M:DPSF.Orientation3D.GetQuaternionWithOrientation(Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3)">
      <summary>
            Returns a Quaternion orientated according to the given Normal and Up Directions
            </summary>
      <param name="sNormalDirection">The Normal (forward) direction that the Quaternion should face</param>
      <param name="sUpDirection">The Up direction that the Quaternion should have</param>
      <returns>Returns a Quaternion orientated according to the given Normal and Up Directions</returns>
    </member>
    <member name="M:DPSF.Orientation3D.GetNormalDirection(Microsoft.Xna.Framework.Quaternion)">
      <summary>
            Returns the Normal (Forward) Direction of the given Quaternion
            </summary>
      <param name="sOrientation">The Quaternion whose Direction we want</param>
      <returns>Returns the Normal (Forward) Direction of the given Quaternion</returns>
    </member>
    <member name="M:DPSF.Orientation3D.SetNormalDirection(Microsoft.Xna.Framework.Quaternion@,Microsoft.Xna.Framework.Vector3)">
      <summary>
            Sets the Normal direction of the given Quaternion to be the given New Normal Direction
            </summary>
      <param name="sOrientation">The Quaternion to modify</param>
      <param name="sNewNormalDirection">The New Normal Direction the Quaternion should have</param>
    </member>
    <member name="M:DPSF.Orientation3D.GetUpDirection(Microsoft.Xna.Framework.Quaternion)">
      <summary>
            Returns the Up Direction of the given Quaternion
            </summary>
      <param name="sOrientation">The Quaternion whose Direction we want</param>
      <returns>Returns the Up Direction of the given Quaternion</returns>
    </member>
    <member name="M:DPSF.Orientation3D.SetUpDirection(Microsoft.Xna.Framework.Quaternion@,Microsoft.Xna.Framework.Vector3)">
      <summary>
            Sets the Up direction of the given Quaternion to be the given New Up Direction
            </summary>
      <param name="sOrientation">The Quaternion to modify</param>
      <param name="sNewUpDirection">The New Up Direction the Quaternion should have</param>
    </member>
    <member name="M:DPSF.Orientation3D.GetRightDirection(Microsoft.Xna.Framework.Quaternion)">
      <summary>
            Returns the Right Direction of the given Quaternion
            </summary>
      <param name="sOrientation">The Quaternion whose Direction we want</param>
      <returns>Returns the Right Direction of the given Quaternion</returns>
    </member>
    <member name="M:DPSF.Orientation3D.SetRightDirection(Microsoft.Xna.Framework.Quaternion@,Microsoft.Xna.Framework.Vector3)">
      <summary>
            Sets the Right direction of the given Quaternion to be the given New Right Direction
            </summary>
      <param name="sOrientation">The Quaternion to modify</param>
      <param name="sNewRightDirection">The New Right Direction the Quaternion should have</param>
    </member>
    <member name="P:DPSF.Orientation3D.Normal">
      <summary>
            Get / Set the Normal (i.e. Forward) direction of the object (i.e. which direction it is facing)
            </summary>
    </member>
    <member name="P:DPSF.Orientation3D.Up">
      <summary>
            Get / Set the Up direction of the object
            </summary>
    </member>
    <member name="P:DPSF.Orientation3D.Right">
      <summary>
            Get / Set the Right direction of the object
            </summary>
    </member>
    <member name="T:DPSF.Position3D">
      <summary>
            Class used to hold and update an object's 3D Position, Velocity, and Acceleration
            </summary>
    </member>
    <member name="F:DPSF.Position3D.Position">
      <summary>
            The object's Position
            </summary>
    </member>
    <member name="F:DPSF.Position3D.Velocity">
      <summary>
            The object's Velocity
            </summary>
    </member>
    <member name="F:DPSF.Position3D.Acceleration">
      <summary>
            The object's Acceleration
            </summary>
    </member>
    <member name="M:DPSF.Position3D.#ctor">
      <summary>
            Default Constructor
            </summary>
    </member>
    <member name="M:DPSF.Position3D.#ctor(DPSF.Position3D)">
      <summary>
            Copy Constructor
            </summary>
      <param name="cPositionToCopy">The Position3D object to copy</param>
    </member>
    <member name="M:DPSF.Position3D.CopyFrom(DPSF.Position3D)">
      <summary>
            Copy the given Position3D object's data into this objects data
            </summary>
      <param name="cPositionToCopy">The Position3D to copy from</param>
    </member>
    <member name="M:DPSF.Position3D.Update(System.Single)">
      <summary>
            Update the Position and Velocity according to the Acceleration
            </summary>
      <param name="fElapsedTimeInSeconds">The time Elapsed in Seconds since the last Update</param>
    </member>
    <member name="T:DPSF.DPSFDefaultNoDisplayParticleSystem`2">
      <summary>
            The Default No Display Particle System class
            </summary>
      <typeparam name="Particle">The Particle class to use</typeparam>
      <typeparam name="Vertex">The Vertex Format to use</typeparam>
    </member>
    <member name="M:DPSF.DPSFDefaultNoDisplayParticleSystem`2.#ctor(Microsoft.Xna.Framework.Game)">
      <summary>
            Constructor
            </summary>
      <param name="cGame">Handle to the Game object being used. Pass in null for this 
            parameter if not using a Game object.</param>
    </member>
    <member name="T:DPSF.DefaultNoDisplayParticleSystem">
      <summary>
            The Default No Display Particle System to inherit from, which uses Default Pixel Particles
            </summary>
    </member>
    <member name="M:DPSF.DefaultNoDisplayParticleSystem.#ctor(Microsoft.Xna.Framework.Game)">
      <summary>
            Constructor
            </summary>
      <param name="cGame">Handle to the Game object being used. Pass in null for this 
            parameter if not using a Game object.</param>
    </member>
    <member name="T:DPSF.DefaultNoDisplayParticle">
      <summary>
            Particle used by the No Display Particle System
            </summary>
    </member>
    <member name="T:DPSF.IDPSFParticleVertex">
      <summary>
            Interface that must be implemented by all Particle Vertex's
            </summary>
    </member>
    <member name="P:DPSF.IDPSFParticleVertex.VertexElements">
      <summary>
            An array describing the Elements of each Vertex
            </summary>
    </member>
    <member name="P:DPSF.IDPSFParticleVertex.SizeInBytes">
      <summary>
            The Size of one Vertex Element in Bytes
            </summary>
    </member>
    <member name="T:DPSF.DefaultNoDisplayParticleVertex">
      <summary>
            Dummy structure used for the vertices of a No Display particle system.
            Since the particles are not drawn, they do not have vertices, so this structure is empty.
            </summary>
    </member>
    <member name="P:DPSF.DefaultNoDisplayParticleVertex.VertexElements">
      <summary>
            An array describing the attributes of each Vertex
            </summary>
    </member>
    <member name="P:DPSF.DefaultNoDisplayParticleVertex.SizeInBytes">
      <summary>
            The Size of one Vertex in Bytes
            </summary>
    </member>
    <member name="T:DPSF.DPSFDefaultSpriteTextureCoordinatesParticleSystem`2">
      <summary>
            The Default Sprite with Texture Coordinates Particle System class
            </summary>
      <typeparam name="Particle">The Particle class to use</typeparam>
      <typeparam name="Vertex">The Vertex Format to use</typeparam>
    </member>
    <member name="M:DPSF.DPSFDefaultSpriteTextureCoordinatesParticleSystem`2.#ctor(Microsoft.Xna.Framework.Game)">
      <summary>
            Constructor
            </summary>
      <param name="cGame">Handle to the Game object being used. Pass in null for this 
            parameter if not using a Game object.</param>
    </member>
    <member name="M:DPSF.DPSFDefaultSpriteTextureCoordinatesParticleSystem`2.DrawSprite(DPSF.DPSFParticle,Microsoft.Xna.Framework.Graphics.SpriteBatch)">
      <summary>
            Function to draw a Sprite Particle. This function should be used to draw the given
            Particle with the provided SpriteBatch.
            </summary>
      <param name="Particle">The Particle Sprite to Draw</param>
      <param name="cSpriteBatch">The SpriteBatch to use to doing the Drawing</param>
    </member>
    <member name="T:DPSF.DPSFDefaultAnimatedSpriteParticleSystem`2">
      <summary>
            The Default Animated Sprite Particle System class
            </summary>
      <typeparam name="Particle">The Particle class to use</typeparam>
      <typeparam name="Vertex">The Vertex Format to use</typeparam>
    </member>
    <member name="M:DPSF.DPSFDefaultAnimatedSpriteParticleSystem`2.#ctor(Microsoft.Xna.Framework.Game)">
      <summary>
            Constructor
            </summary>
      <param name="cGame">Handle to the Game object being used. Pass in null for this 
            parameter if not using a Game object.</param>
    </member>
    <member name="M:DPSF.DPSFDefaultAnimatedSpriteParticleSystem`2.UpdateParticleAnimationAndTextureCoordinates(DPSF.DefaultAnimatedSpriteParticle,System.Single)">
      <summary>
            Updates the Animation, as well as the Particle's Texture Coordinates to match the Animation
            </summary>
      <param name="cParticle">The Particle to update</param>
      <param name="fElapsedTimeInSeconds">How long it has been since the last update</param>
    </member>
    <member name="M:DPSF.DPSFDefaultAnimatedSpriteParticleSystem`2.UpdateParticleToDieOnceAnimationFinishesPlaying(DPSF.DefaultAnimatedSpriteParticle,System.Single)">
      <summary>
            Updates the Particle to be removed from the Particle System once the Animation finishes Playing
            </summary>
      <param name="cParticle">The Particle to update</param>
      <param name="fElapsedTimeInSeconds">How long it has been since the last update</param>
    </member>
    <member name="T:DPSF.DefaultAnimatedSpriteParticleSystem">
      <summary>
            The Default Animated Sprite Particle System to inherit from, which uses Default Animated Sprite Particles
            </summary>
    </member>
    <member name="M:DPSF.DefaultAnimatedSpriteParticleSystem.#ctor(Microsoft.Xna.Framework.Game)">
      <summary>
            Constructor
            </summary>
      <param name="cGame">Handle to the Game object being used. Pass in null for this 
            parameter if not using a Game object.</param>
    </member>
    <member name="T:DPSF.DefaultSpriteTextureCoordinatesParticle">
      <summary>
            Particle used by the Default Sprite with Texture Coordinates Particle System
            </summary>
    </member>
    <member name="F:DPSF.DefaultSpriteTextureCoordinatesParticle.TextureCoordinates">
      <summary>
            The top-left Position and the Dimensions of this Picture in the Texture
            </summary>
    </member>
    <member name="M:DPSF.DefaultSpriteTextureCoordinatesParticle.SetTextureCoordinates(System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>
            Sets the Texture Coordinates to use for the Picture that represents this Particle
            </summary>
      <param name="iLeft">The X position of the top-left corner of the Picture in the Texture</param>
      <param name="iTop">The Y position of the top-left corner of the Picture in the Texture</param>
      <param name="iRight">The X position of the bottom-right corner of the Picture in the Texture</param>
      <param name="iBottom">The Y position of the bottom-right corner of the Picture in the Texture</param>
    </member>
    <member name="M:DPSF.DefaultSpriteTextureCoordinatesParticle.Reset">
      <summary>
            Resets the Particle variables to their default values
            </summary>
    </member>
    <member name="M:DPSF.DefaultSpriteTextureCoordinatesParticle.CopyFrom(DPSF.DPSFParticle)">
      <summary>
            Deep copy all of the Particle properties
            </summary>
      <param name="ParticleToCopy">The Particle to Copy the properties from</param>
    </member>
    <member name="T:DPSF.DefaultAnimatedSpriteParticle">
      <summary>
            Particle used by the Default Animated Sprite Particle System
            </summary>
    </member>
    <member name="F:DPSF.DefaultAnimatedSpriteParticle.Animation">
      <summary>
            Class to hold this Particle's Animation information
            </summary>
    </member>
    <member name="M:DPSF.DefaultAnimatedSpriteParticle.Reset">
      <summary>
            Resets the Particle variables to their default values
            </summary>
    </member>
    <member name="M:DPSF.DefaultAnimatedSpriteParticle.CopyFrom(DPSF.DPSFParticle)">
      <summary>
            Deep copy all of the Particle properties
            </summary>
      <param name="ParticleToCopy">The Particle to Copy the properties from</param>
    </member>
    <member name="T:DPSF.Animations">
      <summary>
            Class to hold a List of Animations and the texture coordintes of the Pictures used by the Animations.
            To start, Create Picture's of all images that will be used in any Animations. Then Create an Animation
            by specifying the order of the Picture IDs to go through, and the speed to flip through them at (i.e. frame-rate).
            </summary>
    </member>
    <member name="T:DPSF.Animations.SPicture">
      <summary>
            Structure to store an individual Picture's position and dimensions within a texture
            </summary>
    </member>
    <member name="M:DPSF.Animations.SPicture.#ctor(System.Int32,Microsoft.Xna.Framework.Rectangle)">
      <summary>
            Explicit constructor
            </summary>
      <param name="iID">The ID of this Picture (this should be unique)</param>
      <param name="sTextureCoordinates">The top-left (x,y) position and (width,height) dimensions
            of the Picture within the texture</param>
    </member>
    <member name="T:DPSF.Animations.Animation">
      <summary>
            Class to hold a single Animation's (i.e. Walking, Running, Jumping, etc) sequence of 
            Pictures and how long to display each Picture in the Animation for
            </summary>
    </member>
    <member name="M:DPSF.Animations.Animation.#ctor(System.Int32,System.Collections.Generic.List{System.Int32},System.Single,System.Int32)">
      <summary>
            Explicit Constructor
            </summary>
      <param name="iID">The ID of this Animation (this should be unique)</param>
      <param name="cPictureRotationOrder">A List of Picture ID's which tell the sequence of 
            Pictures that make up the Animation</param>
      <param name="fPictureRotationTime">How long (in seconds) to wait before switching to the
            next Picture in the Picture Rotation Order</param>
      <param name="iNumberOfTimesToPlay">The Number of Times the Animation should Play before stopping. A value
            of zero means the Animation should repeat forever.</param>
    </member>
    <member name="M:DPSF.Animations.Animation.MoveToNextPictureInAnimation">
      <summary>
            Moves the Current Picture Index to the next element in the Picture Rotation Order, and loops
            if it reaches the end of the Animation
            </summary>
    </member>
    <member name="P:DPSF.Animations.Animation.CurrentPicturesID">
      <summary>
            Returns the Picture ID of the Current Picture being displayed.
            </summary>
    </member>
    <member name="P:DPSF.Animations.Animation.AnimationHasEnded">
      <summary>
            Get if the Animation has finished Playing or not.
            NOTE: Animations with Number Of Times To Play == 0 will never end
            </summary>
    </member>
    <member name="M:DPSF.Animations.CopyFrom(DPSF.Animations)">
      <summary>
            Copies the given Animations data into this Animation
            </summary>
      <param name="cAnimationToCopy">The Animation to Copy from</param>
    </member>
    <member name="M:DPSF.Animations.CreatePicture(Microsoft.Xna.Framework.Rectangle)">
      <summary>
            Creates a Picture that can be used in a Animation, and returns its unique ID. 
            A Picture can be used multiple times in an Animation.
            </summary>
      <param name="sTextureCoordinates">The top-left (x,y) position and (width,height) dimensions
            in the Texture that form this Picture</param>
      <returns>Returns the new Picture's unique ID.</returns>
    </member>
    <member name="M:DPSF.Animations.CreatePicturesFromTileSet(System.Int32,System.Int32,Microsoft.Xna.Framework.Rectangle)">
      <summary>
            Automatically creates the specified Total Number Of Pictures. All pictures are assumed to have 
            the same width and height, as specified in the First Picture rectangle. Also, the First Picture
            is assumed to be at the top-left corner of the Tileset.
            <para>Pictures are created in left-to-right, top-to-bottom order. The ID of the first Picture created
            is returned, with each new Picture created incrementing the ID value, so the last Picture created
            will have an ID of (returned ID + (Total Number Of Pictures - 1)).</para></summary>
      <param name="iTotalNumberOfPictures">The Total Number Of Pictures in the Tileset</param>
      <param name="iPicturesPerRow">How many Pictures are in a row in the texture</param>
      <param name="sFirstPicture">The Position of the top-left Picture in the Tileset, and the
            width and height of each Picture in the Tileset</param>
      <returns>The ID of the first Picture created
            is returned, with each new Picture created incrementing the ID value, so the last Picture created
            will have an ID of (returned ID + (Total Number Of Pictures - 1)).</returns>
    </member>
    <member name="M:DPSF.Animations.CreateAnimation(System.Collections.Generic.List{System.Int32},System.Single,System.Int32)">
      <summary>
            Creates a new Animation and returns the Animation's unique ID.
            <para>NOTE: Returns -1 if an invalid Picture ID was specified in the PictureRotationOrder.</para><para>NOTE: Be sure to Create the Pictures before creating the Animation.</para></summary>
      <param name="cPictureRotationOrder">A List of Picture IDs that specifies the Order of Pictures
            to Rotate through in order to produce the Animation. A single Picture ID can be used many times.</param>
      <param name="fPictureRotationTime">How long (in seconds) to wait before switching to the
            next Picture in the Picture Rotation Order (i.e. The frame-rate of the Animation)</param>
      <param name="iNumberOfTimesToPlay">The number of times this Animation should be played 
            (it replays when the end of the Animation is reached). Specify a value of zero to have the 
            Animation repeat forever</param>
      <returns>Returns the new Animation's unique ID.</returns>
    </member>
    <member name="M:DPSF.Animations.CreateAnimation(System.Int32[],System.Single,System.Int32)">
      <summary>
            Creates a new Animation and returns the Animation's unique ID.
            <para>NOTE: Returns -1 if an invalid Picture ID was specified in the PictureRotationOrder.</para><para>NOTE: Be sure to Create the Pictures before creating the Animation.</para></summary>
      <param name="iaPictureRotationOrder">An array of Picture IDs that specifies the Order of Pictures
            to Rotate through in order to produce the Animation</param>
      <param name="fPictureRotationTime">How long (in seconds) to wait before switching to the
            next Picture in the Picture Rotation Order (i.e. The next Frame in the Animation)</param>
      <param name="iNumberOfTimesToPlay">The number of times this Animation should be played 
            (it replays when the end of the Animation is reached). Specify a value of zero to have the 
            Animation repeat forever</param>
      <returns>Returns the new Animation's unique ID.
            NOTE: Returns -1 if an invalid Picture ID was specified in the PictureRotationOrder.</returns>
    </member>
    <member name="M:DPSF.Animations.PictureIDIsValid(System.Int32)">
      <summary>
            Returns true if the given Picture ID is valid (i.e. A Picture with the same ID exists).
            </summary>
      <param name="iPictureID">The Picture ID to look for</param>
      <returns>Returns true if the given Picture ID is valid (i.e. A Picture with the same ID exists).</returns>
    </member>
    <member name="M:DPSF.Animations.AnimationIDIsValid(System.Int32)">
      <summary>
            Returns true if the given Animation ID is valid (i.e. An Animation with the same ID exists).
            </summary>
      <param name="iAnimationID">The Animation ID to look for</param>
      <returns>Returns true if the given Animation ID is valid (i.e. An Animation with the same ID exists).</returns>
    </member>
    <member name="M:DPSF.Animations.SetCurrentAnimationAndPositionInAnimation(System.Int32,System.Int32)">
      <summary>
            Sets the Current Animation being used, as well as what index in the Animation's Picture Rotation
            Order the Animation should start at. 
            <para>NOTE: If the specified Animiation to use is not valid, the Current Animation will not be 
            changed, and if the specified Picture Rotation Order Index is not valid, the Animation will 
            start from the beginning of the Animation.</para></summary>
      <param name="iAnimationID">The ID of the Animation to use</param>
      <param name="iPictureRotationOrderIndex">The Index in the Animation's Picture Rotation Order
            that the Animation should begin playing from</param>
    </member>
    <member name="M:DPSF.Animations.GetAnimationsPictureRotationTime(System.Int32)">
      <summary>
            Returns how much Time (in seconds) should elapse before switching frames in the Animation.
            <para>NOTE: Returns zero if the specified Animation ID is not valid.</para></summary>
      <param name="iAnimationID">The ID of the Animation containing the Picture Rotation Time to retrive</param>
      <returns>Returns how much Time (in seconds) should elapse before switching frames in the Animation.
            NOTE: Returns zero if the specified Animation ID is not valid.</returns>
    </member>
    <member name="M:DPSF.Animations.SetAnimationsPictureRotationTime(System.Int32,System.Single)">
      <summary>
            Sets how much Time should elapse before switching frames in the Animation
            </summary>
      <param name="iAnimationID">The ID of the Animation to update</param>
      <param name="fNewPictureRotationTime">The Time (in seconds) to wait before moving to the
            next Picture in the Animations Picture Rotation Order</param>
    </member>
    <member name="M:DPSF.Animations.GetAnimationsNumberOfTimesToPlay(System.Int32)">
      <summary>
            Returns the Number of times the given Animation ID is set to Play.
            Zero means the Animation will repeat forever.
            <para>NOTE: If the given Animation ID is invalid, -1 is returned.</para></summary>
      <param name="iAnimationID">The ID of the Animation to update</param>
      <returns>Returns the Number of times the given Animation ID is set to Play.
            Zero means the Animation will repeat forever.
            NOTE: If the given Animation ID is invalid, -1 is returned.</returns>
    </member>
    <member name="M:DPSF.Animations.SetAnimationsNumberOfTimesToPlay(System.Int32,System.Int32)">
      <summary>
            Sets the Number of times the given Animation ID should Play
            (it replays when the end of the Animation is reached). 
            Specify a value of zero to have the Animation repeat forever.
            <para>NOTE: If the given Animation ID is invalid, no changes are made.</para></summary>
      <param name="iAnimationID">The ID of the Animation to update</param>
      <param name="iNewNumberOfTimesToPlay">The New Number of times the Animation should Play</param>
    </member>
    <member name="M:DPSF.Animations.TimeRequiredToPlayAnimation(System.Int32)">
      <summary>
            Returns the amount of Time required to play the specified Animation.
            <para>NOTE: If an invalid AnimationID is specified, zero is returned.</para></summary>
      <param name="iAnimationID">The ID of the Animation to check</param>
      <returns>Returns the amount of Time required to play the specified Animation.
            NOTE: If an invalid AnimationID is specified, zero is returned.</returns>
    </member>
    <member name="M:DPSF.Animations.GetPicturesTextureCoordinates(System.Int32)">
      <summary>
            Returns the Rectangle representing the Texture Coordinates of the specified Picture.
            </summary>
      <param name="iPictureID">The Picture ID of the Picture whose Texture Coordinates 
            should be retrieved</param>
      <returns>Returns the Rectangle representing the Texture Coordinates of the specified Picture.</returns>
    </member>
    <member name="M:DPSF.Animations.Update(System.Single)">
      <summary>
            Updates the Animation according to how much time has elapsed
            </summary>
      <param name="fElapsedTime">The amount of Time (in seconds) since the last Update</param>
    </member>
    <member name="P:DPSF.Animations.CurrentAnimationID">
      <summary>
            Get / Set the Current Animation being used. The Animation is started at its beginning.
            <para>NOTE: If an invalid Animiation ID is given when Setting, the Animation will not be changed.</para><para>NOTE: If an Animation has not beeng set yet when Getting, -1 is returned.</para></summary>
    </member>
    <member name="P:DPSF.Animations.CurrentAnimationsPictureRotationTime">
      <summary>
            Get / Set how much Time should elapsed before switching frames in the Current Animation. 
            <para>NOTE: If no Animation has been set yet, zero will be returned.</para></summary>
    </member>
    <member name="P:DPSF.Animations.CurrentAnimationsPictureRotationOrderIndex">
      <summary>
            Get / Set the Current Index in the Current Animation's Picture Rotation Order. 
            <para>NOTE: If no Animation has been set yet, Get returns -1, and Set doesn't change anything 
            (as well as if the specified Index is invalid).</para></summary>
    </member>
    <member name="P:DPSF.Animations.CurrentAnimationsNumberOfTimesToPlay">
      <summary>
            Get / Set the Number of times the Current Animation should Play
            (it replays when the end of the Animation is reached). 
            Specify a value of zero to have the Animation repeat forever.
            <para>NOTE: If no Animation has been set yet, no changes are made when
            Setting, and -1 is returned when Getting.</para></summary>
    </member>
    <member name="P:DPSF.Animations.CurrentAnimationsNumberOfTimesPlayed">
      <summary>
            Get / Set the Number of times the Current Animation has Played already.
            <para>NOTE: If no Animation has been set yet, Get returns -1, and Set doesn't change anything.</para></summary>
    </member>
    <member name="P:DPSF.Animations.CurrentAnimationIsDonePlaying">
      <summary>
            Get if the Current Animation is Done Playing or not (i.e. Its Number Of Times Played is
            greater than or equal to its Number Of Times To Play). Returns true even if no
            Animation has been set to Play yet.
            </summary>
    </member>
    <member name="P:DPSF.Animations.TimeRequiredToPlayCurrentAnimation">
      <summary>
            Gets the amount of Time (in seconds) required to play the Current Animation.
            <para>NOTE: If no Animation has been played yet, zero is returned.</para></summary>
    </member>
    <member name="P:DPSF.Animations.TimeRequiredToPlayTheRestOfTheCurrentAnimation">
      <summary>
            Gets the amount of Time (in seconds) required to play the remainder of the Current Animation.
            <para>NOTE: If no Animation has been played yet, zero is returned.</para></summary>
    </member>
    <member name="P:DPSF.Animations.CurrentPicturesTextureCoordinates">
      <summary>
            Get the Rectangle representing the Texture Coordinates of the Picture 
            in the Animation that should be displayed at this point in time
            </summary>
    </member>
    <member name="P:DPSF.Animations.Paused">
      <summary>
            Get / Set if the Animation should be Paused or not. If Paused, the Animation will
            not be Updated.
            </summary>
    </member>
    <member name="P:DPSF.Animations.CurrentAnimationIsValid">
      <summary>
            Get if the Current Animation has been set yet or not
            </summary>
    </member>
    <member name="T:DPSF.DefaultQuadParticleSystem">
      <summary>
            The Default Quad Particle System to inherit from, which uses Default Quad Particles
            </summary>
    </member>
    <member name="M:DPSF.DefaultQuadParticleSystem.#ctor(Microsoft.Xna.Framework.Game)">
      <summary>
            Constructor
            </summary>
      <param name="cGame">Handle to the Game object being used. Pass in null for this 
            parameter if not using a Game object.</param>
    </member>
    <member name="T:DPSF.DefaultQuadParticleVertex">
      <summary>
            Structure used to hold a Default Quad Particle's Vertex's properties used for drawing.
            This contains a Vector3 Position and a Color Color.
            </summary>
    </member>
    <member name="F:DPSF.DefaultQuadParticleVertex.Position">
      <summary>
            The Position of the vertex in 3D space. The position of this vertex
            relative to the quads other three vertices determines the Particle's orientation.
            </summary>
    </member>
    <member name="F:DPSF.DefaultQuadParticleVertex.Color">
      <summary>
            The Color of the vertex
            </summary>
    </member>
    <member name="P:DPSF.DefaultQuadParticleVertex.VertexElements">
      <summary>
            An array describing the attributes of each Vertex
            </summary>
    </member>
    <member name="P:DPSF.DefaultQuadParticleVertex.SizeInBytes">
      <summary>
            The Size of one Vertex in Bytes
            </summary>
    </member>
    <member name="T:DPSF.AutoMemoryManagerModes">
      <summary>
            The possible Modes the Automatic Memory Manager can be in
            </summary>
    </member>
    <member name="F:DPSF.AutoMemoryManagerModes.Disabled">
      <summary>
            Do not use the Automatic Memory Manager. The Number Of Particles Allocated In Memory will not be changed dynamically at run-time.
            This is the best option if performance is critical, as it can be expensive to allocate and release large chunks of memory at 
            run-time. If using this mode you should be sure that the Number Of Particles Allocated In Memory is large enough to accommodate 
            the particle system, but small enough that it does not waste large amounts of memory.
            </summary>
    </member>
    <member name="F:DPSF.AutoMemoryManagerModes.IncreaseAndDecrease">
      <summary>
            Allow the Automatic Memory Manager to allocate more memory when needed, and reduce it when not needed.
            </summary>
    </member>
    <member name="F:DPSF.AutoMemoryManagerModes.IncreaseOnly">
      <summary>
            Only allow the Automatic Memory Manager to allocate more memory when needed (cannot reduce space).
            </summary>
    </member>
    <member name="F:DPSF.AutoMemoryManagerModes.DecreaseOnly">
      <summary>
            Only allow the Automatic Memory Manager to reduce the amount of memory allocated when it is not needed (cannot increase space).
            </summary>
    </member>
    <member name="T:DPSF.AutoMemoryManagerSettings">
      <summary>
            Class to hold the Automatic Memory Manager Settings
            </summary>
    </member>
    <member name="F:DPSF.AutoMemoryManagerSettings.MemoryManagementMode">
      <summary>
            The Memory Management Mode being used.
            <para>NOTE: Default value is AutoMemoryManagerModes.IncreaseAndDecrease.</para></summary>
    </member>
    <member name="P:DPSF.AutoMemoryManagerSettings.AbsoluteMinNumberOfParticles">
      <summary>
            The Absolute Minimum Number Of Particles this Particle System has to have memory allocated for.
            The Automatic Memory Manager will never allocate space for fewer Particles than this.
            <para>NOTE: This value must be greater than zero.</para><para>NOTE: Default value is 10.</para></summary>
    </member>
    <member name="P:DPSF.AutoMemoryManagerSettings.ReduceAmount">
      <summary>
            The Automatic Memory Manager keeps track of the Max Particles that were Active in a single
            frame over the last X seconds (call this number M). If the Max Number Of Particles is greater
            than M, the Automatic Memory Manager can de-allocate unused memory. The Reduce Amount determines
            how much more memory than M to allocate. For example, setting the Reduce Amount to 1.0 would set
            the Max Number Of Particles to M. Setting the Reduce Amount to 1.1 would set the Max Number Of
            Particles to M + 10%. Setting it to 2.0 would set the Max Number Of Particles to M + 100% (i.e. M * 2).
            <para>NOTE: This value is clamped to the range 1.0 - 2.0.</para><para>NOTE: The Automatic Memory Manager will never reduce the amount of memory to be less than
            what is required for the Absolute Min Number Of Particles.</para><para>NOTE: Default value is 1.1.</para></summary>
    </member>
    <member name="P:DPSF.AutoMemoryManagerSettings.IncreaseAmount">
      <summary>
            The amount the Automatic Memory Manager increases the memory allocated for Particles by.
            When adding a new Particle, if we discover that the Number Of Active Particles has reached
            the Max Number Of Particles, the Automatic Memory Manager will increase the Max Number Of
            Particles by the Increase Amount. For example, if the Increase Amount is set to 2.0, then 
            the Max Number Of Particles will be doubled (200%). If it is set to 3.0 it will be tripled 
            (300%). If it is set to 0.5, the Max Number Of Particles will be increased to 150%.
            <para>NOTE: This value is clamped to the range 1.01 - 10.0 (i.e. 101% - 1000%).</para><para>NOTE: The Automatic Memory Manager will never increase the amount of memory to be more than
            what is required by the Absolute Max Number Of Particles.</para><para>NOTE: Default value is 2.0.</para></summary>
    </member>
    <member name="P:DPSF.AutoMemoryManagerSettings.SecondsMaxNumberOfParticlesMustExistForBeforeReducingSize">
      <summary>
            The Automatic Memory Manager keeps track of the Max Particles that were Active in a single
            frame over the last X seconds (call this number M). If the Max Number Of Particles is greater
            than M, the Automatic Memory Manager can de-allocate unused memory. The Seconds Max Number Of 
            Particles Must Exist For Before Reducing Size tells how long M must be unchanged for before
            the Automatic Memory Manager can reduce the amount of allocated memory.
            <para>NOTE: This value must be greater than zero.</para><para>NOTE: Default value is 3.0.</para></summary>
    </member>
    <member name="T:DPSF.DPSFHelper">
      <summary>
            Collection of static functions for performing common operations
            </summary>
    </member>
    <member name="M:DPSF.DPSFHelper.RandomNumberBetween(System.Single,System.Single)">
      <summary>
            Returns a random number between the specified values
            </summary>
      <param name="fValue1">The first value</param>
      <param name="fValue2">The second value</param>
      <returns>Returns a random number between the specified values</returns>
    </member>
    <member name="M:DPSF.DPSFHelper.FadeInQuicklyAndFadeOutSlowlyBasedOnLifetime(System.Single)">
      <summary>
            Returns how transparent a Particle should be, based on it's Normalized Elapsed Time, so that it
            fades in quickly and fades out slowly.
            </summary>
      <param name="fNormalizedElapsedTime">The current Normalized Elapsed Time (0.0 - 1.0) of a Particle</param>
      <returns>Returns the Alpha Color component that should be used for the Particle</returns>
    </member>
    <member name="M:DPSF.DPSFHelper.FadeInQuicklyAndFadeOutQuicklyBasedOnLifetime(System.Single)">
      <summary>
            Returns how transparent a Particle should be, based on it's Normalized Elapsed Time, so that it
            fades in quickly and fades out quickly.
            </summary>
      <param name="fNormalizedElapsedTime">The current Normalized Elapsed Time (0.0 - 1.0) of a Particle</param>
      <returns>Returns the Alpha Color component that should be used for the Particle</returns>
    </member>
    <member name="M:DPSF.DPSFHelper.InterpolationAmountForEqualLerpInAndLerpOut(System.Single)">
      <summary>
            Returns the interpolation amount (between 0.0 and 1.0) that should be used in a Lerp function to have a 
            property reach its full value when the NormalizedLifetime reaches 0.5, and go back to its original value 
            by the time the NormalizedLifetime reaches 1.0.
            <para>An example of where to use this would be if you wanted a particle to start off small, and reach
            its full size when the particle's lifetime is half over, and then to shrink back to being small by the
            time the particle dies. You would use the value returned by this function as the interpolation amount
            for the Lerp function. e.g. MathHelper.Lerp(SmallSize, LargeSize, ValueReturnedByThisFunction).</para></summary>
      <param name="fNormalizedElapsedTime">The current Normalized Elapsed Time (0.0 - 1.0) of a Particle</param>
      <returns>Returns the interpolation amount (between 0.0 and 1.0) that should be used in a Lerp function to have a 
            property reach its full value when the NormalizedLifetime reaches 0.5, and go back to its original value 
            by the time the NormalizedLifetime reaches 1.0.</returns>
    </member>
    <member name="M:DPSF.DPSFHelper.RandomNormalizedVector">
      <summary>
            Returns a vector with a Random direction that has been Normalized.
            </summary>
      <returns>Returns a vector with a Random direction that has been Normalized.</returns>
    </member>
    <member name="M:DPSF.DPSFHelper.SourceToTargetVector(Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3)">
      <summary>
            Returns a vector representing the line from the source point to the target point.
            </summary>
      <param name="source">The source position.</param>
      <param name="target">The target position.</param>
      <returns>Returns a vector representing the line from the source point to the target point.</returns>
    </member>
    <member name="M:DPSF.DPSFHelper.SourceToTargetDirection(Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3)">
      <summary>
            Returns a normalized vector representing the direction that points from the source point to the target point.
            </summary>
      <param name="source">The source position.</param>
      <param name="target">The target position.</param>
      <returns>Returns a normalized vector representing the direction that points from the source point to the target point.</returns>
    </member>
    <member name="M:DPSF.DPSFHelper.RandomVectorBetweenTwoVectors(Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3)">
      <summary>
            Returns a Vector whose individual XYZ components are each randomly chosen to be somewhere 
            between the two given Vectors' individual XYZ components. Unlike choosing a random Lerp value
            between two vectors, which would give a point somewhere on the LINE between the two points, this
            chooses a random Lerp value between each of the two vectors individual xyz components, returning
            a point somewhere in the cube-shaped AREA (i.e. Volume) between the two points.
            </summary>
      <param name="sVector1">The first Vector</param>
      <param name="sVector2">The second Vector</param>
      <returns>Returns a Vector whose individual XYZ components are each randomly chosen to be somewhere 
            between the two given Vectors' individual XYZ components.</returns>
    </member>
    <member name="M:DPSF.DPSFHelper.RandomColor">
      <summary>
            Returns a random opaque Color (i.e. no transparency)
            </summary>
      <returns>Returns a random opaque Color (i.e. no transparency)</returns>
    </member>
    <member name="M:DPSF.DPSFHelper.RandomColorWithRandomTransparency">
      <summary>
            Returns a random Color with a random alpha value as well (i.e. random transparency)
            </summary>
      <returns>Returns a random Color with a random alpha value as well (i.e. random transparency)</returns>
    </member>
    <member name="M:DPSF.DPSFHelper.LerpColor(Microsoft.Xna.Framework.Color,Microsoft.Xna.Framework.Color,System.Single)">
      <summary>
            Returns the linearly interpolated Color between Color 1 and Color 2
            </summary>
      <param name="sColor1">The Color value used with InterpolationAmount 0.0</param>
      <param name="sColor2">The Color value used with InterpolationAmount 1.0</param>
      <param name="fInterpolationAmount">A value between 0.0 and 1.0 indicating how 
            much to interpolate the RGBA values between Color 1 and Color 2</param>
      <returns>Returns the interpolated Color</returns>
    </member>
    <member name="M:DPSF.DPSFHelper.LerpColor(Microsoft.Xna.Framework.Color,Microsoft.Xna.Framework.Color,System.Single,System.Single,System.Single,System.Single)">
      <summary>
            Returns the linearly interpolated Color between Color 1 and Color 2
            </summary>
      <param name="sColor1">The Color value used with InterpolationAmount 0.0</param>
      <param name="sColor2">The Color value used with InterpolationAmount 1.0</param>
      <param name="fRInterpolationAmount">A value between 0.0 and 1.0 indicating how 
            much to interpolate the Red value between Color 1 and Color 2</param>
      <param name="fGInterpolationAmount">A value between 0.0 and 1.0 indicating how 
            much to interpolate the Green value between Color 1 and Color 2</param>
      <param name="fBInterpolationAmount">A value between 0.0 and 1.0 indicating how 
            much to interpolate the Blue value between Color 1 and Color 2</param>
      <param name="fAInterpolationAmount">A value between 0.0 and 1.0 indicating how 
            much to interpolate the Alpha value between Color 1 and Color 2</param>
      <returns>Returns the interpolated Color</returns>
    </member>
    <member name="M:DPSF.DPSFHelper.PointOnCircle(System.Single)">
      <summary>
            Returns a point on a circle with a radius of one, on the X-Y axis plane. 
            To use a different radius simply multiply the returned value by the desired radius value.
            </summary>
      <param name="fAngle">The angle on the circle in radians</param>
      <returns>Returns a 2D position on a circle</returns>
    </member>
    <member name="M:DPSF.DPSFHelper.PointOnCircleVector3(System.Single)">
      <summary>
            Returns a point on a circle with a radius of one, on the X-Y axis plane (Z value of zero). 
            To use a different radius simply multiply the returned value by the desired radius value.
            </summary>
      <param name="fAngle">The angle on the circle in radians</param>
      <returns>Returns a 3D position on a circle</returns>
    </member>
    <member name="M:DPSF.DPSFHelper.RandomPointOnCircle">
      <summary>
            Returns a random point on a circle with a radius of one, on the X-Y axis plane. 
            To use a different radius simply multiply the returned value by the desired radius value.
            </summary>
      <returns>Returns a random 2D position on a circle</returns>
    </member>
    <member name="M:DPSF.DPSFHelper.RandomPointOnCircleVector3">
      <summary>
            Returns a random point on a circle with a radius of one, on the X-Y axis plane (Z value of zero). 
            To use a different radius simply multiply the returned value by the desired radius value.
            </summary>
      <returns>Returns a random 3D position on a circle, with a Z value of zero</returns>
    </member>
    <member name="M:DPSF.DPSFHelper.NormalizedPointOnSphere(System.Single,System.Single)">
      <summary>
            Returns a point on a sphere with a radius of one.  To use a different radius simply 
            multiply the returned value by the desired radius value, before translating it
            to the sphere's position in world coordinates.  To create a circle simply use a
            constant value for one of the Angles while changing the other Angle.
            </summary>
      <param name="fYawAngle">Imagine a point on the surface of the sphere at the front 
            center of the sphere. This value will be how much to rotate that point around the 
            horizontal ring around the center of the sphere, in radians.</param>
      <param name="fPitchAngle">This value will be how much to rotate that point around 
            the vertical ring around the sphere, at the current position of the point, in radians.</param>
      <returns>Returns a point on a sphere with a radius of one</returns>
    </member>
    <member name="M:DPSF.DPSFHelper.RandomNormalizedPointOnSphere">
      <summary>
            Returns a random point on a sphere with a radius of one.  To use a different radius simply 
            multiply the returned value by the desired radius value, before translating it
            to the sphere's position in world coordinates.
            </summary>
      <returns>Returns a random point on a sphere with a radius of one</returns>
    </member>
    <member name="M:DPSF.DPSFHelper.PointOnSphere(System.Single,System.Single,System.Single)">
      <summary>
            Returns a point on a sphere with the given Radius. To create a circle simply use a
            constant value for one of the Angles while changing the other Angle.
            </summary>
      <param name="fYawAngle">Imagine a point on the surface of the sphere at the front 
            center of the sphere. This value will be how much to rotate that point around the 
            horizontal ring around the center of the sphere, in radians.</param>
      <param name="fPitchAngle">This value will be how much to rotate that point around 
            the vertical ring around the sphere, at the current position of the point, in radians.</param>
      <param name="fRadius">The radius the sphere should have</param>
      <returns>Returns a point on a sphere with the given radius</returns>
    </member>
    <member name="M:DPSF.DPSFHelper.RandomPointOnSphere(System.Single)">
      <summary>
            Returns a random point on a sphere with the given Radius
            </summary>
      <param name="fRadius">The radius the sphere should have</param>
      <returns>Returns a random point on a sphere with the given Radius</returns>
    </member>
    <member name="M:DPSF.DPSFHelper.PointOnSphere(System.Single,System.Single,System.Single,Microsoft.Xna.Framework.Vector3)">
      <summary>
            Returns a point on a sphere with the given Radius, at the specified Sphere Position.
            To create a circle simply use a constant value for one of the Angles while changing 
            the other Angle.
            </summary>
      <param name="fYawAngle">Imagine a point on the surface of the sphere at the front 
            center of the sphere. This value will be how much to rotate that point around the 
            horizontal ring around the center of the sphere, in radians.</param>
      <param name="fPitchAngle">This value will be how much to rotate that point around 
            the vertical ring around the sphere, at the current position of the point, in radians.</param>
      <param name="fRadius">The radius the sphere should have</param>
      <param name="sSpherePosition">The center position of the sphere in world coordinates</param>
      <returns>Returns a point on a sphere with the given Radius, at the specified Sphere Position</returns>
    </member>
    <member name="M:DPSF.DPSFHelper.RandomPointOnSphere(System.Single,Microsoft.Xna.Framework.Vector3)">
      <summary>
            Returns a random point on a sphere with the given Radius, at the specified Sphere Position
            </summary>
      <param name="fRadius">The radius the sphere should have</param>
      <param name="sSpherePosition">The center position of the sphere in world coordinates</param>
      <returns>Returns a random point on a sphere with the given Radius, at the specified Sphere Position</returns>
    </member>
    <member name="M:DPSF.DPSFHelper.VectorsAreEqualWithinTolerance(Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,System.Single)">
      <summary>
            Returns true if the difference between the individual XYZ components of the
            given Vectors are all less than the specified Tolerance
            </summary>
      <param name="sVector1">The first Vector</param>
      <param name="sVector2">The second Vector</param>
      <param name="fTolerance">How much of a difference there may be between the individual
            XYZ components for them to be considered equal</param>
      <returns>Returns true if the difference between the individual XYZ components of the
            given Vectors are each less than the specified Tolerance</returns>
    </member>
    <member name="M:DPSF.DPSFHelper.CloneBlendState(Microsoft.Xna.Framework.Graphics.BlendState)">
      <summary>
            Returns a clone of the given BlendState.
            Read-only properties, such as the GraphicsDevice property, are not copied though.
            </summary>
      <param name="blendStateToClone">The BlendState to clone.</param>
    </member>
    <member name="M:DPSF.DPSFHelper.CloneDepthStencilState(Microsoft.Xna.Framework.Graphics.DepthStencilState)">
      <summary>
            Returns a clone of the given DepthStencilState.
            Read-only properties, such as the GraphicsDevice property, are not copied though.
            </summary>
      <param name="depthStencilStateToClone">The DepthStencilState to clone.</param>
    </member>
    <member name="M:DPSF.DPSFHelper.CloneRasterizerState(Microsoft.Xna.Framework.Graphics.RasterizerState)">
      <summary>
            Returns a clone of the given RasterizerState.
            Read-only properties, such as the GraphicsDevice property, are not copied though.
            </summary>
      <param name="rasterizerStateToClone">The RasterizerState to clone.</param>
    </member>
    <member name="M:DPSF.DPSFHelper.CloneSamplerState(Microsoft.Xna.Framework.Graphics.SamplerState)">
      <summary>
            Returns a clone of the given SamplerState.
            Read-only properties, such as the GraphicsDevice property, are not copied though.
            </summary>
      <param name="samplerStateToClone">The SamplerState to clone.</param>
    </member>
    <member name="P:DPSF.DPSFHelper.Version">
      <summary>
            Return the version of the DPSF.dll being used. 
            This includes the Major, Minor, Build, and Revision numbers.
            </summary>
    </member>
    <member name="P:DPSF.DPSFHelper.DPSFInheritsDrawableGameComponent">
      <summary>
            Get if the Particle Systems are inheriting from DrawableGameComponent or not.
            <para>If inheriting from DrawableGameComponent, the Particle Systems
            are automatically added to the given Game object's Components and the
            Update() and Draw() functions are automatically called by the
            Game object when it updates and draws the rest of its Components.</para><para>If the Update() and Draw() functions are called by the user anyways,
            they will exit without performing any operations, so it is suggested
            to include them anyways to make switching between inheriting and
            not inheriting from DrawableGameComponent seamless; just be aware
            that the updates and draws are actually being performed when the
            Game object is told to update and draw (i.e. when base.Update() and base.Draw()
            are called), not when the particle system functions are called.</para></summary>
    </member>
    <member name="T:DPSF.DefaultSpriteParticleSystem">
      <summary>
            The Default Sprite Particle System to inherit from, which uses Default Sprite Particles
            </summary>
    </member>
    <member name="M:DPSF.DefaultSpriteParticleSystem.#ctor(Microsoft.Xna.Framework.Game)">
      <summary>
            Constructor
            </summary>
      <param name="cGame">Handle to the Game object being used. Pass in null for this 
            parameter if not using a Game object.</param>
    </member>
    <member name="T:DPSF.DefaultSpriteParticleVertex">
      <summary>
            Dummy structure used for the vertices of Default Sprites. Since Sprites are drawn using a 
            SpriteBatch, they do not have vertices, so this structure is empty.
            </summary>
    </member>
    <member name="P:DPSF.DefaultSpriteParticleVertex.VertexElements">
      <summary>
            An array describing the attributes of each Vertex
            </summary>
    </member>
    <member name="P:DPSF.DefaultSpriteParticleVertex.SizeInBytes">
      <summary>
            The Size of one Vertex in Bytes
            </summary>
    </member>
    <member name="T:DPSF.ParticleSystemManager">
      <summary>
            Class to manage the Updating and Drawing of DPSF Particle Systems each frame
            </summary>
    </member>
    <member name="M:DPSF.ParticleSystemManager.CopyFrom(DPSF.ParticleSystemManager)">
      <summary>
            Copies the given DPSF Particle System Manager's information into this Manager
            </summary>
      <param name="cManagerToCopy">The Manager To Copy from</param>
    </member>
    <member name="M:DPSF.ParticleSystemManager.SetSimulationSpeedForAllParticleSystems(System.Single)">
      <summary>
            Sets each individual Particle Systems' Simulation Speed to the specified Simulation Speed.
            </summary>
      <param name="fSimulationSpeed">The new Simulation Speed that all Particle Systems 
            currently in this Manager should have</param>
    </member>
    <member name="M:DPSF.ParticleSystemManager.SetUpdatesPerSecondForAllParticleSystems(System.Int32)">
      <summary>
            Sets each individual Particle Systems' Updates Per Second to the specified Updates Per Second.
            </summary>
      <param name="iUpdatesPerSecond">The new Updates Per Second that all particle systems
            currently in this Manager should have</param>
    </member>
    <member name="M:DPSF.ParticleSystemManager.SetWorldViewProjectionMatricesForAllParticleSystems(Microsoft.Xna.Framework.Matrix,Microsoft.Xna.Framework.Matrix,Microsoft.Xna.Framework.Matrix)">
      <summary>
            Sets the World, View, and Projection Matrices for all of the Particle Systems in this Manager.
            <para>NOTE: Sprite particle systems are not affected by the World, View, and Projection matrices.</para></summary>
      <param name="cWorld">The World Matrix</param>
      <param name="cView">The View Matrix</param>
      <param name="cProjection">The Projection Matrix</param>
    </member>
    <member name="M:DPSF.ParticleSystemManager.SetTransformationMatrixForAllSpriteParticleSystems(Microsoft.Xna.Framework.Matrix)">
      <summary>
            Sets the SpriteBatchSettings.TransformationMatrix for all Sprite Particle Systems in this Manager.
            </summary>
      <param name="sTransformationMatrix">The Transformation Matrix to apply to the Sprite Particle Systems</param>
    </member>
    <member name="M:DPSF.ParticleSystemManager.SetCameraPositionForAllParticleSystems(Microsoft.Xna.Framework.Vector3)">
      <summary>
            Sets the CameraPosition property of all particle system's in this manager to the given Camera Position.
            Reflection is used to determine if the particle system contains a public Vector3 "CameraPosition" property, 
            and if so, this functions sets it to the given value.
            </summary>
      <param name="cameraPosition">The current position of the Camera.</param>
    </member>
    <member name="M:DPSF.ParticleSystemManager.ContainsParticleSystem(DPSF.IDPSFParticleSystem)">
      <summary>
            Returns true if the given Particle System is in the Manager, false if not.
            </summary>
      <param name="cParticleSystemToFind">The Particle System to look for</param>
      <returns>Returns true if the given Particle System is in the Manager, false if not.</returns>
    </member>
    <member name="M:DPSF.ParticleSystemManager.ContainsParticleSystem(System.Int32)">
      <summary>
            Returns true if the Particle System with the given ID is in the Manager, false if not.
            </summary>
      <param name="iIDOfParticleSystemToFind">The ID of the Particle System to find</param>
      <returns>Returns true if the Particle System with the given ID is in the Manager, false if not.</returns>
    </member>
    <member name="M:DPSF.ParticleSystemManager.AddParticleSystem(DPSF.IDPSFParticleSystem)">
      <summary>
            Add an initialized Particle System to the Particle System Manager.
            <para>NOTE: This sets the Particle System's ParticleSystemManagerToCopyPropertiesFrom
            property to this Particle System Manager.</para></summary>
      <param name="cParticleSystemToAdd">The initialized Particle System to add</param>
    </member>
    <member name="M:DPSF.ParticleSystemManager.RemoveParticleSystem(DPSF.IDPSFParticleSystem)">
      <summary>
            Removes the specified Particle System from the Particle System Manager.
            Returns true if the Particle System was found and removed, false if it was not found.
            </summary>
      <param name="cParticleSystemToRemove">A handle to the Particle System to Remove</param>
      <returns>Returns true if the Particle System was found and removed, false if it was not found.</returns>
    </member>
    <member name="M:DPSF.ParticleSystemManager.RemoveParticleSystem(System.Int32)">
      <summary>
            Removes the specified Particle System from the Particle System Manager.
            Returns true if the Particle System was found and removed, false if it was not found.
            </summary>
      <param name="iIDOfParticleSystemToRemove">The ID of the Particle System to Remove</param>
      <returns>Returns true if the Particle System was found and removed, false if it was not found.</returns>
    </member>
    <member name="M:DPSF.ParticleSystemManager.RemoveAllParticleSystems">
      <summary>
            Removes all Particle Systems from the Particle System Manager
            </summary>
    </member>
    <member name="M:DPSF.ParticleSystemManager.AutoInitializeAllParticleSystems(Microsoft.Xna.Framework.Graphics.GraphicsDevice,Microsoft.Xna.Framework.Content.ContentManager,Microsoft.Xna.Framework.Graphics.SpriteBatch)">
      <summary>
            Calls the AutoInitialize() function for every Particle System in this Manager
            </summary>
      <param name="cGraphicsDevice">The Graphics Device that the Particle Systems should be drawn to</param>
      <param name="cContentManager">The Content Manager used to load Effect files and Textures</param>
      <param name="cSpriteBatch">The Sprite Batch that the Sprite Particle System should use to draw its particles.
            If this is not initializing a Sprite particle system, or you want the particle system to use its own Sprite Batch,
            pass in null.</param>
    </member>
    <member name="M:DPSF.ParticleSystemManager.DestroyAllParticleSystems">
      <summary>
            Calls the Destroy() function for every Particle System in this Manager
            </summary>
    </member>
    <member name="M:DPSF.ParticleSystemManager.DestroyAndRemoveAllParticleSystems">
      <summary>
            Destroys each Particle System in the Manager, then removes them from the Manager
            </summary>
    </member>
    <member name="M:DPSF.ParticleSystemManager.UpdateAllParticleSystems(System.Single)">
      <summary>
            Updates all of the Particle Systems.
            <para>NOTE: This will only Update the Particle Systems if they do not inherit from DrawableGameComponent, 
            since if they do they will be updated automatically by the Game object.</para></summary>
      <param name="fElapsedTimeInSeconds">The amount of Time in seconds that has passed since
            the last Update</param>
    </member>
    <member name="M:DPSF.ParticleSystemManager.UpdateAllParticleSystemsForced(System.Single)">
      <summary>
            Updates all of the Particle Systems.
            <para>NOTE: If the Particle Systems inherit from DrawableGameComponent and this is called, the Particle
            Systems will be updated twice each frame; once here and once when called automatically by the game object.
            If not inheriting from DrawableGameComponent, this function acts the same as calling UpdateAllParticleSystems().</para></summary>
      <param name="fElapsedTimeInSeconds">The amount of Time in seconds that has passed since
            the last Update</param>
    </member>
    <member name="M:DPSF.ParticleSystemManager.DrawAllParticleSystems">
      <summary>
            Draws all of the Particle Systems.
            <para>NOTE: This will only Draw the Particle Systems if they do not inherit from DrawableGameComponent, 
            since if they do they will be drawn automatically by the Game object.</para></summary>
    </member>
    <member name="M:DPSF.ParticleSystemManager.DrawAllParticleSystemsForced">
      <summary>
            Draws all of the Particle Systems, even if they inherit from DrawableGameComponent.
            <para>NOTE: If the Particle Systems inherit from DrawableGameComponent and this is called, the Particle
            Systems will be drawn twice each frame; once here and once when called automatically by the game object.
            If not inheriting from DrawableGameComponent, this function acts the same as calling DrawAllParticleSystems().</para></summary>
    </member>
    <member name="M:DPSF.ParticleSystemManager.DrawAllParticleSystemsToTexture(Microsoft.Xna.Framework.Graphics.GraphicsDevice,System.Int32,System.Int32)">
      <summary>
            Draws all of the Particle Systems to a Texture and returns the Texture, which has a Transparent Black background
            </summary>
      <param name="cGraphicsDevice">A Graphics Device to use for drawing; The Graphics Device contents will not be overwritten.
            <para>NOTE: The size of the Texture before scaling will be the size of the Graphics Device's Viewport.</para></param>
      <param name="iTextureWidth">The desired Width of the Texture</param>
      <param name="iTextureHeight">The desired Height of the Texture</param>
      <returns>Returns a Texture with the Particle Systems in their current state drawn on it</returns>
    </member>
    <member name="M:DPSF.ParticleSystemManager.DrawAllParticleSystemsAnimationToFiles(Microsoft.Xna.Framework.Graphics.GraphicsDevice,System.Int32,System.Int32,System.String,System.Single,System.Single,System.Boolean,System.Boolean)">
      <summary>
            Draws the Particle Systems' Animation over the given timespan to a sequence of Image files.
            <para>NOTE: This function is not available on the Xbox 360.</para></summary>
      <param name="cGraphicsDevice">A Graphics Device to use for drawing; The Graphics Device contents will not be overwritten.
            <para>NOTE: The size of the Texture before scaling will be the size of the Graphics Device's Viewport.</para></param>
      <param name="iImageWidth">The desired Width of the Image files generated</param>
      <param name="iImageHeight">The desired Height of the Image files generated</param>
      <param name="sDirectoryName">The Directory to store the generated Image files in.
            <para>NOTE: This Directory will be created in the same directory as the application's executable.</para></param>
      <param name="fTotalAnimationTime">The amount of Time in seconds that the Animation should run for</param>
      <param name="fTimeStep">The amount of Time that should elapse between frames (i.e. 1.0 / 30.0 = 30fps)</param>
      <param name="bCreateAnimatedGIF">Set this to true to also produce an animated GIF from the Image files generated</param>
      <param name="bCreateTileSetImage">Set this to true to also produce a Tile Set from the Image files generated.
            Be careful when setting this to true as the system may run out of memory and throw an exception if the Tile Set
            image to generate is too large. Exactly how large it is allowed to be differs from system to system.</param>
    </member>
    <member name="M:DPSF.ParticleSystemManager.CreateAnimatedGIFFromImageFiles(System.Collections.Generic.List{System.String},System.Single,System.String)">
      <summary>
            Creates an Animated GIF from the files with the given File Paths and stores it in the given Directory 
            relative to the application's executable.
            <para>NOTE: This function is not available on the Xbox 360.</para></summary>
      <param name="cFilePathsList">The Paths of the image Files to create the animated GIF from</param>
      <param name="fTimeStep">How long between switching animation frames, in seconds</param>
      <param name="sDirectory">The Directory to store the Animated GIF in</param>
    </member>
    <member name="M:DPSF.ParticleSystemManager.AddImageToTileSet(Microsoft.Xna.Framework.Graphics.GraphicsDevice,Microsoft.Xna.Framework.Graphics.RenderTarget2D@,Microsoft.Xna.Framework.Graphics.Texture2D,Microsoft.Xna.Framework.Rectangle)">
      <summary>
            Draws the given Texture to the given Tile Set Render Target at the specified Position.
            </summary>
      <param name="cGraphicsDevice">The Graphics Device used to do the drawing</param>
      <param name="cTileSetRenderTarget">The Tile Set Render Target to draw to</param>
      <param name="cTexture">The Texture to draw</param>
      <param name="sPositionAndDimensionsInTileSetToAddImage">The Position where the Texture should be drawn
            on the Tile Set Render Target, and its Dimensions</param>
    </member>
    <member name="M:DPSF.ParticleSystemManager.SortParticleSystemLists">
      <summary>
            Sort the two Particle System Lists
            </summary>
    </member>
    <member name="M:DPSF.ParticleSystemManager.SortParticleSystemsByUpdateOrderList">
      <summary>
            Sorts the Particle System List Sorted By Update Order
            </summary>
    </member>
    <member name="M:DPSF.ParticleSystemManager.SortParticleSystemsByDrawOrderList">
      <summary>
            Sorts the Particle System List Sorted By Draw Order
            </summary>
    </member>
    <member name="M:DPSF.ParticleSystemManager.ParticleSystem_UpdateOrderChanged(System.Object,System.EventArgs)">
      <summary>
            Records that the Particle Systems need to be resorted before doing the next Updates
            </summary>
      <param name="sender">The Object that sent the event</param>
      <param name="e">Extra information</param>
    </member>
    <member name="M:DPSF.ParticleSystemManager.ParticleSystem_DrawOrderChanged(System.Object,System.EventArgs)">
      <summary>
            Records that the Particle Systems need to be resorted before doing the next Draws
            </summary>
      <param name="sender">The Object that sent the event</param>
      <param name="e">Extra information</param>
    </member>
    <member name="P:DPSF.ParticleSystemManager.ParticleSystemsInheritDrawableGameComponent">
      <summary>
            Get if the Particle Systems are inheriting from DrawableGameComponent or not
            </summary>
    </member>
    <member name="P:DPSF.ParticleSystemManager.Enabled">
      <summary>
            Get / Set if the Particle Systems should be Updated or not
            </summary>
    </member>
    <member name="P:DPSF.ParticleSystemManager.Visible">
      <summary>
            Get / Set if this Particle Systems should be drawn or not.
            <para>NOTE: Setting this to false causes the particle systems' Draw() function to not be called, including the 
            particle systems' BeforeDraw() and AfterDraw() functions.</para></summary>
    </member>
    <member name="P:DPSF.ParticleSystemManager.SimulationSpeedIsEnabled">
      <summary>
            Get / Set if the Particle System Manager's SimulationSpeed property
            should be used for each of the particle systems it contains or not.
            <para>Default value is true.</para></summary>
    </member>
    <member name="P:DPSF.ParticleSystemManager.UpdatesPerSecondIsEnabled">
      <summary>
            Get / Set if the Particle System Manager's UpdatesPerSecond property
            should be used for each of the particle systems it contains or not.
            <para>Default value is true.</para></summary>
    </member>
    <member name="P:DPSF.ParticleSystemManager.SimulationSpeed">
      <summary>
            Get / Set how fast the Particle System Simulations should run. 
            <para>Example: 1.0 = normal speed, 0.5 = half speed, 2.0 = double speed.</para><para>NOTE: This sets the SimulationSpeed property of each individual Particle
            System in this Manager to the given value. It will also set a particle system's
            Simulation Speed when the particle system is re-initialized, 
            and when a new Particle System is added to the Manager in the future.</para><para>NOTE: Setting this property only has an effect if the SimulationSpeedIsEnabled property is true.</para><para>NOTE: This will be set to zero if a negative value is specified.</para></summary>
    </member>
    <member name="P:DPSF.ParticleSystemManager.UpdatesPerSecond">
      <summary>
            Get / Set how often the Particle Systems should be Updated. 
            <para>NOTE: This sets the UpdatesPerSecond property of each individual Particle
            System in this Manager to the given value. It will also set a particle system's
            Updates Per Second when the particle system is re-initialized, 
            and when a new Particle System is added to the Manager in the future.</para><para>NOTE: Setting this property only has an effect if the UpdatesPerSecondIsEnabled property is true.</para><para>NOTE: A value of zero means update the particle systems every time Update() is called.</para><para>NOTE: This will be set to zero if a negative value is specified.</para></summary>
    </member>
    <member name="P:DPSF.ParticleSystemManager.TotalNumberOfActiveParticles">
      <summary>
            Get the cumulative Number Of Active Particles of all Particle Systems in this Manager
            </summary>
    </member>
    <member name="P:DPSF.ParticleSystemManager.TotalNumberOfParticlesBeingDrawn">
      <summary>
            Get the cumulative Number Of Particles Being Drawn by all Particle Systems in this Manager.
            This is the total number of Active AND Visible Particles.
            <para>NOTE: This ignores whether the Manager is Visible or not.</para></summary>
    </member>
    <member name="P:DPSF.ParticleSystemManager.TotalNumberOfParticlesAllocatedInMemory">
      <summary>
            Get the cumulative Max Number Of Particles allocated in memory by all Particle Systems in the Manager.
            </summary>
    </member>
    <member name="P:DPSF.ParticleSystemManager.ParticleSystems">
      <summary>
            Returns a Linked List of handles to the Particle Systems in this Manager
            </summary>
    </member>
    <member name="T:System.Collections.Generic.Extensions">
      <summary>
            Class used to extend other classes.
            </summary>
    </member>
    <member name="M:System.Collections.Generic.Extensions.RemoveAll``1(System.Collections.Generic.List{``0},System.Func{``0,System.Boolean})">
      <summary>
            Removes all elements from the List that match the conditions defined by the specified predicate.
            </summary>
      <typeparam name="T">The type of elements held by the List.</typeparam>
      <param name="list">The List to remove the elements from.</param>
      <param name="match">The Predicate delegate that defines the conditions of the elements to remove.</param>
    </member>
    <member name="M:System.Collections.Generic.Extensions.Exists``1(System.Collections.Generic.List{``0},System.Func{``0,System.Boolean})">
      <summary>
            Returns true if the List contains elements that match the conditions defined by the specified predicate.
            </summary>
      <typeparam name="T">The type of elements held by the List.</typeparam>
      <param name="list">The List to search for a match in.</param>
      <param name="match">The Predicate delegate that defines the conditions of the elements to match against.</param>
    </member>
    <member name="T:DPSF.DefaultSpriteTextureCoordinatesParticleSystem">
      <summary>
            The Default Sprite with Texture Coordinates Particle System to inherit from, which uses Default Sprite with Texture Coordinates Particles
            </summary>
    </member>
    <member name="M:DPSF.DefaultSpriteTextureCoordinatesParticleSystem.#ctor(Microsoft.Xna.Framework.Game)">
      <summary>
            Constructor
            </summary>
      <param name="cGame">Handle to the Game object being used. Pass in null for this 
            parameter if not using a Game object.</param>
    </member>
    <member name="T:DPSF.ParticleEmitter">
      <summary>
            Class used to automatically create new Particles in a Particle System
            </summary>
    </member>
    <member name="M:DPSF.ParticleEmitter.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:DPSF.ParticleEmitter.UpdateAndGetNumberOfParticlesToEmit(System.Single)">
      <summary>
            Updates the Emitter's Position and Orientation according to its 
            Velocities and Accelerations, and returns how many Particles should 
            be emitted this frame.
            </summary>
      <param name="fElapsedTimeInSeconds">How long (in seconds) it has been 
            since this function was called</param>
      <returns>Returns the number of Particles that should be emitted</returns>
    </member>
    <member name="M:DPSF.ParticleEmitter.CalculateHowManyParticlesToEmit(System.Single)">
      <summary>
            Calculates how many Particles should be emitted based on the amount of Time Elapsed
            </summary>
      <param name="fElapsedTimeInSeconds">How much Time has Elapsed (in seconds) since the last Update</param>
      <returns>Returns how many Particles should be emitted</returns>
    </member>
    <member name="P:DPSF.ParticleEmitter.Enabled">
      <summary>
            Get / Set if the Emitter is able to Emit Particles or not.
            <para>NOTE: If this is false, not even Bursts will Emit Particles.</para><para>NOTE: The Position, Orientation, and Pivot Data will still be updated when this is false.</para></summary>
    </member>
    <member name="P:DPSF.ParticleEmitter.PositionData">
      <summary>
            Get the Position Data (Position, Velocity, and Acceleration)
            </summary>
    </member>
    <member name="P:DPSF.ParticleEmitter.OrientationData">
      <summary>
            Get the Orientation Data (Orientation, Rotational Velocity, and Rotational Acceleration)
            </summary>
    </member>
    <member name="P:DPSF.ParticleEmitter.PivotPointData">
      <summary>
            Get the Pivot Point Data (Pivot Point, Pivot Rotational Velocity, and Pivot Rotational Acceleration)
            </summary>
    </member>
    <member name="P:DPSF.ParticleEmitter.EmitParticlesAutomatically">
      <summary>
            Get / Set if the Emitter should Emit Particles Automatically or not.
            <para>NOTE: Particles will only be emitted if the Emitter is Enabled.</para></summary>
    </member>
    <member name="P:DPSF.ParticleEmitter.ParticlesPerSecond">
      <summary>
            Get / Set how many Particles should be emitted per Second
            </summary>
    </member>
    <member name="P:DPSF.ParticleEmitter.BurstParticles">
      <summary>
            Get / Set how many Particles the Emitter should Burst. The Emitter will emit
            Particles, at the speed corresponding to its Particles Per Second rate, until this amount 
            of Particles have been emitted.
            <para>NOTE: Bursts are only processed when the Emit Particles Automatically property is false.</para><para>NOTE: Bursts will only emit Particles if the Emitter is Enabled.</para><para>NOTE: This will be set to zero if a negative value is specified.</para><para>NOTE: This will fire the BurstComplete event when it reaches (or is set to) zero.</para></summary>
    </member>
    <member name="P:DPSF.ParticleEmitter.BurstTime">
      <summary>
            Get / Set how long the Emitter should Burst for (in seconds). The Emitter will emit
            Particles, at the speed corresponding to its Particles Per Second rate, until this amount 
            of time in seconds has elapsed.
            <para>NOTE: Bursts are only processed when the Emit Particles Automatically property is false.</para><para>NOTE: Bursts will only emit Particles if the Emitter is Enabled.</para><para>NOTE: This will be set to zero if a negative value is specified.</para><para>NOTE: This will fire the BurstComplete event when it reaches (or is set to) zero.</para></summary>
    </member>
    <member name="E:DPSF.ParticleEmitter.BurstComplete">
      <summary>
            Raised when a Burst property reaches (or is set to) zero 
            </summary>
    </member>
    <member name="T:DPSF.DPSFResources">
      <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
    </member>
    <member name="P:DPSF.DPSFResources.ResourceManager">
      <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
    </member>
    <member name="P:DPSF.DPSFResources.Culture">
      <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
    </member>
    <member name="T:DPSF.RandomNumbers">
      <summary>
            Class that may be used to obtain random numbers. This class inherits the Random class
            and adds additional functionality.
            </summary>
    </member>
    <member name="M:DPSF.RandomNumbers.Between(System.Single,System.Single)">
      <summary>
            Returns a random number between the specified values
            </summary>
      <param name="fValue1">The first value</param>
      <param name="fValue2">The second value</param>
      <returns>Returns a random number between the specified values</returns>
    </member>
    <member name="M:DPSF.RandomNumbers.NextFloat">
      <summary>
            Returns a random number between 0.0f and 1.0f.
            </summary>
      <returns>Returns a random number between 0.0f and 1.0f.</returns>
    </member>
    <member name="T:DPSF.PivotPoint2D">
      <summary>
            Class to hold and update an object's 2D Pivot Point (point to rotate around), Pivot Velocity, and 
            Pivot Acceleration. This class requires a Position2D object, and optionally a Orientation2D object,
            that should be affected by rotations around the Pivot Point.
            </summary>
    </member>
    <member name="F:DPSF.PivotPoint2D.PivotPoint">
      <summary>
            The 2D Pivot Point that the object should rotate around.
            <para>NOTE: This only has effect when Rotational Pivot Velocity / Acceleration are used.</para></summary>
    </member>
    <member name="F:DPSF.PivotPoint2D.PivotRotationalVelocity">
      <summary>
            The object's Rotational Velocity around the Pivot Point (Position change).
            <para>NOTE: Roations are specified in radians.</para></summary>
    </member>
    <member name="F:DPSF.PivotPoint2D.PivotRotationalAcceleration">
      <summary>
            The object's Rotational Acceleration around the Pivot Point (Position change).
            <para>NOTE: Rotations are specified in radians.</para></summary>
    </member>
    <member name="M:DPSF.PivotPoint2D.#ctor(DPSF.PivotPoint2D)">
      <summary>
            Copy Constructor
            </summary>
      <param name="cPivotPointToCopy">The PivotPoint2D object to copy</param>
    </member>
    <member name="M:DPSF.PivotPoint2D.CopyFrom(DPSF.PivotPoint2D)">
      <summary>
            Copies the given PivotPoint2D object's data into this object's data
            </summary>
      <param name="cPivotPointToCopy">
      </param>
    </member>
    <member name="M:DPSF.PivotPoint2D.#ctor(DPSF.Position2D)">
      <summary>
            Explicit Constructor. Set the Position2D object that should be affected by rotations around
            this Pivot Point.
            </summary>
      <param name="cPosition">Handle to the Position2D object to update</param>
    </member>
    <member name="M:DPSF.PivotPoint2D.#ctor(DPSF.Position2D,DPSF.Orientation2D)">
      <summary>
            Explicit Constructor. Set the Position2D and Orientation2D objects that should be affected by 
            rotational around this Pivot Point.
            </summary>
      <param name="cPosition">Handle to the Position2D object to update</param>
      <param name="cOrientation">Handle to the Orienetation2D object to update</param>
    </member>
    <member name="M:DPSF.PivotPoint2D.RotatePositionAndOrientation(System.Single,Microsoft.Xna.Framework.Vector2)">
      <summary>
            Rotates the object about its center, changing its Orientation, as well as around the 
            specified Pivot Point, changing its Position
            </summary>
      <param name="fRotation">The Rotation in radians to apply to the object</param>
      <param name="sPivotPoint">The Point to rotate the object around</param>
    </member>
    <member name="M:DPSF.PivotPoint2D.RotatePositionAndOrientationVector3(System.Single,Microsoft.Xna.Framework.Vector3)">
      <summary>
            Rotates the object about its center, changing its Orientation, as well as around the 
            specified 3D Pivot Point, changing its 2D Position.
            <para>NOTE: The Pivot Point's Z-value is ignored.</para><para>NOTE: This function is provided for convenience when using 3D Vectors in 2D coordinate systems.</para></summary>
      <param name="fRotation">The Rotation in radians to apply to the object</param>
      <param name="sPivotPoint">The Point to rotate the object around. 
            NOTE: The Z-value is ignored, since this is a 2D rotation.</param>
    </member>
    <member name="M:DPSF.PivotPoint2D.RotatePosition(System.Single,Microsoft.Xna.Framework.Vector2)">
      <summary>
            Rotates the object around the specified Pivot Point, changing its Position, without 
            changing its Orientation.
            </summary>
      <param name="fRotation">The Rotation in radians to apply to the object</param>
      <param name="sPivotPoint">The Point to rotate the object around</param>
    </member>
    <member name="M:DPSF.PivotPoint2D.RotatePositionVector3(System.Single,Microsoft.Xna.Framework.Vector3)">
      <summary>
            Rotates the object around the specified Pivot Point, changing its Position, without 
            changing its Orientation.
            <para>NOTE: The Pivot Point's Z-value is ignored.</para><para>NOTE: This function is provided for convenience when using 3D Vectors in 2D coordinate systems.</para></summary>
      <param name="fRotation">The Rotation in radians to apply to the object</param>
      <param name="sPivotPoint">The Point to rotate the object around.
            NOTE: The Z-value is ignored, since this is a 2D rotation.</param>
    </member>
    <member name="M:DPSF.PivotPoint2D.Update(System.Single)">
      <summary>
            Update the Position and Orientation according to the Pivot Rotational Velocity / Acceleration
            </summary>
      <param name="fElapsedTimeInSeconds">The time Elapsed in Seconds since the last Update</param>
    </member>
    <member name="M:DPSF.PivotPoint2D.RotatePositionAndOrientation(System.Single,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2@,System.Single@)">
      <summary>
            Rotates the given Position and Orientation around the Pivot Point, changing the Position and Orientation
            </summary>
      <param name="fRotation">The Rotation in radians to apply to the object</param>
      <param name="sPivotPoint">The Point to rotate the object around</param>
      <param name="srPosition">The Position of the object to be modified</param>
      <param name="frOrientation">The Orientation (rotation) of the object to be modified</param>
    </member>
    <member name="M:DPSF.PivotPoint2D.RotatePositionAndOrientationVector3(System.Single,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3@,System.Single@)">
      <summary>
            Rotates the given Position and Orientation around the Pivot Point, changing the Position and Orientation.
            <para>NOTE: The Pivot Point and Position's Z-values are ignored.</para><para>NOTE: This function is provided for convenience when using 3D Vectors in 2D coordinate systems.</para></summary>
      <param name="fRotation">The Rotation in radians to apply to the object</param>
      <param name="sPivotPoint">The Point to rotate the object around.
            NOTE: The Z-value is ignored, since this is a 2D rotation.</param>
      <param name="srPosition">The Position of the object to be modified.
            NOTE: The Z-value is ignored and will not be changed, since this is a 2D rotation.</param>
      <param name="frOrientation">The Orientation (rotation) of the object to be modified</param>
    </member>
    <member name="M:DPSF.PivotPoint2D.RotatePosition(System.Single,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2)">
      <summary>
            Returns the new Position after Rotating the given Position around the specified Pivot Point
            </summary>
      <param name="fRotation">The Rotation in radians to rotate around the Pivot Point by</param>
      <param name="sPivotPoint">The Point to Rotate around</param>
      <param name="sPosition">The current Position of the object</param>
      <returns>Returns the new Position after Rotating the given Position around the specified Pivot Point</returns>
    </member>
    <member name="M:DPSF.PivotPoint2D.RotatePositionVector3(System.Single,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3)">
      <summary>
            Returns the new Position after Rotating the given Position around the specified Pivot Point.
            <para>NOTE: The Pivot Point and Position's Z-values are ignored.</para><para>This function is provided for convenience when using 3D Vectors in 2D coordinate systems.</para></summary>
      <param name="fRotation">The Rotation in radians to rotate around the Pivot Point by</param>
      <param name="sPivotPoint">The Point to Rotate around.
            NOTE: The Z-value is ignored, since this is a 2D rotation.</param>
      <param name="sPosition">The current Position of the object.
            NOTE: The Z-value is ignored and will not be changed, since this is a 2D rotation.</param>
      <returns>Returns the new Position after Rotating the given Position around the specified Pivot Point.</returns>
    </member>
    <member name="P:DPSF.PivotPoint2D.PositionData">
      <summary>
            Get / Set the Position2D object that the Pivot Point should affect
            </summary>
    </member>
    <member name="P:DPSF.PivotPoint2D.OrientationData">
      <summary>
            Get / Set the Orientation2D object that the Pivot Point should affect
            </summary>
    </member>
    <member name="P:DPSF.PivotPoint2D.RotateOrientationToo">
      <summary>
            Specify if the Update() function should Rotate the object's Orientation too when it
            rotates the object around the Pivot Point
            </summary>
    </member>
    <member name="T:DPSF.DefaultTexturedQuadParticleSystem">
      <summary>
            The Default Textured Quad Particle System to inherit from, which uses Default Textured Quad Particles
            </summary>
    </member>
    <member name="M:DPSF.DefaultTexturedQuadParticleSystem.#ctor(Microsoft.Xna.Framework.Game)">
      <summary>
            Constructor
            </summary>
      <param name="cGame">Handle to the Game object being used. Pass in null for this 
            parameter if not using a Game object.</param>
    </member>
    <member name="T:DPSF.DefaultTexturedQuadParticleVertex">
      <summary>
            Structure used to hold a Default Textured Quad Particle's Vertex's properties used for drawing.
            This contains a Vector3 Position, Vector2 TextureCoordinate, and Color Color.
            </summary>
    </member>
    <member name="F:DPSF.DefaultTexturedQuadParticleVertex.Position">
      <summary>
            The Position of the vertex in 3D space. The position of this vertex
            relative to the quads other three vertices determines the Particle's orientation.
            </summary>
    </member>
    <member name="F:DPSF.DefaultTexturedQuadParticleVertex.TextureCoordinate">
      <summary>
            The Coordinate of the Texture that this Vertex corresponds to
            </summary>
    </member>
    <member name="F:DPSF.DefaultTexturedQuadParticleVertex.Color">
      <summary>
            The Color to tint the Texture
            </summary>
    </member>
    <member name="P:DPSF.DefaultTexturedQuadParticleVertex.VertexElements">
      <summary>
            An array describing the attributes of each Vertex
            </summary>
    </member>
    <member name="P:DPSF.DefaultTexturedQuadParticleVertex.SizeInBytes">
      <summary>
            The Size of one Vertex in Bytes
            </summary>
    </member>
    <member name="T:DPSF.PivotPoint3D">
      <summary>
            Class to hold and update an object's 3D Pivot Point (point to rotate around), Pivot Velocity, and 
            Pivot Acceleration. This class requires a Position3D object, and optionally a Orientation3D object, 
            that should be affected by rotations around the Pivot Point.
            </summary>
    </member>
    <member name="F:DPSF.PivotPoint3D.PivotPoint">
      <summary>
            The 3D Pivot Point that the object should rotate around.
            <para>NOTE: This only has effect when Rotational Pivot Velocity / Acceleration are used.</para></summary>
    </member>
    <member name="F:DPSF.PivotPoint3D.PivotRotationalVelocity">
      <summary>
            The object's Rotational Velocity around the Pivot Point (Position change).
            <para>NOTE: Rotations are specified by giving a 3D Vector, where the direction is the axis to 
            rotate around, and the vector length is the amount (angle in radians) to rotate.
            It can also be thought of as Vector(PitchVelocity, YawVelocity, RollVelocity).</para></summary>
    </member>
    <member name="F:DPSF.PivotPoint3D.PivotRotationalAcceleration">
      <summary>
            Get / Set the object's Rotational Acceleration around the Pivot Point (Position change).
            <para>NOTE: Rotations are specified by giving a 3D Vector, where the direction is the axis to 
            rotate around, and the vector length is the amount (angle in radians) to rotate.
            It can also be thought of as Vector(PitchAcceleration, YawAcceleration, RollAcceleration).</para></summary>
    </member>
    <member name="M:DPSF.PivotPoint3D.#ctor(DPSF.PivotPoint3D)">
      <summary>
            Copy Constructor
            </summary>
      <param name="cPivotPointToCopy">The PivotPoint3D object to copy</param>
    </member>
    <member name="M:DPSF.PivotPoint3D.CopyFrom(DPSF.PivotPoint3D)">
      <summary>
            Copy the given PivotPoint3D object's data into this object's data
            </summary>
      <param name="cPivotPointToCopy">The PivotPoint3D object to copy from</param>
    </member>
    <member name="M:DPSF.PivotPoint3D.#ctor(DPSF.Position3D)">
      <summary>
            Explicit Constructor. Set the Position3D object that should be affected by rotations around
            this Pivot Point.
            </summary>
      <param name="cPosition">Handle to the Position3D object to update</param>
    </member>
    <member name="M:DPSF.PivotPoint3D.#ctor(DPSF.Position3D,DPSF.Orientation3D)">
      <summary>
            Explicit Constructor. Set the Position3D and Orientation3D objects that should be affected by 
            rotational around this Pivot Point.
            </summary>
      <param name="cPosition">Handle to the Position3D object to update</param>
      <param name="cOrientation">Handle to the Orienetation3D object to update</param>
    </member>
    <member name="M:DPSF.PivotPoint3D.RotatePositionAndOrientation(Microsoft.Xna.Framework.Matrix)">
      <summary>
            Rotates the object about its center, changing its Orientation, as well as around the 
            Pivot Point, changing its Position
            </summary>
      <param name="sRotationMatrix">The Rotation to apply to the object, rotating it 
            around the Pivot Point</param>
    </member>
    <member name="M:DPSF.PivotPoint3D.RotatePosition(Microsoft.Xna.Framework.Matrix)">
      <summary>
            Rotates the object around the Pivot Point, changing its Position, without 
            changing its Orientation
            </summary>
      <param name="sRotationMatrix">The Rotation to apply to the object, rotating it 
            around the Pivot Point</param>
    </member>
    <member name="M:DPSF.PivotPoint3D.Update(System.Single)">
      <summary>
            Update the Position and Orientation according to the Pivot Rotational Velocity / Acceleration
            </summary>
      <param name="fElapsedTimeInSeconds">The time Elapsed in Seconds since the last Update</param>
    </member>
    <member name="M:DPSF.PivotPoint3D.RotatePositionAndOrientation(Microsoft.Xna.Framework.Matrix,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Quaternion@)">
      <summary>
            Rotates the given Position and Orientation around the Pivot Point, changing the Position and Orientation
            </summary>
      <param name="sRotationMatrix">The Rotation to apply to the object</param>
      <param name="sPivotPoint">The Point to rotate the object around</param>
      <param name="srPosition">The Position of the object (to be modified)</param>
      <param name="srOrientation">The Orientation of the object (to be modified)</param>
    </member>
    <member name="M:DPSF.PivotPoint3D.RotatePosition(Microsoft.Xna.Framework.Matrix,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3)">
      <summary>
            Returns the new Position after Rotating the given Position around the specified Pivot Point
            </summary>
      <param name="sRotationMatrix">The Rotation to apply to the Emitter</param>
      <param name="sPivotPoint">The Point to rotate the Emitter around</param>
      <param name="sPosition">The Position to be rotated around the Pivot Point</param>
      <returns>Returns the new Position after Rotating the given Position around the specified Pivot Point</returns>
    </member>
    <member name="P:DPSF.PivotPoint3D.PositionData">
      <summary>
            Get / Set the Position3D object that the Pivot Point should affect
            </summary>
    </member>
    <member name="P:DPSF.PivotPoint3D.OrientationData">
      <summary>
            Get / Set the Orientation3D object that the Pivot Point should affect
            </summary>
    </member>
    <member name="P:DPSF.PivotPoint3D.RotateOrientationToo">
      <summary>
            Specify if the Update() function should Rotate the object's Orientation too when it
            rotates the object around the Pivot Point
            </summary>
    </member>
    <member name="T:DPSF.DPSFDefaultEffectTechniques">
      <summary>
            The Techniques provided by the DPSF Default Effect.
            </summary>
    </member>
    <member name="F:DPSF.DPSFDefaultEffectTechniques.Sprites">
      <summary>
            The default technique used to display particles as sprites.
            </summary>
    </member>
    <member name="F:DPSF.DPSFDefaultEffectTechniques.Quads">
      <summary>
            The default technique used to display particles as colored quads.
            </summary>
    </member>
    <member name="F:DPSF.DPSFDefaultEffectTechniques.TexturedQuads">
      <summary>
            The default technique used to display particles as textured quads.
            </summary>
    </member>
    <member name="F:DPSF.DPSFDefaultEffectTechniques.TexturedQuadsExperimental">
      <summary>
            An experimental technique used to display particles as textured quads, doing the color blending using premultiplied colors.
            </summary>
    </member>
    <member name="T:DPSF.DPSFDefaultEffect">
      <summary>
            The Default Effect provided by DPSF.
            </summary>
    </member>
    <member name="T:DPSF.DPSFDefaultEffect.DPSFDefaultEffectConfigurations">
      <summary>
            The list of valid DPSF Default Effect configurations
            </summary>
    </member>
    <member name="F:DPSF.DPSFDefaultEffect._configuration">
      <summary>
            Holds this effects configuration in case we need to clone it.
            </summary>
    </member>
    <member name="M:DPSF.DPSFDefaultEffect.#ctor(Microsoft.Xna.Framework.Graphics.GraphicsDevice,DPSF.DPSFDefaultEffect.DPSFDefaultEffectConfigurations)">
      <summary>
            Constructor
            </summary>
      <param name="graphicsDevice">The Graphics Device to load the effect with.</param>
      <param name="configuration">The effect configuration to load (i.e. Windows HiDef, Xbox 360 Reach, etc.)</param>
    </member>
    <member name="M:DPSF.DPSFDefaultEffect.#ctor(DPSF.DPSFDefaultEffect)">
      <summary>
            Initializes a new instance of the <see cref="T:DPSF.DPSFDefaultEffect" /> class.
            </summary>
      <param name="effectToClone">The effect to clone.</param>
    </member>
    <member name="M:DPSF.DPSFDefaultEffect.Clone">
      <summary>
            Creates and returns a clone of this DPSFDefaultEffect instance.
            </summary>
    </member>
    <member name="P:DPSF.DPSFDefaultEffect.ColorBlendAmount">
      <summary>
            How much of the vertex Color should be blended in with the Texture's Color.
            0.0 = use Texture's color, 1.0 = use specified color. Default is 0.5.
            </summary>
    </member>
    <member name="P:DPSF.DPSFDefaultEffect.Texture">
      <summary>
            The texture to use to draw the particles.
            </summary>
    </member>
    <member name="P:DPSF.DPSFDefaultEffect.World">
      <summary>
            The World matrix.
            </summary>
    </member>
    <member name="P:DPSF.DPSFDefaultEffect.View">
      <summary>
            The View matrix.
            </summary>
    </member>
    <member name="P:DPSF.DPSFDefaultEffect.Projection">
      <summary>
            The Projection matrix.
            </summary>
    </member>
  </members>
</doc>